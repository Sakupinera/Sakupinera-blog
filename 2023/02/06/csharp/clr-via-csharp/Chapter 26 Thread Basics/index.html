<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sakupinera" href="http://sakupinera.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sakupinera" href="http://sakupinera.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sakupinera" href="http://sakupinera.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="è¯»ä¹¦ç¬”è®°,C#"><link rel="canonical" href="http://sakupinera.github.io/2023/02/06/csharp/clr-via-csharp/Chapter%2026%20Thread%20Basics/"><title>CLR via C# - Chapter 26 Thread Basics - CLR-via-CSharp - CSharp | Hanamai Sora = Sakupinera</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">CLR via C# - Chapter 26 Thread Basics</h1><div class="meta"><span class="item" title="Created: 2023-02-06 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2023-02-06T00:00:00+08:00">2023-02-06</time> </span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">Symbols count in article</span> <span>48k</span> <span class="text">words</span> </span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">Reading time</span> <span>43 mins.</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hanamai Sora</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s2.loli.net/2023/03/08/R9PEJQ54o7HMAis.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/6bW8i2mQY4dyzLo.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/Z2usRnE64TXN1Lp.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/hr2Sybs5CRvjFdI.png"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/OQq9sc7VlKfnvGL.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/r1VBTR45h8jQWZA.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/" itemprop="item" rel="index" title="In CSharp"><span itemprop="name">CSharp</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/CLR-via-CSharp/" itemprop="item" rel="index" title="In CLR-via-CSharp"><span itemprop="name">CLR-via-CSharp</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://sakupinera.github.io/2023/02/06/csharp/clr-via-csharp/Chapter%2026%20Thread%20Basics/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Sakupinera"><meta itemprop="description" content=", ä¿æŒä½ çš„å†³å¿ƒï¼"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakupinera"></span><div class="body md" itemprop="articleBody"><h1 id="chapter-26-thread-basics"><a class="anchor" href="#chapter-26-thread-basics">#</a> Chapter 26 Thread Basics</h1><h2 id="why-does-windows-support-threads"><a class="anchor" href="#why-does-windows-support-threads">#</a> Why Does Windows Support Threads?</h2><blockquote><p>Back in the early days of computers, operating systems didnâ€™t offer the concept of a thread. In effect, there was just one thread of execution that ran throughout the entire system, which included both operating system code and application code. The problem with having only one thread of execution was that a long-running task would prevent other tasks from executing. For example, in the days of 16-bit Windows, it was very common for an application that was printing a document to stall the entire machine, causing the operating system and all other applications to stop responding. And, sometimes applications would have a bug in them, resulting in an infinite loop that also stopped the entire machine from operating.</p></blockquote><blockquote><p>At this point, the end user would have no choice but to reboot the computer by pressing the reset button or power switch. Of course, end users hated doing this (they still do, in fact) because all running applications terminated; more importantly, any data that these applications were processing was thrown out of memory and lost. Microsoft knew that 16-bit Windows would not be a good enough operating system to keep Microsoft relevant as the computer industry progressed, so they set out to build a new operating system to address the needs of corporations and individuals. This new operating system had to be robust, reliable, scalable, and secure, and it had to improve the many deficiencies of 16-bit Windows. This operating system kernel originally shipped in Windows NT. Over the years, this kernel has had many tweaks and features added to it. The latest version of this kernel ships in the latest versions of the Microsoft client and server Windows operating systems.</p></blockquote><blockquote><p>When Microsoft was designing this operating system kernel, they decided to run each instance of an application in what is called a process. A process is just a collection of resources that is used by a single instance of an application. Each process is given a virtual address space, ensuring that the code and data used by one process is not accessible to another process. This makes application instances robust because one process cannot corrupt code or data being used by another. In addition, the operating systemâ€™s kernel code and data are not accessible to processes; therefore, itâ€™s not possible for application code to corrupt operating system code or data. So now, application code cannot corrupt other applications or the operating system itself, and the whole computing experience is much better for end users. In addition, the system is more secure because application code cannot access user names, passwords, credit card information, or other sensitive information that is in use by another application or the operating system itself.</p></blockquote><blockquote><p>This is all well and good, but what about the CPU itself? What if an application enters an infinite loop? Well, if there is only one CPU in the machine, then it executes the infinite loop and cannot execute anything else, so although the data cannot be corrupted and is more secure, the system could still stop responding to the end user. Microsoft needed to fix this problem, too, and threads were the answer. A thread is a Windows concept whose job is to virtualize the CPU. Windows gives each process its very own thread (which functions similar to a CPU), and if application code enters an infinite loop, the process associated with that code freezes up, but other processes (which have their own threads) are not frozen; they keep running!</p></blockquote><p>ğŸ’¡å°ç»“ï¼šåœ¨è®¡ç®—æœºçš„æ—©æœŸå²æœˆï¼Œæ“ä½œç³»ç»Ÿæ²¡æœ‰çº¿ç¨‹çš„æ¦‚å¿µã€‚äº‹å®ä¸Šï¼Œæ•´ä¸ªç³»ç»Ÿåªè¿è¡Œç€ä¸€ä¸ªæ‰§è¡Œçº¿ç¨‹ï¼Œå…¶ä¸­åŒæ—¶åŒ…å«æ“ä½œç³»ç»Ÿä»£ç å’Œåº”ç”¨ç¨‹åºä»£ç ã€‚åªç”¨ä¸€ä¸ªæ‰§è¡Œçº¿ç¨‹çš„é—®é¢˜åœ¨äºï¼Œé•¿æ—¶é—´è¿è¡Œçš„ä»»åŠ¡å›é˜»æ­¢å…¶ä»–ä»»åŠ¡æ‰§è¡Œã€‚Microsoft åœ¨è®¾è®¡æ–°çš„ OS å†…æ ¸æ—¶ï¼Œå†³å®šåœ¨ä¸€ä¸ªè¿›ç¨‹ä¸­è¿è¡Œåº”ç”¨ç¨‹åºçš„æ¯ä¸ªå®ä¾‹ã€‚è¿›ç¨‹å®é™…æ˜¯åº”ç”¨ç¨‹åºçš„å®ä¾‹è¦ä½¿ç”¨çš„èµ„æºçš„é›†åˆã€‚æ¯ä¸ªè¿›ç¨‹éƒ½è¢«èµ‹äºˆäº†ä¸€ä¸ªè™šæ‹Ÿåœ°å€ç©ºé—´ï¼Œç¡®ä¿åœ¨ä¸€ä¸ªè¿›ç¨‹ä¸­ä½¿ç”¨çš„ä»£ç å’Œæ•°æ®æ— æ³•ç”±å¦ä¸€ä¸ªè¿›ç¨‹è®¿é—®ã€‚è¿™å°±ç¡®ä¿äº†åº”ç”¨ç¨‹åºå®ä¾‹çš„å¥å£®æ€§ï¼Œå› ä¸ºä¸€ä¸ªè¿›ç¨‹æ— æ³•ç ´åå¦ä¸€ä¸ªè¿›ç¨‹ä½¿ç”¨çš„ä»£ç æˆ–æ•°æ®ã€‚æ­¤å¤–ï¼Œè¿›ç¨‹è®¿é—®ä¸äº† OS çš„å†…æ ¸ä»£ç å’Œæ•°æ®ï¼›æ‰€ä»¥åº”ç”¨ç¨‹åºä»£ç ç ´åä¸äº†æ“ä½œç³»ç»Ÿä»£ç æˆ–æ•°æ®ã€‚ä½†å°±è¿™æ ·è¿˜ä¸å¤Ÿï¼Œå¦‚æœæœºå™¨åªæœ‰ä¸€ä¸ª CPUï¼Œå®ƒä¼šæ‰§è¡Œæ­»å¾ªç¯ï¼Œä¸èƒ½æ‰§è¡Œå…¶ä»–ä»»ä½•ä¸œè¥¿ã€‚æ‰€ä»¥ï¼Œè™½ç„¶æ•°æ®æ— æ³•è¢«ç ´åï¼Œè€Œä¸”æ›´å®‰å…¨ï¼Œä½†ç³»ç»Ÿä»ç„¶å¯èƒ½åœæ­¢å“åº”ã€‚Microsoft éœ€è¦ä¿®å¤è¿™ä¸ªé—®é¢˜ï¼Œå®ƒä»¬æ‹¿å‡ºçš„æ–¹æ¡ˆå°±æ˜¯çº¿ç¨‹ã€‚ä½œä¸ºä¸€ä¸ª Windows æ¦‚å¿µã€‚çº¿ç¨‹çš„èŒè´£æ˜¯å¯¹ CPU è¿›è¡Œè™šæ‹ŸåŒ–ã€‚Windows ä¸ºæ¯ä¸ªè¿›ç¨‹éƒ½æä¾›äº†è¯¥è¿›ç¨‹ä¸“ç”¨çš„çº¿ç¨‹ï¼ˆåŠŸèƒ½ç›¸å½“äºä¸€ä¸ª CPUï¼‰ã€‚åº”ç”¨ç¨‹åºçš„ä»£ç è¿›å…¥æ­»å¾ªç¯ï¼Œä¸é‚£ä¸ªä»£ç å…³è”çš„è¿›ç¨‹ä¼š â€œå†»ç»“â€ï¼Œä½†å…¶ä»–è¿›ç¨‹ï¼ˆå®ƒä»¬æœ‰è‡ªå·±çš„çº¿ç¨‹ï¼‰ä¸ä¼šå†»ç»“ï¼Œå®ƒä»¬ä¼šç»§ç»­æ‰§è¡Œã€‚</p><h2 id="thread-overhead"><a class="anchor" href="#thread-overhead">#</a> Thread Overhead</h2><blockquote><p>Threads are awesome because they enable Windows to be responsive even when applications are executing long-running tasks. Also, threads allow the user to use one application (like Task Manager) to forcibly kill an application that appears frozen because it is executing a long-running task. But as with every virtualization mechanism, threads have space (memory consumption) and time (runtime execution performance) overhead associated with them.</p></blockquote><blockquote><p>Letâ€™s explore this overhead in more detail now. Every thread has one of each of the following:</p><ul><li><p>Thread kernel object The operating system allocates and initializes one of these data structures for each thread created in the system. The data structure contains a bunch of properties (discussed later in this chapter) that describe the thread. This data structure also contains what is called the threadâ€™s context. The context is a block of memory that contains a set of the CPUâ€™s registers. For the x86, x64, and ARM CPU architectures, the threadâ€™s context uses approximately 700, 1,240, or 350 bytes of memory, respectively.</p></li><li><p>Thread environment block (TEB) The TEB is a block of memory allocated and initialized in user mode (address space that application code can quickly access). The TEB consumes 1 page of memory (4 KB on x86, x64 CPUs, and ARM CPUs). The TEB contains the head of the threadâ€™s exception-handling chain. Each try block that the thread enters inserts a node in the head of this chain; the node is removed from the chain when the thread exits the try block. In addition, the TEB contains the threadâ€™s thread-local storage data and some data structures for use by Graphics Device Interface (GDI) and OpenGL graphics.</p></li><li><p>User-mode stack The user-mode stack is used for local variables and arguments passed to methods. It also contains the address indicating what the thread should execute next when the current method returns. By default, Windows allocates 1 MB of memory for each threadâ€™s user-mode stack. More specifically, Windows reserves the 1 MB of address space and sparsely commits physical storage to it as the thread actually requires it when growing the stack.</p></li><li><p>Kernel-mode stack The kernel-mode stack is also used when application code passes arguments to a kernel-mode function in the operating system. For security reasons, Windows copies any arguments passed from user-mode code to the kernel from the threadâ€™s user-mode stack to the threadâ€™s kernel-mode stack. Once copied, the kernel can verify the argumentsâ€™ values, and because the application code canâ€™t access the kernel-mode stack, the application canâ€™t modify the argumentsâ€™ values after they have been validated and the operating system kernel code begins to operate on them. In addition, the kernel calls methods within itself and uses the kernel-mode stack to pass its own arguments, to store a functionâ€™s local variables, and to store return addresses. The kernel-mode stack is 12 KB when running on a 32-bit Windows system and 24 KB when running on a 64-bit Windows system.</p></li><li><p>DLL thread-attach and thread-detach notifications Windows has a policy that whenever a thread is created in a process, all unmanaged DLLs loaded in that process have their DllMain method called, passing a DLL_THREAD_ATTACH flag. Similarly, whenever a thread dies, all DLLs in the process have their DllMain method called, passing it a DLL_THREAD_DETACH flag. Some DLLs need these notifications to perform some special initialization or cleanup for each thread created/destroyed in the process. For example, the C-Runtime library DLL allocates some thread-local storage state that is required should the thread use functions contained within the C-Runtime library.</p></li></ul></blockquote><blockquote><p>In the early days of Windows, many processes had maybe 5 or 6 DLLs loaded into them, but today, some processes have several hundred DLLs loaded into them. Right now, on my machine, Microsoft Visual Studio has about 470 DLLs loaded into its process address space! This means that whenever a new thread is created in Visual Studio, 470 DLL functions must get called before the thread is allowed to do what it was created to do. And these 470 functions must be called again whenever a thread in Visual Studio dies. Wowâ€”this can seriously affect the performance of creating and destroying threads within a process.</p></blockquote><blockquote><p>So now, you see all the space and time overhead that is associated with creating a thread, letting it sit around in the system, and destroying it. But the situation gets even worseâ€”now weâ€™re going to start talking about context switching. A computer with only one CPU in it can do only one thing at a time. Therefore, Windows has to share the actual CPU hardware among all the threads (logical CPUs) that are sitting around in the system.</p></blockquote><blockquote><p>At any given moment in time, Windows assigns one thread to a CPU. That thread is allowed to run for a time-slice (sometimes referred to as a quantum). When the time-slice expires, Windows context switches to another thread. Every context switch requires that Windows performs the following actions:</p><ol><li>Save the values in the CPUâ€™s registers to the currently running threadâ€™s context structure inside the threadâ€™s kernel object.</li><li>Select one thread from the set of existing threads to schedule next. If this thread is owned by another process, then Windows must also switch the virtual address space seen by the CPU before it starts executing any code or touching any data.</li><li>Load the values in the selected threadâ€™s context structure into the CPUâ€™s registers.</li></ol></blockquote><blockquote><p>After the context switch is complete, the CPU executes the selected thread until its time-slice expires, and then another context switch happens again. Windows performs context switches about every 30 ms. Context switches are pure overhead; that is, there is no memory or performance benefit that comes from context switches. Windows performs context switching to provide end users with a robust and responsive operating system.</p></blockquote><blockquote><p>Now, if an applicationâ€™s thread enters into an infinite loop, Windows will periodically preempt that thread, assign a different thread to an actual CPU, and let this other thread run for a while. This other thread could be Task Managerâ€™s thread and now, the end user can use Task Manager to kill the process containing the thread that is in an infinite loop. When doing this, the process dies and all the data it was working on is destroyed, too, but all other processes in the system continue to run just fine without losing their data. Of course, the user doesnâ€™t have to reset the machine and reboot, so context switches are required to provide end users with a much better overall experience at the cost of performance.</p></blockquote><blockquote><p>In fact, the performance hit is much worse than you might think. Yes, a performance hit occurs when Windows context switches to another thread. But the CPU was executing another thread, and the previously running threadâ€™s code and data reside in the CPUâ€™s caches so that the CPU doesnâ€™t have to access RAM memory as much, which has significant latency associated with it. When Windows context switches to a new thread, this new thread is most likely executing different code and accessing different data that is not in the CPUâ€™s cache. The CPU must access RAM memory to populate its cache so it can get back to a good execution speed. But then, about 30 ms later, another context switch occurs</p></blockquote><blockquote><p>The time required to perform a context switch varies with different CPU architectures and speed. And the time required to build up a CPUâ€™s cache depends on what applications are running in the system, the size of the CPUâ€™s caches, and various other factors. So it is impossible for me to give you an absolute figure or even an estimate as to what time overhead is incurred for each context switch. Suffice it to say that you want to avoid using context switches as much as possible if you are interested in building high-performing applications and components.</p></blockquote><p>ğŸ’¡é‡è¦æç¤ºï¼šä¸€ä¸ªæ—¶é—´ç‰‡ç»“æŸæ—¶ï¼Œå¦‚æœ Windows å†³å®šå†æ¬¡è°ƒåº¦åŒä¸€ä¸ªçº¿ç¨‹ (è€Œä¸æ˜¯åˆ‡æ¢åˆ°å¦ä¸€ä¸ªçº¿ç¨‹)ï¼Œé‚£ä¹ˆ Windows ä¸ä¼šæ‰§è¡Œä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚ç›¸åï¼Œçº¿ç¨‹å°†ç»§ç»­è¿è¡Œã€‚è¿™æ˜¾è‘—æ”¹è¿›äº†æ€§èƒ½ã€‚æ³¨æ„ï¼Œåœ¨è®¾è®¡è‡ªå·±çš„ä»£ç æ—¶ï¼Œä¸Šä¸‹æ–‡åˆ‡æ¢èƒ½é¿å…å°±è¦å°½é‡é¿å…ã€‚</p><p>ğŸ’¡é‡è¦æç¤ºï¼šçº¿ç¨‹å¯è‡ªä¸»æå‰ç»ˆæ­¢å…¶æ—¶é—´ç‰‡ã€‚è¿™ç»å¸¸å‘ç”Ÿï¼Œå› ä¸ºçº¿ç¨‹ç»å¸¸è¦ç­‰å¾… I/O æ“ä½œ (é”®ç›˜ã€é¼ æ ‡ã€æ–‡ä»¶ã€ç½‘ç»œç­‰) ç»“æŸã€‚ä¾‹å¦‚ï¼Œâ€œè®°äº‹æœ¬â€ ç¨‹åºçš„çº¿ç¨‹ç»å¸¸éƒ½ä¼šå¤„äºç©ºé—²çŠ¶æ€ï¼Œä»€ä¹ˆäº‹æƒ…éƒ½ä¸åšï¼›è¿™ä¸ªçº¿ç¨‹æ˜¯åœ¨ç­‰å¾…è¾“å…¥ã€‚å¦‚æœç”¨æˆ·æŒ‰é”®ç›˜ä¸Šçš„ J é”®ï¼ŒWindows ä¼šå”¤é†’ â€œè®°äº‹æœ¬â€ çº¿ç¨‹ï¼Œè®©ä»–å¤„ç†æŒ‰é”®æ“ä½œã€‚â€œè®°äº‹æœ¬â€ çº¿ç¨‹å¯èƒ½èŠ± 5 æ¯«ç§’å¤„ç†æŒ‰é”®ï¼Œç„¶åè°ƒç”¨ä¸€ä¸ª Win32 å‡½æ•°ï¼Œå‘Šè¯‰ Windows å®ƒå‡†å¤‡å¥½å¤„ç†ä¸‹ä¸€ä¸ªè¾“å…¥äº‹ä»¶ã€‚å¦‚æœæ²¡æœ‰æ›´å¤šçš„è¾“å…¥äº‹ä»¶ï¼ŒWindows ä½¿ â€œè®°äº‹æœ¬â€ çº¿ç¨‹è¿›å…¥ç­‰å¾…çŠ¶æ€ (æ—¶é—´ç‰‡å‰©ä½™çš„éƒ¨åˆ†å°±æ”¾å¼ƒäº†)ï¼Œä½¿çº¿ç¨‹åœ¨ä»»ä½• CPU ä¸Šéƒ½ä¸å†è°ƒåº¦ï¼Œç›´åˆ°å‘ç”Ÿä¸‹ä¸€æ¬¡è¾“å…¥äº‹ä»¶ã€‚è¿™å¢å¼ºäº†ç³»ç»Ÿçš„æ€»ä½“æ€§èƒ½ï¼Œå› ä¸ºæ­£åœ¨ç­‰å¾… I/O æ“ä½œå®Œæˆçš„çº¿ç¨‹ä¸ä¼šåœ¨ CPU ä¸Šè°ƒåº¦ï¼Œæ‰€ä»¥ä¸ä¼šæµªè´¹ CPU æ—¶é—´ï¼Œè€ŒèŠ‚çœå‡ºæ¥çš„æ—¶é—´åˆ™å¯ä»¥ä¾› CPU è°ƒåº¦å…¶ä»–çº¿ç¨‹ã€‚</p><blockquote><p>In addition, when performing a garbage collection, the CLR must suspend all the threads, walk their stacks to find the roots to mark objects in the heap, walk their stacks again (updating roots to objects that moved during compaction), and then resume all the threads. So avoiding threads will greatly improve the performance of the garbage collector, too. And whenever you are using a debugger, Windows suspends all threads in the application being debugged every time a breakpoint is hit and resumes all the threads when you single-step or run the application. So the more threads you have, the slower your debugging experience will be.</p></blockquote><blockquote><p>From this discussion, you should conclude that you must avoid using threads as much as possible because they consume a lot of memory and they require time to create, destroy, and manage. Time is also wasted when Windows context switches between threads and when garbage collections occur. However, this discussion should also help you realize that threads must be used sometimes because they allow Windows to be robust and responsive.</p></blockquote><blockquote><p>I should also point out that a computer with multiple CPUs in it can actually run multiple threads simultaneously, increasing scalability (the ability to do more work in less time). Windows will assign one thread to each CPU core, and each core will perform its own context switching to other threads. Windows makes sure that a single thread is not scheduled on multiple cores at one time because this would wreak havoc. Today, computers that contain multiple CPUs, hyperthreaded CPUs, or multi-core CPUs are commonplace. But when Windows was originally designed, single-CPU computers were commonplace, and Windows added threads to improve system responsiveness and reliability. Today, threads are also being used to improve scalability, which can happen only on computers that have multiple cores in them.</p></blockquote><blockquote><p>The remaining chapters in this book discuss the various Windows and CLR mechanisms that exist so that you can effectively wrestle with the tension of creating as few threads as possible, while still keeping your code responsive and allowing it to scale if your code is running on a machine with multiple cores.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šå’Œä¸€åˆ‡è™šæ‹ŸåŒ–æœºåˆ¶ä¸€æ ·ï¼Œçº¿ç¨‹æœ‰ç©ºé—´ï¼ˆå†…å­˜è€—ç”¨ï¼‰å’Œæ—¶é—´ï¼ˆè¿è¡Œæ—¶çš„æ‰§è¡Œæ€§èƒ½ï¼‰ä¸Šçš„å¼€é”€ã€‚æ¯ä¸ªçº¿ç¨‹éƒ½æœ‰ä»¥ä¸‹è¦ç´ ï¼šçº¿ç¨‹å†…æ ¸å¯¹è±¡ã€çº¿ç¨‹ç¯å¢ƒå—ã€ç”¨æˆ·æ¨¡å¼æ ˆã€å†…æ ¸æ¨¡å¼æ ˆã€DLL çº¿ç¨‹è¿æ¥å’Œçº¿ç¨‹åˆ†ç¦»é€šçŸ¥ã€‚ä»»ä½•æ—¶å€™åœ¨è¿›ç¨‹ä¸­åˆ›å»ºçº¿ç¨‹æˆ–ç»ˆæ­¢çº¿ç¨‹éƒ½ä¼šè°ƒç”¨è¿›ç¨‹ä¸­çš„æ‰€æœ‰éæ‰˜ç®¡ DLL çš„ DllMain æ–¹æ³•ï¼Œå¹¶å‘æ–¹æ³•ä¼ é€’å¯¹åº”çš„æ ‡å¿—ã€‚å¦‚ä»Šï¼Œéšä¾¿ä¸€ä¸ªè¿›ç¨‹å°±å¯èƒ½åŠ è½½å‡ ç™¾ä¸ª DLLï¼Œè¿™ä¸¥é‡å½±å“äº†åœ¨è¿›ç¨‹ä¸­åˆ›å»ºå’Œé”€æ¯çº¿ç¨‹çš„æ€§èƒ½ã€‚å• CPUã€è®¡ç®—æœºä¸€æ¬¡åªèƒ½åšä¸€ä»¶äº‹æƒ…ã€‚æ‰€ä»¥ï¼ŒWindows å¿…é¡»åœ¨ç³»ç»Ÿä¸­çš„æ‰€æœ‰çº¿ç¨‹ï¼ˆé€»è¾‘ CPUï¼‰ä¹‹é—´å…±äº«ç‰©ç† CPUã€‚Windows ä»»ä½•æ—¶åˆ»åªå°†ä¸€ä¸ªçº¿ç¨‹åˆ†é…ç»™ä¸€ä¸ª CPUã€‚é‚£ä¸ªçº¿ç¨‹èƒ½è¿è¡Œä¸€ä¸ª â€œæ—¶é—´ç‰‡â€ çš„é•¿åº¦ã€‚æ—¶é—´ç‰‡åˆ°æœŸï¼ŒWindows å°±ä¸Šä¸‹æ–‡åˆ‡æ¢åˆ°å¦ä¸€ä¸ªçº¿ç¨‹ã€‚ä¸Šä¸‹æ–‡åˆ‡æ¢å®Œæˆåï¼ŒCPU æ‰§è¡Œæ‰€é€‰çš„çº¿ç¨‹ï¼Œç›´åˆ°å®ƒçš„æ—¶é—´ç‰‡åˆ°æœŸã€‚ç„¶åå‘ç”Ÿä¸‹æ¬¡ä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚Windows å¤§çº¦æ¯ 30 æ¯«ç§’æ‰§è¡Œä¸€æ¬¡ä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚ä¸Šä¸‹æ–‡åˆ‡æ¢æ˜¯å‡€å¼€é”€ï¼›ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸Šä¸‹æ–‡åˆ‡æ¢æ‰€äº§ç”Ÿçš„å¼€é”€ä¸ä¼šæ¢æ¥ä»»ä½•å†…å­˜æˆ–æ€§èƒ½ä¸Šçš„æ”¶ç›Šã€‚å½“ Windows ä¸Šä¸‹æ–‡åˆ‡æ¢åˆ°æ–°çº¿ç¨‹æ—¶ï¼Œè¿™ä¸ªæ–°çº¿ç¨‹ææœ‰å¯èƒ½å¿…é¡»è®¿é—® RAM æ¥å¡«å……å®ƒçš„é«˜é€Ÿç¼“å­˜ï¼Œä»¥æ¢å¤é«˜é€Ÿæ‰§è¡ŒçŠ¶æ€ã€‚å› æ­¤ï¼Œåœ¨è®¾è®¡è‡ªå·±çš„ä»£ç æ—¶ï¼Œä¸Šä¸‹æ–‡åˆ‡æ¢èƒ½é¿å…å°±è¦å°½é‡é¿å…ã€‚æ‰§è¡Œä¸Šä¸‹æ–‡åˆ‡æ¢æ‰€éœ€çš„æ—¶é—´å–å†³äº CPU æ¶æ„å’Œé€Ÿåº¦ã€‚è€Œå¡«å…… CPU ç¼“å­˜æ‰€éœ€çš„æ—¶é—´å–å†³äºç³»ç»Ÿä¸­è¿è¡Œçš„åº”ç”¨ç¨‹åºã€CPU ç¼“å­˜çš„å¤§å°ä»¥åŠå…¶ä»–å„ç§å› ç´ ã€‚æ­¤å¤–ï¼Œæ‰§è¡Œåƒåœ¾å›æ”¶æ—¶ï¼ŒCLR å¿…é¡»æŒ‚èµ·ï¼ˆæš‚åœï¼‰æ‰€æœ‰çº¿ç¨‹ï¼Œéå†å®ƒä»¬çš„æ ˆæ¥æŸ¥æ‰¾æ ¹ä»¥ä¾¿å¯¹å †ä¸­å¯¹è±¡è¿›è¡Œæ ‡è®°ï¼Œå†æ¬¡éå†å®ƒä»¬çš„æ ˆï¼ˆæœ‰çš„å¯¹è±¡åœ¨å‹ç¼©æœŸé—´å‘ç”Ÿäº†ç§»åŠ¨ï¼Œæ‰€ä»¥è¦æ›´æ–°å®ƒä»¬çš„æ ¹ï¼‰ï¼Œå†æ¢å¤æ‰€æœ‰çº¿ç¨‹ã€‚æ‰€ä»¥ï¼Œå‡å°‘çº¿ç¨‹çš„æ•°é‡ä¹Ÿä¼šæ˜¾è‘—æå‡åƒåœ¾å›æ”¶å™¨çš„æ€§èƒ½ã€‚è°ƒè¯•å™¨åŒç†ã€‚å®‰è£…äº†å¤šä¸ª CPUï¼ˆæˆ–è€…ä¸€ä¸ªå¤šæ ¸ CPUï¼‰çš„è®¡ç®—æœºå¯ä»¥çœŸæ­£åŒæ—¶è¿è¡Œå‡ ä¸ªçº¿ç¨‹ï¼Œè¿™æå‡äº†åº”ç”¨ç¨‹åºçš„å¯ä¼¸ç¼©æ€§ã€‚Windows ä¸ºæ¯ä¸ª CPU å†…æ ¸éƒ½åˆ†é…ä¸€ä¸ªçº¿ç¨‹ï¼Œæ¯ä¸ªå†…æ ¸éƒ½è‡ªå·±æ‰§è¡Œåˆ°å…¶ä»–çº¿ç¨‹çš„ä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚Windows ç¡®ä¿å•ä¸ªçº¿ç¨‹ä¸ä¼šåŒæ—¶åœ¨å¤šä¸ªå†…æ ¸ä¸Šè°ƒåº¦ï¼Œå› ä¸ºè¿™ä¼šå¸¦æ¥å·¨å¤§çš„æ··ä¹±ã€‚</p><h2 id="stop-the-madness"><a class="anchor" href="#stop-the-madness">#</a> Stop the Madness</h2><blockquote><p>If all we cared about was raw performance, then the optimum number of threads to have on any machine is identical to the number of CPUs on that machine. So a machine with one CPU would have only one thread, a machine with two CPUs would have two threads, and so on. The reason is obvious: if you have more threads than CPUs, then context switching is introduced and performance deteriorates. If each CPU has just one thread, then no context switching exists and the threads run at full speed.</p></blockquote><blockquote><p>However, Microsoft designed Windows to favor reliability and responsiveness as opposed to favoring raw speed and performance. And I commend this decision: I donâ€™t think any of us would be using Windows or the .NET Framework today if applications could still stop the operating system and other applications. Therefore, Windows gives each process its own thread for improved system reliability and responsiveness. On my machine, for example, when I run Task Manager and select the Performance tab, I see the image shown in Figure 26-1.</p></blockquote><blockquote><p>It shows that my machine currently has 55 processes running on it, and so weâ€™d expect that there were at least 55 threads on my machine, because each process gets at least 1 thread. But Task Manager also shows that my machine currently has 864 threads in it! All these threads end up allocating many megabytes of memory on my machine, which has only 4 GB of RAM in it. This also means that there is an average of approximately 15.7 threads per process, when I should ideally have only 2 threads per process on my dual core machine!</p></blockquote><p><img data-src="/2023/02/06/csharp/clr-via-csharp/Chapter%2026%20Thread%20Basics/image-20230203194758897.png" alt="image-20230203194758897"></p><p><strong>Figure 26-1</strong> Task Manager showing system performance.</p><blockquote><p>To make matters worse, when I look at the CPU Usage, it shows that my CPU is busy 5 percent of the time. This means that 95 percent of the time, these 864 threads have literally nothing to doâ€”they are just soaking up memory that is definitely not being used when the threads are not running. You have to ask yourself: Do these applications need all these threads to do nothing 95 percent of the time? The answer to this question has to be â€œNo.â€ Now, if you want to see which processes are the most wasteful, click the Task Managerâ€™s Details tab, add the Threads column, and sort this column in descending order, as shown in Figure 26-2.</p></blockquote><blockquote><p>As you can see here, System has created 105 threads and is using 1 percent of the CPU, Explorer has created 47 threads to use 0 percent of the CPU, Visual Studio (Devenv.exe) has created 36 threads to use 0 percent of the CPU, Microsoft Outlook has created 24 threads to use 0 percent of the CPU, and so on. What is going on here?</p></blockquote><blockquote><p>When developers were learning about Windows, they learned that a process in Windows is very, very expensive. Creating a process usually takes several seconds, a lot of memory must be allocated, this memory must be initialized, the EXE and DLL files have to load from disk, and so on. By comparison, creating a thread in Windows is very cheap, so developers decided to stop creating processes and start creating threads instead. So now we have lots of threads. But even though threads are cheaper than processes, they are still very expensive compared to most other system resources, so they should be used sparingly and appropriately.</p></blockquote><p><img data-src="/2023/02/06/csharp/clr-via-csharp/Chapter%2026%20Thread%20Basics/image-20230203203315170.png" alt="image-20230203203315170"></p><p><strong>FIGURE 26-2</strong> Task Manager showing details.</p><blockquote><p>Well, without a doubt, we can say for sure that all of the applications weâ€™ve just discussed are using threads inefficiently. There is just no way that all of these threads need to exist in the system. It is one thing to allocate resources inside an application; itâ€™s quite another to allocate them and then not use them. This is just wasteful, and allocating all the memory for thread stacks means that there is less memory for more important data, such as a userâ€™s document.</p></blockquote><blockquote><p>To make matters worse, what if these were the processes running in a single userâ€™s Remote Desktop Services sessionâ€”and what if there were actually 100 users on this machine? Then there would be 100 instances of Outlook, all creating 24 threads only to do nothing with them. Thatâ€™s 2,400 threads each with its own kernel object, TEB, user-mode stack, kernel-mode stack, etc. That is a lot of wasted resources. This madness has to stop, especially if Microsoft wants to give users a good experience when running Windows on netbook computers, many of which have only 1 GB of RAM. Again, the chapters in this part of the book will describe how to properly design an application to use very few threads in an efficient manner.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šåœ¨ Windows ä¸­ï¼Œè¿›ç¨‹æ˜¯ååˆ† â€œæ˜‚è´µâ€ çš„ã€‚åˆ›å»ºä¸€ä¸ªè¿›ç¨‹é€šå¸¸è¦èŠ±å‡ ç§’é’Ÿçš„æ—¶é—´ï¼Œå¿…é¡»åˆ†é…å¤§é‡å†…å­˜ï¼Œè¿™äº›å†…å­˜å¿…é¡»åˆå§‹åŒ–ï¼ŒEXE å’Œ DLL æ–‡ä»¶å¿…é¡»ä»ç£ç›˜ä¸ŠåŠ è½½ï¼Œç­‰ç­‰ã€‚ç›¸åï¼Œåœ¨ Windows ä¸­åˆ›å»ºçº¿ç¨‹åˆ™ååˆ† â€œå»‰ä»·â€ã€‚ä½†æ˜¯ï¼Œè™½ç„¶çº¿ç¨‹æ¯”è¿›ç¨‹å»‰ä»·ï¼Œå®ƒä»¬å’Œå…¶ä»–ç³»ç»Ÿèµ„æºç›¸æ¯”ä»ç„¶ååˆ†æ˜‚è´µï¼Œæ‰€ä»¥è¿˜æ˜¯åº”è¯¥çœç€ç”¨ï¼Œè€Œä¸”è¦ç”¨å¾—æ°å½“ã€‚</p><h2 id="cpu-trends"><a class="anchor" href="#cpu-trends">#</a> CPU Trends</h2><blockquote><p>In the past, CPU speeds used to increase with time, so an application that ran slowly on one machine would typically run faster on a newer machine. However, CPU manufacturers are unable to continue the trend of making CPUs faster. When you run CPUs at high speeds, they produce a lot of heat that has to be dissipated. A few years ago, I acquired a newly released notebook computer from a respected manufacturer. This computer had a bug in its firmware that made it not turn the fan on enough; as a result, after running the computer for a while, the CPU and the motherboard melted. The hardware manufacturer replaced the machine and then â€œimprovedâ€ the firmware by making the fan run more frequently. Unfortunately, this had the effect of draining the battery faster, because fans consume a lot of power.</p></blockquote><blockquote><p>These are the kinds of problems that the hardware vendors face today. Because CPU manufacturers canâ€™t continuously produce higher-speed CPUs, they have instead turned their attention to making transistors smaller so that more of them can reside on a single chip. Today, we can have a single silicon chip that contains two or more CPU cores. The result is that our software only gets faster if we write our software to use the multiple cores. How do we do this? We use threads in an intelligent fashion.</p></blockquote><blockquote><p>Computers use three kinds of multi-CPU technologies today:</p><ul><li><p>Multiple CPUs Some computers just have multiple CPUs in them. That is, the motherboard has multiple sockets on it, with each socket containing a CPU. Because the motherboard must be bigger, the computer case is bigger as well, and sometimes these machines have multiple power supplies in them due to the additional power drain. These kinds of computers have been around for a few decades, but they are not as popular today due to their increased size and cost.</p></li><li><p>Hyperthreaded chips This technology (owned by Intel) allows a single chip to look like two chips. The chip contains two sets of architectural states, such as CPU registers, but the chip has only one set of execution resources. To Windows, this looks like there are two CPUs in the machine, so Windows schedules two threads concurrently. However, the chip only executes one of the threads at a time. When one thread pauses due to a cache miss, branch misprediction, or data dependency, the chip switches to the other thread. This all happens in hardware, and Windows doesnâ€™t know that it is happening; Windows believes that both threads are running concurrently. Windows does know about hyperthreaded CPUs, and if you have multiple hyperthreaded CPUs in a single machine, Windows will first schedule one thread on each CPU so that the threads are truly running concurrently and then schedule other threads on the already-busy CPUs. Intel claims that a hyperthreaded CPU can improve performance by 10 percent to 30 percent.</p></li><li><p>Multi-core chips A few years ago, single chips containing multiple CPU cores have entered the scene. As I write this, chips with two, three, and four cores are readily available. Even my notebook computer has two cores in it; our mobile phones now have multiple cores in them too. Intel has even been working on a single chip with 80 cores on it! Wow, this is a lot of computing power! And Intel even has hyperthreaded multi-core chips.</p></li></ul></blockquote><p>ğŸ’¡å°ç»“ï¼šCPU å‚å•†è¿‡å»åªçŸ¥é“ä¸€å‘³åœ°æé«˜ CPU é€Ÿåº¦ï¼Œä½†é«˜é€Ÿè¿è¡Œçš„ CPU ä¼šäº§ç”Ÿå¤§é‡çƒ­é‡ã€‚ç”±äºä¸èƒ½åšåˆ°ä¸€ç›´æå‡ CPU çš„é€Ÿåº¦ï¼Œæ‰€ä»¥åˆæ”¹ä¸ºä¾§é‡äºè®²æ™¶ä½“ç®¡åšçš„æ›´å°ï¼Œä½¿ä¸€ä¸ªèŠ¯ç‰‡èƒ½å®¹ä¸‹æ›´å¤šçš„æ™¶ä½“ç®¡ã€‚å¦‚ä»Šçš„è®¡ç®—æœºä½¿ç”¨äº†ä¸€ä¸‹ä¸‰ç§å¤š CPU æŠ€æœ¯ï¼š1. å¤šä¸ª CPUï¼Œæœ‰çš„ä¸»æ¿ä¸Šæœ‰å¤šä¸ª CPU æ’åº§ã€‚2. è¶…çº¿ç¨‹èŠ¯ç‰‡ï¼Œè¿™ç§æŠ€æœ¯å…è®¸ä¸€ä¸ªèŠ¯ç‰‡åœ¨æ“ä½œç³»ç»Ÿä¸­æ˜¾ç¤ºæˆä¸¤ä¸ªã€‚èŠ¯ç‰‡ä¸­åŒ…å«ä¸¤ç»„æ¶æ„çŠ¶æ€ï¼Œä½†èŠ¯ç‰‡åªæœ‰ä¸€ç»„æ‰§è¡Œèµ„æºã€‚å¯¹äº Windowsï¼Œè¿™çœ‹èµ·æ¥æ˜¯å®‰è£…äº†ä¸¤ä¸ª CPUï¼Œæ‰€ä»¥ Windows ä¼šåŒæ—¶è°ƒåº¦ä¸¤ä¸ªçº¿ç¨‹ã€‚ä½†èŠ¯ç‰‡ä¸€æ¬¡åªèƒ½æ‰§è¡Œä¸€ä¸ªçº¿ç¨‹ã€‚ä¸€ä¸ªçº¿ç¨‹ç”±äºç¼“æœªå‘½ä¸­ (cache miss)ã€åˆ†æ”¯é¢„æµ‹é”™è¯¯ (branch misprediction) æˆ–è€…è¦ç­‰å¾…æ•°æ® (data dependency) è€Œæš‚åœæ—¶ï¼ŒèŠ¯ç‰‡å°†åˆ‡æ¢åˆ°å¦ä¸€ä¸ªçº¿ç¨‹ã€‚Windows ä¸çŸ¥é“å®é™…ä½¿ç”¨çš„æ˜¯è¶…çº¿ç¨‹ CPUã€‚å¦‚æœä¸€å°æœºå™¨ä¸Šå®‰è£…äº†å¤šä¸ªè¶…çº¿ç¨‹ CPUï¼ŒWindows é¦–å…ˆåœ¨æ¯ä¸ª CPU ä¸Šéƒ½è°ƒåº¦ä¸€ä¸ªçº¿ç¨‹ï¼Œä½¿çº¿ç¨‹çœŸæ­£å¹¶å‘è¿è¡Œï¼Œç„¶åå†å·²ç»å¤„äº â€œå¿™â€ çŠ¶æ€çš„ CPU ä¸Šè°ƒåº¦å…¶ä»–çº¿ç¨‹ã€‚Intel å£°ç§°è¶…çº¿ç¨‹ CPU èƒ½æå‡ 10%~30% çš„æ€§èƒ½ã€‚3. å¤šæ ¸èŠ¯ç‰‡ï¼Œæœ‰çš„ CPU åŒ…å«å¤šä¸ªå†…æ ¸ã€‚åˆæ¬¡ä¹‹å¤–ï¼ŒIntel ç”šè‡³æ¨å‡ºäº†è¶…çº¿ç¨‹çš„å¤šæ ¸èŠ¯ç‰‡ã€‚</p><h2 id="clr-threads-and-windows-threads"><a class="anchor" href="#clr-threads-and-windows-threads">#</a> CLR Threads and Windows Threads</h2><blockquote><p>Today, the CLR uses the threading capabilities of Windows, so Part V of this book is really focusing on how the threading capabilities of Windows are exposed to developers who write code by using the CLR. I will explain about how threads in Windows work and how the CLR alters the behavior (if it does). However, if youâ€™d like more information about threads, I recommend reading some of my earlier writings on the topic, such as Windows via C/C++, Fifth Edition, by myself and Christophe Nasarre (Microsoft Press, 2007).</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šåœ¨ .NET Framework çš„æ—©æœŸå²æœˆï¼ŒCLR å›¢é˜Ÿè®¤ä¸ºæœ‰æœä¸€æ—¥ CLR ä¼šæä¾›ä¸ä¸€å®šä¼šæ˜ å°„åˆ° Windows çº¿ç¨‹çš„é€»è¾‘çº¿ç¨‹ã€‚ä½†å¤§çº¦åœ¨ 2005 å¹´çš„æ—¶å€™ï¼Œè¿™ä¸ªå°è¯•å®£å‘Šå¤±è´¥ï¼ŒCLR å›¢é˜Ÿæ”¾å¼ƒäº†åœ¨è¿™ä¸ªæ–¹é¢çš„åŠªåŠ›ã€‚æ‰€ä»¥ï¼Œä»Šå¤©çš„ CLR çº¿ç¨‹å®Œå…¨ç­‰ä»·äº Windows çº¿ç¨‹ï¼Œä½† .NET Framework ä»ç„¶ç•™ä¸‹äº†ä¸€äº›èƒ½çœ‹å‡ºå½“å¹´åŠªåŠ›æˆæœçš„ä¸€äº›ä¸œè¥¿ã€‚ä¾‹å¦‚ï¼Œ <code>System.Environment</code> ç±»å…¬å¼€äº† <code>CurrentManagedThreadId</code> å±æ€§ï¼Œè¿”å›çº¿ç¨‹çš„ CLR IDï¼›è€Œ <code>System.Diagnostics.ProcessThread</code> ç±»å…¬å¼€äº† <code>Id</code> å±æ€§ï¼Œè¿”å›åŒä¸€ä¸ªçº¿ç¨‹çš„ Windows IDã€‚ <code>System.Thread</code> ç±»çš„ <code>BeginThreadAffinity</code> å’Œ <code>EndThreadAffinity</code> æ–¹æ³•åˆ™å¤„ç† CLR çº¿ç¨‹æ²¡æœ‰æ˜ å°„åˆ° Windows çº¿ç¨‹çš„æƒ…å†µã€‚</p><p>ğŸ’¡æ³¨æ„ï¼šMicrosoft ä¸º Windows Store åº”ç”¨ç§»é™¤äº†å’Œçº¿ç¨‹å¤„ç†æœ‰å…³çš„ä¸€äº› APIï¼Œå› ä¸ºå®ƒä»¬é¼“åŠ±ä¸å¥½çš„ç¼–ç¨‹å®è·µ (å°±åƒ 26.3 èŠ‚ â€œåœæ­¢ç–¯ç‹‚â€ æè¿°çš„é‚£æ ·)ï¼Œæˆ–è€…æ˜¯å› ä¸ºå®ƒä»¬ä¸åˆ©äºè¾¾æˆ Microsoft ä¸º Windows Store åº”ç”¨è®¾ç«‹çš„ç›®æ ‡ã€‚ä¾‹å¦‚ï¼Œæ•´ä¸ª <code>System.Thread</code> ç±»éƒ½ä¸å¼€æ”¾ç»™ Windows Store åº”ç”¨ï¼Œå› ä¸ºå…¶ä¸­æœ‰è®¸å¤šä¸å¥½çš„ API (æ¯”å¦‚ <code>Start</code> ï¼Œ <code>IsBackground</code> ï¼Œ <code>Sleep</code> ï¼Œ <code>Suspend</code> ï¼Œ <code>Resume</code> ï¼Œ <code>Join</code> ï¼Œ <code>Interrupt</code> ï¼Œ <code>Abort</code> ï¼Œ <code>BeginThreadAffinity</code> å’Œ <code>EndThreadAffinity</code> )ã€‚æˆ‘ä¸ªäººèµæˆè¿™ä¸ªåšæ³•ï¼Œè€Œä¸”è®¤ä¸ºæ—©å°±è¯¥è¿™ä¹ˆåšã€‚æ‰€ä»¥ï¼Œç¬¬ 26 ç« åˆ°ç¬¬ 30 ç« è®¨è®ºäº†é€‚åˆæ¡Œé¢åº”ç”¨ä½†ä¸é€‚åˆ Windows Store åº”ç”¨çš„ä¸€äº› API å’ŒåŠŸèƒ½ã€‚é˜…è¯»è¿‡ç¨‹ä¸­èƒ½æ¸…æ¥šåœ°è®¤è¯†åˆ°ä¸ºä½•æœ‰ä¸€äº› API ä¸é€‚åˆ Windows Store åº”ç”¨ã€‚</p><p>ğŸ’¡å°ç»“ï¼šCLR çº¿ç¨‹å®Œå…¨ç­‰ä»·äº Windows çº¿ç¨‹ã€‚</p><h2 id="using-a-dedicated-thread-to-perform-an-asynchronous-compute-bound-operation"><a class="anchor" href="#using-a-dedicated-thread-to-perform-an-asynchronous-compute-bound-operation">#</a> Using a Dedicated Thread to Perform an Asynchronous Compute-Bound Operation</h2><blockquote><p>In this section, I will show you how to create a thread and have it perform an asynchronous computebound operation. Although I am going to walk you through this, I highly recommend that you avoid the technique I show you here. And, in fact, this technique is not even possible if you are building a Windows Store app because the Thread class is not available. Instead, you should use the thread pool to execute asynchronous compute-bound operations whenever possible. I go into the details about doing this in Chapter 27, â€œCompute-Bound Asynchronous Operations.â€</p></blockquote><blockquote><p>However, there are some very unusual occasions when you might want to explicitly create a thread dedicated to executing a particular compute-bound operation. Typically, youâ€™d want to create a dedicated thread if youâ€™re going to execute code that requires the thread to be in a particular state that is not normal for a thread pool thread. For example, explicitly create your own thread if any of the following is true:</p><ul><li><p>You need the thread to run with a non-normal thread priority. All thread pool threads run at normal priority. Although you can change this, it is not recommended, and the priority change does not persist across thread pool operations.</p></li><li><p>You need the thread to behave as a foreground thread, thereby preventing the application from dying until the thread has completed its task. For more information, see the â€Foreground Threads vs. Background Threadsâ€ section later in this chapter. Thread pool threads are always background threads, and they may not complete their task if the CLR wants to terminate the process.</p></li><li><p>The compute-bound task is extremely long-running; this way, I would not be taxing the thread poolâ€™s logic as it tries to figure out whether to create an additional thread.</p></li><li><p>You want to start a thread and possibly abort it prematurely by calling Threadâ€™s Abort method (discussed in Chapter 22, â€œCLR Hosting and AppDomainsâ€).</p></li></ul></blockquote><blockquote><p>To create a dedicated thread, you construct an instance of the System.Threading.Thread class, passing the name of a method into its constructor. Here is the prototype of Threadâ€™s constructor.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Thread</span> <span class="token punctuation">:</span> CriticalFinalizerObject<span class="token punctuation">,</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Thread</span><span class="token punctuation">(</span><span class="token class-name">ParameterizedThreadStart</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// Less commonly used constructors are not shown here </span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The start parameter identifies the method that the dedicated thread will execute, and this method must match the signature of the ParameterizedThreadStart delegate.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">delegate</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ParameterizedThreadStart</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>Constructing a Thread object is a relatively lightweight operation because it does not actually create a physical operating system thread. To actually create the operating system thread and have it start executing the callback method, you must call Threadâ€™s Start method, passing into it the object (state) that you want passed as the callback methodâ€™s argument.</p></blockquote><blockquote><p>The following code demonstrates how to create a dedicated thread and have it call a method asynchronously.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Threading</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Main thread: starting a dedicated thread "</span> <span class="token operator">+</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token string">"to do an asynchronous operation"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token class-name">Thread</span> dedicatedThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Thread</span><span class="token punctuation">(</span>ComputeBoundOp<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> dedicatedThread<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Main thread: Doing other work here..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> Thread<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Simulating other work (10 seconds) </span></pre></td></tr><tr><td data-num="11"></td><td><pre> dedicatedThread<span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Wait for thread to terminate </span></pre></td></tr><tr><td data-num="12"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Hit &lt;Enter> to end this program..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// This method's signature must match the ParameterizedThreadStart delegate </span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ComputeBoundOp</span><span class="token punctuation">(</span><span class="token class-name">Object</span> state<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token comment">// This method is executed by a dedicated thread </span></pre></td></tr><tr><td data-num="18"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"In ComputeBoundOp: state=&#123;0&#125;"</span><span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> Thread<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Simulates other work (1 second) </span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token comment">// When this method returns, the dedicated thread dies </span></pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When I compile and run this code, I get the following output.</p></blockquote><pre><code class="language-cmd">Main thread: starting a dedicated thread to do an asynchronous operation 
Main thread: Doing other work here... 
In ComputeBoundOp: state=5
</code></pre><blockquote><p>Sometimes when I run this code, I get the following output, because I canâ€™t control how Windows schedules the two threads.</p></blockquote><pre><code class="language-cmd">Main thread: starting a dedicated thread to do an asynchronous operation 
In ComputeBoundOp: state=5 
Main thread: Doing other work here...
</code></pre><blockquote><p>Notice that the Main method calls Join. The Join method causes the calling thread to stop executing any code until the thread identified by dedicatedThread has destroyed itself or been terminated.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šåº”å°½é‡ä½¿ç”¨çº¿ç¨‹æ± æ¥æ‰§è¡Œå¼‚æ­¥çš„è®¡ç®—é™åˆ¶æ“ä½œã€‚å¦‚æœæ‰§è¡Œçš„ä»£ç è¦æ±‚çº¿ç¨‹å¤„äºä¸€ç§ç‰¹å®šçŠ¶æ€ï¼Œè€Œè¿™ç§çŠ¶æ€å¯¹äºçº¿ç¨‹æ± çº¿ç¨‹æ¥è¯´æ˜¯éåŒå¯»å¸¸çš„ï¼Œå°±å¯è€ƒè™‘åˆ›å»ºä¸“ç”¨çº¿ç¨‹ã€‚1. çº¿ç¨‹éœ€è¦ä»¥éæ™®é€šçº¿ç¨‹ä¼˜å…ˆçº§è¿è¡Œã€‚æ‰€æœ‰çº¿ç¨‹æ± çº¿ç¨‹éƒ½ä»¥æ™®é€šä¼˜å…ˆçº§è¿è¡Œã€‚2. éœ€è¦çº¿ç¨‹è¡¨ç°ä¸ºä¸€ä¸ªå‰å°çº¿ç¨‹ï¼Œé˜²æ­¢åº”ç”¨ç¨‹åºå†çº¿ç¨‹ç»“æŸä»»åŠ¡å‰ç»ˆæ­¢ã€‚3. è®¡ç®—é™åˆ¶çš„ä»»åŠ¡éœ€è¦é•¿æ—¶é—´è¿è¡Œã€‚çº¿ç¨‹æ± ä¸ºäº†åˆ¤æ–­æ˜¯å¦éœ€è¦åˆ›å»ºä¸€ä¸ªé¢å¤–çš„çº¿ç¨‹ï¼Œæ‰€é‡‡ç”¨çš„é€»è¾‘æ˜¯æ¯”è¾ƒå¤æ‚çš„ã€‚ç›´æ¥ä¸ºé•¿æ—¶é—´è¿è¡Œçš„ä»»åŠ¡åˆ›å»ºä¸“ç”¨çº¿ç¨‹ï¼Œå°±å¯ä»¥é¿å…è¿™ä¸ªé—®é¢˜ã€‚4. è¦å¯åŠ¨çº¿ç¨‹ï¼Œå¹¶å¯èƒ½è°ƒç”¨ Thread çš„ Abort æ–¹æ³•æ¥æå‰ç»ˆæ­¢å®ƒã€‚è¦åˆ›å»ºä¸“ç”¨çº¿ç¨‹ï¼Œéœ€è¦æ„é€  <code>System.Threading.Thread</code> ç±»çš„å®ä¾‹ã€‚æ„é€  <code>Thread</code> å¯¹è±¡æ˜¯è½»é‡çº§æ“ä½œï¼Œå› ä¸ºå®ƒå¹¶ä¸å®é™…åˆ›å»ºä¸€ä¸ªæ“ä½œç³»ç»Ÿçº¿ç¨‹ã€‚è¦å®é™…åˆ›å»ºæ“ä½œç³»ç»Ÿçº¿ç¨‹ï¼Œå¹¶è®©å®ƒå¼€å§‹æ‰§è¡Œå›è°ƒæ–¹æ³•ï¼Œå¿…é¡»è°ƒç”¨ <code>Thread</code> çš„ <code>Start</code> æ–¹æ³•ï¼Œå‘å®ƒåˆ›å»ºè¦ä½œä¸ºå›è°ƒæ–¹æ³•çš„å®å‚ä¼ é€’çš„å¯¹è±¡ï¼ˆçŠ¶æ€ï¼‰ã€‚</p><h2 id="reasons-to-use-threads"><a class="anchor" href="#reasons-to-use-threads">#</a> Reasons to Use Threads</h2><blockquote><p>There are really two reasons to use threads:</p><ul><li><p>Responsiveness (typically for client-side GUI applications) Windows gives each process its own thread so that one application entering an infinite loop doesnâ€™t prevent the user from working with other applications. Similarly, within your client-side GUI application, you could spawn some work off onto a thread so that your GUI thread remains responsive to user input events. In this example, you are possibly creating more threads than available cores on the machine, so you are wasting system resources and hurting performance. However, the user is gaining a responsive user interface and therefore having a better overall experience with your application.</p></li><li><p>Performance (for client and server side applications) Because Windows can schedule one thread per CPU and because the CPUs can execute these threads concurrently, your application can improve its performance by having multiple operations executing at the same time in parallel. Of course, you only get the improved performance if and only if your application is running on a machine with multiple CPUs in it. Today, machines with multiple CPUs in them are quite common, so designing your application to use multiple cores makes sense and is the focus of Chapter 27 and Chapter 28, â€œI/O-Bound Asynchronous Operations.â€</p></li></ul></blockquote><blockquote><p>Now, Iâ€™d like to share with you a theory of mine. Every computer has an incredibly powerful resource inside it: the CPU itself. If someone spends money on a computer, then that computer should be working all the time. In other words, I believe that all the CPUs in a computer should be running at 100 percent utilization all the time. I will qualify this statement with two caveats. First, you may not want the CPUs running at 100 percent utilization if the computer is on battery power, because that may drain the battery too quickly. Second, some data centers would prefer to have 10 machines running at 50 percent CPU utilization rather than 5 machines running at 100 percent CPU utilization, because running CPUs at full power tends to generate heat, which requires cooling systems, and powering an HVAC cooling system can be more expensive than powering more computers running at reduced capacity. Although data centers find it increasingly expensive to maintain multiple machines, because each machine has to have periodic hardware and software upgrades and monitoring, this has to be weighed against the expense of running a cooling system.</p></blockquote><blockquote><p>Now, if you agree with my theory, then the next step is to figure out what the CPUs should be doing. Before I give you my ideas here, let me say something else first. In the past, developers and end users always felt that the computer was not powerful enough. Therefore, we developers would never just execute code unless the end users give us permission to do so and indicate that it is OK for the application to consume CPU resources via UI elements, such as menu items, buttons, and check boxes.</p></blockquote><blockquote><p>But now, times have changed. Computers ship with phenomenal amounts of computing power. Earlier in this chapter, I showed you how Task Manager was reporting that my CPU was busy just 5 percent of the time. If my computer contained a quad-core CPU in it instead of the dual-core CPU that it now has, then Task Manager will report 2 percent more often. When an 80-core processor comes out, the machine will look like itâ€™s doing nothing almost all the time. To computer purchasers, it looks like theyâ€™re spending more money for more CPUs and the computer is doing less work!</p></blockquote><blockquote><p>This is the reason why the hardware manufacturers are having a hard time selling multi-core computers to users: the software isnâ€™t taking advantage of the hardware and users get no benefit from buying machines with additional CPUs. What Iâ€™m saying is that we now have an abundance of computing power available and more is on the way, so developers can aggressively consume it. Thatâ€™s rightâ€”in the past, we would never dream of having our applications perform some computation unless we knew the end user wanted the result of that computation. But now that we have extra computing power, we can dream like this.</p></blockquote><blockquote><p>Hereâ€™s an example: when you stop typing in Visual Studioâ€™s editor, Visual Studio automatically spawns the compiler and compiles your code. This makes developers incredibly productive because they can see warnings and errors in their source code as they type and can fix things immediately. In fact, what developers think of today as the Edit-Build-Debug cycle will become just the Edit-Debug cycle, because building (compiling) code will just happen all the time. You, as an end user, wonâ€™t notice this because there is a lot of CPU power available and other things youâ€™re doing will barely be affected by the frequent running of the compiler. In fact, I would expect that in some future version of Visual Studio, the Build menu item will disappear completely, because building will just become automatic. Not only does the applicationâ€™s UI get simpler, but the application also offers â€œanswersâ€ to the end user, making them more productive.</p></blockquote><blockquote><p>When we remove UI components like menu items, computers get simpler for end users. There are fewer options for them and fewer concepts for them to read and understand. It is the multi-core revolution that allows us to remove these UI elements, thereby making software so much simpler for end users that my grandmother might someday feel comfortable using a computer. For developers, removing UI elements usually results in less testing, and offering fewer options to the end user simplifies the code base. And if you currently localize the text in your UI elements and your documentation (like Microsoft does), then removing the UI elements means that you write less documentation and you donâ€™t have to localize this documentation anymore. All of this can save your organization a lot of time and money.</p></blockquote><blockquote><p>Here are some more examples of aggressive CPU consumption: spell checking and grammar checking of documents, recalculation of spreadsheets, indexing files on your disk for fast searching, and defragmenting your hard disk to improve I/O performance.</p></blockquote><blockquote><p>I want to live in a world where the UI is reduced and simplified, I have more screen real estate to visualize the data that Iâ€™m actually working on, and applications offer me information that helps me get my work done quickly and efficiently instead of me telling the application to go get information for me. I think the hardware has been there for software developers to use for the past few years. Itâ€™s time for the software to start using the hardware creatively.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šä½¿ç”¨çº¿ç¨‹ä¸»è¦æœ‰ä¸¤ä¸ªç†ç”±ï¼š1. å¯å“åº”æ€§ï¼ˆé€šå¸¸æ˜¯å¯¹äºå®¢æˆ·ç«¯ GUI åº”ç”¨ç¨‹åºï¼‰ï¼ŒWindows ä¸ºæ¯ä¸ªè¿›ç¨‹æä¾›å®ƒè‡ªå·±çš„çº¿ç¨‹ï¼Œç¡®ä¿å‘ç”Ÿæ­»å¾ªç¯çš„åº”ç”¨ç¨‹åºä¸ä¼šå¦¨ç¢å…¶ä»–åº”ç”¨ç¨‹åºã€‚2. æ€§èƒ½ï¼ˆå¯¹äºå®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨åº”ç”¨ç¨‹åºï¼‰ï¼Œç”±äº Windows æ¯ä¸ª CPU è°ƒåº¦ä¸€ä¸ªçº¿ç¨‹ï¼Œè€Œä¸”å¤šä¸ª CPU èƒ½å¹¶å‘æ‰§è¡Œè¿™äº›çº¿ç¨‹ï¼Œæ‰€ä»¥åŒæ—¶æ‰§è¡Œå¤šä¸ªæ“ä½œèƒ½æå‡æ€§èƒ½ã€‚å½“ç„¶ï¼Œåªæœ‰å¤šä¸ª CPUï¼ˆæˆ–å¤šæ ¸ CPUï¼‰æ‰èƒ½å¾—åˆ°æ€§èƒ½çš„æå‡ã€‚å¦‚ä»Šçš„è®¡ç®—æœºä¸€èˆ¬éƒ½é…å¤‡äº†å¼ºå¤§çš„è®¡ç®—èƒ½åŠ›ï¼Œæ‰€ä»¥å¼€å‘äººå‘˜åº”è¯¥å¤§èƒ†æ¶ˆè´¹å®ƒã€‚äº‹å®ä¸Šï¼Œä¼ ç»Ÿçš„ â€œç¼–è¾‘ - ç”Ÿæˆ - è°ƒè¯•â€ æ¨¡å¼é€æ¸å˜æˆ â€œç¼–è¾‘ - è°ƒè¯•â€ï¼Œå› ä¸ºç”Ÿæˆï¼ˆç¼–è¯‘ï¼‰ä»£ç çš„åŠ¨ä½œä¸€ç›´éƒ½åœ¨å‘ç”Ÿã€‚ä½œä¸ºæœ€ç»ˆç”¨æˆ·ï¼Œä½ æ˜¯æ³¨æ„ä¸åˆ°è¿™ä¸€ç‚¹çš„ï¼Œå› ä¸ºæœ‰å……è¶³çš„è®¡ç®—èµ„æºå¯ä¾›ä½¿ç”¨ï¼Œè€Œä¸”ç¼–è¯‘å™¨çš„é¢‘ç¹è¿è¡Œä¸€èˆ¬ä¸ä¼šå½±å“ä½ æ­£åœ¨åšçš„å…¶ä»–äº‹æƒ…ã€‚</p><h2 id="thread-scheduling-and-priorities"><a class="anchor" href="#thread-scheduling-and-priorities">#</a> Thread Scheduling and Priorities</h2><blockquote><p>A preemptive operating system must use some kind of algorithm to determine which threads should be scheduled when and for how long. In this section, weâ€™ll look at the algorithm Windows uses. Earlier in this chapter, I mentioned how every threadâ€™s kernel object contains a context structure. The context structure reflects the state of the threadâ€™s CPU registers when the thread last executed. After a timeslice, Windows looks at all the thread kernel objects currently in existence. Of these objects, only the threads that are not waiting for something are considered schedulable. Windows selects one of the schedulable thread kernel objects and context switches to it. Windows actually keeps a record of how many times each thread gets context switched to. You can see this when using a tool such as Microsoft Spy++. Figure 26-3 shows the properties for a thread. Notice that this thread has been scheduled 31,768 times.</p></blockquote><p><img data-src="/2023/02/06/csharp/clr-via-csharp/Chapter%2026%20Thread%20Basics/image-20230206115047785.png" alt="image-20230206115047785"></p><p><strong>FIGURE 26-3</strong> Spy++ showing a threadâ€™s properties.</p><blockquote><p>At this point, the thread is executing code and manipulating data in its processâ€™s address space. After another time-slice, Windows performs another context switch. Windows performs context switches from the moment the system is booted and continues until the system is shut down.</p></blockquote><blockquote><p>Windows is called a preemptive multithreaded operating system because a thread can be stopped at any time and another thread can be scheduled. As youâ€™ll see, you have some control over this, but not much. Just remember that you cannot guarantee that your thread will always be running and that no other thread will be allowed to run.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šç»å¸¸æœ‰å¼€å‘äººå‘˜é—®æˆ‘ï¼Œæ€æ ·ä¿è¯çº¿ç¨‹åœ¨å‘ç”ŸæŸä¸ªäº‹ä»¶åçš„ä¸€æ®µæ—¶é—´å†…å¼€å§‹è¿è¡Œ â€”â€” ä¾‹å¦‚ï¼Œæ€æ ·ä¿è¯ä¸€ä¸ªçº¿ç¨‹åœ¨ç½‘ç»œæœ‰æ•°æ®ä¼ æ¥çš„ 1 æ¯«ç§’å†…å¼€å§‹è¿è¡Œï¼Ÿå¯¹æ­¤æˆ‘çš„å›ç­”æ€»æ˜¯å¾ˆå¹²è„†ï¼šä¿è¯ä¸äº†ï¼</p><p>å®æ—¶æ“ä½œç³»ç»Ÿèƒ½åšå‡ºè¿™æ ·çš„ä¿è¯ï¼Œä½† Windows ä¸æ˜¯å®æ—¶æ“ä½œç³»ç»Ÿã€‚å®æ—¶æ“ä½œç³»ç»Ÿéœ€è¦å¯¹ç¡¬ä»¶çš„è¿è¡Œæƒ…å†µæœ‰ä¸€ä¸ªç²¾å‡†çš„æŠŠæ¡ï¼Œå®ƒçŸ¥é“ç¡¬ç›˜æ§åˆ¶å™¨ã€é”®ç›˜ä»¥åŠå…¶ä»–ç»„ä»¶çš„å‡†ç¡®å»¶è¿Ÿæ—¶é—´ã€‚ä½† Microsoft Windows çš„è®¾è®¡ç›®æ ‡æ˜¯å…¼å®¹å¤§èŒƒå›´çš„ç¡¬ä»¶ï¼ŒåŒ…æ‹¬ä¸åŒçš„ CPUã€ä¸åŒçš„é©±åŠ¨å™¨ã€ä¸åŒçš„ç½‘ç»œç­‰ã€‚ç®€å•åœ°è¯´ï¼ŒWindows æ²¡æœ‰è¢«è®¾è®¡æˆå®æ—¶æ“ä½œç³»ç»Ÿã€‚è¡¥å……ä¸€å¥ï¼ŒCLR ä½¿æ‰˜ç®¡ä»£ç çš„è¡Œä¸ºå˜å¾—æ›´ä¸ â€œå®æ—¶â€ äº†ã€‚ä¹‹æ‰€ä»¥è¦è¿™æ ·è®¾è®¡ï¼Œæ˜¯å‡ºäºè®¸å¤šæ–¹é¢çš„åŸå› ï¼ŒåŒ…æ‹¬ DLL çš„ JIT (just-in-time) åŠ è½½ã€ä»£ç çš„ JIT ç¼–è¯‘ä»¥åŠåƒåœ¾å›æ”¶å™¨æ— æ³•é¢„æµ‹çš„ä»‹å…¥æ—¶é—´ç­‰ã€‚</p><blockquote><p>Every thread is assigned a priority level ranging from 0 (the lowest) to 31 (the highest). When the system decides which thread to assign to a CPU, it examines the priority 31 threads first and schedules them in a round-robin fashion. If a priority 31 thread is schedulable, it is assigned to a CPU. At the end of this threadâ€™s time-slice, the system checks to see whether there is another priority 31 thread that can run; if so, it allows that thread to be assigned to a CPU.</p></blockquote><blockquote><p>As long as priority 31 threads are schedulable, the system never assigns any thread with a priority of 0 through 30 to a CPU. This condition is called starvation, and it occurs when higher-priority threads use so much CPU time that they prevent lower-priority threads from executing. Starvation is much less likely to occur on a multiprocessor machine because a priority 31 thread and a priority 30 thread can run simultaneously on such a machine. The system always tries to keep the CPUs busy, and CPUs sit idle only if no threads are schedulable.</p></blockquote><blockquote><p>Higher-priority threads always preempt lower-priority threads, regardless of what the lower-priority threads are executing. For example, if a priority 5 thread is running and the system determines that a higher-priority thread is ready to run, the system immediately suspends the lower-priority thread (even if itâ€™s in the middle of its time-slice) and assigns the CPU to the higher-priority thread, which gets a full time-slice.</p></blockquote><blockquote><p>By the way, when the system boots, it creates a special thread called the zero page thread. This thread is assigned priority 0 and is the only thread in the entire system that runs at priority 0. The zero page thread is responsible for zeroing any free pages of RAM in the system when no other threads need to perform work.</p></blockquote><blockquote><p>Microsoft realized that assigning priority levels to threads was going to be too hard for developers to rationalize. Should this thread be priority level 10? Should this other thread be priority level 23? To resolve this issue, Windows exposes an abstract layer over the priority level system.</p></blockquote><blockquote><p>When designing your application, you should decide whether your application needs to be more or less responsive than other applications that may be running on the machine. Then you choose a process priority class to reflect your decision. Windows supports six process priority classes: Idle, Below Normal, Normal, Above Normal, High, and Realtime. Of course, Normal is the default and is therefore the most common priority class by far.</p></blockquote><blockquote><p>The Idle priority class is perfect for applications (like screen savers) that run when the system is all but doing nothing. A computer that is not being used interactively might still be busy (acting as a file server, for example) and should not have to compete for CPU time with a screen saver. Statisticstracking applications that periodically update some state about the system usually should not interfere with more critical tasks.</p></blockquote><blockquote><p>You should use the High priority class only when absolutely necessary. You should avoid using the Realtime priority class if possible. Realtime priority is extremely high and can interfere with operating system tasks, such as preventing required disk I/O and network traffic from occurring. In addition, a Realtime processâ€™s threads could prevent keyboard and mouse input from being processed in a timely manner, causing the user to think that the system is completely frozen. Basically, you should have a good reason for using Realtime priority, such as the need to respond to hardware events with short latency or to perform some short-lived task.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šä¸ºäº†ä¿æŒç³»ç»Ÿæ€»ä½“å¹³ç¨³è¿è¡Œï¼Œé™¤éç”¨æˆ·æœ‰ â€œæé«˜è°ƒåº¦ä¼˜å…ˆçº§â€(Increase Scheduling Priority) ç‰¹æƒï¼Œå¦åˆ™è¿›ç¨‹ä¸èƒ½ä»¥ <code>Realtime</code> ä¼˜å…ˆçº§ç±»è¿è¡Œã€‚ç®¡ç†å‘˜å’Œ Power User é»˜è®¤æœ‰è¿™ä¸ªç‰¹æƒã€‚</p><blockquote><p>After you select a priority class, you should stop thinking about how your application relates to other applications and just concentrate on the threads within your application. Windows supports seven relative thread priorities: Idle, Lowest, Below Normal, Normal, Above Normal, Highest, and Time-Critical. These priorities are relative to the processâ€™s priority class. Again, Normal relative thread priority is the default, and it is therefore the most common.</p></blockquote><blockquote><p>So, to summarize, your process is a member of a priority class and within that process you assign thread priorities that are relative to each other. Youâ€™ll notice that I havenâ€™t said anything about priority levels 0 through 31. Application developers never work with priority levels directly. Instead, the system maps the processâ€™s priority class and a threadâ€™s relative priority to a priority level. Table 26-1 shows how the processâ€™s priority class and the threadâ€™s relative priority maps to priority levels.</p></blockquote><p><img data-src="/2023/02/06/csharp/clr-via-csharp/Chapter%2026%20Thread%20Basics/image-20221205211539751.png" alt="image-20221205211539751"></p><blockquote><p>For example, a Normal thread in a Normal process is assigned a priority level of 8. Because most processes are of the Normal priority class and most threads are of Normal thread priority, most threads in the system have a priority level of 8.</p></blockquote><blockquote><p>If you have a Normal thread in a high-priority process, the thread will have a priority level of 13. If you change the processâ€™s priority class to Idle, the threadâ€™s priority level becomes 4. Remember that thread priorities are relative to the processâ€™s priority class. If you change a processâ€™s priority class, the threadâ€™s relative priority will not change, but its priority number will.</p></blockquote><blockquote><p>Notice that the table does not show any way for a thread to have a priority level of 0. This is because the 0 priority is reserved for the zero page thread and the system does not allow any other thread to have a priority of 0. Also, the following priority levels are not obtainable: 17, 18, 19, 20, 21, 27, 28, 29, or 30. If you are writing a device driver that runs in kernel mode, you can obtain these levels; a user-mode application cannot. Also note that a thread in the Realtime priority class canâ€™t be below priority level 16. Likewise, a thread in a priority class other than Realtime cannot be above 15.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šâ€œè¿›ç¨‹ä¼˜å…ˆçº§ç±»â€ çš„æ¦‚å¿µå®¹æ˜“å¼•èµ·æ··æ·†ã€‚äººä»¬å¯èƒ½ä»¥ä¸º Windows åœ¨è°ƒåº¦è¿›ç¨‹ã€‚äº‹å®ä¸Š Windows æ°¸è¿œä¸ä¼šè°ƒåº¦è¿›ç¨‹ï¼Œå®ƒåªè°ƒåº¦çº¿ç¨‹ã€‚â€œè¿›ç¨‹ä¼˜å…ˆçº§ç±»â€ æ˜¯ Microsoft æå‡ºçš„æŠ½è±¡æ¦‚å¿µï¼Œæ—¨åœ¨å¸®åŠ©ä½ ç†è§£è‡ªå·±çš„åº”ç”¨ç¨‹åºå’Œå…¶ä»–æ­£åœ¨è¿è¡Œçš„åº”ç”¨ç¨‹åºçš„å…³ç³»ï¼Œå®ƒæ²¡æœ‰åˆ«çš„ç”¨é€”ã€‚</p><p>ğŸ’¡é‡è¦æç¤ºï¼šæœ€å¥½æ˜¯é™ä½ä¸€ä¸ªçº¿ç¨‹çš„ä¼˜å…ˆçº§ï¼Œè€Œä¸æ˜¯æå‡å¦ä¸€ä¸ªçº¿ç¨‹çš„ä¼˜å…ˆçº§ã€‚å¦‚æœçº¿ç¨‹è¦æ‰§è¡Œé•¿æ—¶é—´çš„è®¡ç®—é™åˆ¶ä»»åŠ¡ï¼Œæ¯”å¦‚ç¼–è¯‘ä»£ç ã€æ‹¼å†™æ£€æŸ¥ã€ç”µå­è¡¨æ ¼é‡æ–°è®¡ç®—ç­‰ï¼Œä¸€èˆ¬åº”é™ä½è¯¥çº¿ç¨‹çš„ä¼˜å…ˆçº§ã€‚å¦‚æœçº¿ç¨‹è¦å¿«é€Ÿå“åº”æŸä¸ªäº‹ä»¶ï¼Œè¿è¡ŒçŸ­æš‚æ—¶é—´ï¼Œå†å›å¤ä¸ºç­‰å¾…çŠ¶æ€ï¼Œåˆ™åº”æé«˜è¯¥çº¿ç¨‹çš„ä¼˜å…ˆçº§ã€‚é«˜ä¼˜å…ˆçº§çº¿ç¨‹åœ¨å…¶ç”Ÿå­˜æœŸçš„å¤§å¤šæ•°æ—¶é—´é‡Œéƒ½åº”å‡ºäºç­‰å¾…çŠ¶æ€ï¼Œè¿™æ ·æ‰ä¸è‡³äºå½±å“ç³»ç»Ÿçš„æ€»ä½“å“åº”èƒ½åŠ›ã€‚ä¾‹å¦‚ï¼Œå“åº”ç”¨æˆ·æŒ‰ Windows å¾½æ ‡é”®çš„ â€œWindows èµ„æºç®¡ç†å™¨â€ çº¿ç¨‹å°±æ˜¯ä¸€ä¸ªé«˜ä¼˜å…ˆçº§çº¿ç¨‹ã€‚å½“ç”¨æˆ·æŒ‰è¿™ä¸ªé”®æ—¶ï¼ŒWindows èµ„æºç®¡ç†å™¨ç«‹å³æŠ¢å å…¶ä»–æ›´ä½ä¼˜å…ˆçº§çš„çº¿ç¨‹ï¼Œå¹¶æ˜¾ç¤ºå®ƒçš„èœå•ã€‚ç”¨æˆ·åœ¨èœå•ä¸­ä¸Šä¸‹ç§»åŠ¨æ—¶ï¼Œ Windows èµ„æºç®¡ç†å™¨çš„çº¿ç¨‹ä¼šå¿«é€Ÿå“åº”æ¯ä¸€æ¬¡æŒ‰é”® (æˆ–é¼ æ ‡ç§»åŠ¨)ï¼Œæ›´æ–°èœå•ï¼Œå¹¶åœæ­¢è¿è¡Œï¼Œç›´åˆ°ç”¨æˆ·ç»§ç»­åœ¨èœå•ä¸­å¯¼èˆªã€‚</p><blockquote><p>Normally, a process is assigned a priority class based on the process that starts it running. And most processes are started by Explorer, which spawns all its child processes in the Normal priority class. Managed applications are not supposed to act as though they own their own processes; they are supposed to act as though they run in an AppDomain, so managed applications are not supposed to change their processâ€™s priority class because this would affect all code running in the process. For example, many <span class="exturl" data-url="aHR0cDovL0FTUC5ORVQ=">ASP.NET</span> applications run in a single process, with each application in its own AppDomain. The same is true for Microsoft Silverlight applications, which run in an Internet browser process, and managed stored procedures, which run inside the Microsoft SQL Server process.</p></blockquote><blockquote><p>In addition, a Windows Store app is not able to create additional AppDomains, cannot change its processâ€™s priority class, or any of its threadsâ€™ priorities. Furthermore, when a Windows Store app is not in the foreground, Windows automatically suspends all its threads. This serves two purposes. First, it prevents a background app from â€œstealingâ€ CPU time away from the app the user is actively interacting with. This ensures that touch events like swipes are fast and fluid. Second, by reducing CPU usage, battery power is conserved, allowing the PC to run longer on a single charge.</p></blockquote><blockquote><p>On the other hand, your application can change the relative thread priority of its threads by setting Threadâ€™s Priority property, passing it one of the five values (Lowest, BelowNormal, Normal, AboveNormal, or Highest) defined in the ThreadPriority enumerated type. However, just as Windows has reserved the priority level 0 and the real-time range for itself, the CLR reserves the Idle and Time-Critical priority levels for itself. Today, the CLR has no threads that run at Idle priority level, but this could change in the future. However, the CLRâ€™s finalizer thread, discussed in Chapter 21, â€œThe Managed Heap and Garbage Collection,â€ runs at the Time-Critical priority level. Therefore, as a managed developer, you really only get to use the five highlighted relative thread priorities listed in Table 26-1.</p></blockquote><p>ğŸ’¡é‡è¦æç¤ºï¼šä»Šå¤©ï¼Œå¤§å¤šæ•°åº”ç”¨ç¨‹åºéƒ½æ²¡æœ‰åˆ©ç”¨çº¿ç¨‹ä¼˜å…ˆçº§ã€‚ä½†åœ¨æˆ‘è®¾æƒ³çš„ç†æƒ³ä¸–ç•Œä¸­ï¼ŒCPU åº”ä¿æŒ 100% çš„åˆ©ç”¨ç‡ï¼Œä¸€è‡´éƒ½åœ¨åšæœ‰ç”¨çš„å·¥ä½œã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä¸ºäº†ä¿è¯ç³»ç»Ÿå“åº”èƒ½åŠ›ä¸å—å½±å“ï¼Œçº¿ç¨‹ä¼˜å…ˆçº§å°±æ˜¾å¾—è‡³å…³é‡è¦ã€‚é—æ†¾çš„æ˜¯ï¼Œå¤šå¹´æ¥æœ€ç»ˆç”¨æˆ·å·²å…»æˆäº†ä¸€ä¸ªä¹ æƒ¯ï¼›ä¸€æ—¦çœ‹åˆ°å¤ªé«˜çš„ CPU ä½¿ç”¨ç‡ï¼Œå°±æ„Ÿè§‰åº”ç”¨ç¨‹åºè¦å¤±å»æ§åˆ¶äº†ã€‚åœ¨æˆ‘çš„æ–°ä¸–ç•Œä¸­ï¼Œéœ€è¦å¯¹æœ€ç»ˆç”¨æˆ·è¿›è¡Œ â€œçŸ¥è¯†å†æ™®åŠâ€ï¼Œè®©ä»–ä»¬æ˜ç™½é«˜çš„ CPU åˆ©ç”¨ç‡ä¹Ÿè®¸æ˜¯ä¸€ä»¶å¥½äº‹æƒ… â€”â€” è¡¨æ˜è®¡ç®—æœºæ­£åœ¨ç§¯æåœ°ä¸ºç”¨æˆ·å¤„ç†æœ‰ç”¨çš„ä¿¡æ¯ã€‚å¦‚æœæ‰€æœ‰ CPU éƒ½å¿™äºè¿è¡Œä¼˜å…ˆçº§ 8 å’Œä»¥ä¸Šçš„çº¿ç¨‹ï¼Œå°±çœŸçš„å‡ºé—®é¢˜äº†ã€‚è¿™æ„å‘³ç€åº”ç”¨ç¨‹åºåœ¨å“åº”æœ€ç»ˆç”¨æˆ·çš„è¾“å…¥æ—¶é‡åˆ°éº»çƒ¦ã€‚â€œä»»åŠ¡ç®¡ç†å™¨â€ æœªæ¥çš„ç‰ˆæœ¬åœ¨æŠ¥å‘Š CPU åˆ©ç”¨ç‡æ—¶ï¼Œæˆ–è®¸åº”è¯¥å°†çº¿ç¨‹ä¼˜å…ˆçº§è€ƒè™‘åœ¨å†…ï¼›è¯Šæ–­æœ‰é—®é¢˜çš„ç³»ç»Ÿæ—¶ï¼Œè¿™ç§ä¿¡æ¯æ˜¯ç›¸å½“æœ‰å¸®åŠ©çš„ã€‚</p><blockquote><p>For desktop apps (nonâ€“Windows Store apps), I should point out that the System.Diagnostics namespace contains a Process class and a ProcessThread class. These classes provide the Windows view of a process and thread, respectively. These classes are provided for developers wanting to write utility applications in managed code or for developers who are trying to instrument their code to help them debug it. In fact, this is why the classes are in the System.Diagnostics namespace. Applications need to be running with special security permissions to use these two classes. You would not be able to use these classes from a Silverlight application or an <span class="exturl" data-url="aHR0cDovL0FTUC5ORVQ=">ASP.NET</span> application, for example.</p></blockquote><blockquote><p>On the other hand, applications can use the AppDomain and Thread classes, which expose the CLRâ€™s view of an AppDomain and thread. For the most part, special security permissions are not required to use these classes, although some operations are still considered privileged.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šæ¯ä¸ªçº¿ç¨‹çš„å†…æ ¸å¯¹è±¡éƒ½åŒ…å«ä¸€ä¸ªä¸Šä¸‹æ–‡ç»“æ„ã€‚ä¸Šä¸‹æ–‡ï¼ˆcontextï¼‰ç»“æ„åæ˜ äº†çº¿ç¨‹ä¸Šä¸€æ¬¡æ‰§è¡Œå®Œæ¯•å CPU å¯„å­˜å™¨çš„çŠ¶æ€ã€‚åœ¨ä¸€ä¸ªæ—¶é—´ç‰‡ï¼ˆtime-sliceï¼‰ä¹‹åï¼ŒWindows æ£€æŸ¥ç°å­˜çš„æ‰€æœ‰çº¿ç¨‹å†…æ ¸å¯¹è±¡ã€‚åœ¨è¿™äº›å¯¹è±¡ä¸­ï¼Œåªæœ‰é‚£äº›æ²¡æœ‰æ­£åœ¨ç­‰å¾…ä»€ä¹ˆçš„çº¿ç¨‹æ‰é€‚åˆè°ƒåº¦ã€‚Windows ä¹‹æ‰€ä»¥è¢«ç§°ä¸ºæŠ¢å å¼å¤šçº¿ç¨‹ï¼ˆpreemptive multithreadedï¼‰æ“ä½œç³»ç»Ÿï¼Œæ˜¯å› ä¸ºçº¿ç¨‹å¯åœ¨ä»»ä½•æ—¶é—´åœæ­¢ï¼ˆè¢«æŠ¢å ï¼‰å¹¶è°ƒåº¦å¦ä¸€ä¸ªçº¿ç¨‹ã€‚æ¯ä¸ªçº¿ç¨‹éƒ½åˆ†é…äº†ä» 0ï¼ˆæœ€ä½ï¼‰åˆ° 31ï¼ˆæœ€é«˜ï¼‰çš„ä¼˜å…ˆçº§ã€‚ç³»ç»Ÿå†³å®šä¸º CPU åˆ†é…å“ªä¸ªçº¿ç¨‹æ—¶ï¼Œé¦–å…ˆæ£€æŸ¥ä¼˜å…ˆçº§ 31 çš„çº¿ç¨‹ï¼Œå¹¶ä»¥ä¸€ç§è½®æµï¼ˆround-robinï¼‰æ–¹å¼è°ƒåº¦å®ƒä»¬ã€‚å¦‚æœä¼˜å…ˆçº§ 31 çš„ä¸€ä¸ªçº¿ç¨‹å¯ä»¥è°ƒåº¦ï¼Œå°±æŠŠå®ƒåˆ†é…ç»™ CPUã€‚åœ¨è¿™ä¸ªçº¿ç¨‹çš„æ—¶é—´ç‰‡ç»“æŸæ—¶ï¼Œç³»ç»Ÿæ£€æŸ¥æ˜¯å¦æœ‰å¦ä¸€ä¸ªä¼˜å…ˆçº§ 31 çš„çº¿ç¨‹å¯ä»¥è¿è¡Œï¼›å¦‚æœæ˜¯ï¼Œå°±è¿è¡Œå°†é‚£ä¸ªçº¿ç¨‹åˆ†é…ç»™ CPUã€‚åªè¦å­˜åœ¨å¯è°ƒåº¦çš„è¾ƒé«˜ä¼˜å…ˆçº§çš„çº¿ç¨‹ï¼Œå…¶ä»–ä¼˜å…ˆçº§çš„çº¿ç¨‹å°±æ— æ³•è¿è¡Œï¼Œè¿™ç§æƒ…å†µç§°ä¸ºé¥¥é¥¿ã€‚å¤šå¤„ç†å™¨æœºå™¨å‘ç”Ÿé¥¥é¥¿çš„å¯èƒ½æ€§è¦å°å¾—å¤šï¼Œå› ä¸ºè¿™ç§æœºå™¨ä¸Šä¼˜å…ˆçº§ä¸º 31 çš„çº¿ç¨‹å’Œä¼˜å…ˆçº§ä¸º 30 çš„çº¿ç¨‹å¯ä»¥åŒæ—¶è¿è¡Œã€‚ç³»ç»Ÿæ€»æ˜¯ä¿æŒå„ä¸ª CPU å¤„äºå¿™ç¢ŒçŠ¶æ€ï¼Œåªæœ‰æ²¡æœ‰çº¿ç¨‹å¯è°ƒåº¦çš„æ—¶å€™ï¼ŒCPU æ‰ä¼šç©ºé—²ä¸‹æ¥ã€‚è¾ƒé«˜ä¼˜å…ˆçº§çš„çº¿ç¨‹æ€»æ˜¯æŠ¢å è¾ƒä½ä¼˜å…ˆçº§çš„çº¿ç¨‹ï¼Œæ— è®ºæ­£åœ¨è¿è¡Œçš„æ˜¯ä»€ä¹ˆè¾ƒä½ä¼˜å…ˆçº§çš„çº¿ç¨‹ã€‚ç³»ç»Ÿå¯åŠ¨æ—¶ä¼šåˆ›å»ºä¸€ä¸ªç‰¹æ®Šçš„é›¶é¡µçº¿ç¨‹ï¼ˆzero page threadï¼‰ã€‚è¯¥çº¿ç¨‹çš„ä¼˜å…ˆçº§æ˜¯ 0ï¼Œè€Œä¸”æ˜¯æ•´ä¸ªç³»ç»Ÿå”¯ä¸€ä¼˜å…ˆçº§ä¸º 0 çš„çº¿ç¨‹ã€‚åœ¨æ²¡æœ‰å…¶ä»–çº¿ç¨‹éœ€è¦ â€œå¹²æ´»å„¿â€ çš„æ—¶å€™ï¼Œé›¶é¡µçº¿ç¨‹å°†ç³»ç»Ÿ RAM çš„æ‰€æœ‰ç©ºé—²é¡µæ¸…é›¶ã€‚ç”±äºå¼€å‘äººå‘˜åœ¨ä¸ºçº¿ç¨‹åˆ†é…ä¼˜å…ˆçº§æ—¶å¾ˆéš¾åšåˆ°å®Œå…¨åˆç†ï¼Œå› æ­¤ Windows å…¬å¼€äº†ä¼˜å…ˆçº§ç³»ç»Ÿçš„ä¸€ä¸ªæŠ½è±¡å±‚ã€‚Windows æ”¯æŒ 6 ä¸ªè¿›ç¨‹ä¼˜å…ˆçº§ç±»ï¼šIdleã€Below Normalã€Normalã€Above Normalã€High å’Œ Realtimeã€‚é»˜è®¤çš„ Normal æ˜¯æœ€å¸¸ç”¨çš„ä¼˜å…ˆçº§ç±»ã€‚åªæœ‰ç»å¯¹å¿…è¦çš„æ—¶å€™æ‰åº”ä½¿ç”¨ High ä¼˜å…ˆçº§ç±»ã€‚Realtime ä¼˜å…ˆçº§ç±»è¦å°½å¯èƒ½åœ°é¿å…ã€‚Realtime ä¼˜å…ˆçº§ç›¸å½“é«˜ï¼Œå®ƒç”šè‡³å¯èƒ½å¹²æ‰°æ“ä½œç³»ç»Ÿä»»åŠ¡ï¼Œæ¯”å¦‚é˜»ç¢ä¸€äº›å¿…è¦çš„ç£ç›˜ I/O å’Œç½‘ç»œä¼ è¾“ã€‚æ­¤å¤–ï¼ŒWindows æ”¯æŒ 7 ä¸ªç›¸å¯¹çº¿ç¨‹ä¼˜å…ˆçº§ï¼šIdleã€Lowestã€Below Normalã€Normalã€Above Normalã€Highest å’Œ Time-Criticalã€‚è¿™äº›ä¼˜å…ˆçº§æ˜¯ç›¸å¯¹äºè¿›ç¨‹ä¼˜å…ˆçº§ç±»è€Œè¨€çš„ã€‚æ¯ä¸ªçº¿ç¨‹çš„ä¼˜å…ˆçº§å–å†³äºä¸¤ä¸ªæ ‡å‡†ï¼š1) å®ƒçš„è¿›ç¨‹çš„ä¼˜å…ˆçº§ç±»ï¼›2) åœ¨å…¶è¿›ç¨‹çš„ä¼˜å…ˆçº§ç±»ä¸­ï¼Œçº¿ç¨‹çš„ä¼˜å…ˆçº§ã€‚ä¼˜å…ˆçº§ç±»å’Œä¼˜å…ˆçº§åˆå¹¶æ„æˆäº†ä¸€ä¸ªçº¿ç¨‹çš„ â€œåŸºç¡€ä¼˜å…ˆçº§â€(base priority)ã€‚æ³¨æ„ï¼Œæ¯ä¸ªçº¿ç¨‹éƒ½æœ‰ä¸€ä¸ªåŠ¨æ€ä¼˜å…ˆçº§ (dynamic priority)ã€‚çº¿ç¨‹è°ƒåº¦å™¨æ ¹æ®è¿™ä¸ªä¼˜å…ˆçº§æ¥å†³å®šè¦æ‰§è¡Œå“ªä¸ªçº¿ç¨‹ã€‚æœ€åˆï¼Œçº¿ç¨‹çš„åŠ¨æ€ä¼˜å…ˆçº§å’Œå®ƒçš„åŸºç¡€ä¼˜å…ˆçº§æ˜¯ç›¸åŒçš„ã€‚ç³»ç»Ÿå¯æå‡ (boost) å’Œé™ä½ (lower) åŠ¨æ€ä¼˜å…ˆçº§ï¼Œä»¥ç¡®ä¿å®ƒçš„å¯å“åº”æ€§ï¼Œå¹¶é¿å…çº¿ç¨‹åœ¨å¤„ç†å™¨æ—¶é—´å†… â€œé¥¥é¥¿â€ã€‚ä½†æ˜¯ï¼Œå¯¹äºåŸºç¡€ä¼˜å…ˆçº§ 16~31 ä¹‹é—´çš„çº¿ç¨‹ï¼Œç³»ç»Ÿä¸ä¼šæå‡å®ƒä»¬çš„ä¼˜å…ˆçº§ã€‚åªæœ‰åŸºç¡€ä¼˜å…ˆçº§åœ¨ 0 åˆ° 15 ä¹‹é—´çš„çº¿ç¨‹æ‰ä¼šè¢«åŠ¨æ€æå‡ (ä¼˜å…ˆçº§)ã€‚æ›´æ”¹ä¸€ä¸ªè¿›ç¨‹çš„ä¼˜å…ˆçº§ç±»ï¼Œçº¿ç¨‹çš„ç›¸å¯¹ä¼˜å…ˆçº§ä¸ä¼šæ”¹å˜ï¼Œä½†å®ƒçš„ç»å¯¹ä¼˜å…ˆçº§å€¼ä¼šæ”¹å˜ã€‚ä»¥ä¸‹ä¼˜å…ˆçº§åªæœ‰ä»¥å†…æ ¸æ¨¡å¼è¿è¡Œçš„è®¾å¤‡é©±åŠ¨ç¨‹åºæ‰èƒ½è·å¾—ï¼š0ï¼Œ17ï¼Œ18ï¼Œ19ï¼Œ20ï¼Œ21ï¼Œ27ï¼Œ28ï¼Œ29 æˆ–è€… 30ã€‚ä½ çš„åº”ç”¨ç¨‹åºå¯æ›´æ”¹å…¶çº¿ç¨‹çš„ç›¸å¯¹çº¿ç¨‹ä¼˜å…ˆçº§ï¼Œè¿™éœ€è¦è®¾ç½® <code>Thread</code> çš„ <code>Priority</code> å±æ€§ï¼Œå‘å…¶ä¼ é€’ <code>ThreadPriority</code> æšä¸¾ç±»å‹å®šä¹‰çš„ 5 ä¸ªå€¼ä¹‹ä¸€ï¼› <code>Lowest</code> ï¼Œ <code>BelowNormal</code> ï¼Œ <code>Normal</code> ï¼Œ <code>AboveNormal</code> æˆ–è€… <code>Highest</code> ã€‚ç„¶è€Œï¼Œå°±åƒ Windows ä¸ºè‡ªå·±ä¿ç•™äº†ä¼˜å…ˆçº§ 0 å’Œ Realtime èŒƒå›´ä¸€æ ·ï¼ŒCLR ä¸ºè‡ªå·±ä¿ç•™äº† Idle å’Œ Time-Critical ä¼˜å…ˆçº§ã€‚<strong>CLR çš„ç»ˆç»“å™¨çº¿ç¨‹ä»¥ Time-Critical ä¼˜å…ˆçº§è¿è¡Œã€‚</strong></p><h2 id="foreground-threads-vs-background-threads"><a class="anchor" href="#foreground-threads-vs-background-threads">#</a> Foreground Threads vs. Background Threads</h2><blockquote><p>The CLR considers every thread to be either a foreground thread or a background thread. When all the foreground threads in a process stop running, the CLR forcibly ends any background threads that are still running. These background threads are ended immediately; no exception is thrown.</p></blockquote><blockquote><p>Therefore, you should use foreground threads to execute tasks that you really want to complete, like flushing data from a memory buffer out to disk. And you should use background threads for tasks that are not mission-critical, like recalculating spreadsheet cells or indexing records, because this work can continue again when the application restarts, and there is no need to force the application to stay active if the user wants to terminate it.</p></blockquote><blockquote><p>The CLR needed to provide this concept of foreground and background threads to better support AppDomains. You see, each AppDomain could be running a separate application and each of these applications would have its own foreground thread. If one application exits, causing its foreground thread to terminate, then the CLR still needs to stay up and running so that other applications continue to run. After all the applications exit and all their foreground threads terminate, the whole process can be destroyed.</p></blockquote><blockquote><p>The following code demonstrates the difference between foreground and background threads.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Threading</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// Create a new thread (defaults to foreground)</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Thread</span><span class="token punctuation">(</span>Worker<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// Make the thread a background thread</span></pre></td></tr><tr><td data-num="8"></td><td><pre> t<span class="token punctuation">.</span>IsBackground <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> t<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Start the thread</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// If t is a foreground thread, the application won't die for about 10 seconds</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// If t is a background thread, the application dies immediately</span></pre></td></tr><tr><td data-num="12"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Returning from Main"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Worker</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> Thread<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Simulate doing 10 seconds of work</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token comment">// The following line only gets displayed if this code is executed by a foreground thread</span></pre></td></tr><tr><td data-num="17"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Returning from Worker"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>It is possible to change a thread from foreground to background and vice versa at any time during its lifetime. An applicationâ€™s primary thread and any threads explicitly created by constructing a Thread object default to being foreground threads. On the other hand, thread pool threads default to being background threads. Also, any threads created by native code that enter the managed execution environment are marked as background threads.</p></blockquote><p>ğŸ’¡é‡è¦æç¤ºï¼šå°½é‡é¿å…ä½¿ç”¨å‰å°çº¿ç¨‹ã€‚æˆ‘æœ‰æ¬¡æ¥æ‰‹äº†ä¸€ä¸ªé¡¾é—®å·¥ä½œï¼Œæœ‰ä¸ªåº”ç”¨ç¨‹åºå°±æ˜¯ä¸ç»ˆæ­¢ã€‚èŠ±äº†å‡ å°æ—¶ç ”ç©¶é—®é¢˜åï¼Œæ‰å‘ç°æ˜¯ä¸€ä¸ª UI ç»„ä»¶æ˜¾å¼åœ°åˆ›å»ºäº†ä¸€ä¸ªå‰å°çº¿ç¨‹ (é»˜è®¤)ï¼Œè¿™æ­£æ˜¯è¿›ç¨‹ä¸€ç›´ä¸ç»ˆæ­¢çš„åŸå› ã€‚åæ¥ä¿®æ”¹ç»„ä»¶ä½¿ç”¨çº¿ç¨‹æ± æ‰è§£å†³äº†é—®é¢˜ã€‚æ‰§è¡Œæ•ˆç‡ä¹Ÿæå‡äº†ã€‚</p><p>ğŸ’¡å°ç»“ï¼šCLR å°†æ¯ä¸ªçº¿ç¨‹è¦ä¹ˆè§†ä¸ºå‰å°çº¿ç¨‹ï¼Œè¦ä¹ˆè§†ä¸ºåå°çº¿ç¨‹ã€‚ä¸€ä¸ªè¿›ç¨‹çš„æ‰€æœ‰å‰å°çº¿ç¨‹åœæ­¢è¿è¡Œæ—¶ï¼ŒCLR å¼ºåˆ¶ç»ˆæ­¢ä»ç„¶åœ¨è¿è¡Œçš„ä»»ä½•åå°çº¿ç¨‹ã€‚è¿™äº›åå°çº¿ç¨‹è¢«ç›´æ¥ç»ˆæ­¢ï¼Œä¸æŠ›å‡ºå¼‚å¸¸ã€‚æ¯ä¸ª AppDomain éƒ½å¯è¿è¡Œä¸€ä¸ªå•ç‹¬çš„åº”ç”¨ç¨‹åºï¼Œè€Œæ¯ä¸ªåº”ç”¨ç¨‹åºéƒ½æœ‰è‡ªå·±çš„å‰å°çº¿ç¨‹ã€‚å¦‚æœåº”ç”¨ç¨‹åºé€€å‡ºï¼Œé€ æˆå®ƒçš„å‰å°çº¿ç¨‹ç»ˆæ­¢ï¼Œåˆ™ CLR ä»éœ€ä¿æŒæ´»åŠ¨å¹¶è¿è¡Œï¼Œä½¿å…¶ä»–åº”ç”¨ç¨‹åºèƒ½ç»§ç»­è¿è¡Œã€‚åœ¨çº¿ç¨‹çš„ç”Ÿå­˜æœŸä¸­ï¼Œä»»ä½•æ—¶å€™éƒ½å¯ä»¥ä»å‰å°å˜æˆåå°ï¼Œæˆ–è€…ä»åå°å˜æˆå‰å°ã€‚åº”ç”¨ç¨‹åºçš„ä¸»çº¿ç¨‹ä»¥åŠé€šè¿‡æ„é€ ä¸€ä¸ª Thread å¯¹è±¡æ¥æ˜¾å¼åˆ›å»ºçš„ä»»ä½•çº¿ç¨‹éƒ½é»˜è®¤ä¸ºå‰å°çº¿ç¨‹ã€‚ç›¸åï¼Œçº¿ç¨‹æ± çº¿ç¨‹é»˜è®¤ä¸ºåå°çº¿ç¨‹ã€‚å¦å¤–ï¼Œç”±è¿›å…¥æ‰˜ç®¡æ‰§è¡Œç¯å¢ƒçš„æœ¬æœºï¼ˆnativeï¼‰ä»£ç åˆ›å»ºçš„ä»»ä½•çº¿ç¨‹éƒ½è¢«æ ‡è®°ä¸ºåå°çº¿ç¨‹ã€‚</p><h2 id="what-now"><a class="anchor" href="#what-now">#</a> What Now?</h2><blockquote><p>In this chapter, Iâ€™ve explained the basics about threads, and I hope Iâ€™ve made it clear to you that threads are very expensive resources that should be used sparingly. The best way to accomplish this is by using the thread pool. The thread pool will manage thread creation and destruction for you automatically. The thread pool creates a set of threads that get reused for various tasks so your application requires just a few threads to accomplish all of its work.</p></blockquote><blockquote><p>In Chapter 27, I will focus on how to use the thread pool to perform compute-bound operations. Then, in Chapter 28, I will discuss how to use the thread pool to perform I/O-bound operations. In many scenarios, you can perform asynchronous compute-bound and I/O-bound operations in such a way that thread synchronization is not required at all. However, there are some scenarios where thread synchronization is required, and the way that the thread synchronization constructs work and the difference between these various constructs are discussed in Chapter 29, â€œPrimitive Thread Synchronization Constructs,â€ and Chapter 30, â€œHybrid Thread Synchronization Constructs.â€</p></blockquote><blockquote><p>Before ending this discussion, Iâ€™d like to point out that I have been working extensively with threads because the first beta version of Windows NT 3.1 was available around 1992. And when .NET was in beta, I started producing a library of classes that can simplify asynchronous programming and thread synchronization. This library is called the Wintellect Power Threading Library, and it is freely downloadable and usable. Versions of the library exist for the desktop CLR, the Silverlight CLR, and the Compact Framework. The library, documentation, and sample code can be downloaded from <span class="exturl" data-url="aHR0cDovL1dpbnRlbGxlY3QuY29tL1Bvd2VyVGhyZWFkaW5nLmFzcHg=">http://Wintellect.com/PowerThreading.aspx</span>. This website also contains links to a support forum, in addition to videos that show how to use various parts of the library.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šçº¿ç¨‹æ˜¯éå¸¸å®è´µçš„èµ„æºï¼Œå¿…é¡»çœç€ç”¨ï¼Œä¸ºäº†åšåˆ°è¿™ä¸€ç‚¹ï¼Œæœ€å¥½çš„æ–¹å¼å°±æ˜¯ä½¿ç”¨ CLR çš„çº¿ç¨‹æ± ã€‚çº¿ç¨‹æ± è‡ªåŠ¨ä¸ºä½ ç®¡ç†çº¿ç¨‹çš„åˆ›å»ºå’Œé”€æ¯ã€‚çº¿ç¨‹æ± åˆ›å»ºçš„çº¿ç¨‹å°†ä¸ºå„ç§ä»»åŠ¡è€Œé‡ç”¨ï¼Œæ‰€ä»¥ä½ çš„åº”ç”¨ç¨‹åºå…¶å®åªéœ€å‡ ä¸ªçº¿ç¨‹å³å¯å®Œæˆå…¨éƒ¨å·¥ä½œã€‚</p><div class="tags"><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> è¯»ä¹¦ç¬”è®°</a> <a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C#</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2023-02-06 21:14:28" itemprop="dateModified" datetime="2023-02-06T21:14:28+08:00">2023-02-06</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(ï¿£â–½ï¿£)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Sakupinera WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Sakupinera Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Sakupinera PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Sakupinera <i class="ic i-at"><em>@</em></i>Sakupinera</li><li class="link"><strong>Post link: </strong><a href="http://sakupinera.github.io/2023/02/06/csharp/clr-via-csharp/Chapter%2026%20Thread%20Basics/" title="CLR via C# - Chapter 26 Thread Basics">http://sakupinera.github.io/2023/02/06/csharp/clr-via-csharp/Chapter 26 Thread Basics/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/01/11/cpp/cpp-primer/Chapter%2019%20Specialized%20Tools%20and%20Techniques/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;03&#x2F;08&#x2F;3EGdFBS1HMzVQjJ.png" title="C++ Primer - Chapter 19 Specialized Tools and Techniques"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i> Cpp-Primer</span><h3>C++ Primer - Chapter 19 Specialized Tools and Techniques</h3></a></div><div class="item right"><a href="/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;03&#x2F;08&#x2F;rkHPIpA3EmFKe7i.png" title="CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-26-thread-basics"><span class="toc-number">1.</span> <span class="toc-text">Chapter 26 Thread Basics</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#why-does-windows-support-threads"><span class="toc-number">1.1.</span> <span class="toc-text">Why Does Windows Support Threads?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#thread-overhead"><span class="toc-number">1.2.</span> <span class="toc-text">Thread Overhead</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stop-the-madness"><span class="toc-number">1.3.</span> <span class="toc-text">Stop the Madness</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cpu-trends"><span class="toc-number">1.4.</span> <span class="toc-text">CPU Trends</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#clr-threads-and-windows-threads"><span class="toc-number">1.5.</span> <span class="toc-text">CLR Threads and Windows Threads</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#using-a-dedicated-thread-to-perform-an-asynchronous-compute-bound-operation"><span class="toc-number">1.6.</span> <span class="toc-text">Using a Dedicated Thread to Perform an Asynchronous Compute-Bound Operation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reasons-to-use-threads"><span class="toc-number">1.7.</span> <span class="toc-text">Reasons to Use Threads</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#thread-scheduling-and-priorities"><span class="toc-number">1.8.</span> <span class="toc-text">Thread Scheduling and Priorities</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#foreground-threads-vs-background-threads"><span class="toc-number">1.9.</span> <span class="toc-text">Foreground Threads vs. Background Threads</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#what-now"><span class="toc-number">1.10.</span> <span class="toc-text">What Now?</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"><ul><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/" rel="bookmark" title="CLR via C# - Chapter 1 The CLRâ€™s Execution Model">CLR via C# - Chapter 1 The CLRâ€™s Execution Model</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/" rel="bookmark" title="CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types">CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%203%20Shared%20Assemblies%20and%20Strongly%20Named%20Assemblies/" rel="bookmark" title="CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies">CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies</a></li><li><a href="/2022/09/27/csharp/clr-via-csharp/Chapter%204%20Type%20Fundamentals/" rel="bookmark" title="CLR via C# - Chapter 4 Type Fundamentals">CLR via C# - Chapter 4 Type Fundamentals</a></li><li><a href="/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/" rel="bookmark" title="CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals">CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals</a></li><li><a href="/2022/10/21/csharp/clr-via-csharp/Chapter%206%20Type%20and%20Member%20Basics/" rel="bookmark" title="CLR via C# - Chapter 6 Type and Member Basics">CLR via C# - Chapter 6 Type and Member Basics</a></li><li><a href="/2022/10/24/csharp/clr-via-csharp/Chapter%207%20Constants%20and%20Fields/" rel="bookmark" title="CLR via C# - Chapter 7 Constants and Fields">CLR via C# - Chapter 7 Constants and Fields</a></li><li><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" rel="bookmark" title="CLR via C# - Chapter 8 Methods">CLR via C# - Chapter 8 Methods</a></li><li><a href="/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/" rel="bookmark" title="CLR via C# - Chapter 9 Parameters">CLR via C# - Chapter 9 Parameters</a></li><li><a href="/2022/10/28/csharp/clr-via-csharp/Chapter%2010%20Properties/" rel="bookmark" title="CLR via C# - Chapter 10 Properties">CLR via C# - Chapter 10 Properties</a></li><li><a href="/2022/10/29/csharp/clr-via-csharp/Chapter%2011%20Events/" rel="bookmark" title="CLR via C# - Chapter 11 Events">CLR via C# - Chapter 11 Events</a></li><li><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" rel="bookmark" title="CLR via C# - Chapter 12 Generics">CLR via C# - Chapter 12 Generics</a></li><li><a href="/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/" rel="bookmark" title="CLR via C# - Chapter 13 Interfaces">CLR via C# - Chapter 13 Interfaces</a></li><li><a href="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/" rel="bookmark" title="CLR via C# - Chapter 14 Chars, Strings, and Working with Text">CLR via C# - Chapter 14 Chars, Strings, and Working with Text</a></li><li><a href="/2022/11/17/csharp/clr-via-csharp/Chapter%2015%20Enumerated%20Types%20and%20Bit%20Flags/" rel="bookmark" title="CLR via C# - Chapter 15 Enumerated Types and Bit Flags">CLR via C# - Chapter 15 Enumerated Types and Bit Flags</a></li><li><a href="/2022/11/19/csharp/clr-via-csharp/Chapter%2016%20Arrays/" rel="bookmark" title="CLR via C# - Chapter 16 Arrays">CLR via C# - Chapter 16 Arrays</a></li><li><a href="/2022/11/21/csharp/clr-via-csharp/Chapter%2017%20Delegates/" rel="bookmark" title="CLR via C# - Chapter 17 Delegates">CLR via C# - Chapter 17 Delegates</a></li><li><a href="/2022/11/22/csharp/clr-via-csharp/Chapter%2018%20Custom%20Attributes/" rel="bookmark" title="CLR via C# - Chapter 18 Custom Attributes">CLR via C# - Chapter 18 Custom Attributes</a></li><li><a href="/2022/11/23/csharp/clr-via-csharp/Chapter%2019%20Nullable%20Value%20Types/" rel="bookmark" title="CLR via C# - Chapter 19 Nullable Value Types">CLR via C# - Chapter 19 Nullable Value Types</a></li><li><a href="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/" rel="bookmark" title="CLR via C# - Chapter 20 Exceptions and State Management">CLR via C# - Chapter 20 Exceptions and State Management</a></li><li><a href="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/" rel="bookmark" title="CLR via C# - Chapter 21 The Managed Heap and Garbage  Collection">CLR via C# - Chapter 21 The Managed Heap and Garbage Collection</a></li><li><a href="/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/" rel="bookmark" title="CLR via C# - Chapter 22 CLR Hosting and AppDomains">CLR via C# - Chapter 22 CLR Hosting and AppDomains</a></li><li><a href="/2022/11/29/csharp/clr-via-csharp/Chapter%2023%20Assembly%20Loading%20and%20Reflection/" rel="bookmark" title="CLR via C# - Chapter 23 Assembly Loading and Reflection">CLR via C# - Chapter 23 Assembly Loading and Reflection</a></li><li><a href="/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/" rel="bookmark" title="CLR via C# - Chapter 24 Runtime Serialization">CLR via C# - Chapter 24 Runtime Serialization</a></li><li><a href="/2022/12/06/csharp/clr-via-csharp/Chapter%2025%20Interoperating%20with%20WinRT%20%20Components/" rel="bookmark" title="CLR via C# - Chapter 25 Interoperating with WinRT Components">CLR via C# - Chapter 25 Interoperating with WinRT Components</a></li><li class="active"><a href="/2023/02/06/csharp/clr-via-csharp/Chapter%2026%20Thread%20Basics/" rel="bookmark" title="CLR via C# - Chapter 26 Thread Basics">CLR via C# - Chapter 26 Thread Basics</a></li><li><a href="/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations">CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations</a></li><li><a href="/2023/02/08/csharp/clr-via-csharp/Chapter%2028%20IO-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 28 IO-Bound Asynchronous Operations">CLR via C# - Chapter 28 IO-Bound Asynchronous Operations</a></li><li><a href="/2023/02/09/csharp/clr-via-csharp/Chapter%2029%20Primitive%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 29 Primitive Thread Synchronization">CLR via C# - Chapter 29 Primitive Thread Synchronization</a></li><li><a href="/2023/02/10/csharp/clr-via-csharp/Chapter%2030%20Hybrid%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 30 Hybrid Thread Synchronization">CLR via C# - Chapter 30 Hybrid Thread Synchronization</a></li></ul></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sakupinera" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Sakupinera</p><div class="description" itemprop="description">ä¿æŒä½ çš„å†³å¿ƒï¼</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">86</span> <span class="name">posts</span></a></div><div class="item categories"><a href="/categories/"><span class="count">13</span> <span class="name">categories</span></a></div><div class="item tags"><a href="/tags/"><span class="count">6</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nha3VwaW5lcmE=" title="https:&#x2F;&#x2F;github.com&#x2F;sakupinera"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9zYWt1cGluZXJh" title="https:&#x2F;&#x2F;twitter.com&#x2F;sakupinera"><i class="ic i-twitter"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQwNzIyOTA3MQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;407229071"><i class="ic i-cloud-music"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMjIzMDczOTg/c3BtX2lkX2Zyb209MzMzLjEwMDcuMC4w" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;22307398?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li><li class="item"><a href="/games/" rel="section"><i class="ic i-flag"></i>Games</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-person"></i>About</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/01/11/cpp/cpp-primer/Chapter%2019%20Specialized%20Tools%20and%20Techniques/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" title="CLR via C# - Chapter 12 Generics">CLR via C# - Chapter 12 Generics</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/12/06/csharp/clr-via-csharp/Chapter%2025%20Interoperating%20with%20WinRT%20%20Components/" title="CLR via C# - Chapter 25 Interoperating with WinRT Components">CLR via C# - Chapter 25 Interoperating with WinRT Components</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/09/04/linux/learn-linux/Shell%E7%BC%96%E7%A8%8B/" title="LearnLinux - Shellç¼–ç¨‹">LearnLinux - Shellç¼–ç¨‹</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2023/01/07/cpp/cpp-primer/Chapter%2015%20Object-Oriented%20Programming/" title="C++ Primer - Chapter 15 Object-Oriented Programming">C++ Primer - Chapter 15 Object-Oriented Programming</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2022/12/13/cpp/cpp-primer/Chapter%205%20Statements/" title="C++ Primer - Chapter 5 Statements">C++ Primer - Chapter 5 Statements</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/" title="CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals">CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/08/28/linux/learn-linux/%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/" title="LearnLinux - ç”¨æˆ·å’Œç”¨æˆ·ç»„ç®¡ç†">LearnLinux - ç”¨æˆ·å’Œç”¨æˆ·ç»„ç®¡ç†</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/09/05/linux/learn-linux/%E5%90%AF%E5%8A%A8%E7%AE%A1%E7%90%86/" title="LearnLinux - å¯åŠ¨ç®¡ç†">LearnLinux - å¯åŠ¨ç®¡ç†</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/09/05/linux/learn-linux/%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/" title="LearnLinux - å¤‡ä»½ä¸æ¢å¤">LearnLinux - å¤‡ä»½ä¸æ¢å¤</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/21/csharp/clr-via-csharp/Chapter%2017%20Delegates/" title="CLR via C# - Chapter 17 Delegates">CLR via C# - Chapter 17 Delegates</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 â€“ <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Sakupinera @ Hanamai Sora</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="Symbols count total">2.2m words</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="Reading time total">33:30</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/02/06/csharp/clr-via-csharp/Chapter 26 Thread Basics/",favicon:{show:"ï¼ˆâ—Â´3ï½€â—ï¼‰Goooood",hide:"(Â´Ğ”ï½€)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/shifuku.model.json"},display:{position:"left",width:250,height:500},mobile:{show:!1},react:{opacity:.9},log:!1})</script></body></html>