<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sakupinera" href="http://sakupinera.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sakupinera" href="http://sakupinera.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sakupinera" href="http://sakupinera.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="è¯»ä¹¦ç¬”è®°,C#"><link rel="canonical" href="http://sakupinera.github.io/2023/02/09/csharp/clr-via-csharp/Chapter%2029%20Primitive%20Thread%20Synchronization%20Constructs/"><title>CLR via C# - Chapter 29 Primitive Thread Synchronization - CLR-via-CSharp - CSharp | Hanamai Sora = Sakupinera</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">CLR via C# - Chapter 29 Primitive Thread Synchronization</h1><div class="meta"><span class="item" title="Created: 2023-02-09 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2023-02-09T00:00:00+08:00">2023-02-09</time> </span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">Symbols count in article</span> <span>72k</span> <span class="text">words</span> </span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">Reading time</span> <span>1:05</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hanamai Sora</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipetv6p75j20zk0m8x6p.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipevuctzzj20zk0m84qp.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipet8c1a2j20zk0m8kct.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipey84bjtj20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gicm0fdw5cj20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipeu7txpzj20zk0m81kx.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/" itemprop="item" rel="index" title="In CSharp"><span itemprop="name">CSharp</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/CLR-via-CSharp/" itemprop="item" rel="index" title="In CLR-via-CSharp"><span itemprop="name">CLR-via-CSharp</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://sakupinera.github.io/2023/02/09/csharp/clr-via-csharp/Chapter%2029%20Primitive%20Thread%20Synchronization%20Constructs/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Sakupinera"><meta itemprop="description" content=", ä¿æŒä½ çš„å†³å¿ƒï¼"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakupinera"></span><div class="body md" itemprop="articleBody"><h1 id="chapter-29-primitive-thread-synchronization-constructs"><a class="anchor" href="#chapter-29-primitive-thread-synchronization-constructs">#</a> Chapter 29 Primitive Thread Synchronization Constructs</h1><blockquote><p>When a thread pool thread blocks, the thread pool creates additional threads, and the time and memory resources required to create, destroy, and schedule threads is very expensive. When many developers see that they have threads in their program that are not doing anything useful, they tend to create more threads in hopes that the new threads will do something useful. The key to building scalable and responsive applications is to not block the threads you have so that they can be used and reused to execute other tasks. Chapter 27, â€œCompute-Bound Asynchronous Operations,â€ focused on how to use existing threads to perform compute-bound operations, and Chapter 28, â€œI/O-Bound Asynchronous Operations,â€ focused on how to use threads when performing I/O-bound operations.</p></blockquote><blockquote><p>In this chapter, I focus on thread synchronization. Thread synchronization is used to prevent corruption when multiple threads access shared data at the same time. I emphasize at the same time, because thread synchronization is all about timing. If you have some data that is accessed by two threads and those threads cannot possibly touch the data simultaneously, then thread synchronization is not required at all. In Chapter 28, I discussed how different sections of async functions can be executed by different threads. Here we could potentially have two different threads accessing the same variables and data. But async functions are implemented in such a way that it is impossible for two threads to access this same data at the same time. Therefore, no thread synchronization is required when code accesses data contained within the async function.</p></blockquote><blockquote><p>This is ideal because thread synchronization has many problems associated with it. First, it is tedious and extremely error-prone. In your code, you must identify all data that could potentially be touched by multiple threads at the same time. Then you must surround this code with additional code that acquires and releases a thread synchronization lock. The lock ensures that only one thread at a time can access the resource. If you forget to surround just one block of code with a lock, then the data will become corrupted. Also, there is no way to prove that you have added all your locking code correctly. You just have to run your application, stress-test it a lot, and hope that nothing goes wrong. In fact, you should test your application on a machine that has as many CPUs as possible because the more CPUs you have, the better chance that two or more threads will attempt to access the resource at the same time, making it more likely youâ€™ll detect a problem.</p></blockquote><blockquote><p>The second problem with locks is that they hurt performance. It takes time to acquire and release a lock because there are additional method calls, and because the CPUs must coordinate with each other to determine which thread will acquire the lock first. Having the CPUs in the machine communicate with each other this way hurts performance. For example, letâ€™s say that you have code that adds a node to the head of a linked list.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// This class is used by the LinkedList class</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">internal</span> <span class="token class-name">Node</span> m_next<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// Other members not shown</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">LinkedList</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Node</span> m_head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token class-name">Node</span> newNode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// The following two lines perform very fast reference assignments</span></pre></td></tr><tr><td data-num="10"></td><td><pre> newNode<span class="token punctuation">.</span>m_next <span class="token operator">=</span> m_head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> m_head <span class="token operator">=</span> newNode<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>This Add method simply performs two reference assignments that can execute extremely fast. Now, if we want to make Add thread safe so that multiple threads can call it simultaneously without corrupting the linked list, then we need to have the Add method acquire and release a lock.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">LinkedList</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">SomeKindOfLock</span> m_lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SomeKindOfLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Node</span> m_head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token class-name">Node</span> newNode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> m_lock<span class="token punctuation">.</span><span class="token function">Enter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// The following two lines perform very fast reference assignments</span></pre></td></tr><tr><td data-num="7"></td><td><pre> newNode<span class="token punctuation">.</span>m_next <span class="token operator">=</span> m_head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> m_head <span class="token operator">=</span> newNode<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> m_lock<span class="token punctuation">.</span><span class="token function">Leave</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Although Add is now thread safe, it has also become substantially slower. How much slower depends on the kind of lock chosen; I will compare the performance of various locks in this chapter and in Chapter 30, â€œHybrid Thread Synchronization Constructs.â€ But even the fastest lock could make the Add method several times slower than the version of it that didnâ€™t have any lock code in it at all. Of course, the performance becomes significantly worse if the code calls Add in a loop to insert several nodes into the linked list.</p></blockquote><blockquote><p>The third problem with thread synchronization locks is that they allow only one thread to access the resource at a time. This is the lockâ€™s whole reason for existing, but it is also a problem, because blocking a thread causes more threads to be created. So, for example, if a thread pool thread attempts to acquire a lock that it cannot have, it is likely that the thread pool will create a new thread to keep the CPUs saturated with work. As discussed in Chapter 26, â€œThread Basics,â€ creating a thread is very expensive in terms of both memory and performance. And to make matters even worse, when the blocked thread gets to run again, it will run with this new thread pool thread; Windows is now scheduling more threads than there are CPUs, and this increases context switching, which also hurts performance.</p></blockquote><blockquote><p>The summary of all of this is that thread synchronization is bad, so you should try to design your applications to avoid as much of it as possible. To that end, you should avoid shared data such as static fields. When a thread uses the new operator to construct an object, the new operator returns a reference to the new object. At this point in time, only the thread that constructs the object has a reference to it; no other thread can access that object. If you avoid passing this reference to another thread that might use the object at the same time as the creating thread, then there is no need to synchronize access to the object.</p></blockquote><blockquote><p>Try to use value types because they are always copied, so each thread operates on its own copy. Finally, it is OK to have multiple threads accessing shared data simultaneously if that access is readonly. For example, many applications create some data structures during their initialization. Once initialized, the application can create as many threads as it wants; if all these threads just query the data, then all the threads can do this simultaneously without acquiring or releasing any locks. The String type is an example of this: after a String object is created, it is immutable; so many threads can access a single String object at the same time without any chance of the String object becoming corrupted.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šä¸ºäº†æ„å»ºå¯ä¼¸ç¼©çš„ã€å“åº”çµæ•çš„åº”ç”¨ç¨‹åºï¼Œå…³é”®åœ¨äºä¸è¦é˜»å¡ä½ æ‹¥æœ‰çš„çº¿ç¨‹ï¼Œä½¿å®ƒä»¬èƒ½ç”¨äº (å’Œé‡ç”¨äº) æ‰§è¡Œå…¶ä»–ä»»åŠ¡ã€‚å¤šä¸ªçº¿ç¨‹<strong>åŒæ—¶</strong>è®¿é—®å…±äº«æ•°æ®æ—¶ï¼Œçº¿ç¨‹åŒæ­¥èƒ½é˜²æ­¢æ•°æ®æŸåã€‚ä¹‹æ‰€ä»¥è¦å¼ºè°ƒ<strong>åŒæ—¶</strong>ï¼Œæ˜¯å› ä¸ºçº¿ç¨‹åŒæ­¥é—®é¢˜å…¶å®å°±æ˜¯è®¡æ—¶é—®é¢˜ã€‚å¦‚æœä¸€äº›æ•°æ®ç”±ä¸¤ä¸ªçº¿ç¨‹è®¿é—®ï¼Œä½†é‚£äº›çº¿ç¨‹ä¸å¯èƒ½åŒæ—¶æ¥è§¦åˆ°æ•°æ®ï¼Œå°±å®Œå…¨ç”¨ä¸ç€çº¿ç¨‹åŒæ­¥ã€‚å¯èƒ½æœ‰ä¸¤ä¸ªä¸åŒçš„çº¿ç¨‹è®¿é—®ç›¸åŒçš„å˜é‡å’Œæ•°æ®ï¼Œä½†æ ¹æ®å¼‚æ­¥å‡½æ•°çš„å®ç°æ–¹å¼ï¼Œä¸å¯èƒ½æœ‰ä¸¤ä¸ªçº¿ç¨‹<strong>åŒæ—¶</strong>è®¿é—®ç›¸åŒçš„æ•°æ®ã€‚æ‰€ä»¥ï¼Œåœ¨ä»£ç è®¿é—®å¼‚æ­¥å‡½æ•°ä¸­åŒ…å«çš„æ•°æ®æ—¶ä¸éœ€è¦çº¿ç¨‹åŒæ­¥ã€‚ä¸éœ€è¦çº¿ç¨‹åŒæ­¥æ˜¯æœ€ç†æƒ³çš„æƒ…å†µï¼Œå› ä¸ºçº¿ç¨‹åŒæ­¥å­˜åœ¨è®¸å¤šé—®é¢˜ã€‚ç¬¬ä¸€ä¸ªé—®é¢˜æ˜¯å®ƒæ¯”è¾ƒç¹çï¼Œè€Œä¸”å¾ˆå®¹æ˜“å†™é”™ã€‚åœ¨ä½ çš„ä»£ç ä¸­ï¼Œå¿…é¡»æ ‡è¯†å‡ºæ‰€æœ‰å¯èƒ½ç”±å¤šä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®çš„æ•°æ®ã€‚ç„¶åï¼Œå¿…é¡»ç”¨é¢å¤–çš„ä»£ç å°†è¿™äº›ä»£ç åŒ…å›´èµ·æ¥ï¼Œå¹¶è·å–å’Œé‡Šæ”¾ä¸€ä¸ªçº¿ç¨‹åŒæ­¥é”ã€‚é”çš„ä½œç”¨æ˜¯ç¡®ä¿ä¸€æ¬¡åªæœ‰ä¸€ä¸ªçº¿ç¨‹è®¿é—®èµ„æºã€‚åªè¦æœ‰ä¸€ä¸ªä»£ç å—å¿˜è®°ç”¨é”åŒ…å›´ï¼Œæ•°æ®å°±ä¼šæŸåã€‚å¦å¤–ï¼Œæ²¡æœ‰åŠæ³•è¯æ˜ä½ å·²æ­£ç¡®æ·»åŠ äº†æ‰€æœ‰é”å®šä»£ç ã€‚åªèƒ½è¿è¡Œåº”ç”¨ç¨‹åºï¼Œå¯¹å®ƒè¿›è¡Œå¤§é‡å‹åŠ›æµ‹è¯•ï¼Œå¹¶å¯„å¸Œæœ›äºæ²¡æœ‰ä»€ä¹ˆåœ°æ–¹å‡ºé”™ã€‚äº‹å®ä¸Šï¼Œåº”è¯¥åœ¨ CPU (æˆ– CPU å†…æ ¸) æ•°é‡å°½å¯èƒ½å¤šçš„æœºå™¨ä¸Šæµ‹è¯•åº”ç”¨ç¨‹åºã€‚å› ä¸º CPU è¶Šå¤šï¼Œä¸¤ä¸ªæˆ–å¤šä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®èµ„æºçš„æœºç‡è¶Šå¤§ï¼Œè¶Šå®¹æ˜“æ£€æµ‹åˆ°é—®é¢˜ã€‚é”çš„ç¬¬äºŒä¸ªé—®é¢˜åœ¨äºï¼Œå®ƒä»¬ä¼šæŸå®³æ€§èƒ½ã€‚è·å–å’Œé‡Šæ”¾é”æ˜¯éœ€è¦æ—¶é—´çš„ï¼Œå› ä¸ºè¦è°ƒç”¨ä¸€äº›é¢å¤–çš„æ–¹æ³•ï¼Œè€Œä¸”ä¸åŒçš„ CPU å¿…é¡»è¿›è¡Œåè°ƒï¼Œä»¥å†³å®šå“ªä¸ªçº¿ç¨‹å…ˆå–å¾—é”ã€‚è®©æœºå™¨ä¸­çš„ CPU ä»¥è¿™ç§æ–¹å¼ç›¸äº’é€šä¿¡ï¼Œä¼šå¯¹æ€§èƒ½é€ æˆå½±å“ã€‚çº¿ç¨‹åŒæ­¥é”çš„ç¬¬ä¸‰ä¸ªé—®é¢˜åœ¨äºï¼Œå®ƒä»¬ä¸€æ¬¡åªå…è®¸ä¸€ä¸ªçº¿ç¨‹è®¿é—®èµ„æºã€‚è¿™æ˜¯é”çš„å…¨éƒ¨æ„ä¹‰ä¹‹æ‰€åœ¨ï¼Œä½†ä¹Ÿæ˜¯é—®é¢˜ä¹‹æ‰€åœ¨ï¼Œå› ä¸ºé˜»å¡ä¸€ä¸ªçº¿ç¨‹ä¼šé€ æˆæ›´å¤šçš„çº¿ç¨‹è¢«åˆ›å»ºã€‚åˆ›å»ºçº¿ç¨‹æ—¶ä¸€ä¸ªæ˜‚è´µçš„æ“ä½œï¼Œä¼šè€—è´¹å¤§é‡å†…å­˜å’Œæ—¶é—´ã€‚æ›´ä¸å¦™çš„æ˜¯ï¼Œå½“é˜»å¡çš„çº¿ç¨‹å†æ¬¡è¿è¡Œæ—¶ï¼Œå®ƒä¼šå’Œè¿™ä¸ªæ–°çš„çº¿ç¨‹æ± çº¿ç¨‹å…±åŒè¿è¡Œã€‚ä¹Ÿå°±æ˜¯è¯´ï¼ŒWindows ç°åœ¨è¦è°ƒåº¦æ¯” CPU æ•°é‡æ›´å¤šçš„çº¿ç¨‹ï¼Œè¿™ä¼šå¢å¤§ä¸Šä¸‹æ–‡åˆ‡æ¢çš„æœºç‡ï¼Œè¿›ä¸€æ­¥æŸå®³åˆ°æ€§èƒ½ã€‚ç»¼ä¸Šæ‰€è¿°ï¼Œçº¿ç¨‹åŒæ­¥æ˜¯ä¸€ä»¶ä¸å¥½çš„äº‹æƒ…ï¼Œæ‰€ä»¥åœ¨è®¾è®¡è‡ªå·±çš„åº”ç”¨ç¨‹åºæ—¶ï¼Œåº”è¯¥å°½å¯èƒ½åœ°é¿å…è¿›è¡Œçº¿ç¨‹åŒæ­¥ã€‚å…·ä½“å°±æ˜¯é¿å…ä½¿ç”¨åƒé™æ€å­—æ®µè¿™æ ·çš„å…±äº«æ•°æ®ã€‚çº¿ç¨‹ç”¨ <code>new</code> æ“ä½œç¬¦æ„é€ å¯¹è±¡æ—¶ï¼Œ <code>new</code> æ“ä½œç¬¦ä¼šè¿”å›å¯¹æ–°å¯¹è±¡çš„å¼•ç”¨ã€‚åœ¨è¿™ä¸ªæ—¶åˆ»ï¼Œåªè¦æ„é€ å¯¹è±¡çš„çº¿ç¨‹æ‰æœ‰å¯¹å®ƒçš„å¼•ç”¨ï¼›å…¶ä»–ä»»ä½•çº¿ç¨‹éƒ½ä¸èƒ½è®¿é—®é‚£ä¸ªå¯¹è±¡ã€‚å¦‚æœèƒ½é¿å…å°†è¿™ä¸ªå¼•ç”¨ä¼ ç»™å¯èƒ½åŒæ—¶ä½¿ç”¨å¯¹è±¡çš„å¦ä¸€ä¸ªçº¿ç¨‹ï¼Œå°±ä¸å¿…åŒæ­¥å¯¹è¯¥å¯¹è±¡çš„è®¿é—®ã€‚å¯è¯•ç€ä½¿ç”¨å€¼ç±»å‹ï¼Œå› ä¸ºå®ƒä»¬æ€»æ˜¯è¢«å¤åˆ¶ï¼Œæ¯ä¸ªçº¿ç¨‹æ“ä½œçš„éƒ½æ˜¯å®ƒè‡ªå·±çš„å‰¯æœ¬ã€‚æœ€åï¼Œå¤šä¸ªçº¿ç¨‹åŒæ—¶å¯¹å…±äº«æ•°æ®è¿›è¡Œåªè¯»è®¿é—®æ˜¯æ²¡æœ‰ä»»ä½•é—®é¢˜çš„ã€‚</p><h2 id="class-libraries-and-thread-safety"><a class="anchor" href="#class-libraries-and-thread-safety">#</a> Class Libraries and Thread Safety</h2><blockquote><p>Now, Iâ€™d like to say a quick word about class libraries and thread synchronization. Microsoftâ€™s Framework Class Library (FCL) guarantees that all static methods are thread safe. This means that if two threads call a static method at the same time, no data will get corrupted. The FCL had to do this internally because there is no way that multiple companies producing different assemblies could coordinate on a single lock for arbitrating access to the resource. The Console class contains a static field, inside which many of its methods acquire and release to ensure that only one thread at a time is accessing the console.</p></blockquote><blockquote><p>For the record, making a method thread safe does not mean that it internally takes a thread synchronization lock. A thread-safe method means that data doesnâ€™t get corrupted if two threads attempt to access the data at the same time. The System.Math class has a static Max method implemented as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">Max</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> val1<span class="token punctuation">,</span> <span class="token class-name">Int32</span> val2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">return</span> <span class="token punctuation">(</span>val1 <span class="token operator">&lt;</span> val2<span class="token punctuation">)</span> <span class="token punctuation">?</span> val2 <span class="token punctuation">:</span> val1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>This method is thread safe even though it doesnâ€™t take any lock. Because Int32 is a value type, the two Int32 values passed to Max are copied into it and so, multiple threads could be calling Max simultaneously, but each thread is working on its own data, isolated from any other thread.</p></blockquote><blockquote><p>On the other hand, the FCL does not guarantee that instance methods are thread safe because adding all the locking code would hurt performance too much. And, in fact, if every instance method acquires and releases a lock, then you ultimately end up having just one thread running in your application at any given time, which hurts performance even more. As mentioned earlier, when a thread constructs an object, only this thread has a reference to the object, no other thread can access that object, and no thread synchronization is required when invoking instance methods. However, if the thread then exposes the reference to the objectâ€”by placing it in a static field, passing as the state argument to ThreadPool.QueueUserWorkItem or to a Task, and so onâ€”then thread synchronization is required if the threads could attempt simultaneous non-read-only access</p></blockquote><blockquote><p>It is recommended that your own class libraries follow this pattern; that is, make all your static methods thread safe and make all your instance methods not thread safe. There is one caveat to this pattern: if the purpose of the instance method is to coordinate threads, then the instance method should be thread safe. For example, one thread can cancel an operation by calling CancellationTokenSourceâ€™s Cancel method, and another thread detects that it should stop what itâ€™s doing by querying the corresponding CancellationTokenâ€™s IsCancellationRequested property. These two instance members have some special thread synchronization code inside them to ensure that the coordination of the two threads goes as expected.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šMicrosoft çš„ Framework Class Library (FCL) ä¿è¯æ‰€æœ‰é™æ€æ–¹æ³•éƒ½æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚è¿™æ„å‘³ç€å‡å¦‚ä¸¤ä¸ªçº¿ç¨‹åŒæ—¶è°ƒç”¨ä¸€ä¸ªé™æ€æ–¹æ³•ï¼Œä¸ä¼šå‘ç”Ÿæ•°æ®è¢«ç ´åçš„æƒ…å†µã€‚FCL å¿…é¡»åœ¨å†…éƒ¨åšåˆ°è¿™ä¸€ç‚¹ï¼Œå› ä¸ºå¼€å‘ä¸åŒç¨‹åºé›†çš„å¤šä¸ªå…¬å¸ä¸å¯èƒ½äº‹å…ˆåå•†å¥½ä½¿ç”¨ä¸€ä¸ªé”æ¥ä»²è£å¯¹èµ„æºçš„è®¿é—®ã€‚ <code>Console</code> ç±»åŒ…å«äº†ä¸€ä¸ªé™æ€å­—æ®µï¼Œç±»çš„è®¸å¤šæ–¹æ³•éƒ½è¦è·å–å’Œé‡Šæ”¾è¿™ä¸ªå­—æ®µä¸Šçš„é”ï¼Œç¡®ä¿ä¸€æ¬¡åªæœ‰ä¸€ä¸ªçº¿ç¨‹è®¿é—®æ§åˆ¶å°ã€‚è¦éƒ‘é‡å£°æ˜çš„æ˜¯ï¼Œä½¿ä¸€ä¸ªæ–¹æ³•çº¿ç¨‹å®‰å…¨ï¼Œå¹¶ä¸æ˜¯è¯´å®ƒä¸€å®šè¦åœ¨å†…éƒ¨è·å–ä¸€ä¸ªçº¿ç¨‹åŒæ­¥é”ã€‚çº¿ç¨‹å®‰å…¨çš„æ–¹æ³•æ„å‘³ç€åœ¨ä¸¤ä¸ªçº¿ç¨‹è¯•å›¾åŒæ—¶è®¿é—®æ•°æ®æ—¶ï¼Œæ•°æ®ä¸ä¼šè¢«ç ´åã€‚å¦ä¸€æ–¹é¢ï¼ŒFCL ä¸ä¿è¯å®ä¾‹æ–¹æ³•æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œå› ä¸ºå‡å¦‚å…¨éƒ¨æ·»åŠ é”å®šï¼Œä¼šé€ æˆæ€§èƒ½çš„å·¨å¤§æŸå¤±ã€‚å¦å¤–ï¼Œå‡å¦‚æ¯ä¸ªå®ä¾‹æ–¹æ³•éƒ½éœ€è¦è·å–å’Œé‡Šæ”¾ä¸€ä¸ªé”ï¼Œäº‹å®ä¸Šä¼šé€ æˆæœ€ç»ˆåœ¨ä»»ä½•ç»™å®šçš„æ—¶åˆ»ï¼Œä½ çš„åº”ç”¨ç¨‹åºåªæœ‰ä¸€ä¸ªçº¿ç¨‹åœ¨è¿è¡Œï¼Œè¿™å¯¹æ€§èƒ½çš„å½±å“æ˜¯æ˜¾è€Œæ˜“è§çš„ã€‚å¦‚å‰æ‰€è¿°ï¼Œè°ƒç”¨å®ä¾‹æ–¹æ³•æ—¶æ— éœ€çº¿ç¨‹åŒæ­¥ã€‚ç„¶è€Œï¼Œå¦‚æœçº¿ç¨‹éšåå…¬å¼€äº†è¿™ä¸ªå¯¹è±¡å¼•ç”¨ â€”â€”â€”â€” æŠŠå®ƒæ”¾åˆ°ä¸€ä¸ªé™æ€å­—æ®µä¸­ï¼ŒæŠŠå®ƒä½œä¸ºçŠ¶æ€å®å‚ä¼ ç»™ä¸€ä¸ª <code>ThreadPool.QueueUserWorkItem</code> æˆ– <code>Task</code> â€”â€”â€”â€” é‚£ä¹ˆåœ¨å¤šä¸ªçº¿ç¨‹å¯èƒ½åŒæ—¶è¿›è¡Œéè¯»åªè¯»è®¿é—®çš„å‰æä¸‹ï¼Œå°±éœ€è¦çº¿ç¨‹åŒæ­¥ã€‚å»ºè®®ä½ è‡ªå·±çš„ç±»åº“ä¹Ÿéµå¾ª FCL çš„è¿™ä¸ªæ¨¡å¼ï¼›ä¹Ÿå°±æ˜¯è¯´ï¼Œä½¿è‡ªå·±çš„æ‰€æœ‰é™æ€æ–¹æ³•éƒ½çº¿ç¨‹å®‰å…¨ï¼Œä½¿æ‰€æœ‰å®ä¾‹æ–¹æ³•éƒ½éçº¿ç¨‹å®‰å…¨ã€‚è¿™ä¸ªæ¨¡å¼æœ‰ä¸€ç‚¹è¦æ³¨æ„ï¼šå¦‚æœå®ä¾‹æ–¹æ³•çš„ç›®çš„æ˜¯åè°ƒçº¿ç¨‹ï¼Œåˆ™å®ä¾‹æ–¹æ³•åº”è¯¥æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚</p><h2 id="primitive-user-mode-and-kernel-mode-constructs"><a class="anchor" href="#primitive-user-mode-and-kernel-mode-constructs">#</a> Primitive User-Mode and Kernel-Mode Constructs</h2><blockquote><p>n this chapter, I explain the primitive thread synchronization constructs. By primitive, I mean the simplest constructs that are available to use in your code. There are two kinds of primitive constructs: user-mode and kernel-mode. Whenever possible, you should use the primitive user-mode constructs, because they are significantly faster than the kernel-mode constructs because they use special CPU instructions to coordinate threads. This means that the coordination is occurring in hardware (which is what makes it fast). But this also means that the Windows operating system never detects that a thread is blocked on a primitive user-mode construct. Because a thread pool thread blocked on a user-mode primitive construct is never considered blocked, the thread pool will not create a new thread to replace the temporarily blocked thread. In addition, these CPU instructions block the thread for an incredibly short period of time.</p></blockquote><blockquote><p>Wow! All of this sounds great, doesnâ€™t it? And it is great, which is why I recommend using these constructs as much as possible. However, there is a downsideâ€”only the Windows operating system kernel can stop a thread from running so that it is not wasting CPU time. A thread running in user mode can be preempted by the system, but the thread will be scheduled again as soon as possible. So, a thread that wants to acquire some resource, but canâ€™t get it, spins in user mode. This potentially wastes a lot of CPU time, which would be better spent performing other work or even just letting the CPU go idle to conserve power.</p></blockquote><blockquote><p>This brings us to the primitive kernel-mode constructs. The kernel-mode constructs are provided by the Windows operating system itself. As such, they require that your applicationâ€™s threads call functions implemented in the operating system kernel. Having threads transition from user mode to kernel mode and back incurs a big performance hit, which is why kernel-mode constructs should be avoided.2 However, they do have a positive featureâ€”when a thread uses a kernel-mode construct to acquire a resource that another thread has, Windows blocks the thread so that it is no longer wasting CPU time. Then, when the resource becomes available, Windows resumes the thread, allowing it to access the resource.</p></blockquote><blockquote><p>A thread waiting on a construct might block forever if the thread currently holding the construct never releases it. If the construct is a user-mode construct, the thread is running on a CPU forever, and we call this a livelock. If the construct is a kernel-mode construct, the thread is blocked forever, and we call this a deadlock. Both of these are bad, but of the two, a deadlock is always preferable to a livelock, because a livelock wastes both CPU time and memory (the threadâ€™s stack, etc.), whereas a deadlock wastes only memory.</p></blockquote><blockquote><p>In an ideal world, weâ€™d like to have constructs that take the best of both worlds. That is, weâ€™d like a construct that is fast and non-blocking (like the user-mode constructs) when there is no contention. But when there is contention for the construct, weâ€™d like it to be blocked by the operating system kernel. Constructs that work like this do exist; I call them hybrid constructs, and I will discuss them in Chapter 30. It is very common for applications to use the hybrid constructs, because in most applications, it is rare for two or more threads to attempt to access the same data at the same time. A hybrid construct keeps your application running fast most of the time, and occasionally it runs slowly to block the thread. The slowness usually doesnâ€™t matter at this point, because your thread is going to be blocked anyway.</p></blockquote><blockquote><p>Many of the CLRâ€™s thread synchronization constructs are really just object-oriented class wrappers around Win32 thread synchronization constructs. After all, CLR threads are Windows threads, which means that Windows schedules and controls the synchronization of threads. Windows thread synchronization constructs have been around because 1992, and a ton of material has been written about them.4 Therefore, I give them only cursory treatment in this chapter.</p></blockquote><p>ğŸ’¡å°ç»“ï¼š<strong>åŸºå…ƒ</strong> (primitive) æ˜¯æŒ‡å¯ä»¥åœ¨ä»£ç ä¸­ä½¿ç”¨çš„æœ€ç®€å•çš„æ„é€ ã€‚æœ‰ä¸¤ç§åŸºå…ƒæ„é€ ï¼›ç”¨æˆ·æ¨¡å¼ (user-mode) å’Œå†…æ ¸æ¨¡å¼ (kernel-mode)ã€‚åº”å°½é‡ä½¿ç”¨åŸºå…ƒç”¨æˆ·æ¨¡å¼æ„é€ ï¼Œå®ƒä»¬çš„é€Ÿåº¦è¦æ˜¾è‘—å¿«äºå†…æ ¸æ¨¡å¼çš„æ„é€ ã€‚è¿™æ˜¯å› ä¸ºå®ƒä»¬ä½¿ç”¨äº†ç‰¹æ®Š CPU æŒ‡ä»¤æ¥åè°ƒçº¿ç¨‹ã€‚è¿™æ„å‘³ç€åè°ƒæ˜¯åœ¨ç¡¬ä»¶ä¸­å‘ç”Ÿçš„ (æ‰€ä»¥æ‰è¿™ä¹ˆå¿«)ã€‚ä½†è¿™ä¹Ÿæ„å‘³ç€ Microsoft Windows æ“ä½œç³»ç»Ÿæ°¸è¿œæ£€æµ‹ä¸åˆ°ä¸€ä¸ªçº¿ç¨‹åœ¨åŸºå…ƒç”¨æˆ·æ¨¡å¼çš„æ„é€ ä¸Šé˜»å¡äº†ã€‚ç”±äºåœ¨ç”¨æˆ·æ¨¡å¼çš„åŸºå…ƒæ„é€ ä¸Šé˜»å¡çš„çº¿ç¨‹æ± çº¿ç¨‹æ°¸è¿œä¸è®¤ä¸ºå·²é˜»å¡ï¼Œæ‰€ä»¥çº¿ç¨‹æ± ä¸ä¼šåˆ›å»ºæ–°çº¿ç¨‹æ¥æ›¿æ¢è¿™ç§ä¸´æ—¶é˜»å¡çš„çº¿ç¨‹ã€‚æ­¤å¤–ï¼Œè¿™äº› CPU æŒ‡ä»¤åªé˜»å¡çº¿ç¨‹ç›¸å½“çŸ­çš„æ—¶é—´ã€‚ä½†å®ƒä»¬ä¹Ÿæœ‰ä¸€ä¸ªç¼ºç‚¹ï¼šåªæœ‰ Windows æ“ä½œç³»ç»Ÿå†…æ ¸æ‰èƒ½åœæ­¢ä¸€ä¸ªçº¿ç¨‹çš„è¿è¡Œ (é˜²æ­¢å®ƒæµªè´¹ CPU æ—¶é—´)ã€‚åœ¨ç”¨æˆ·æ¨¡å¼ä¸­è¿è¡Œçš„çº¿ç¨‹å¯èƒ½è¢«ç³»ç»ŸæŠ¢å  (preempted)ï¼Œä½†çº¿ç¨‹ä¼šä»¥æœ€å¿«çš„é€Ÿåº¦å†æ¬¡è°ƒåº¦ã€‚æ‰€ä»¥ï¼Œæƒ³è¦å–å¾—èµ„æºä½†æš‚æ—¶å–ä¸åˆ°çš„çº¿ç¨‹ä¼šä¸€ç›´åœ¨ç”¨æˆ·æ¨¡å¼ä¸­ â€œè‡ªæ—‹â€ï¼Œè¿™å¯èƒ½æµªè´¹å¤§é‡ CPU æ—¶é—´ï¼Œè€Œè¿™äº› CPU æ—¶é—´æœ¬å¯ç”¨äºæ‰§è¡Œå…¶ä»–æ›´æœ‰ç”¨çš„å·¥ä½œã€‚å³ä¾¿æ²¡æœ‰å…¶ä»–æ›´æœ‰ç”¨çš„å·¥ä½œï¼Œæ›´å¥½çš„åšæ³•ä¹Ÿæ˜¯è®© CPU ç©ºé—²ï¼Œè¿™è‡³å°‘èƒ½çœä¸€ç‚¹ç”µã€‚æ ¸æ¨¡å¼çš„æ„é€ æ˜¯ç”± Windows æ“ä½œç³»ç»Ÿè‡ªèº«æä¾›çš„ã€‚æ‰€ä»¥ï¼Œå®ƒä»¬è¦æ±‚åœ¨åº”ç”¨ç¨‹åºçš„çº¿ç¨‹ä¸­è°ƒç”¨ç”±æ“ä½œç³»ç»Ÿå†…æ ¸å®ç°çš„å‡½æ•°ã€‚å°†çº¿ç¨‹ä»ç”¨æˆ·æ¨¡å¼åˆ‡æ¢ä¸ºå†…æ ¸æ¨¡å¼ (æˆ–ç›¸å) ä¼šæ‹›è‡´å·¨å¤§çš„æ€§èƒ½æŸå¤±ï¼Œè¿™æ­£æ˜¯ä¸ºä»€ä¹ˆè¦é¿å…ä½¿ç”¨å†…æ ¸æ¨¡å¼æ„é€ çš„åŸå› ã€‚&lt;sup&gt;â‘ &lt;/sup &gt; ä½†å®ƒä»¬æœ‰ä¸€ä¸ªé‡è¦çš„ä¼˜ç‚¹ï¼šçº¿ç¨‹é€šè¿‡å†…æ ¸æ¨¡å¼çš„æ„é€ è·å–å…¶ä»–çº¿ç¨‹æ‹¥æœ‰çš„èµ„æºæ—¶ï¼ŒWindows ä¼šé˜»å¡çº¿ç¨‹ä»¥é¿å…å®ƒæµªè´¹ CPU æ—¶é—´ã€‚å½“èµ„æºå˜å¾—å¯ç”¨æ—¶ï¼ŒWindows ä¼šæ¢å¤çº¿ç¨‹ï¼Œå…è®¸å®ƒè®¿é—®èµ„æºã€‚å¯¹äºåœ¨ä¸€ä¸ªæ„é€ ä¸Šç­‰å¾…çš„çº¿ç¨‹ï¼Œå¦‚æœæ‹¥æœ‰è¿™ä¸ªæ„é€ çš„çº¿ç¨‹ä¸€ç›´ä¸é‡Šæ”¾å®ƒï¼Œå‰è€…å°±å¯èƒ½ä¸€ç›´é˜»å¡ã€‚å¦‚æœæ˜¯ç”¨æˆ·æ¨¡å¼çš„æ„é€ ï¼Œçº¿ç¨‹å°†ä¸€ç›´åœ¨ä¸€ä¸ª CPU ä¸Šè¿è¡Œï¼Œæˆ‘ä»¬ç§°ä¸º â€œæ´»é”â€(deadlock)ã€‚ä¸¤ç§æƒ…å†µéƒ½ä¸å¥½ã€‚ä½†åœ¨ä¸¤è€…ä¹‹é—´ï¼Œæ­»é”æ€»æ˜¯ä¼˜äºæ´»é”ï¼Œå› ä¸ºæ´»é”æ—¢æµªè´¹ CPU æ—¶é—´ï¼Œåˆæµªè´¹å†…å­˜ (çº¿ç¨‹æ ˆç­‰)ï¼Œè€Œæ­»é”åªæµªè´¹å†…å­˜ã€‚ç†æƒ³ä¸­çš„æ„é€ åº”å…¼å…·ä¸¤è€…çš„é•¿å¤„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨æ²¡æœ‰ç«äº‰çš„æƒ…å†µä¸‹ï¼Œè¿™ä¸ªæ„é€ åº”è¯¥å¿«è€Œä¸”ä¸ä¼šé˜»å¡ (å°±åƒç”¨æˆ·æ¨¡å¼çš„æ„é€ )ã€‚ä½†å¦‚æœå­˜åœ¨å¯¹æ„é€ çš„ç«äº‰ï¼Œæˆ‘å¸Œæœ›å®ƒè¢«æ“ä½œç³»ç»Ÿå†…æ ¸é˜»å¡ã€‚åƒè¿™æ ·çš„æ„é€ ç¡®å®å­˜åœ¨ï¼›æˆ‘æŠŠå®ƒä»¬ç§°ä¸º<strong>æ··åˆæ„é€ </strong> (hybrid construct)ã€‚æ··åˆæ„é€ ä½¿ä½ çš„åº”ç”¨ç¨‹åºåœ¨å¤§å¤šæ•°æ—¶é—´éƒ½å¿«é€Ÿè¿è¡Œï¼Œå¶å°”è¿è¡Œå¾—æ¯”è¾ƒæ…¢æ˜¯ä¸ºäº†é˜»å¡çº¿ç¨‹ã€‚CLR çš„è®¸å¤šçº¿ç¨‹åŒæ­¥æ„é€ å®é™…åªæ˜¯ &quot;Win32 çº¿ç¨‹åŒæ­¥æ„é€ &quot; çš„ä¸€äº›é¢å‘å¯¹è±¡çš„ç±»åŒ…è£…å™¨ã€‚æ¯•ç«Ÿï¼ŒCLR çº¿ç¨‹å°±æ˜¯ Windows çº¿ç¨‹ï¼Œè¿™æ„å‘³ç€è¦ç”± Windows è°ƒåº¦çº¿ç¨‹å’Œæ§åˆ¶çº¿ç¨‹åŒæ­¥ã€‚</p><h2 id="user-mode-constructs"><a class="anchor" href="#user-mode-constructs">#</a> User-Mode Constructs</h2><blockquote><p>The CLR guarantees that reads and writes to variables of the following data types are atomic: Boolean, Char, (S)Byte, (U)Int16, (U)Int32, (U)IntPtr, Single, and reference types. This means that all bytes within that variable are read from or written to all at once. So, for example, if you have the following class:</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>and if a thread executes this line of code:</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>SomeType<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">0x01234567</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>then the x variable will change from 0x00000000 to 0x01234567 all at once (atomically). Another thread cannot possibly see the value in an intermediate state. For example, it is impossible for some other read to query SomeType.x and get a value of 0x01230000. Suppose that the x field in the preceding SomeType class is an Int64. If a thread executes this line of code:</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>SomeType<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">0x0123456789abcdef</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>it is possible that another thread could query x and get a value of 0x0123456700000000 or 0x0000000089abcdef, because the read and write operations are not atomic. This is called a torn read.</p></blockquote><blockquote><p>Although atomic access to variable guarantees that the read or write happens all at once, it does not guarantee when the read or write will happen due to compiler and CPU optimizations. The primitive user-mode constructs discussed in this section are used to enforce the timing of these atomic read and write operations. In addition, these constructs can also force atomic and timed access to variables of additional data types: (U)Int64 and Double.</p></blockquote><blockquote><p>There are two kinds of primitive user-mode thread synchronization constructs:</p><ul><li><p>Volatile constructs, which perform an atomic read or write operation on a variable containing a simple data type at a specific time</p></li><li><p>Interlocked constructs, which perform an atomic read and write operation on a variable containing a simple data type at a specific time</p></li></ul></blockquote><blockquote><p>All the volatile and interlocked constructs require you to pass a reference (memory address) to a variable containing a simple data type.</p></blockquote><h3 id="volatile-constructs"><a class="anchor" href="#volatile-constructs">#</a> Volatile Constructs</h3><blockquote><p>Back in the early days of computing, software was written using assembly language. Assembly language is very tedious, because programmers must explicitly state everythingâ€”use this CPU register for this, branch to that, call indirect through this other thing, and so on. To simplify programming, higher-level languages were introduced. These higher-level languages introduced common useful constructs, like if/else, switch/case, various loops, local variables, arguments, virtual method calls, operator overloads, and much more. Ultimately, these language compilers must convert the high-level constructs down to the low-level constructs so that the computer can actually do what you want it to do.</p></blockquote><blockquote><p>In other words, the C# compiler translates your C# constructs into Intermediate Language (IL), which is then converted by the just-in-time (JIT) compiler into native CPU instructions, which must then be processed by the CPU itself. In addition, the C# compiler, the JIT compiler, and even the CPU itself can optimize your code. For example, the following ridiculous method can ultimately be compiled into nothing.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">OptimizedAway</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Constant expression is computed at compile time resulting in zero</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Int32</span> <span class="token keyword">value</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">50</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// If value is 0, the loop never executes</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> <span class="token keyword">value</span><span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// There is no need to compile the code in the loop because it can never execute</span></pre></td></tr><tr><td data-num="7"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Jeff"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In this code, the compiler can see that value will always be 0; therefore, the loop will never execute and consequently, there is no need to compile the code inside the loop. This method could be compiled down to nothing. In fact, when JITting a method that calls OptimizedAway, the JITter will try to inline the OptimizedAway methodâ€™s code. Because there is no code, the JITter will even remove the code that tries to call OptimizedAway. We love this feature of compilers. As developers, we get to write the code in the way that makes the most sense to us. The code should be easy to write, read, and maintain. Then compilers translate our intentions into machine-understandable code. We want our compilers to do the best job possible for us.</p></blockquote><blockquote><p>When the C# compiler, JIT compiler, and CPU optimize our code, they guarantee us that the intention of the code is preserved. That is, from a single-threaded perspective, the method does what we want it to do, although it may not do it exactly the way we described in our source code. However, the intention might not be preserved from a multithreaded perspective. Here is an example where the optimizations make the program not work as expected.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">StrangeBehavior</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// As you'll see later, mark this field as volatile to fix the problem</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Boolean</span> s_stopWorker <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Main: letting worker run for 5 seconds"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Thread</span><span class="token punctuation">(</span>Worker<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> t<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> Thread<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> s_stopWorker <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Main: waiting for worker to stop"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> t<span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Worker</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>s_stopWorker<span class="token punctuation">)</span> x<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Worker: stopped when x=&#123;0&#125;"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In this code, the Main method creates a new thread that executes the Worker method. This Worker method counts as high as it can before being told to stop. The Main method allows the Worker thread to run for five seconds before telling it to stop by setting the static Boolean field to true. At this point, the Worker thread should display what it counted up to, and then the thread will terminate. The Main thread waits for the Worker thread to terminate by calling Join, and then the Main thread returns, causing the whole process to terminate.</p></blockquote><blockquote><p>Looks simple enough, right? Well, the program has a potential problem due to all the optimizations that could happen to it. You see, when the Worker method is compiled, the compiler sees that s_stopWorker is either true or false, and it also sees that this value never changes inside the Worker method itself. So the compiler could produce code that checks s_stopWorker first. If s_stopWorker is true, then Worker: stopped when x=0 will be displayed. If s_stopWorker is false, then the compiler produces code that enters an infinite loop that increments x forever. You see, the optimizations cause the loop to run very fast because checking s_stopWorker only occurs once before the loop; it does not get checked with each iteration of the loop.</p></blockquote><blockquote><p>If you actually want to see this in action, put this code in a .cs file and compile the code by using C#â€™s /platform:x86 and /optimize+ switches. Then run the resulting EXE file, and youâ€™ll see that the program runs forever. Note that you have to compile for x86, ensuring that the x86 JIT compiler is used at run time. The x86 JIT compiler is more mature than the x64 JIT compiler, so it performs more aggressive optimizations. The x64 JIT compiler does not perform this particular optimization, and therefore the program runs to completion. This highlights another interesting point about all of this. Whether your program behaves as expected depends on a lot of factors, such as which compiler version and compiler switches are used, which JIT compiler is used, and which CPU your code is running on. In addition, to see the preceding program run forever, you must not run the program under a debugger because the debugger causes the JIT compiler to produce unoptimized code that is easier to step through.</p></blockquote><blockquote><p>Letâ€™s look at another example, which has two threads that are both accessing two fields.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">ThreadsSharingData</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// This method is executed by one thread </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Thread1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Note: These could execute in reverse order</span></pre></td></tr><tr><td data-num="7"></td><td><pre> m_value <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> m_flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// This method is executed by another thread </span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Thread2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// Note: m_value could be read before m_flag</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>m_flag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>m_value<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The problem with this code is that the compilers/CPU could translate the code in such a way as to reverse the two lines of code in the Thread1 method. After all, reversing the two lines of code does not change the intention of the method. The method needs to get a 5 in m_value and a 1 in m_flag. From a single-threaded applicationâ€™s perspective, the order of executing this code is unimportant. If these two lines do execute in reverse order, then another thread executing the Thread2 method could see that m_flag is 1 and then display 0.</p></blockquote><blockquote><p>Letâ€™s look at this code another way. Letâ€™s say that the code in the Thread1 method executes in program order (the way it was written). When compiling the code in the Thread2 method, the compiler must generate code to read m_flag and m_value from RAM into CPU registers. It is possible that RAM will deliver the value of m_value first, which would contain a 0. Then the Thread1 method could execute, changing m_value to 5 and m_flag to 1. But Thread2â€™s CPU register doesnâ€™t see that m_value has been changed to 5 by this other thread, and then the value in m_flag could be read from RAM into a CPU register and the value of m_flag becomes 1 now, causing Thread2 to again display 0.</p></blockquote><blockquote><p>This is all very scary stuff and is more likely to cause problems in a release build of your program than in a debug build of your program, making it particularly tricky to detect these problems and correct your code. Now, letâ€™s talk about how to correct your code.</p></blockquote><blockquote><p>The static System.Threading.Volatile class offers two static methods that look like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Volatile</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Write</span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token class-name">Int32</span> location<span class="token punctuation">,</span> <span class="token class-name">Int32</span> <span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">Read</span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token class-name">Int32</span> location<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>These methods are special. In effect, these methods disable some optimizations usually performed by the C# compiler, the JIT compiler, and the CPU itself. Hereâ€™s how the methods work:</p><ul><li><p>The Volatile.Write method forces the value in location to be written to at the point of the call. In addition, any earlier program-order loads and stores must occur before the call to Volatile.Write.</p></li><li><p>The Volatile.Read method forces the value in location to be read from at the point of the call. In addition, any later program-order loads and stores must occur after the call to Volatile.Read.</p></li></ul></blockquote><p>ğŸ’¡é‡è¦æç¤ºï¼šæˆ‘çŸ¥é“ç›®å‰è¿™äº›æ¦‚å¿µå¾ˆå®¹æ˜“ä»¤äººè¿·æƒ‘ï¼Œæ‰€ä»¥è®©æˆ‘å½’çº³ä¸€æ¡ç®€å•çš„è§„åˆ™ï¼šå½“çº¿ç¨‹é€šè¿‡å…±äº«å†…å­˜ç›¸äº’é€šä¿¡æ—¶ï¼Œè°ƒç”¨ <code>Volatile.Write</code> æ¥å†™å…¥æœ€åä¸€ä¸ªå€¼ï¼Œè°ƒç”¨ <code>Volatile.Read</code> æ¥è¯»å–ç¬¬ä¸€ä¸ªå€¼ã€‚</p><blockquote><p>So now we can fix the ThreadsSharingData class by using these methods.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">ThreadsSharingData</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// This method is executed by one thread </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Thread1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Note: 5 must be written to m_value before 1 is written to m_flag</span></pre></td></tr><tr><td data-num="7"></td><td><pre> m_value <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> Volatile<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token keyword">ref</span> m_flag<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// This method is executed by another thread </span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Thread2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// Note: m_value must be read after m_flag is read </span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>Volatile<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span><span class="token keyword">ref</span> m_flag<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>m_value<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>First, notice that we are following the rule. The Thread1 method writes two values out to fields that are shared by multiple threads. The last value that we want written (setting m_flag to 1) is performed by calling Volatile.Write. The Thread2 method reads two values from fields shared by multiple threads, and the first value being read (m_flag) is performed by calling Volatile.Read.</p></blockquote><blockquote><p>But what is really happening here? Well, for the Thread1 method, the Volatile.Write call ensures that all the writes above it are completed before a 1 is written to m_flag. Because m_value = 5 is before the call to Volatile.Write, it must complete first. In fact, if there were many variables being modified before the call to Volatile.Write, they would all have to complete before 1 is written to m_flag. Note that the writes before the call to Volatile.Write can be optimized to execute in any order; itâ€™s just that all the writes have to complete before the call to Volatile.Write.</p></blockquote><blockquote><p>For the Thread2 method, the Volatile.Read call ensures that all variable reads after it start after the value in m_flag has been read. Because reading m_value is after the call to Volatile.Read, the value must be read after having read the value in m_flag. If there were many reads after the call to Volatile.Read, they would all have to start after the value in m_flag has been read. Note that the reads after the call to Volatile.Read can be optimized to execute in any order; itâ€™s just that the reads canâ€™t start happening until after the call to Volatile.Read.</p></blockquote><h3 id="cs-support-for-volatile-fields"><a class="anchor" href="#cs-support-for-volatile-fields">#</a> C#â€™s Support for Volatile Fields</h3><blockquote><p>Making sure that programmers call the Volatile.Read and Volatile.Write methods correctly is a lot to ask. Itâ€™s hard for programmers to keep all of this in their minds and to start imagining what other threads might be doing to shared data in the background. To simplify this, the C# compiler has the volatile keyword, which can be applied to static or instance fields of any of these types: Boolean, (S)Byte, (U)Int16, (U)Int32, (U)IntPtr, Single, or Char. You can also apply the volatile keyword to reference types and any enum field as long as the enumerated type has an underlying type of (S)Byte, (U)Int16, or (U)Int32. The JIT compiler ensures that all accesses to a volatile field are performed as volatile reads and writes, so that it is not necessary to explicitly call Volatile's static Read or Write methods. Furthermore, the volatile keyword tells the C# and JIT compilers not to cache the field in a CPU register, ensuring that all reads to and from the field actually cause the value to be read from memory.</p></blockquote><blockquote><p>Using the volatile keyword, we can rewrite the ThreadsSharingData class as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">ThreadsSharingData</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token class-name">Int32</span> m_flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// This method is executed by one thread </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Thread1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Note: 5 must be written to m_value before 1 is written to m_flag</span></pre></td></tr><tr><td data-num="7"></td><td><pre> m_value <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> m_flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// This method is executed by another thread </span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Thread2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// Note: m_value must be read after m_flag is read </span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>m_flag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>m_value<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>There are some developers (and I am one of them) who do not like C#â€™s volatile keyword, and they think that the language should not provide it.6 Our thinking is that most algorithms require few volatile read or write accesses to a field and that most other accesses to the field can occur normally, improving performance; seldom is it required that all accesses to a field be volatile. For example, it is difficult to interpret how to apply volatile read operations to algorithms like this one.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>m_amount <span class="token operator">=</span> m_amount <span class="token operator">+</span> m_amount<span class="token punctuation">;</span> <span class="token comment">// Assume m_amount is a volatile field defined in a class</span></pre></td></tr></table></figure><blockquote><p>Normally, an integer number can be doubled simply by shifting all bits left by 1 bit, and many compilers can examine the preceding code and perform this optimization. However, if m_amount is a volatile field, then this optimization is not allowed. The compiler must produce code to read m_amount into a register and then read it again into another register, add the two registers together, and then write the result back out to the m_amount field. The unoptimized code is certainly bigger and slower; it would be unfortunate if it were contained inside a loop.</p></blockquote><blockquote><p>Furthermore, C# does not support passing a volatile field by reference to a method. For example, if m_amount is defined as a volatile Int32, attempting to call Int32â€™s TryParse method causes the compiler to generate a warning as shown here.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Boolean</span> success <span class="token operator">=</span> Int32<span class="token punctuation">.</span><span class="token function">TryParse</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">,</span> <span class="token keyword">out</span> m_amount<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// The preceding line causes the C# compiler to generate a warning: </span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// CS0420: a reference to a volatile field will not be treated as volatile</span></pre></td></tr></table></figure><blockquote><p>Finally, volatile fields are not Common Language Specification (CLS) compliant because many languages (including Visual Basic) do not support them.</p></blockquote><h3 id="interlocked-constructs"><a class="anchor" href="#interlocked-constructs">#</a> Interlocked Constructs</h3><blockquote><p>Volatileâ€™s Read method performs an atomic read operation, and its Write method performs an atomic write operation. That is, each method performs either an atomic read operation or an atomic write operation. In this section, we look at the static System.Threading.Interlocked classâ€™s methods. Each of the methods in the Interlocked class performs an atomic read and write operation. In addition, all the Interlocked methods are full memory fences. That is, any variable writes before the call to an Interlocked method execute before the Interlocked method, and any variable reads after the call execute after the call.</p></blockquote><blockquote><p>The static methods that operate on Int32 variables are by far the most commonly used methods. I show them here.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Interlocked</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// return (++location) </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">Increment</span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token class-name">Int32</span> location<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// return (--location) </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">Decrement</span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token class-name">Int32</span> location<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// return (location += value) </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// Note: value can be a negative number allowing subtraction </span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token class-name">Int32</span> location<span class="token punctuation">,</span> <span class="token class-name">Int32</span> <span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// Int32 old = location; location = value; return old; </span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">Exchange</span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token class-name">Int32</span> location<span class="token punctuation">,</span> <span class="token class-name">Int32</span> <span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// Int32 old = location; </span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// if (location == comparand) location = value;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token comment">// return old; </span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">CompareExchange</span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token class-name">Int32</span> location<span class="token punctuation">,</span> <span class="token class-name">Int32</span> <span class="token keyword">value</span><span class="token punctuation">,</span> <span class="token class-name">Int32</span> comparand<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token range operator">..</span><span class="token punctuation">.</span> </pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>There are also overloads of the preceding methods that operate on Int64 values. Furthermore, the Interlocked class offers Exchange and CompareExchange methods that take Object, IntPtr, Single, and Double, and there is also a generic version in which the generic type is constrained to class (any reference type).</p></blockquote><blockquote><p>Personally, I love the Interlocked methods, because they are relatively fast and you can do so much with them. Let me show you some code that uses the Interlocked methods to asynchronously query several web servers and concurrently process the returned data. This code is pretty short, never blocks any threads, and uses thread pool threads to scale automatically, consuming up to the number of CPUs available if its workload could benefit from it. In addition, the code, as is, supports accessing up to 2,147,483,647 (Int32.MaxValue) web servers. In other words, this code is a great model to follow for your own scenarios.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">MultiWebRequests</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// This helper class coordinates all the asynchronous operations</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">AsyncCoordinator</span> m_ac <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">AsyncCoordinator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// Set of web servers we want to query &amp; their responses (Exception or Int32)</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// NOTE: Even though multiple could access this dictionary simultaneously,</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// there is no need to synchronize access to it because the keys are </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// read-only after construction</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Dictionary<span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token punctuation">></span></span> m_servers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Dictionary<span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#123;</span> <span class="token string">"http://Wintellect.com/"</span><span class="token punctuation">,</span> <span class="token keyword">null</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#123;</span> <span class="token string">"http://Microsoft.com/"</span><span class="token punctuation">,</span> <span class="token keyword">null</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">&#123;</span> <span class="token string">"http://1.1.1.1/"</span><span class="token punctuation">,</span> <span class="token keyword">null</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">public</span> <span class="token function">MultiWebRequests</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> timeout <span class="token operator">=</span> Timeout<span class="token punctuation">.</span>Infinite<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token comment">// Asynchronously initiate all the requests all at once</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> httpClient <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">HttpClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> server <span class="token keyword">in</span> m_servers<span class="token punctuation">.</span>Keys<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre> m_ac<span class="token punctuation">.</span><span class="token function">AboutToBegin</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre> httpClient<span class="token punctuation">.</span><span class="token function">GetByteArrayAsync</span><span class="token punctuation">(</span>server<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token punctuation">.</span><span class="token function">ContinueWith</span><span class="token punctuation">(</span>task <span class="token operator">=></span> <span class="token function">ComputeResult</span><span class="token punctuation">(</span>server<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token comment">// Tell AsyncCoordinator that all operations have been initiated and to call</span></pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token comment">// AllDone when all operations complete, Cancel is called, or the timeout occurs</span></pre></td></tr><tr><td data-num="23"></td><td><pre> m_ac<span class="token punctuation">.</span><span class="token function">AllBegun</span><span class="token punctuation">(</span>AllDone<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ComputeResult</span><span class="token punctuation">(</span><span class="token class-name">String</span> server<span class="token punctuation">,</span> <span class="token class-name">Task<span class="token punctuation">&lt;</span>Byte<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">></span></span> task<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token class-name">Object</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>task<span class="token punctuation">.</span>Exception <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre> result <span class="token operator">=</span> task<span class="token punctuation">.</span>Exception<span class="token punctuation">.</span>InnerException<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre> <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre> <span class="token comment">// Process I/O completion here on thread pool thread(s)</span></pre></td></tr><tr><td data-num="31"></td><td><pre> <span class="token comment">// Put your own compute-intensive algorithm here...</span></pre></td></tr><tr><td data-num="32"></td><td><pre> result <span class="token operator">=</span> task<span class="token punctuation">.</span>Result<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> <span class="token comment">// This example just returns the length</span></pre></td></tr><tr><td data-num="33"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre> <span class="token comment">// Save result (exception/sum) and indicate that 1 operation completed</span></pre></td></tr><tr><td data-num="35"></td><td><pre> m_servers<span class="token punctuation">[</span>server<span class="token punctuation">]</span> <span class="token operator">=</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre> m_ac<span class="token punctuation">.</span><span class="token function">JustEnded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="38"></td><td><pre> <span class="token comment">// Calling this method indicates that the results don't matter anymore</span></pre></td></tr><tr><td data-num="39"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> m_ac<span class="token punctuation">.</span><span class="token function">Cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="40"></td><td><pre> <span class="token comment">// This method is called after all web servers respond, </span></pre></td></tr><tr><td data-num="41"></td><td><pre> <span class="token comment">// Cancel is called, or the timeout occurs</span></pre></td></tr><tr><td data-num="42"></td><td><pre> <span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">AllDone</span><span class="token punctuation">(</span><span class="token class-name">CoordinationStatus</span> status<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="43"></td><td><pre> <span class="token keyword">switch</span> <span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="44"></td><td><pre> <span class="token keyword">case</span> CoordinationStatus<span class="token punctuation">.</span>Cancel<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="45"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Operation canceled."</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre> <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="47"></td><td><pre> <span class="token keyword">case</span> CoordinationStatus<span class="token punctuation">.</span>Timeout<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="48"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Operation timed-out."</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="49"></td><td><pre> <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="50"></td><td><pre> <span class="token keyword">case</span> CoordinationStatus<span class="token punctuation">.</span>AllDone<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="51"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Operation completed; results below:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="52"></td><td><pre> <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> server <span class="token keyword">in</span> m_servers<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="53"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token string">"&#123;0&#125; "</span><span class="token punctuation">,</span> server<span class="token punctuation">.</span>Key<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="54"></td><td><pre> <span class="token class-name">Object</span> result <span class="token operator">=</span> server<span class="token punctuation">.</span>Value<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="55"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token keyword">is</span> <span class="token class-name">Exception</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="56"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"failed due to &#123;0&#125;."</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="57"></td><td><pre> <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="58"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"returned &#123;0:N0&#125; bytes."</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="59"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="60"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="61"></td><td><pre> <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="62"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="63"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="64"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>OK, the preceding code doesnâ€™t actually use any Interlocked methods directly, because I encapsulated all the coordination code in a reusable class called AsyncCoordinator, which Iâ€™ll explain shortly. Let me first explain what this class is doing. When the MultiWebRequest class is constructed, it initializes an AsyncCoordinator and a dictionary containing the set of server URIs (and their future result). It then issues all the web requests asynchronously one right after the other. It does this by first calling AsyncCoordinatorâ€™s AboutToBegin method, passing it the number of requests about to be issued.7 Then it initiates the request by calling HttpClientâ€™s GetByteArrayAsync. This returns a Task and I then call ContinueWith on this Task so that when the server replies with the bytes, they can be processed by my ComputeResult method concurrently via many thread pool threads. After all the web serversâ€™ requests have been made, the AsyncCoordinatorâ€™s AllBegun method is called, passing it the name of the method (AllDone) that should execute when all the operations complete and a timeout value. As each web server responds, various thread pool threads will call the MultiWebRequestsâ€™s ComputeResult method. This method processes the bytes returned from the server (or any error that may have occurred) and saves the result in the dictionary collection. After storing each result, AsyncCoordinatorâ€™s JustEnded method is called to let the AsyncCoordinator object know that an operation completed.</p></blockquote><blockquote><p>If all the operations have completed, then the AsyncCoordinator will invoke the AllDone method to process the results from all the web servers. The code executing the AllDone method will be the thread pool thread that just happened to get the last web server response. If timeout or cancellation occurs, then AllDone will be invoked via whatever thread pool thread notifies the AsyncCoordinator of timeout or using whatever thread happened to call the Cancel method. There is also a chance that the thread issuing the web server requests could invoke AllDone itself if the last request completes before AllBegun is called.</p></blockquote><blockquote><p>Note that there is a race because it is possible that all web server requests complete, AllBegun is called, timeout occurs, and Cancel is called all at the exact same time. If this happens, then the AsyncCoordinator will select a winner and three losers, ensuring that the AllDone method is never called more than once. The winner is identified by the status argument passed into AllDone, which can be one of the symbols defined by the CoordinationStatus type.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">enum</span> <span class="token class-name">CoordinationStatus</span> <span class="token punctuation">&#123;</span> AllDone<span class="token punctuation">,</span> Timeout<span class="token punctuation">,</span> Cancel <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>Now that you get a sense of what happens, letâ€™s take a look at how it works. The AsyncCoordinator class encapsulates all the thread coordination logic in it. It uses Interlocked methods for everything to ensure that the code runs extremely fast and that no threads ever block. Here is the code for this class.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">AsyncCoordinator</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_opCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// Decremented when AllBegun calls JustEnded</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_statusReported <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 0=false, 1=true</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Action<span class="token punctuation">&lt;</span>CoordinationStatus<span class="token punctuation">></span></span> m_callback<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Timer</span> m_timer<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// This method MUST be called BEFORE initiating an operation </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">AboutToBegin</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> opsToAdd <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> Interlocked<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">ref</span> m_opCount<span class="token punctuation">,</span> opsToAdd<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// This method MUST be called AFTER an operationâ€™s result has been processed </span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">JustEnded</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>Interlocked<span class="token punctuation">.</span><span class="token function">Decrement</span><span class="token punctuation">(</span><span class="token keyword">ref</span> m_opCount<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token function">ReportStatus</span><span class="token punctuation">(</span>CoordinationStatus<span class="token punctuation">.</span>AllDone<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// This method MUST be called AFTER initiating ALL operations</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">AllBegun</span><span class="token punctuation">(</span><span class="token class-name">Action<span class="token punctuation">&lt;</span>CoordinationStatus<span class="token punctuation">></span></span> callback<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token class-name">Int32</span> timeout <span class="token operator">=</span> Timeout<span class="token punctuation">.</span>Infinite<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre> m_callback <span class="token operator">=</span> callback<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout <span class="token operator">!=</span> Timeout<span class="token punctuation">.</span>Infinite<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre> m_timer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Timer</span><span class="token punctuation">(</span>TimeExpired<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> timeout<span class="token punctuation">,</span> Timeout<span class="token punctuation">.</span>Infinite<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token function">JustEnded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">TimeExpired</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">ReportStatus</span><span class="token punctuation">(</span>CoordinationStatus<span class="token punctuation">.</span>Timeout<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">ReportStatus</span><span class="token punctuation">(</span>CoordinationStatus<span class="token punctuation">.</span>Cancel<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ReportStatus</span><span class="token punctuation">(</span><span class="token class-name">CoordinationStatus</span> status<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token comment">// If status has never been reported, report it; else ignore it</span></pre></td></tr><tr><td data-num="27"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>Interlocked<span class="token punctuation">.</span><span class="token function">Exchange</span><span class="token punctuation">(</span><span class="token keyword">ref</span> m_statusReported<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="28"></td><td><pre> <span class="token function">m_callback</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The most important field in this class is the m_opCount field. This field keeps track of the number of asynchronous operations that are still outstanding. Just before each asynchronous operation is started, AboutToBegin is called. This method calls Interlocked.Add to add the number passed to it to the m_opCount field in an atomic way. Adding to m_opCount must be performed atomically because web servers could be processing responses on thread pool threads as more operations are being started. As web server responses are processed, JustEnded is called. This method calls Interlocked.Decrement to atomically subtract 1 from m_opCount. Whichever thread happens to set m_opCount to 0 calls ReportStatus.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼š <code>m_opCount</code> å­—æ®µåˆå§‹åŒ–ä¸º 1 (è€Œé 0)ï¼Œè¿™ä¸€ç‚¹å¾ˆé‡è¦ã€‚æ‰§è¡Œæ„é€ å™¨æ–¹æ³•çš„çº¿ç¨‹åœ¨å‘å‡º <strong>Web</strong> æœåŠ¡å™¨è¯·æ±‚æœŸé—´ï¼Œç”±äº <code>m_opCount</code> å­—æ®µä¸º 1ï¼Œæ‰€ä»¥èƒ½ä¿è¯ <code>AllDone</code> ä¸ä¼šè¢«è°ƒç”¨ã€‚æ„é€ å™¨è°ƒç”¨ <code>AllBegun</code> ä¹‹å‰ï¼Œ <code>m_opCount</code> æ°¸è¿œä¸ä¸å¯èƒ½å˜æˆ 0 ã€‚æ„é€ å™¨è°ƒç”¨ <code>AllBegun</code> æ—¶ï¼Œ <code>AllBegun</code> å†…éƒ¨è°ƒç”¨ <code>JustEnded</code> æ¥é€’å‡ <code>m_opCount</code> ï¼Œæ‰€ä»¥äº‹å®ä¸Šæ’¤é”€ ( <code>undo</code> ) äº†æŠŠå®ƒåˆå§‹åŒ–æˆ 1 çš„æ•ˆæœã€‚ç°åœ¨ <code>m_opCount</code> èƒ½å˜æˆ 0 äº†ï¼Œä½†åªèƒ½æ˜¯åœ¨å‘èµ·äº†æ‰€æœ‰ Web æœåŠ¡å™¨è¯·æ±‚ä¹‹åã€‚</p><blockquote><p>The ReportStatus method arbitrates the race that can occur among all the operations completing, the timeout occurring, and Cancel being called. ReportStatus must make sure that only one of these conditions is considered the winner so that the m_callback method is invoked only once. Arbitrating the winner is done via calling Interlocked.Exchange, passing it a reference to the m_statusReported field. This field is really treated as a Boolean variable; however, it canâ€™t actually be a Boolean variable because there are no Interlocked methods that accept a Boolean variable. So I use an Int32 variable instead where 0 means false and 1 means true.</p></blockquote><blockquote><p>Inside ReportStatus, the Interlocked.Exchange call will change m_statusReported to 1. But only the first thread to do this will see Interlocked.Exchange return a 0, and only this thread will invoke the callback method. Any other threads that call Interlocked.Exchange will get a return value of 1, effectively notifying these threads that the callback method has already been invoked and therefore it should not be invoked again.</p></blockquote><h3 id="implementing-a-simple-spin-lock"><a class="anchor" href="#implementing-a-simple-spin-lock">#</a> Implementing a Simple Spin Lock</h3><blockquote><p>The Interlocked methods are great, but they mostly operate on Int32 values. What if you need to manipulate a bunch of fields in a class object atomically? In this case, we need a way to stop all threads but one from entering the region of code that manipulates the fields. Using Interlocked methods, we can build a thread synchronization lock.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">struct</span> <span class="token class-name">SimpleSpinLock</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_ResourceInUse<span class="token punctuation">;</span> <span class="token comment">// 0=false (default), 1=true</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Enter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// Always set resource to in-use</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// When this thread changes it from not in-use, return</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>Interlocked<span class="token punctuation">.</span><span class="token function">Exchange</span><span class="token punctuation">(</span><span class="token keyword">ref</span> m_ResourceInUse<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Black magic goes here...</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Leave</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// Set resource to not in-use</span></pre></td></tr><tr><td data-num="13"></td><td><pre> Volatile<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token keyword">ref</span> m_ResourceInUse<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>And here is a class that shows how to use the SimpleSpinLock.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SomeResource</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">SimpleSpinLock</span> m_sl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SimpleSpinLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">AccessResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> m_sl<span class="token punctuation">.</span><span class="token function">Enter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// Only one thread at a time can get in here to access the resource...</span></pre></td></tr><tr><td data-num="6"></td><td><pre> m_sl<span class="token punctuation">.</span><span class="token function">Leave</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The SimpleSpinLock implementation is very simple. If two threads call Enter at the same time, Interlocked.Exchange ensures that one thread changes m_resourceInUse from 0 to 1 and sees that m_resourceInUse was 0. This thread then returns from Enter so that it can continue executing the code in the AccessResource method. The other thread will change m_resourceInUse from a 1 to a 1. This thread will see that it did not change m_resourceInUse from a 0, and this thread will now start spinning continuously, calling Exchange until the first thread calls Leave.</p></blockquote><blockquote><p>When the first thread is done manipulating the fields of the SomeResource object, it calls Leave, which internally calls Volatile.Write and changes m_resourceInUse back to a 0. This causes the spinning thread to then change m_resourceInUse from a 0 to a 1, and this thread now gets to return from Enter so that it can access SomeResource objectâ€™s fields.</p></blockquote><blockquote><p>There you have it. This is a simple implementation of a thread synchronization lock. The big potential problem with this lock is that it causes threads to spin when there is contention for the lock. This spinning wastes precious CPU time, preventing the CPU from doing other, more useful work. As a result, spin locks should only ever be used to guard regions of code that execute very quickly.</p></blockquote><blockquote><p>Spin locks should not typically be used on single-CPU machines, because the thread that holds the lock canâ€™t quickly release it if the thread that wants the lock is spinning. The situation becomes much worse if the thread holding the lock is at a lower priority than the thread wanting to get the lock, because now the thread holding the lock may not get a chance to run at all, resulting in a livelock situation. Windows sometimes boosts a threadâ€™s priority dynamically for short periods of time. Therefore, boosting should be disabled for threads that are using spin locks; see the PriorityBoostEnabled properties of System.Diagnostics.Process and System.Diagnostics.ProcessThread. There are issues related to using spin locks on hyperthreaded machines, too. In an attempt to circumvent these kinds of problems, many spin locks have some additional logic in them; I refer to the additional logic as Black Magic. Iâ€™d rather not go into the details of Black Magic because it changes over time as more people study locks and their performance. However, I will say this: The FCL ships with a structure, System.Threading.SpinWait, which encapsulates the state-of-the-art thinking around this Black Magic.</p></blockquote><p><strong>åœ¨çº¿ç¨‹å¤„ç†ä¸­å¼•å…¥å»¶è¿Ÿ</strong></p><p>â€œé»‘ç§‘æŠ€â€ æ—¨åœ¨è®©å¸Œæœ›è·å¾—èµ„æºçš„çº¿ç¨‹æš‚åœæ‰§è¡Œï¼Œä½¿å½“å‰æ‹¥æœ‰èµ„æºçš„çº¿ç¨‹èƒ½æ‰§è¡Œå®ƒçš„ä»£ç å¹¶è®©å‡ºèµ„æºã€‚ä¸ºæ­¤ï¼Œ <code>SpinWait</code> ç»“æ„å†…éƒ¨è°ƒç”¨ <code>Thread</code> çš„é™æ€ <code>Sleep</code> ï¼Œ <code>Yield</code> å’Œ <code>SpinWait</code> æ–¹æ³•ã€‚åœ¨è¿™é‡Œçš„è¡¥å……å†…å®¹ä¸­ï¼Œæˆ‘æƒ³ç®€å•è§£é‡Šä¸€ä¸‹è¿™äº›æ–¹æ³•ã€‚</p><p>çº¿ç¨‹å¯å‘Šè¯‰ç³»ç»Ÿå®ƒåœ¨æŒ‡å®šæ—¶é—´å†…ä¸æƒ³è¢«è°ƒåº¦ï¼Œè¿™æ˜¯è°ƒç”¨ <code>Thread</code> çš„é™æ€ <code>Sleep</code> æ–¹æ³•æ¥å®ç°çš„ï¼š</p><pre><code class="language-C#">public static void Sleep(Int32 millisecondsTimeout);
public static void Sleep(TimeSpan timeout);
</code></pre><p>è¿™ä¸ªæ–¹æ³•å¯¼è‡´çº¿ç¨‹åœ¨æŒ‡å®šæ—¶é—´å†…æŒ‚èµ·ã€‚è°ƒç”¨ <code>Sleep</code> å…è®¸çº¿ç¨‹è‡ªæ„¿æ”¾å¼ƒå®ƒçš„æ—¶é—´ç‰‡çš„å‰©ä½™éƒ¨åˆ†ã€‚ç³»ç»Ÿä¼šä½¿çº¿ç¨‹åœ¨å¤§è‡´æŒ‡å®šçš„æ—¶é—´é‡Œä¸è¢«è°ƒåº¦ã€‚æ²¡æœ‰é”™ â€”â€”â€”â€” å¦‚æœå‘Šè¯‰ç³»ç»Ÿä½ å¸Œæœ›ä¸€ä¸ªçº¿ç¨‹ç¡çœ  100 æ¯«ç§’ï¼Œé‚£ä¹ˆä¼šç¡çœ å¤§è‡´é‚£ä¹ˆé•¿çš„æ—¶é—´ï¼Œä½†ä¹Ÿæœ‰å¯èƒ½ä¼šå¤šç¡çœ å‡ ç§’ã€ç”šè‡³å‡ åˆ†é’Ÿçš„æ—¶é—´ã€‚è®°ä½ï¼ŒWindows ä¸æ˜¯å®æ—¶æ“ä½œç³»ç»Ÿã€‚ä½ çš„çº¿ç¨‹å¯èƒ½åœ¨æ­£ç¡®çš„æ—¶é—´å”¤é†’ï¼Œä½†å…·ä½“æ˜¯å¦è¿™æ ·ï¼Œè¦å–å†³äºç³»ç»Ÿä¸­æ­£åœ¨å‘ç”Ÿçš„åˆ«çš„äº‹æƒ…ã€‚</p><p>å¯ä»¥è°ƒç”¨ <code>Sleep</code> ï¼Œå¹¶ä¸º <code>millisecondsTimeout</code> å‚æ•°ä¼ é€’ <code>System.Threading.Timeout.Infinite</code> ä¸­çš„å€¼ (å®šä¹‰ä¸º <code>-1</code> )ã€‚è¿™å‘Šè¯‰ç³»ç»Ÿæ°¸è¿œä¸è°ƒåº¦çº¿ç¨‹ï¼Œä½†è¿™æ ·åšæ²¡ä»€ä¹ˆæ„ä¹‰ã€‚æ›´å¥½çš„åšæ³•æ˜¯è®©çº¿ç¨‹é€€å‡ºï¼Œå›æ”¶å®ƒçš„æ ˆå’Œå†…æ ¸å¯¹è±¡ã€‚å¯ä»¥å‘ <code>Sleep</code> ä¼ é€’ <code>0</code> ï¼Œå‘Šè¯‰ç³»ç»Ÿè°ƒç”¨çº¿ç¨‹æ”¾å¼ƒäº†å®ƒå½“å‰æ—¶é—´ç‰‡çš„å‰©ä½™éƒ¨åˆ†ï¼Œå¼ºè¿«ç³»ç»Ÿè°ƒåº¦å¦ä¸€ä¸ªçº¿ç¨‹ã€‚ä½†ç³»ç»Ÿå¯èƒ½é‡æ–°è°ƒåº¦åˆšæ‰è°ƒç”¨äº† <code>Sleep</code> çš„çº¿ç¨‹ (å¦‚æœæ²¡æœ‰ç›¸åŒæˆ–æ›´é«˜ä¼˜å…ˆçº§çš„å…¶ä»–å¯è°ƒåº¦çº¿ç¨‹ï¼Œå°±ä¼šå‘ç”Ÿè¿™ç§æƒ…å†µ)ã€‚</p><p>çº¿ç¨‹å¯è¦æ±‚ Windows åœ¨å½“å‰ CPU ä¸Šè°ƒåº¦å¦ä¸€ä¸ªçº¿ç¨‹ï¼Œè¿™æ˜¯é€šè¿‡ <code>Thread</code> çš„ <code>Yield</code> æ–¹æ³•æ¥å®ç°çš„ï¼š</p><pre><code class="language-C#">public static Boolean Yield();
</code></pre><p>å¦‚æœ Windows å‘ç°æœ‰å¦ä¸€ä¸ªçº¿ç¨‹å‡†å¤‡å¥½åœ¨å½“å‰å¤„ç†å™¨ä¸Šè¿è¡Œï¼Œ <code>Yield</code> å°±ä¼šè¿”å› <code>true</code> ï¼Œè°ƒç”¨ <code>Yield</code> çš„çº¿ç¨‹ä¼šæå‰ç»“æŸå®ƒçš„æ—¶é—´ç‰‡ &lt;sup&gt;â‘ &lt;/sup&gt;ï¼Œæ‰€é€‰çš„çº¿ç¨‹å¾—ä»¥è¿è¡Œä¸€ä¸ªæ—¶é—´ç‰‡ã€‚ç„¶åï¼Œè°ƒç”¨ <code>Yield</code> çš„çº¿ç¨‹è¢«å†æ¬¡è°ƒåº¦ï¼Œå¼€å§‹ç”¨ä¸€ä¸ªå…¨æ–°çš„æ—¶é—´ç‰‡è¿è¡Œã€‚å¦‚æœ Windows å‘ç°æ²¡æœ‰å…¶ä»–çº¿ç¨‹å‡†å¤‡åœ¨å½“å‰å¤„ç†å™¨ä¸Šè¿è¡Œï¼Œ <code>Yield</code> å°±ä¼šè¿”å› <code>false</code> ï¼Œè°ƒç”¨ <code>Yield</code> çš„çº¿ç¨‹ç»§ç»­è¿è¡Œå®ƒçš„æ—¶é—´ç‰‡ã€‚</p><p><code>Yield</code> æ–¹æ³•æ—¨åœ¨ä½¿ â€œé¥¥é¥¿â€ çŠ¶æ€çš„ã€å…·æœ‰ç›¸ç­‰æˆ–æ›´ä½ä¼˜å…ˆçº§çš„çº¿ç¨‹æœ‰æœºä¼šè¿è¡Œã€‚å¦‚æœä¸€ä¸ªçº¿ç¨‹å¸Œæœ›è·å¾—å½“å‰å¦ä¸€ä¸ªçº¿ç¨‹æ‹¥æœ‰çš„èµ„æºï¼Œå°±è°ƒç”¨è¿™ä¸ªæ–¹æ³•ã€‚å¦‚æœè¿æ°”å¥½ï¼ŒWindows ä¼šè°ƒåº¦å½“å‰æ‹¥æœ‰èµ„æºçš„çº¿ç¨‹ï¼Œè€Œé‚£ä¸ªçº¿ç¨‹ä¼šè®©å‡ºèµ„æºã€‚ç„¶åï¼Œå½“è°ƒç”¨ <code>Yield</code> çš„çº¿ç¨‹å†æ¬¡è¿è¡Œæ—¶å°±ä¼šæ‹¿åˆ°èµ„æºã€‚</p><p>è°ƒç”¨ <code>Yield</code> çš„æ•ˆæœä»‹äºè°ƒç”¨ <code>Thread.Sleep(0)</code> å’Œ <code>Thread.Sleep(1)</code> ä¹‹é—´ã€‚ <code>Thread.Sleep(0)</code> ä¸å…è®¸è¾ƒä½ä¼˜å…ˆçº§çš„çº¿ç¨‹è¿è¡Œï¼Œè€Œ <code>Thread.Sleep(1)</code> æ€»æ˜¯å¼ºè¿«è¿›è¡Œä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œè€Œç”±äºå†…éƒ¨ç³»ç»Ÿè®¡æ—¶å™¨çš„è§£æåº¦çš„é—®é¢˜ï¼Œ Windows æ€»æ˜¯å¼ºè¿«çº¿ç¨‹ç¡çœ è¶…è¿‡ 1 æ¯«ç§’çš„æ—¶é—´ã€‚</p><p>äº‹å®ä¸Šï¼Œè¶…çº¿ç¨‹ CPU ä¸€æ¬¡åªå…è®¸ä¸€ä¸ªçº¿ç¨‹è¿è¡Œã€‚æ‰€ä»¥ï¼Œåœ¨è¿™äº› CPU ä¸Šæ‰§è¡Œ â€œè‡ªæ—‹â€ å¾ªç¯æ—¶ï¼Œéœ€è¦å¼ºè¿«å½“å‰çº¿ç¨‹æš‚åœï¼Œä½¿ CPU æœ‰æœºä¼šåˆ‡æ¢åˆ°å¦ä¸€ä¸ªçº¿ç¨‹å¹¶å…è®¸å®ƒè¿è¡Œã€‚çº¿ç¨‹å¯è°ƒç”¨ <code>Thread</code> çš„ <code>SpinWait</code> æ–¹æ³•å¼ºè¿«å®ƒè‡ªèº«æš‚åœï¼Œå…è®¸è¶…çº¿ç¨‹ CPU åˆ‡æ¢åˆ°å¦ä¸€çº¿ç¨‹ï¼š</p><pre><code class="language-C#">public static void SpinWait(Int32 iterations);
</code></pre><p>è°ƒç”¨è¿™ä¸ªæ–¹æ³•å®é™…ä¼šæ‰§è¡Œä¸€ä¸ªç‰¹æ®Šçš„ CPU æŒ‡ä»¤ï¼›å®ƒä¸å‘Šè¯‰ Windows åšä»»ä½•äº‹æƒ… (å› ä¸º Windows å·²ç»è®¤ä¸ºå®ƒåœ¨ CPU ä¸Šè°ƒåº¦äº†ä¸¤ä¸ªçº¿ç¨‹)ã€‚åœ¨éè¶…çº¿ç¨‹ CPU ä¸Šï¼Œè¿™ä¸ªç‰¹æ®Š CPU æŒ‡ä»¤ä¼šè¢«å¿½ç•¥ã€‚</p><p>è¦æ›´å¤šåœ°äº†è§£è¿™äº›æ–¹æ³•ï¼Œè¯·å‚è§å®ƒä»¬çš„ Win32 ç­‰ä»·å‡½æ•°ï¼š <code>Sleep</code> ï¼Œ <code>SwitchToThread</code> å’Œ <code>YieldProcessor</code> ã€‚å¦å¤–ï¼Œè¦æƒ³è¿›ä¸€æ­¥äº†è§£å¦‚ä½•è°ƒæ•´ç³»ç»Ÿè®¡æ—¶å™¨çš„è§£æåº¦ï¼Œè¯·å‚è€ƒ Win32 <code>timeBeginPeriod</code> å’Œ <code>timeEndPeriod</code> å‡½æ•°ã€‚</p><blockquote><p>The FCL also includes a System.Threading.SpinLock structure that is similar to my SimpleSpinLock class shown earlier, except that it uses the SpinWait structure to improve performance. The SpinLock structure also offers timeout support. By the way, it is interesting to note that my SimpleSpinLock and the FCLâ€™s SpinLock are both value types. This means that they are lightweight, memory-friendly objects. A SpinLock is a good choice if you need to associate a lock with each item in a collection, for example. However, you must make sure that you do not pass SpinLock instances around, because they are copied and you will lose any and all synchronization. And although you can define instance SpinLock fields, do not mark the field as readonly, because its internal state must change as the lock is manipulated.</p></blockquote><h3 id="the-interlocked-anything-pattern"><a class="anchor" href="#the-interlocked-anything-pattern">#</a> The Interlocked Anything Pattern</h3><blockquote><p>Many people look at the Interlocked methods and wonder why Microsoft doesn't create a richer set of interlocked methods that can be used in a wider range of scenarios. For example, it would be nice if the Interlocked class offered Multiply, Divide, Minimum, Maximum, And, Or, Xor, and a bunch of other methods. Although the Interlocked class doesnâ€™t offer these methods, there is a well-known pattern that allows you to perform any operation on an Int32 in an atomic way by using Interlocked.CompareExchange. In fact, because Interlocked.CompareExchange has additional overloads that operate on Int64, Single, Double, Object, and a generic reference type, this pattern will actually work for all these types, too.</p></blockquote><blockquote><p>This pattern is similar to optimistic concurrency patterns used for modifying database records. Here is an example of the pattern that is being used to create an atomic Maximum method.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">Maximum</span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token class-name">Int32</span> target<span class="token punctuation">,</span> <span class="token class-name">Int32</span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Int32</span> currentVal <span class="token operator">=</span> target<span class="token punctuation">,</span> startVal<span class="token punctuation">,</span> desiredVal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// Don't access target in the loop except in an attempt </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// to change it because another thread may be touching it </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">do</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Record this iteration's starting value</span></pre></td></tr><tr><td data-num="7"></td><td><pre> startVal <span class="token operator">=</span> currentVal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Calculate the desired value in terms of startVal and value</span></pre></td></tr><tr><td data-num="9"></td><td><pre> desiredVal <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">Max</span><span class="token punctuation">(</span>startVal<span class="token punctuation">,</span> <span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// NOTE: the thread could be preempted here!</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// if (target == startVal) target = desiredVal</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// Value prior to potential change is returned</span></pre></td></tr><tr><td data-num="13"></td><td><pre> currentVal <span class="token operator">=</span> Interlocked<span class="token punctuation">.</span><span class="token function">CompareExchange</span><span class="token punctuation">(</span><span class="token keyword">ref</span> target<span class="token punctuation">,</span> desiredVal<span class="token punctuation">,</span> startVal<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token comment">// If the starting value changed during this iteration, repeat </span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>startVal <span class="token operator">!=</span> currentVal<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token comment">// Return the maximum value when this thread tried to set it</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token keyword">return</span> desiredVal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Now let me explain exactly what is going on here. Upon entering the method, currentVal is initialized to the value in target at the moment the method starts executing. Then, inside the loop, startVal is initialized to this same value. Using startVal, you can perform any operation you want. This operation can be extremely complex, consisting of thousands of lines of code. But, ultimately, you must end up with a result that is placed into desiredVal. In my example, I simply determine whether startVal or value contains the larger value.</p></blockquote><blockquote><p>Now, while this operation is running, another thread could change the value in target. It is unlikely that this will happen, but it is possible. If this does happen, then the value in desiredVal is based off an old value in startVal, not the current value in target, and therefore, we should not change the value in target. To ensure that the value in target is changed to desiredVal if no thread has changed target behind our threadâ€™s back, we use Interlocked.CompareExchange. This method checks whether the value in target matches the value in startVal (which identifies the value that we thought was in target before starting to perform the operation). If the value in target didnâ€™t change, then CompareExchange changes it to the new value in desiredVal. If the value in target did change, then CompareExchange does not alter the value in target at all.</p></blockquote><blockquote><p>CompareExchange returns the value that is in target at the time when CompareExchange is called, which I then place in currentVal. Then, a check is made comparing startVal with the new value in currentVal. If these values are the same, then a thread did not change target behind our threadâ€™s back, target now contains the value in desiredVal, the while loop does not loop around, and the method returns. If startVal is not equal to currentVal, then a thread did change the value in target behind our threadâ€™s back, target did not get changed to our value in desiredVal, and the while loop will loop around and try the operation again, this time using the new value in currentVal that reflects the other threadâ€™s change.</p></blockquote><blockquote><p>Personally, I have used this pattern in a lot of my own code and, in fact, I made a generic method, Morph, which encapsulates this pattern.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">delegate</span> <span class="token return-type class-name">Int32</span> <span class="token generic-method"><span class="token function">Morpher</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>TResult<span class="token punctuation">,</span> TArgument<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">Int32</span> startValue<span class="token punctuation">,</span> <span class="token class-name">TArgument</span> argument<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">out</span> <span class="token class-name">TResult</span> morphResult<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name">TResult</span> <span class="token generic-method"><span class="token function">Morph</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>TResult<span class="token punctuation">,</span> TArgument<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token class-name">Int32</span> target<span class="token punctuation">,</span> <span class="token class-name">TArgument</span> argument<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">Morpher<span class="token punctuation">&lt;</span>TResult<span class="token punctuation">,</span> TArgument<span class="token punctuation">></span></span> morpher<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token class-name">TResult</span> morphResult<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token class-name">Int32</span> currentVal <span class="token operator">=</span> target<span class="token punctuation">,</span> startVal<span class="token punctuation">,</span> desiredVal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">do</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> startVal <span class="token operator">=</span> currentVal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> desiredVal <span class="token operator">=</span> <span class="token function">morpher</span><span class="token punctuation">(</span>startVal<span class="token punctuation">,</span> argument<span class="token punctuation">,</span> <span class="token keyword">out</span> morphResult<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> currentVal <span class="token operator">=</span> Interlocked<span class="token punctuation">.</span><span class="token function">CompareExchange</span><span class="token punctuation">(</span><span class="token keyword">ref</span> target<span class="token punctuation">,</span> desiredVal<span class="token punctuation">,</span> startVal<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>startVal <span class="token operator">!=</span> currentVal<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">return</span> morphResult<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>ğŸ’¡å°ç»“ï¼šCLR ä¿è¯å¯¹ä»¥ä¸‹æ•°æ®ç±»å‹çš„å˜é‡çš„è¯»å†™æ˜¯åŸå­æ€§çš„ï¼š <code>Boolean</code> ï¼Œ <code>Char</code> ï¼Œ <code>(S)Byte</code> ï¼Œ <code>(U)Int16</code> ï¼Œ <code>(U)Int32</code> ï¼Œ <code>(U)IntPtr</code> ï¼Œ <code>Single</code> ä»¥åŠå¼•ç”¨ç±»å‹ã€‚è¿™æ„å‘³ç€å˜é‡ä¸­çš„æ‰€æœ‰å­—èŠ‚éƒ½ä¸€æ¬¡æ€§è¯»å–æˆ–å†™å…¥ã€‚è™½ç„¶å¯¹å˜é‡çš„åŸå­è®¿é—®å¯ä¿è¯è¯»å–æˆ–å†™å…¥æ“ä½œä¸€æ¬¡æ€§å®Œæˆï¼Œä½†ç”±äºç¼–è¯‘å™¨å’Œ CPU çš„ä¼˜åŒ–ï¼Œä¸ä¿è¯æ“ä½œ <strong>ä»€ä¹ˆæ—¶å€™</strong> å‘ç”Ÿã€‚åŸºå…ƒç”¨æˆ·æ¨¡å¼æ„é€ ç”¨äºè§„åˆ’å¥½è¿™äº›åŸå­æ€§è¯»å– / å†™å…¥ æ“ä½œçš„æ—¶é—´ã€‚æ­¤å¤–ï¼Œè¿™äº›æ„é€ è¿˜å¯å¼ºåˆ¶å¯¹ <code>(U)Int64</code> å’Œ <code>Double</code> ç±»å‹çš„å˜é‡è¿›è¡ŒåŸå­æ€§çš„ã€è§„åˆ’å¥½äº†æ—¶é—´çš„è®¿é—®ã€‚æœ‰ä¸¤ç§åŸºå…ƒç”¨æˆ·æ¨¡å¼çº¿ç¨‹åŒæ­¥æ„é€ ï¼š<strong>æ˜“å˜æ„é€  (volatile construct)</strong> åœ¨ç‰¹å®šçš„æ—¶é—´ï¼Œå®ƒåœ¨åŒ…å«ä¸€ä¸ªç®€å•æ•°æ®ç±»å‹çš„å˜é‡ä¸Šæ‰§è¡ŒåŸå­æ€§çš„è¯»æˆ–å†™æ“ä½œï¼›<strong>äº’é”æ„é€  (interlocked construct)</strong> åœ¨ç‰¹å®šçš„æ—¶é—´ï¼Œå®ƒåœ¨åŒ…å«ä¸€ä¸ªç®€å•æ•°æ®ç±»å‹çš„å˜é‡ä¸Šæ‰§è¡ŒåŸå­æ€§çš„è¯»å’Œå†™æ“ä½œã€‚C# ç¼–è¯‘å™¨å°†ä½ çš„ C# æ„é€ è½¬æ¢æˆä¸­é—´è¯­è¨€ (IL)ã€‚ç„¶åï¼ŒJIT å°† IL è½¬æ¢æˆæœ¬æœº CPU æŒ‡ä»¤ï¼Œç„¶åç”± CPU äº²è‡ªå¤„ç†è¿™äº›æŒ‡ä»¤ã€‚æ­¤å¤–ï¼ŒC# ç¼–è¯‘å™¨ã€JIT ç¼–è¯‘å™¨ã€ç”šè‡³ CPU æœ¬èº«éƒ½å¯èƒ½ä¼˜åŒ–ä½ çš„ä»£ç ã€‚C# ç¼–è¯‘å™¨ã€JIT ç¼–è¯‘å™¨å’Œ CPU å¯¹ä»£ç è¿›è¡Œä¼˜åŒ–æ—¶ï¼Œå®ƒä»¬ä¿è¯æˆ‘ä»¬çš„æ„å›¾ä¼šå¾—åˆ°ä¿ç•™ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œä»å•çº¿ç¨‹çš„è§’åº¦çœ‹ï¼Œæ–¹æ³•ä¼šåšæˆ‘ä»¬å¸Œæœ›å®ƒåšçš„äº‹æƒ…ï¼Œè™½ç„¶åšçš„æ–¹å¼å¯èƒ½æœ‰åˆ«äºæˆ‘ä»¬åœ¨æºä»£ç ä¸­æè¿°çš„æ–¹å¼ã€‚ä½†ä»å¤šçº¿ç¨‹çš„è§’åº¦çœ‹ï¼Œæˆ‘ä»¬çš„æ„å›¾å¹¶ä¸ä¸€å®šèƒ½å¾—åˆ°ä¿ç•™ã€‚x86 JIT ç¼–è¯‘å™¨æ¯” x64 ç¼–è¯‘å™¨æ›´æˆç†Ÿï¼Œæ‰€ä»¥å®ƒåœ¨æ‰§è¡Œä¼˜åŒ–çš„æ—¶å€™æ›´å¤§èƒ†ã€‚å…¶ä»– JIT ç¼–è¯‘å™¨ä¸æ‰§è¡Œè¿™ä¸ªç‰¹å®šçš„ä¼˜åŒ–ï¼Œæ‰€ä»¥ç¨‹åºä¼šåƒé¢„æœŸçš„é‚£æ ·æ­£å¸¸è¿è¡Œåˆ°ç»“æŸã€‚è¿™ä½¿æˆ‘ä»¬æ³¨æ„å¦ä¸€ä¸ªæœ‰è¶£çš„åœ°æ–¹ï¼›ç¨‹åºæ˜¯å¦å¦‚é¢„æƒ³çš„é‚£æ ·å·¥ä½œè¦å–å†³äºå¤§é‡å› ç´ ï¼Œæ¯”å¦‚ä½¿ç”¨çš„æ˜¯ç¼–è¯‘å™¨çš„ä»€ä¹ˆç‰ˆæœ¬å’Œä»€ä¹ˆå¼€å…³ï¼Œä½¿ç”¨çš„æ˜¯å“ªä¸ª JIT ç¼–è¯‘å™¨ï¼Œä»¥åŠä»£ç åœ¨ä»€ä¹ˆ CPU ä¸Šè¿è¡Œç­‰ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œè¦çœ‹åˆ°ä¸Šé¢è¿™ä¸ªç¨‹åºè¿›å…¥æ­»å¾ªç¯ï¼Œä¸€å®šä¸èƒ½åœ¨è°ƒè¯•å™¨ä¸­è¿è¡Œå®ƒï¼Œå› ä¸ºè°ƒè¯•å™¨ä¼šé€ æˆ JIT ç¼–è¯‘å™¨ç”Ÿæˆæœªä¼˜åŒ–çš„ä»£ç  (ç›®çš„æ˜¯æ–¹ä¾¿ä½ è¿›è¡Œå•æ­¥è°ƒè¯•)ã€‚é™æ€ <code>System.Threading.Volatile</code> ç±»æä¾›äº†ä¸¤ä¸ªé™æ€æ–¹æ³•ï¼Œè¿™äº›æ–¹æ³•æ¯”è¾ƒç‰¹æ®Šã€‚å®ƒä»¬äº‹å®ä¸Šä¼šç¦æ­¢ C# ç¼–è¯‘å™¨ã€JIT ç¼–è¯‘å™¨å’Œ CPU å¹³å¸¸æ‰§è¡Œçš„ä¸€äº›ä¼˜åŒ–ã€‚ <code>Volatile.Write</code> æ–¹æ³•å¼ºè¿« <code>location</code> ä¸­çš„å€¼åœ¨è°ƒç”¨æ—¶å†™å…¥ã€‚æ­¤å¤–ï¼ŒæŒ‰ç…§ç¼–ç é¡ºåºï¼Œä¹‹å‰çš„åŠ è½½å’Œå­˜å‚¨æ“ä½œå¿…é¡»åœ¨è°ƒç”¨ <code>Volatile.Write</code> <em>ä¹‹å‰</em>å‘ç”Ÿã€‚ <code>Volatile.Write</code> æ–¹æ³•å¼ºè¿« <code>location</code> ä¸­çš„å€¼åœ¨è°ƒç”¨æ—¶è¯»å–ã€‚æ­¤å¤–ï¼ŒæŒ‰ç…§ç¼–ç é¡ºåºï¼Œä¹‹åçš„åŠ è½½å’Œå­˜å‚¨æ“ä½œå¿…é¡»åœ¨è°ƒç”¨ <code>Volatile.Read</code> <em>ä¹‹å</em>å‘ç”Ÿã€‚ä¸ºäº†ç®€åŒ–ç¼–ç¨‹ï¼ŒC# ç¼–è¯‘å™¨æä¾›äº† <code>volatile</code> å…³é”®å­—ï¼Œå®ƒå¯åº”ç”¨äºä»¥ä¸‹ä»»ä½•ç±»å‹çš„é™æ€æˆ–å®ä¾‹å­—æ®µï¼š <code>Boolean</code> ï¼Œ <code>(S)Byte</code> ï¼Œ <code>(U)Int16</code> ï¼Œ <code>(U)Int32</code> , <code>(U)IntPtr</code> ï¼Œ <code>Single</code> å’Œ <code>Char</code> ï¼Œè¿˜å¯å°† <code>volatile</code> å…³é”®å­—åº”ç”¨äºå¼•ç”¨ç±»å‹çš„å­—æ®µï¼Œä»¥åŠåŸºç¡€ç±»å‹ä¸º <code>(S)Byte</code> ï¼Œ <code>(U)Int16</code> æˆ– <code>(U)Int32</code> çš„ä»»ä½•æšä¸¾å­—æ®µã€‚JIT ç¼–è¯‘å™¨ç¡®ä¿å¯¹æ˜“å˜å­—æ®µçš„æ‰€æœ‰è®¿é—®éƒ½æ˜¯ä»¥æ˜“å˜è¯»å–æˆ–å†™å…¥çš„æ–¹å¼æ‰§è¡Œï¼Œä¸å¿…æ˜¾ç¤ºè°ƒç”¨ <code>Volatile</code> çš„é™æ€ <code>Read</code> æˆ– <code>Write</code> æ–¹æ³•ã€‚å¦å¤–ï¼Œ <code>volatile</code> å…³é”®å­—å‘Šè¯‰ C# å’Œ JIT ç¼–è¯‘å™¨ä¸å°†å­—æ®µç¼“å­˜åˆ° CPU çš„å¯„å­˜å™¨ä¸­ï¼Œç¡®ä¿å­—æ®µçš„æ‰€æœ‰è¯»å†™æ“ä½œéƒ½åœ¨ RAM ä¸­è¿›è¡Œã€‚ <code>Interlocked</code> ç±»ä¸­çš„æ¯ä¸ªæ–¹æ³•éƒ½æ‰§è¡Œä¸€æ¬¡åŸå­è¯»å†™ä»¥åŠå†™å…¥æ“ä½œã€‚æ­¤å¤–ï¼Œ <code>Interlocked</code> çš„æ‰€æœ‰æ–¹æ³•éƒ½å»ºç«‹äº†å®Œæ•´çš„å†…å­˜æ …æ  (memory fence)ã€‚æ¢è¨€ä¹‹ï¼Œè°ƒç”¨æŸä¸ª <code>Interlocked</code> æ–¹æ³•ä¹‹å‰çš„ä»»ä½•å˜é‡å†™å…¥éƒ½åœ¨è¿™ä¸ª <code>Interlocked</code> æ–¹æ³•è°ƒç”¨ä¹‹å‰æ‰§è¡Œï¼›è€Œè¿™ä¸ªè°ƒç”¨ä¹‹åçš„ä»»ä½•å˜é‡è¯»å–çš„éƒ½åœ¨è¿™ä¸ªè°ƒç”¨ä¹‹åè¯»å–ã€‚ <code>Interlocked</code> çš„æ–¹æ³•å¾ˆå¥½ç”¨ï¼Œä½†ä¸»è¦ç”¨äºæ“ä½œ <code>Int32</code> å€¼ã€‚å¯ä»¥ä½¿ç”¨ <code>Interlocked</code> çš„æ–¹æ³•æ„é€ ä¸€ä¸ªçº¿ç¨‹åŒæ­¥å—æ¥å®ç°ä¸€ä¸ªç®€å•çš„è‡ªæ—‹é”ã€‚è¿™ç§é”æœ€å¤§çš„é—®é¢˜åœ¨äºï¼Œåœ¨å­˜åœ¨å¯¹é”çš„ç«äº‰çš„å‰æä¸‹ï¼Œä¼šé€ æˆçº¿ç¨‹ â€œè‡ªæ—‹â€ã€‚è¿™ä¸ª â€œè‡ªæ—‹â€ ä¼šæµªè´¹å®è´µçš„ CPU æ—¶é—´ï¼Œé˜»æ­¢ CPU åšå…¶ä»–æ›´æœ‰ç”¨çš„å·¥ä½œã€‚å› æ­¤ï¼Œè‡ªæ—‹é”åªåº”è¯¥ç”¨äºä¿æŠ¤é‚£äº›ä¼šæ‰§è¡Œå¾—éå¸¸å¿«çš„ä»£ç åŒºåŸŸã€‚è‡ªæ—‹é”ä¸€èˆ¬ä¸è¦åœ¨å• CPU æœºå™¨ä¸Šä½¿ç”¨ï¼Œå› ä¸ºåœ¨è¿™ç§æœºå™¨ä¸Šï¼Œä¸€æ–¹é¢æ˜¯å¸Œæœ›è·å¾—é”çš„çº¿ç¨‹è‡ªæ—‹ï¼Œä¸€æ–¹é¢æ˜¯å æœ‰é”çš„çº¿ç¨‹ä¸èƒ½å¿«é€Ÿé‡Šæ”¾é”ã€‚å¦‚æœå æœ‰é”çš„çº¿ç¨‹çš„ä¼˜å…ˆçº§ä½äºæƒ³è¦è·å–é”çš„çº¿ç¨‹ (è‡ªæ—‹çº¿ç¨‹)ï¼Œå±€é¢è¿˜ä¼šå˜å¾—ç³Ÿç³•ï¼Œå› ä¸ºå æœ‰æ‰€å¾—çº¿ç¨‹å¯èƒ½æ ¹æœ¬æ²¡æœ‰æœºä¼šè¿è¡Œ ã€‚è¿™ä¼šé€ æˆ â€œæ´»é”â€ æƒ…å½¢ã€‚Windows æœ‰æ—¶ä¼šçŸ­æ—¶é—´åœ°åŠ¨æ€æå‡ä¸€ä¸ªçº¿ç¨‹çš„ä¼˜å…ˆçº§ã€‚å› æ­¤ï¼Œå¯¹äºæ­£åœ¨ä½¿ç”¨è‡ªæ—‹é”çš„çº¿ç¨‹ï¼Œåº”è¯¥ç¦æ­¢åƒè¿™æ ·çš„ä¼˜å…ˆçº§æå‡ã€‚è¶…çº¿ç¨‹æœºå™¨åŒæ ·å­˜åœ¨è‡ªæ—‹é”çš„é—®é¢˜ã€‚ä¸ºäº†è§£å†³è¿™äº›é—®é¢˜ï¼Œè®¸å¤šè‡ªæ—‹é”å†…éƒ¨éƒ½æœ‰ä¸€äº›é¢å¤–çš„é€»è¾‘ï¼›æˆ‘å°†è¿™äº›é¢å¤–çš„é€»è¾‘ç§°ä¸º â€œé»‘ç§‘æŠ€â€(Black Magic)ã€‚è¿™é‡Œä¸æ‰“ç®—è¿‡å¤šè®²è§£å…¶ä¸­çš„ç»†èŠ‚ï¼Œå› ä¸ºéšç€è¶Šæ¥è¶Šå¤šçš„äººå¼€å§‹ç ”ç©¶é”åŠå…¶æ€§èƒ½ï¼Œè¿™äº›é€»è¾‘ä¹Ÿå¯èƒ½å‘ç”Ÿå˜åŒ–ã€‚FCL æä¾›äº†ä¸€ä¸ªåä¸º <code>System.Threading.SpinWait</code> çš„ç»“æ„ï¼Œå®ƒå°è£…äº†äººä»¬å…³äºè¿™ç§ â€œé»‘ç§‘æŠ€â€ çš„æœ€æ–°ç ”ç©¶æˆæœã€‚FCL è¿˜åŒ…å«äº†ä¸€ä¸ª <code>System.Threading.SpinLock</code> ç»“æ„ï¼Œå®ƒå’Œå‰é¢å±•ç¤ºçš„ <code>SimpleSpinLock</code> ç±»ç›¸ä¼¼ï¼Œåªæ˜¯ä½¿ç”¨äº† <code>SpinWait</code> ç»“æ„æ¥å¢å¼ºæ€§èƒ½ã€‚ <code>SpinLink</code> ç»“æ„è¿˜æä¾›äº†è¶…æ—¶æ”¯æŒã€‚å¾ˆæœ‰å™¨çš„ä¸€ç‚¹æ˜¯ï¼Œæˆ‘çš„ <code>SimpleSpinLock</code> å’Œ FCL çš„ <code>SpinLink</code> éƒ½æ˜¯å€¼ç±»å‹ã€‚è¿™æ„å‘³ç€å®ƒä»¬æ˜¯è½»é‡çº§çš„ã€å†…å­˜å‹å¥½çš„å¯¹è±¡ã€‚ä½†ä¸€å®šä¸è¦åˆ°åº•ä¼ é€’ <code>SpinLock</code> å®ä¾‹ï¼Œå¦åˆ™å®ƒä»¬ä¼šè¢«å¤åˆ¶ï¼Œè€Œä½ ä¼šå¤±å»æ‰€æœ‰åŒæ­¥ã€‚è™½ç„¶å¯ä»¥å®šä¹‰å®ä¾‹ <code>SpinLock</code> å­—æ®µï¼Œä½†ä¸è¦å°†å­—æ®µæ ‡è®°ä¸º <code>readonly</code> ï¼Œå› ä¸ºåœ¨æ“ä½œé”çš„æ—¶å€™ï¼Œå®ƒçš„å†…éƒ¨çŠ¶æ€å¿…é¡»æ”¹å˜ã€‚</p><h2 id="kernel-mode-constructs"><a class="anchor" href="#kernel-mode-constructs">#</a> Kernel-Mode Constructs</h2><blockquote><p>Windows offers several kernel-mode constructs for synchronizing threads. The kernel-mode constructs are much slower than the user-mode constructs. This is because they require coordination from the Windows operating system itself. Also, each method call on a kernel object causes the calling thread to transition from managed code to native user-mode code to native kernel-mode code and then return all the way back. These transitions require a lot of CPU time and, if performed frequently, can adversely affect the overall performance of your application.</p></blockquote><blockquote><p>However, the kernel-mode constructs offer some benefits over the primitive user-mode constructs, such as:</p><ul><li><p>When a kernel-mode construct detects contention on a resource, Windows blocks the losing thread so that it is not spinning on a CPU, wasting processor resources.</p></li><li><p>Kernel-mode constructs can synchronize native and managed threads with each other.</p></li><li><p>Kernel-mode constructs can synchronize threads running in different processes on the same machine.</p></li><li><p>Kernel-mode constructs can have security applied to them to prevent unauthorized accounts from accessing them.</p></li><li><p>A thread can block until all kernel-mode constructs in a set are available or until any one kernel-mode construct in a set has become available.</p></li><li><p>A thread can block on a kernel-mode construct specifying a timeout value; if the thread canâ€™t have access to the resource it wants in the specified amount of time, then the thread is unblocked and can perform other tasks.</p></li></ul></blockquote><blockquote><p>The two primitive kernel-mode thread synchronization constructs are events and semaphores. Other kernel-mode constructs, such as mutex, are built on top of the two primitive constructs. For more information about the Windows kernel-mode constructs, see the book, Windows via C/C++, Fifth Edition (Microsoft Press, 2007) by myself and Christophe Nasarre.</p></blockquote><blockquote><p>The System.Threading namespace offers an abstract base class called WaitHandle. The WaitHandle class is a simple class whose sole purpose is to wrap a Windows kernel object handle. The FCL provides several classes derived from WaitHandle. All classes are defined in the System.Threading namespace. The class hierarchy looks like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>WaitHandle</pre></td></tr><tr><td data-num="2"></td><td><pre> 	EventWaitHandle</pre></td></tr><tr><td data-num="3"></td><td><pre> 		AutoResetEvent</pre></td></tr><tr><td data-num="4"></td><td><pre> 		ManualResetEvent</pre></td></tr><tr><td data-num="5"></td><td><pre> 	Semaphore</pre></td></tr><tr><td data-num="6"></td><td><pre> 	Mutex</pre></td></tr></table></figure><blockquote><p>Internally, the WaitHandle base class has a SafeWaitHandle field that holds a Win32 kernel object handle. This field is initialized when a concrete WaitHandle-derived class is constructed. In addition, the WaitHandle class publicly exposes methods that are inherited by all the derived classes. Every method called on a kernel-mode construct represents a full memory fence. WaitHandleâ€™s interesting public methods are shown in the following code (some overloads for some methods are not shown).</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">WaitHandle</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">MarshalByRefObject</span><span class="token punctuation">,</span> <span class="token class-name">IDisposable</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// WaitOne internally calls the Win32 WaitForSingleObjectEx function. </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token return-type class-name">Boolean</span> <span class="token function">WaitOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token return-type class-name">Boolean</span> <span class="token function">WaitOne</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> millisecondsTimeout<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token return-type class-name">Boolean</span> <span class="token function">WaitOne</span><span class="token punctuation">(</span><span class="token class-name">TimeSpan</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// WaitAll internally calls the Win32 WaitForMultipleObjectsEx function </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Boolean</span> <span class="token function">WaitAll</span><span class="token punctuation">(</span><span class="token class-name">WaitHandle<span class="token punctuation">[</span><span class="token punctuation">]</span></span> waitHandles<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Boolean</span> <span class="token function">WaitAll</span><span class="token punctuation">(</span><span class="token class-name">WaitHandle<span class="token punctuation">[</span><span class="token punctuation">]</span></span> waitHandles<span class="token punctuation">,</span> <span class="token class-name">Int32</span> millisecondsTimeout<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Boolean</span> <span class="token function">WaitAll</span><span class="token punctuation">(</span><span class="token class-name">WaitHandle<span class="token punctuation">[</span><span class="token punctuation">]</span></span> waitHandles<span class="token punctuation">,</span> <span class="token class-name">TimeSpan</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// WaitAny internally calls the Win32 WaitForMultipleObjectsEx function </span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">WaitAny</span><span class="token punctuation">(</span><span class="token class-name">WaitHandle<span class="token punctuation">[</span><span class="token punctuation">]</span></span> waitHandles<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">WaitAny</span><span class="token punctuation">(</span><span class="token class-name">WaitHandle<span class="token punctuation">[</span><span class="token punctuation">]</span></span> waitHandles<span class="token punctuation">,</span> <span class="token class-name">Int32</span> millisecondsTimeout<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">public</span> </pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">WaitAny</span><span class="token punctuation">(</span><span class="token class-name">WaitHandle<span class="token punctuation">[</span><span class="token punctuation">]</span></span> waitHandles<span class="token punctuation">,</span> <span class="token class-name">TimeSpan</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">const</span> <span class="token class-name">Int32</span> WaitTimeout <span class="token operator">=</span> <span class="token number">258</span><span class="token punctuation">;</span> <span class="token comment">// Returned from WaitAny if a timeout occurs</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// Dispose internally calls the Win32 CloseHandle function â€“ DONâ€™T CALL THIS.</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>There are a few things to note about these methods:</p><ul><li><p>You call WaitHandleâ€™s WaitOne method to have the calling thread wait for the underlying kernel object to become signaled. Internally, this method calls the Win32 WaitForSingleObjectEx function. The returned Boolean is true if the object became signaled or false if a timeout occurs.</p></li><li><p>You call WaitHandleâ€™s static WaitAll method to have the calling thread wait for all the kernel objects specified in the WaitHandle[] to become signaled. The returned Boolean is true if all of the objects became signaled or false if a timeout occurs. Internally, this method calls the Win32 WaitForMultipleObjectsEx function, passing TRUE for the bWaitAll parameter.</p></li><li><p>You call WaitHandleâ€™s static WaitAny method to have the calling thread wait for any one of the kernel objects specified in the WaitHandle[] to become signaled. The returned Int32 is the index of the array element corresponding to the kernel object that became signaled, or WaitHandle.WaitTimeout if no object became signaled while waiting. Internally, this method calls the Win32 WaitForMultipleObjectsEx function, passing FALSE for the bWaitAll parameter.</p></li><li><p>The array that you pass to the WaitAny and WaitAll methods must contain no more than 64 elements or else the methods throw a System.NotSupportedException.</p></li><li><p>You call WaitHandleâ€™s Dispose method to close the underlying kernel object handle. Internally, these methods call the Win32 CloseHandle function. You can only call Dispose explicitly in your code if you know for a fact that no other threads are using the kernel object. This puts a lot of burden on you as you write your code and test it. So, I would strongly discourage you from calling Dispose; instead, just let the garbage collector (GC) do the cleanup. The GC knows when no threads are using the object anymore, and then it will get rid of it. In a way, the GC is doing thread synchronization for you automatically!</p></li></ul></blockquote><p>ğŸ’¡æ³¨æ„ï¼šåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå½“ä¸€ä¸ª COM å•çº¿ç¨‹å¥—é—´çº¿ç¨‹é˜»å¡æ—¶ï¼Œçº¿ç¨‹å¯èƒ½åœ¨å†…éƒ¨é†’æ¥ä»¥ pump æ¶ˆæ¯ã€‚ä¾‹å¦‚ï¼Œé˜»å¡çš„çº¿ç¨‹ä¼šé†’æ¥å¤„ç†å‘è‡ªå¦ä¸€ä¸ªçº¿ç¨‹çš„ Windows æ¶ˆæ¯ã€‚è¿™ä¸ªè®¾è®¡æ˜¯ä¸ºäº†æ”¯æŒ COM äº’æ“ä½œæ€§ã€‚å¯¹äºå¤§å¤šæ•°åº”ç”¨ç¨‹åºï¼Œè¿™éƒ½ä¸æ˜¯ä¸€ä¸ªé—®é¢˜ â€”â€”â€”â€” äº‹å®ä¸Šï¼Œåè€Œæ˜¯ä¸€ä»¶å¥½äº‹ã€‚ç„¶è€Œï¼Œå¦‚æœä½ çš„ä»£ç åœ¨å¤„ç†æ¶ˆæ¯æœŸé—´è·å¾—å¦ä¸€ä¸ªçº¿ç¨‹åŒæ­¥é”ï¼Œå°±å¯èƒ½å‘ç”Ÿæ­»é”ã€‚å¦‚ç¬¬ 30 ç« æ‰€è¿°ï¼Œæ‰€æœ‰æ··åˆé”éƒ½åœ¨å†…éƒ¨è°ƒç”¨è¿™äº›æ–¹æ³•ã€‚æ‰€ä»¥ï¼Œä½¿ç”¨æ··åˆé”å­˜åœ¨ç›¸åŒçš„åˆ©ä¸å¼Šã€‚</p><blockquote><p>The versions of the WaitOne and WaitAll that do not accept a timeout parameter should be prototyped as having a void return type, not Boolean. The reason is because these methods will return only true because the implied timeout is infinite (System.Threading.Timeout.Infinite). When you call any of these methods, you do not need to check their return value.</p></blockquote><blockquote><p>As already mentioned, the AutoResetEvent, ManualResetEvent, Semaphore, and Mutex classes are all derived from WaitHandle, so they inherit WaitHandleâ€™s methods and their behavior. However, these classes introduce additional methods of their own, and Iâ€™ll address those now.</p></blockquote><blockquote><p>First, the constructors for all of these classes internally call the Win32 CreateEvent (passing FALSE for the bManualReset parameter) or CreateEvent (passing TRUE for the bManualReset parameter), CreateSemaphore, or CreateMutex functions. The handle value returned from all of these calls is saved in a private SafeWaitHandle field defined inside the WaitHandle base class.</p></blockquote><blockquote><p>Second, the EventWaitHandle, Semaphore, and Mutex classes all offer static OpenExisting methods, which internally call the Win32 OpenEvent, OpenSemaphore, or OpenMutex functions, passing a String argument that identifies an existing named kernel object. The handle value returned from all of these functions is saved in a newly constructed object that is returned from the OpenExisting method. If no kernel object exists with the specified name, a WaitHandleCannotBeOpenedException is thrown.</p></blockquote><blockquote><p>A common usage of the kernel-mode constructs is to create the kind of application that allows only one instance of itself to execute at any given time. Examples of single-instance applications are Microsoft Outlook, Windows Live Messenger, Windows Media Player, and Windows Media Center. Here is how to implement a single-instance application.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Threading</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token class-name">Boolean</span> createdNew<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// Try to create a kernel object with the specified name</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"SomeUniqueStringIdentifyingMyApp"</span><span class="token punctuation">,</span> <span class="token keyword">out</span> createdNew<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>createdNew<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// This thread created the kernel object so no other instance of this</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// application must be running. Run the rest of the application here...</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token comment">// This thread opened an existing kernel object with the same string name;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token comment">// another instance of this application must be running now.</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// There is nothing to do in here, let's just return from Main to terminate</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token comment">// this second instance of the application.</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In this code, I am using a Semaphore, but it would work just as well if I had used an EventWaitHandle or a Mutex because Iâ€™m not actually using the thread synchronization behavior that the object offers. However, I am taking advantage of some thread synchronization behavior that the kernel offers when creating any kind of kernel object. Let me explain how the preceding code works. Letâ€™s say that two instances of this process are started at exactly the same time. Each process will have its own thread, and both threads will attempt to create a Semaphore with the same string name (â€œSomeUniqueStringIdentifyingMyApp,â€ in my example). The Windows kernel ensures that only one thread actually creates a kernel object with the specified name; the thread that created the object will have its createdNew variable set to true.</p></blockquote><blockquote><p>For the second thread, Windows will see that a kernel object with the specified name already exists; the second thread does not get to create another kernel object with the same name, although if this thread continues to run, it can access the same kernel object as the first processâ€™s thread. This is how threads in different processes can communicate with each other via a single kernel object. However, in this example, the second processâ€™s thread sees that its createdNew variable is set to false. This thread now knows that another instance of this process is running, and the second instance of the process exits immediately.</p></blockquote><h3 id="event-constructs"><a class="anchor" href="#event-constructs">#</a> Event Constructs</h3><blockquote><p>Events are simply Boolean variables maintained by the kernel. A thread waiting on an event blocks when the event is false and unblocks when the event is true. There are two kinds of events. When an auto-reset event is true, it wakes up just one blocked thread, because the kernel automatically resets the event back to false after unblocking the first thread. When a manual-reset event is true, it unblocks all threads waiting for it because the kernel does not automatically reset the event back to false; your code must manually reset the event back to false. The classes related to events look like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EventWaitHandle</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">WaitHandle</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Boolean</span> <span class="token function">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Sets Boolean to true; always returns true</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Boolean</span> <span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Sets Boolean to false; always returns true</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">AutoResetEvent</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">EventWaitHandle</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token function">AutoResetEvent</span><span class="token punctuation">(</span><span class="token class-name">Boolean</span> initialState<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">ManualResetEvent</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">EventWaitHandle</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">public</span> <span class="token function">ManualResetEvent</span><span class="token punctuation">(</span><span class="token class-name">Boolean</span> initialState<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Using an auto-reset event, we can easily create a thread synchronization lock whose behavior is similar to the SimpleSpinLock class I showed earlier.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SimpleWaitLock</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IDisposable</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">AutoResetEvent</span> m_available<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token function">SimpleWaitLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> m_available <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">AutoResetEvent</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Initially free</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Enter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// Block in kernel until resource available</span></pre></td></tr><tr><td data-num="8"></td><td><pre> m_available<span class="token punctuation">.</span><span class="token function">WaitOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Leave</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// Let another thread access the resource</span></pre></td></tr><tr><td data-num="12"></td><td><pre> m_available<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> m_available<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>You would use this SimpleWaitLock exactly the same way that youâ€™d use the SimpleSpinLock. In fact, the external behavior is exactly the same; however, the performance of the two locks is radically different. When there is no contention on the lock, the SimpleWaitLock is much slower than the SimpleSpinLock, because every call to SimpleWaitLockâ€™s Enter and Leave methods forces the calling thread to transition from managed code to the kernel and backâ€”which is bad. But when there is contention, the losing thread is blocked by the kernel and is not spinning and wasting CPU cyclesâ€”which is good. Note also that constructing the AutoResetEvent object and calling Dispose on it also causes managed to kernel transitions, affecting performance negatively. These calls usually happen rarely, so they are not something to be too concerned about.</p></blockquote><blockquote><p>To give you a better feel for the performance differences, I wrote the following code.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">const</span> <span class="token class-name">Int32</span> iterations <span class="token operator">=</span> <span class="token number">10000000</span><span class="token punctuation">;</span> <span class="token comment">// 10 million</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// How long does it take to increment x 10 million times?</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token class-name">Stopwatch</span> sw <span class="token operator">=</span> Stopwatch<span class="token punctuation">.</span><span class="token function">StartNew</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> iterations<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> x<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Incrementing x: &#123;0:N0&#125;"</span><span class="token punctuation">,</span> sw<span class="token punctuation">.</span>ElapsedMilliseconds<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// How long does it take to increment x 10 million times </span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// adding the overhead of calling a method that does nothing?</span></pre></td></tr><tr><td data-num="12"></td><td><pre> sw<span class="token punctuation">.</span><span class="token function">Restart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> iterations<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token function">M</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token function">M</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Incrementing x in M: &#123;0:N0&#125;"</span><span class="token punctuation">,</span> sw<span class="token punctuation">.</span>ElapsedMilliseconds<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token comment">// How long does it take to increment x 10 million times </span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token comment">// adding the overhead of calling an uncontended SimpleSpinLock?</span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token class-name">SpinLock</span> sl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SpinLock</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre> sw<span class="token punctuation">.</span><span class="token function">Restart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> iterations<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token class-name">Boolean</span> taken <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> sl<span class="token punctuation">.</span><span class="token function">Enter</span><span class="token punctuation">(</span><span class="token keyword">ref</span> taken<span class="token punctuation">)</span><span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">;</span> sl<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Incrementing x in SpinLock: &#123;0:N0&#125;"</span><span class="token punctuation">,</span> sw<span class="token punctuation">.</span>ElapsedMilliseconds<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token comment">// How long does it take to increment x 10 million times </span></pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token comment">// adding the overhead of calling an uncontended SimpleWaitLock?</span></pre></td></tr><tr><td data-num="27"></td><td><pre> <span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token class-name">SimpleWaitLock</span> swl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SimpleWaitLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre> sw<span class="token punctuation">.</span><span class="token function">Restart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> iterations<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre> swl<span class="token punctuation">.</span><span class="token function">Enter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">;</span> swl<span class="token punctuation">.</span><span class="token function">Leave</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Incrementing x in SimpleWaitLock: &#123;0:N0&#125;"</span><span class="token punctuation">,</span> sw<span class="token punctuation">.</span>ElapsedMilliseconds<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">MethodImpl</span><span class="token attribute-arguments"><span class="token punctuation">(</span>MethodImplOptions<span class="token punctuation">.</span>NoInlining<span class="token punctuation">)</span></span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">M</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* This method does nothing but return */</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>When I run the <span class="token class-name">preceding</span> code<span class="token punctuation">,</span> I <span class="token keyword">get</span> the following <span class="token class-name">output<span class="token punctuation">.</span></span></pre></td></tr><tr><td data-num="38"></td><td><pre>Incrementing x<span class="token punctuation">:</span> <span class="token number">8</span> Fastest</pre></td></tr><tr><td data-num="39"></td><td><pre><span class="token class-name">Incrementing</span> x <span class="token keyword">in</span> M<span class="token punctuation">:</span> <span class="token number">69</span> <span class="token operator">~</span>9x slower</pre></td></tr><tr><td data-num="40"></td><td><pre><span class="token class-name">Incrementing</span> x <span class="token keyword">in</span> SpinLock<span class="token punctuation">:</span> <span class="token number">164</span> <span class="token operator">~</span>21x slower</pre></td></tr><tr><td data-num="41"></td><td><pre><span class="token class-name">Incrementing</span> x <span class="token keyword">in</span> SimpleWaitLock<span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">,</span><span class="token number">854</span> <span class="token operator">~</span><span class="token number">1</span><span class="token punctuation">,</span>107x slower</pre></td></tr></table></figure><blockquote><p>As you can clearly see, just incrementing x took only 8 milliseconds. To call empty methods before and after incrementing x made the operation take nine times longer! Then, executing code in a method that uses a user-mode construct caused the code to run 21 (164 / 8) times slower. But now, see how much slower the program ran using a kernel-mode construct: 1,107 (8,854 / 8) times slower! So, if you can avoid thread synchronization, you should. If you need thread synchronization, then try to use the user-mode constructs. Always try to avoid the kernel-mode constructs.</p></blockquote><h3 id="semaphore-constructs"><a class="anchor" href="#semaphore-constructs">#</a> Semaphore Constructs</h3><blockquote><p>Semaphores are simply Int32 variables maintained by the kernel. A thread waiting on a semaphore blocks when the semaphore is 0 and unblocks when the semaphore is greater than 0. When a thread waiting on a semaphore unblocks, the kernel automatically subtracts 1 from the semaphoreâ€™s count. Semaphores also have a maximum Int32 value associated with them, and the current count is never allowed to go over the maximum count. Here is what the Semaphore class looks like.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Semaphore</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">WaitHandle</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Semaphore</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> initialCount<span class="token punctuation">,</span> <span class="token class-name">Int32</span> maximumCount<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token function">Release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Calls Release(1); returns previous count</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token function">Release</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> releaseCount<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Returns previous count</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>So now let me summarize how these three kernel-mode primitives behave:</p><ul><li><p>When multiple threads are waiting on an auto-reset event, setting the event causes only one thread to become unblocked.</p></li><li><p>When multiple threads are waiting on a manual-reset event, setting the event causes all threads to become unblocked.</p></li><li><p>When multiple threads are waiting on a semaphore, releasing the semaphore causes releaseCount threads to become unblocked (where releaseCount is the argument passed to Semaphoreâ€™s Release method).</p></li></ul></blockquote><blockquote><p>Therefore, an auto-reset event behaves very similarly to a semaphore whose maximum count is 1. The difference between the two is that Set can be called multiple times consecutively on an auto-reset event, and still only one thread will be unblocked, whereas calling Release multiple times consecutively on a semaphore keeps incrementing its internal count, which could unblock many threads. By the way, if you call Release on a semaphore too many times, causing its count to exceed its maximum count, then Release will throw a SemaphoreFullException.</p></blockquote><blockquote><p>Using a semaphore, we can re-implement the SimpleWaitLock as follows, so that it gives multiple threads concurrent access to a resource (which is not necessarily a safe thing to do unless all threads access the resource in a read-only fashion).</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SimpleWaitLock</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IDisposable</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">Semaphore</span> m_available<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token function">SimpleWaitLock</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> maxConcurrent<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> m_available <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Semaphore</span><span class="token punctuation">(</span>maxConcurrent<span class="token punctuation">,</span> maxConcurrent<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Enter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// Block in kernel until resource available</span></pre></td></tr><tr><td data-num="8"></td><td><pre> m_available<span class="token punctuation">.</span><span class="token function">WaitOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Leave</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// Let another thread access the resource</span></pre></td></tr><tr><td data-num="12"></td><td><pre> m_available<span class="token punctuation">.</span><span class="token function">Release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> m_available<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="mutex-constructs"><a class="anchor" href="#mutex-constructs">#</a> Mutex Constructs</h3><blockquote><p>A Mutex represents a mutual-exclusive lock. It works similar to an AutoResetEvent or a Semaphore with a count of 1 because all three constructs release only one waiting thread at a time. The following shows what the Mutex class looks like.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Mutex</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">WaitHandle</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Mutex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ReleaseMutex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Mutexes have some additional logic in them, which makes them more complex than the other constructs. First, Mutex objects record which thread obtained it by querying the calling threadâ€™s Int32 ID. When a thread calls ReleaseMutex, the Mutex makes sure that the calling thread is the same thread that obtained the Mutex. If the calling thread is not the thread that obtained the Mutex, then the Mutex objectâ€™s state is unaltered and ReleaseMutex throws a System.ApplicationException. Also, if a thread owning a Mutex terminates for any reason, then some thread waiting on the Mutex will be awakened by having a System.Threading.AbandonedMutexException thrown. Usually, this exception will go unhandled, terminating the whole process. This is good because a thread acquired the Mutex and it is likely that the thread terminated before it finished updating the data that the Mutex was protecting. If a thread catches AbandonedMutexException, then it could attempt to access the corrupt data, leading to unpredictable results and security problems.</p></blockquote><blockquote><p>Second, Mutex objects maintain a recursion count indicating how many times the owning thread owns the Mutex. If a thread currently owns a Mutex and then that thread waits on the Mutex again, the recursion count is incremented and the thread is allowed to continue running. When that thread calls ReleaseMutex, the recursion count is decremented. Only when the recursion count becomes 0 can another thread become the owner of the Mutex.</p></blockquote><blockquote><p>Most people do not like this additional logic. The problem is that these â€œfeaturesâ€ have a cost associated with them. The Mutex object needs more memory to hold the additional thread ID and recursion count information. And, more importantly, the Mutex code has to maintain this information, which makes the lock slower. If an application needs or wants these additional features, then the application code could have done this itself; the code doesnâ€™t have to be built into the Mutex object. For this reason, a lot of people avoid using Mutex objects.</p></blockquote><blockquote><p>Usually a recursive lock is needed when a method takes a lock and then calls another method that also requires the lock, as the following code demonstrates.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">SomeClass</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IDisposable</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">Mutex</span> m_lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Mutex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> m_lock<span class="token punctuation">.</span><span class="token function">WaitOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// Do whatever...</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token function">Method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Method2 recursively acquires the lock</span></pre></td></tr><tr><td data-num="7"></td><td><pre> m_lock<span class="token punctuation">.</span><span class="token function">ReleaseMutex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> m_lock<span class="token punctuation">.</span><span class="token function">WaitOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// Do whatever...</span></pre></td></tr><tr><td data-num="12"></td><td><pre> m_lock<span class="token punctuation">.</span><span class="token function">ReleaseMutex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> m_lock<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In the preceding code, code that uses a SomeClass object could call Method1, which acquires the Mutex, performs some thread-safe operation, and then calls Method2, which also performs some thread-safe operation. Because Mutex objects support recursion, the thread will acquire the lock twice and then release it twice before another thread can own the Mutex. If SomeClass has used an AutoResetEvent instead of a Mutex, then the thread would block when it called Method2â€™s WaitOne method.</p></blockquote><blockquote><p>If you need a recursive lock, then you could create one easily by using an AutoResetEvent.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">RecursiveAutoResetEvent</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IDisposable</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">AutoResetEvent</span> m_lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">AutoResetEvent</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_owningThreadId <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_recursionCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Enter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Obtain the calling thread's unique Int32 ID</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token class-name">Int32</span> currentThreadId <span class="token operator">=</span> Thread<span class="token punctuation">.</span>CurrentThread<span class="token punctuation">.</span>ManagedThreadId<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// If the calling thread owns the lock, increment the recursion count</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>m_owningThreadId <span class="token operator">==</span> currentThreadId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> m_recursionCount<span class="token operator">++</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token comment">// The calling thread doesn't own the lock, wait for it</span></pre></td></tr><tr><td data-num="14"></td><td><pre> m_lock<span class="token punctuation">.</span><span class="token function">WaitOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// The calling now owns the lock, initialize the owning thread ID &amp; recursion count</span></pre></td></tr><tr><td data-num="16"></td><td><pre> m_owningThreadId <span class="token operator">=</span> currentThreadId<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre> m_recursionCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Leave</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token comment">// If the calling thread doesn't own the lock, we have an error</span></pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>m_owningThreadId <span class="token operator">!=</span> Thread<span class="token punctuation">.</span>CurrentThread<span class="token punctuation">.</span>ManagedThreadId<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">InvalidOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token comment">// Subtract 1 from the recursion count</span></pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>m_recursionCount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token comment">// If the recursion count is 0, then no thread owns the lock</span></pre></td></tr><tr><td data-num="26"></td><td><pre> m_owningThreadId <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="27"></td><td><pre> m_lock<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Wake up 1 waiting thread (if any)</span></pre></td></tr><tr><td data-num="28"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> m_lock<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Although the behavior of the RecursiveAutoResetEvent class is identical to that of the Mutex class, a RecursiveAutoResetEvent object will have far superior performance when a thread tries to acquire the lock recursively, because all the code that is required to track thread ownership and recursion is now in managed code. A thread has to transition into the Windows kernel only when first acquiring the AutoResetEvent or when finally relinquishing it to another thread.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šWindows æä¾›äº†å‡ ä¸ªå†…æ ¸æ¨¡å¼çš„æ„é€ æ¥åŒæ­¥çº¿ç¨‹ã€‚å†…æ ¸æ¨¡å¼çš„æ„é€ æ¯”ç”¨æˆ·æ¨¡å¼çš„æ„é€ æ…¢å¾—å¤šï¼Œä¸€ä¸ªåŸå› æ˜¯å®ƒä»¬è¦æ±‚ Windows æ“ä½œç³»ç»Ÿè‡ªèº«çš„é…åˆï¼Œå¦ä¸€ä¸ªåŸå› æ˜¯åœ¨å†…æ ¸å¯¹è±¡ä¸Šè°ƒç”¨çš„æ¯ä¸ªæ–¹æ³•éƒ½é€ æˆè°ƒç”¨çº¿ç¨‹ä»æ‰˜ç®¡ä»£ç è½¬æ¢ä¸ºæœ¬æœº (native) ç”¨æˆ·æ¨¡å¼ä»£ç ï¼Œå†è½¬æ¢ä¸ºæœ¬æœº (native) å†…æ ¸æ¨¡å¼ä»£ç ã€‚ç„¶åï¼Œè¿˜è¦æœç›¸åçš„æ–¹å‘ä¸€è·¯è¿”å›ã€‚è¿™äº›è½¬æ¢éœ€è¦å¤§é‡ CPU æ—¶é—´ï¼›ç»å¸¸æ‰§è¡Œä¼šå¯¹åº”ç”¨ç¨‹åºçš„æ€»ä½“æ€§èƒ½é€ æˆè´Ÿé¢å½±å“ã€‚ä½†å†…æ ¸æ¨¡å¼çš„æ„é€ å…·å¤‡åŸºå…ƒç”¨æˆ·æ¨¡å¼æ„é€ æ‰€ä¸å…·å¤‡çš„ä¼˜ç‚¹ã€‚1. å†…æ ¸æ¨¡å¼çš„æ„é€ æ£€æµ‹åˆ°åœ¨ä¸€ä¸ªèµ„æºä¸Šçš„ç«äº‰æ—¶ï¼ŒWindows ä¼šé˜»å¡è¾“æ‰çš„çº¿ç¨‹ï¼Œä½¿å®ƒä¸å ç”¨ä¸€ä¸ª CPU â€œè‡ªæ—‹â€(spinning)ï¼Œæ— è°“åœ°æµªè´¹å¤„ç†å™¨èµ„æºã€‚2. å†…æ ¸æ¨¡å¼çš„æ„é€ å¯å®ç°æœ¬æœº (native) å’Œæ‰˜ç®¡ (managed) çº¿ç¨‹ç›¸äº’ä¹‹é—´çš„åŒæ­¥ã€‚3. å†…æ ¸æ¨¡å¼çš„æ„é€ å¯åŒæ­¥åœ¨åŒä¸€å°æœºå™¨çš„ä¸åŒè¿›ç¨‹ä¸­è¿è¡Œçš„çº¿ç¨‹ã€‚4. å†…æ ¸æ¨¡å¼å¯¹çš„æ„é€ å¯åº”ç”¨å®‰å…¨æ€§è®¾ç½®ï¼Œé˜²æ­¢æœªç»æˆæƒçš„è´¦æˆ·è®¿é—®å®ƒä»¬ã€‚5. çº¿ç¨‹å¯ä¸€ç›´é˜»å¡ï¼Œç›´åˆ°é›†åˆä¸­çš„æ‰€æœ‰å†…æ ¸æ¨¡å¼æ„é€ éƒ½å¯ç”¨ï¼Œæˆ–ç›´åˆ°é›†åˆä¸­çš„ä»»ä½•å†…æ ¸æ¨¡å¼æ„é€ å¯ç”¨ã€‚6. åœ¨å†…æ ¸æ¨¡å¼çš„æ„é€ ä¸Šé˜»å¡çš„çº¿ç¨‹å¯æŒ‡å®šè¶…æ—¶å€¼ï¼›æŒ‡å®šæ—¶é—´å†…è®¿é—®ä¸åˆ°å¸Œæœ›çš„èµ„æºï¼Œçº¿ç¨‹å°±å¯ä»¥è§£é™¤é˜»å¡å¹¶æ‰§è¡Œå…¶ä»–ä»»åŠ¡ã€‚äº‹ä»¶å’Œä¿¡å·é‡æ˜¯ä¸¤ç§åŸºå…ƒå†…æ ¸æ¨¡å¼çº¿ç¨‹åŒæ­¥æ„é€ ã€‚è‡³äºå…¶ä»–å†…æ ¸æ¨¡å¼æ„é€ ï¼Œæ¯”å¦‚äº’æ–¥ä½“ï¼Œåˆ™æ˜¯åœ¨è¿™ä¸¤ä¸ªåŸºè®¡æ„é€ ä¸Šæ„å»ºçš„ã€‚ <code>System.Threading</code> å‘½åç©ºé—´æä¾›äº†ä¸€ä¸ªåä¸º <code>WaitHandle</code> æŠ½è±¡åŸºç±»ã€‚ <code>WaitHandle</code> ç±»æ˜¯ä¸€ä¸ªå¾ˆç®€å•çš„ç±»ï¼Œå®ƒå”¯ä¸€çš„ä½œç”¨å°±æ˜¯åŒ…è£…ä¸€ä¸ª Windows å†…æ ¸å¯¹è±¡å¥æŸ„ã€‚FCL æä¾›äº†å‡ ä¸ªä» <code>WaitHandle</code> æ´¾ç”Ÿçš„ç±»ã€‚æ‰€æœ‰ç±»éƒ½åœ¨ <code>System.Threading</code> å‘½åç©ºé—´ä¸­å®šä¹‰ã€‚ <code>WaitHandle</code> åŸºç±»å†…éƒ¨æœ‰ä¸€ä¸ª <code>SafeWaitHandle</code> å­—æ®µï¼Œå®ƒå®¹çº³äº†ä¸€ä¸ª Win32 å†…æ ¸å¯¹è±¡å¥æŸ„ã€‚è¿™ä¸ªå­—æ®µæ˜¯åœ¨æ„é€ ä¸€ä¸ªå…·ä½“çš„ <code>WaitHandle</code> æ´¾ç”Ÿç±»æ—¶åˆå§‹åŒ–çš„ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œ <code>WaitHandle</code> ç±»å…¬å¼€äº†ç”±æ‰€æœ‰æ´¾ç”Ÿç±»ç»§æ‰¿çš„æ–¹æ³•ã€‚åœ¨ä¸€ä¸ªå†…æ ¸æ¨¡å¼çš„æ„é€ ä¸Šè°ƒç”¨çš„æ¯ä¸ªæ–¹æ³•éƒ½ä»£è¡¨ä¸€ä¸ªå®Œæ•´çš„å†…å­˜æ …æ ã€‚è¿™äº›æ–¹æ³•æœ‰å‡ ç‚¹éœ€è¦æ³¨æ„ï¼š1. å¯ä»¥è°ƒç”¨ <code>WaitHandle</code> çš„ <code>WaitOne</code> æ–¹æ³•è®©è°ƒç”¨çº¿ç¨‹ç­‰å¾…åº•å±‚å†…æ ¸å¯¹è±¡æ”¶åˆ°ä¿¡å·ã€‚è¿™ä¸ªæ–¹æ³•åœ¨å†…éƒ¨è°ƒç”¨ Win32 <code>WaitForSingleObjectEx</code> å‡½æ•°ã€‚å¦‚æœå¯¹è±¡æ”¶åˆ°ä¿¡å·ï¼Œè¿”å›çš„ <code>Boolean</code> æ˜¯ <code>true</code> ï¼›è¶…æ—¶å°±è¿”å› <code>false</code> ã€‚2. å¯ä»¥è°ƒç”¨ <code>WaitHandle</code> çš„é™æ€ <code>WaitAll</code> æ–¹æ³•ï¼Œè®©è°ƒç”¨çº¿ç¨‹ç­‰å¾… <code>WaitHandle[]</code> ä¸­æŒ‡å®šçš„æ‰€æœ‰å†…æ ¸å¯¹è±¡éƒ½æ”¶åˆ°ä¿¡å·ã€‚å¦‚æœæ‰€æœ‰å¯¹è±¡éƒ½æ”¶åˆ°ä¿¡å·ï¼Œè¿”å›çš„ <code>Boolean</code> æ˜¯ <code>true</code> ï¼›è¶…æ—¶åˆ™è¿”å› <code>false</code> ã€‚è¿™ä¸ªæ–¹æ³•åœ¨å†…éƒ¨è°ƒç”¨ Win32 <code>WaitForMultipleObjectsEx</code> å‡½æ•°ï¼Œä¸º <code>bWaitAll</code> å‚æ•°ä¼ é€’ <code>TRUE</code> ã€‚3. å¯ä»¥è°ƒç”¨ <code>WaitHandle</code> çš„é™æ€ <code>WaitAny</code> æ–¹æ³•è®©è°ƒç”¨çº¿ç¨‹ç­‰å¾… <code>WaitHandle[]</code> ä¸­æŒ‡å®šçš„ä»»ä½•å†…æ ¸å¯¹è±¡æ”¶åˆ°ä¿¡å·ã€‚è¿”å›çš„ <code>Int32</code> æ˜¯ä¸æ”¶åˆ°ä¿¡å·çš„å†…æ ¸å¯¹è±¡å¯¹åº”çš„æ•°ç»„å…ƒç´ ç´¢å¼•ï¼›å¦‚æœåœ¨ç­‰å¾…æœŸé—´æ²¡æœ‰å¯¹è±¡æ”¶åˆ°ä¿¡å·ï¼Œåˆ™è¿”å› <code>WaitHandle.WaitTimeout</code> ã€‚è¿™ä¸ªæ–¹æ³•åœ¨å†…éƒ¨è°ƒç”¨ Win32 <code>WaitForMultipleObjectsEx</code> å‡½æ•°ï¼Œä¸º <code>bWaitALl</code> å‚æ•°ä¼ é€’ <code>FALSE</code> ã€‚4. å†ä¼ ç»™ <code>WaitAny</code> å’Œ <code>WaitAll</code> æ–¹æ³•çš„æ•°ç»„ä¸­ï¼ŒåŒ…å«çš„å…ƒç´ æ•°ä¸èƒ½è¶…è¿‡ 64 ä¸ªï¼Œå¦åˆ™æ–¹æ³•ä¼šæŠ›å‡ºä¸€ä¸ª <code>System.NotSupportedException</code> ã€‚5. å¯ä»¥è°ƒç”¨ <code>WaitHandle</code> çš„ <code>Dispose</code> æ–¹æ³•æ¥å…³é—­åº•å±‚å†…æ ¸å¯¹è±¡å¥æŸ„ã€‚è¿™ä¸ªæ–¹æ³•åœ¨å†…éƒ¨è°ƒç”¨ Win32 <code>CloseHandle</code> å‡½æ•°ã€‚åªæœ‰ç¡®å®šæ²¡æœ‰åˆ«çš„çº¿ç¨‹è¦ä½¿ç”¨å†…æ ¸å¯¹è±¡æ‰èƒ½æ˜¾å¼è°ƒç”¨ <code>Dispose</code> ã€‚ ä½ éœ€è¦å†™ä»£ç å¹¶è¿›è¡Œæµ‹è¯•ï¼Œè¿™æ˜¯ä¸€ä¸ªå·¨å¤§çš„è´Ÿæ‹…ã€‚æ‰€ä»¥æˆ‘å¼ºçƒˆåå¯¹æ˜¾å¼è°ƒç”¨ <code>Dispose</code> ï¼›ç›¸åï¼Œè®©åƒåœ¾å›æ”¶å™¨ (GC) å»å®Œæˆæ¸…ç†å·¥ä½œã€‚GC çŸ¥é“ä»€ä¹ˆæ—¶å€™æ²¡æœ‰çº¿ç¨‹ä½¿ç”¨å¯¹è±¡ï¼Œä¼šè‡ªåŠ¨è¿›è¡Œæ¸…ç†ã€‚ä¸æ¥å—è¶…æ—¶å‚æ•°çš„é‚£äº›ç‰ˆæœ¬çš„ <code>WaitOne</code> å’Œ <code>WaitAll</code> æ–¹æ³•åº”è¿”å› <code>void</code> è€Œä¸æ˜¯ <code>Boolean</code> ã€‚åŸå› æ˜¯éšå«çš„è¶…æ—¶æ—¶é—´æ˜¯æ— é™é•¿ ( <code>System.Threading.Timeout.Infinite</code> )ï¼Œæ‰€ä»¥å®ƒä»¬åªä¼šè¿”å› <code>true</code> ã€‚ <code>AutoResetEvent</code> ï¼Œ <code>ManualResetEvent</code> ï¼Œ <code>Semaphore</code> å’Œ <code>Mutex</code> ç±»éƒ½æ´¾ç”Ÿè‡ª <code>WaitHandle</code> ï¼Œå› æ­¤å®ƒä»¬ç»§æ‰¿äº† <code>WaitHandle</code> çš„æ–¹æ³•å’Œè¡Œä¸ºã€‚é¦–å…ˆï¼Œæ‰€æœ‰è¿™äº›ç±»çš„æ„é€ å™¨éƒ½åœ¨å†…éƒ¨è°ƒç”¨ Win32 <code>CreateEvent</code> (ä¸º <code>BManualReset</code> å‚æ•°ä¼ é€’ <code>FALSE</code> æˆ– <code>TRUE</code> )ã€ <code>CreateSemaphore</code> æˆ– <code>CreateMutex</code> å‡½æ•°ã€‚ä»æ‰€æœ‰è¿™äº›è°ƒç”¨è¿”å›çš„å¥æŸ„å€¼éƒ½ä¿å­˜åœ¨ <code>WaitHandle</code> åŸºç±»å†…éƒ¨å®šä¹‰çš„ä¸€ä¸ªç§æœ‰ <code>SafeWaitHandle</code> å­—æ®µä¸­ã€‚å…¶æ¬¡ï¼Œ <code>EventWaitHandle</code> ï¼Œ <code>Semaphore</code> å’Œ <code>Mutex</code> ç±»éƒ½æä¾›äº†é™æ€ <code>OpenExisting</code> æ–¹æ³•ï¼Œå®ƒä»¬åœ¨å†…éƒ¨è°ƒç”¨ Win32 <code>OpenEvent</code> ï¼Œ <code>OpenSemaphore</code> æˆ– <code>OpenMutex</code> å‡½æ•°ï¼Œå¹¶ä¼ é€’ä¸€ä¸ª <code>String</code> å®å‚ (æ ‡è¯†ç°æœ‰çš„ä¸€ä¸ªå…·åå†…æ ¸å¯¹è±¡)ã€‚æ‰€æœ‰å‡½æ•°è¿”å›çš„å¥æŸ„å€¼éƒ½ä¿å­˜åˆ°ä» <code>OpenExisting</code> æ–¹æ³•è¿”å›çš„ä¸€ä¸ªæ–°æ„é€ çš„å¯¹è±¡ä¸­ã€‚å¦‚æœæŒ‡å®šåç§°çš„å†…æ ¸å¯¹è±¡ä¸å­˜åœ¨ï¼Œå°±æŠ›å‡ºä¸€ä¸ª <code>WaitHandleCannotBeOpenedException</code> å¼‚å¸¸ã€‚äº‹ä»¶ (event) å…¶å®åªæ˜¯ç”±å†…æ ¸ç»´æŠ¤çš„ <code>Boolean</code> å˜é‡ã€‚äº‹ä»¶ä¸º <code>false</code> ï¼Œåœ¨äº‹ä»¶ä¸Šç­‰å¾…çš„çº¿ç¨‹å°±é˜»å¡ï¼›äº‹ä»¶ä¸º <code>true</code> ï¼Œå°±è§£é™¤é˜»å¡ã€‚æœ‰ä¸¤ç§äº‹ä»¶ï¼Œå³è‡ªåŠ¨é‡ç½®äº‹ä»¶å’Œæ‰‹åŠ¨é‡ç½®äº‹ä»¶ã€‚å½“ä¸€ä¸ªè‡ªåŠ¨é‡ç½®äº‹ä»¶ä¸º <code>true</code> æ—¶ï¼Œå®ƒåªå”¤é†’ä¸€ä¸ªé˜»å¡çš„çº¿ç¨‹ï¼Œå› ä¸ºåœ¨è§£é™¤ç¬¬ä¸€ä¸ªçº¿ç¨‹çš„é˜»å¡åï¼Œå†…æ ¸å°†äº‹ä»¶è‡ªåŠ¨é‡ç½®å› <code>false</code> ï¼Œé€ æˆå…¶ä½™çº¿ç¨‹ç»§ç»­é˜»å¡ã€‚è€Œå½“ä¸€ä¸ªæ‰‹åŠ¨é‡ç½®äº‹ä»¶ä¸º <code>true</code> æ—¶ï¼Œå®ƒè§£é™¤æ­£åœ¨ç­‰å¾…å®ƒçš„æ‰€æœ‰çº¿ç¨‹çš„é˜»å¡ï¼Œå› ä¸ºå†…æ ¸ä¸å°†äº‹ä»¶è‡ªåŠ¨é‡ç½®å› <code>false</code> ï¼›ç°åœ¨ï¼Œä½ çš„ä»£ç å¿…é¡»å°†äº‹ä»¶æ‰‹åŠ¨é‡ç½®å› <code>false</code> ã€‚å¯ç”¨è‡ªåŠ¨é‡ç½®äº‹ä»¶è½»æ¾åˆ›å»ºçº¿ç¨‹åŒæ­¥é”ï¼ˆ <code>SimpleWaitLock</code> ï¼‰ï¼Œå¯é‡‡å–å’Œä½¿ç”¨ <code>SimpleSpinLock</code> æ—¶å®Œå…¨ä¸€æ ·çš„æ–¹å¼ä½¿ç”¨è¿™ä¸ª <code>SimpleWaitLock</code> ã€‚äº‹å®ä¸Šï¼Œå¤–éƒ¨è¡Œä¸ºæ˜¯å®Œå…¨ç›¸åŒçš„ï¼›ä¸è¿‡ï¼Œä¸¤ä¸ªé”çš„æ€§èƒ½æˆªç„¶ä¸åŒã€‚é”ä¸Šé¢æ²¡æœ‰ç«äº‰çš„æ—¶å€™ï¼Œ <code>SimpleWaitLock</code> æ¯” <code>SimpleSpinLock</code> æ…¢å¾—å¤šï¼Œå› ä¸ºå¯¹ <code>SimpleWaitLock</code> çš„ <code>Enter</code> å’Œ <code>Leave</code> æ–¹æ³•çš„æ¯ä¸€ä¸ªè°ƒç”¨éƒ½å¼ºè¿«è°ƒç”¨çº¿ç¨‹ä»æ‰˜ç®¡ä»£ç è½¬æ¢ä¸ºå†…æ ¸ä»£ç ï¼Œå†è½¬æ¢å›æ¥ â€”â€” è¿™æ˜¯ä¸å¥½çš„åœ°æ–¹ã€‚ä½†åœ¨å­˜åœ¨ç«äº‰çš„æ—¶å€™ï¼Œè¾“æ‰çš„çº¿ç¨‹ä¼šè¢«å†…æ ¸é˜»å¡ï¼Œä¸ä¼šåœ¨é‚£é‡Œ â€œè‡ªæ—‹â€ï¼Œä»è€Œæµªè´¹ CPU æ—¶é—´ â€”â€” è¿™æ˜¯å¥½çš„åœ°æ–¹ã€‚è¿˜è¦æ³¨æ„ï¼Œæ„é€  <code>AutoResetEvent</code> å¯¹è±¡å¹¶åœ¨å®ƒä¸Šé¢è°ƒç”¨ <code>Dispose</code> ä¹Ÿä¼šé€ æˆä»æ‰˜ç®¡å‘å†…æ ¸çš„è½¬æ¢ï¼Œå¯¹æ€§èƒ½é€ æˆè´Ÿé¢å½±å“ã€‚è¿™äº›è°ƒç”¨ä¸€èˆ¬å¾ˆå°‘å‘ç”Ÿï¼Œæ‰€ä»¥ä¸€èˆ¬ä¸å¿…è¿‡äºå…³å¿ƒå®ƒä»¬ã€‚çº¿ç¨‹åŒæ­¥èƒ½é¿å…å°±å°½é‡é¿å…ã€‚å¦‚æœä¸€å®šè¦è¿›è¡Œçº¿ç¨‹åŒæ­¥ï¼Œå°±å°½é‡ä½¿ç”¨ç”¨æˆ·æ¨¡å¼çš„æ„é€ ã€‚å†…æ ¸æ¨¡å¼çš„æ„é€ è¦å°½é‡é¿å…ã€‚ä¿¡å·é‡ (semaphore) å…¶å®å°±æ˜¯ç”±å†…æ ¸ç»´æŠ¤çš„ <code>Int32</code> å˜é‡ã€‚ä¿¡å·é‡ä¸º 0 æ—¶ï¼Œåœ¨ä¿¡å·é‡ä¸Šç­‰å¾…çš„çº¿ç¨‹ä¼šé˜»å¡ï¼›ä¿¡å·é‡å¤§äº 0 æ—¶è§£é™¤é˜»å¡ã€‚åœ¨ä¿¡å·é‡ä¸Šç­‰å¾…çš„çº¿ç¨‹è§£é™¤é˜»å¡æ—¶ï¼Œå†…æ ¸è‡ªåŠ¨ä»ä¿¡å·é‡çš„è®¡æ•°ä¸­å‡ 1ã€‚ä¿¡å·é‡è¿˜å…³è”äº†ä¸€ä¸ªæœ€å¤§ <code>Int32</code> å€¼ï¼Œå½“å‰è®¡æ•°ç»ä¸å…è®¸è¶…è¿‡æœ€å¤§è®¡æ•°ã€‚è‡ªåŠ¨é‡ç½®äº‹ä»¶åœ¨è¡Œä¸ºä¸Šå’Œæœ€å¤§è®¡æ•°ä¸º 1 çš„ä¿¡å·é‡éå¸¸ç›¸ä¼¼ã€‚ä¸¤è€…çš„åŒºåˆ«åœ¨äºï¼Œå¯ä»¥åœ¨ä¸€ä¸ªè‡ªåŠ¨é‡ç½®äº‹ä»¶ä¸Šè¿ç»­å¤šæ¬¡è°ƒç”¨ <code>Set</code> ï¼ŒåŒæ—¶ä»ç„¶åªæœ‰ä¸€ä¸ªçº¿ç¨‹è§£é™¤é˜»å¡ã€‚ç›¸åï¼Œåœ¨ä¸€ä¸ªä¿¡å·é‡ä¸Šè¿ç»­å¤šæ¬¡è°ƒç”¨ <code>Release</code> ï¼Œä¼šä½¿å®ƒçš„å†…éƒ¨è®¡æ•°ä¸€ç›´é€’å¢ï¼Œè¿™å¯èƒ½è§£é™¤å¤§é‡çº¿ç¨‹çš„é˜»å¡ã€‚é¡ºä¾¿è¯´ä¸€å¥ï¼Œå¦‚æœåœ¨ä¸€ä¸ªä¿¡å·é‡ä¸Šå¤šæ¬¡è°ƒç”¨ <code>Release</code> ï¼Œä¼šå¯¼è‡´å®ƒçš„è®¡æ•°è¶…è¿‡æœ€å¤§è®¡æ•°ï¼Œè¿™æ—¶ <code>Release</code> ä¼šæŠ›å‡ºä¸€ä¸ª <code>SemaphoreFullException</code> ã€‚äº’æ–¥ä½“ (mutex) ä»£è¡¨ä¸€ä¸ªäº’æ–¥çš„é”ã€‚å®ƒçš„å·¥ä½œæ–¹å¼å’Œ <code>AutoResetEvent</code> æˆ–è€…è®¡æ•°ä¸º 1 çš„ <code>Semaphore</code> ç›¸ä¼¼ï¼Œä¸‰è€…éƒ½æ˜¯ä¸€æ¬¡åªé‡Šæ”¾ä¸€ä¸ªæ­£åœ¨ç­‰å¾…çš„çº¿ç¨‹ã€‚äº’æ–¥ä½“æœ‰ä¸€äº›é¢å¤–çš„é€»è¾‘ï¼Œè¿™é€ æˆå®ƒä»¬æ¯”å…¶ä»–æ„é€ æ›´å¤æ‚ã€‚é¦–å…ˆï¼Œ <code>Mutex</code> å¯¹è±¡ä¼šæŸ¥è¯¢è°ƒç”¨çº¿ç¨‹çš„ <code>Int32</code> IDï¼Œè®°å½•æ˜¯å“ªä¸ªçº¿ç¨‹è·å¾—äº†å®ƒã€‚ä¸€ä¸ªçº¿ç¨‹è°ƒç”¨ <code>ReleaseMutex</code> æ—¶ï¼Œ <code>Mutex</code> ç¡®ä¿è°ƒç”¨çº¿ç¨‹å°±æ˜¯è·å– <code>Mutex</code> çš„é‚£ä¸ªçº¿ç¨‹ã€‚å¦‚è‹¥ä¸ç„¶ï¼Œ <code>Mutex</code> å¯¹è±¡çš„çŠ¶æ€å°±ä¸ä¼šæ”¹å˜ï¼Œè€Œ <code>ReleaseMutex</code> ä¼šæŠ›å‡ºä¸€ä¸ª <code>System.ApplicationException</code> ã€‚å¦å¤–ï¼Œæ‹¥æœ‰ <code>Mutex</code> çš„çº¿ç¨‹å› ä¸ºä»»ä½•åŸå› è€Œç»ˆæ­¢ï¼Œåœ¨ <code>Mutex</code> ä¸Šç­‰å¾…çš„æŸä¸ªçº¿ç¨‹ä¼šå› ä¸ºæŠ›å‡º <code>System.Threading.AbandonedMutexException</code> å¼‚å¸¸è€Œè¢«å”¤é†’ã€‚è¯¥å¼‚å¸¸é€šå¸¸ä¼šæˆä¸ºæœªå¤„ç†çš„å¼‚å¸¸ï¼Œä»è€Œç»ˆæ­¢æ•´ä¸ªè¿›ç¨‹ã€‚è¿™æ˜¯å¥½äº‹ï¼Œå› ä¸ºçº¿ç¨‹åœ¨è·å–äº†ä¸€ä¸ª <code>Mutex</code> ä¹‹åï¼Œå¯èƒ½åœ¨æ›´æ–°å®Œ <code>Mutex</code> æ‰€ä¿æŠ¤çš„æ•°æ®ä¹‹å‰ç»ˆæ­¢ã€‚å¦‚æœå…¶ä»–çº¿ç¨‹æ•æ‰äº† <code>AbandonedMutexException</code> ï¼Œå°±å¯èƒ½è§†å›¾è®¿é—®æŸåçš„æ•°æ®ï¼Œé€ æˆæ— æ³•é¢„æ–™çš„ç»“æœå’Œå®‰å…¨éšæ‚£ã€‚å…¶æ¬¡ï¼Œ <code>Mutex</code> å¯¹è±¡ç»´æŠ¤ç€ä¸€ä¸ªé€’å½’è®¡æ•° (recursion count)ï¼ŒæŒ‡å‡ºæ‹¥æœ‰è¯¥ <code>Mutex</code> çš„çº¿ç¨‹æ‹¥æœ‰äº†å®ƒå¤šå°‘æ¬¡ã€‚å¦‚æœä¸€ä¸ªçº¿ç¨‹å½“å‰æ‹¥æœ‰ä¸€ä¸ª <code>Mutex</code> ï¼Œè€Œåè¯¥çº¿ç¨‹å†æ¬¡åœ¨ <code>Mutex</code> ä¸Šç­‰å¾…ï¼Œè®¡æ•°å°±ä¼šé€’å¢ï¼Œè¿™ä¸ªçº¿ç¨‹å…è®¸ç»§ç»­è¿›è¡Œã€‚çº¿ç¨‹è°ƒç”¨ <code>ReleaseMutex</code> å°†å¯¼è‡´è®¡æ•°é€’å‡ã€‚åªæœ‰è®¡æ•°å˜æˆ 0ï¼Œå¦ä¸€ä¸ªçº¿ç¨‹æ‰èƒ½æˆä¸ºè¯¥ <code>Mutex</code> çš„æ‰€æœ‰è€…ã€‚é€šå¸¸ï¼Œå½“ä¸€ä¸ªæ–¹æ³•è·å–äº†ä¸€ä¸ªé”ï¼Œç„¶åè°ƒç”¨ä¹Ÿéœ€è¦é”çš„å¦ä¸€ä¸ªæ–¹æ³•ï¼Œå°±éœ€è¦ä¸€ä¸ªé€’å½’é”ã€‚ç”±äº <code>Mutex</code> å¯¹è±¡æ”¯æŒé€’å½’ï¼Œæ‰€ä»¥çº¿ç¨‹è·å–ä¸¤æ¬¡é”ï¼Œå°±è¦é‡Šæ”¾å®ƒä¸¤æ¬¡ã€‚åœ¨æ­¤ä¹‹åï¼Œå¦ä¸€ä¸ªçº¿ç¨‹æ‰èƒ½æ‹¥æœ‰è¿™ä¸ª <code>Mutex</code> ã€‚</p><div class="tags"><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> è¯»ä¹¦ç¬”è®°</a> <a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C#</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2023-02-10 21:46:10" itemprop="dateModified" datetime="2023-02-10T21:46:10+08:00">2023-02-10</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(ï¿£â–½ï¿£)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Sakupinera WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Sakupinera Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Sakupinera PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Sakupinera <i class="ic i-at"><em>@</em></i>Sakupinera</li><li class="link"><strong>Post link: </strong><a href="http://sakupinera.github.io/2023/02/09/csharp/clr-via-csharp/Chapter%2029%20Primitive%20Thread%20Synchronization%20Constructs/" title="CLR via C# - Chapter 29 Primitive Thread Synchronization">http://sakupinera.github.io/2023/02/09/csharp/clr-via-csharp/Chapter 29 Primitive Thread Synchronization Constructs/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/02/08/csharp/clr-via-csharp/Chapter%2028%20IO-Bound%20Asynchronous%20Operations/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giciusoyjnj219g0u0x56.jpg" title="CLR via C# - Chapter 28 IO-Bound Asynchronous Operations"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 28 IO-Bound Asynchronous Operations</h3></a></div><div class="item right"><a href="/2023/02/10/csharp/clr-via-csharp/Chapter%2030%20Hybrid%20Thread%20Synchronization%20Constructs/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclx29mstj20zk0m8hdt.jpg" title="CLR via C# - Chapter 30 Hybrid Thread Synchronization"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 30 Hybrid Thread Synchronization</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-29-primitive-thread-synchronization-constructs"><span class="toc-number">1.</span> <span class="toc-text">Chapter 29 Primitive Thread Synchronization Constructs</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#class-libraries-and-thread-safety"><span class="toc-number">1.1.</span> <span class="toc-text">Class Libraries and Thread Safety</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#primitive-user-mode-and-kernel-mode-constructs"><span class="toc-number">1.2.</span> <span class="toc-text">Primitive User-Mode and Kernel-Mode Constructs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#user-mode-constructs"><span class="toc-number">1.3.</span> <span class="toc-text">User-Mode Constructs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile-constructs"><span class="toc-number">1.3.1.</span> <span class="toc-text">Volatile Constructs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cs-support-for-volatile-fields"><span class="toc-number">1.3.2.</span> <span class="toc-text">C#â€™s Support for Volatile Fields</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#interlocked-constructs"><span class="toc-number">1.3.3.</span> <span class="toc-text">Interlocked Constructs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#implementing-a-simple-spin-lock"><span class="toc-number">1.3.4.</span> <span class="toc-text">Implementing a Simple Spin Lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#the-interlocked-anything-pattern"><span class="toc-number">1.3.5.</span> <span class="toc-text">The Interlocked Anything Pattern</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kernel-mode-constructs"><span class="toc-number">1.4.</span> <span class="toc-text">Kernel-Mode Constructs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#event-constructs"><span class="toc-number">1.4.1.</span> <span class="toc-text">Event Constructs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#semaphore-constructs"><span class="toc-number">1.4.2.</span> <span class="toc-text">Semaphore Constructs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mutex-constructs"><span class="toc-number">1.4.3.</span> <span class="toc-text">Mutex Constructs</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"><ul><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/" rel="bookmark" title="CLR via C# - Chapter 1 The CLRâ€™s Execution Model">CLR via C# - Chapter 1 The CLRâ€™s Execution Model</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/" rel="bookmark" title="CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types">CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%203%20Shared%20Assemblies%20and%20Strongly%20Named%20Assemblies/" rel="bookmark" title="CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies">CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies</a></li><li><a href="/2022/09/27/csharp/clr-via-csharp/Chapter%204%20Type%20Fundamentals/" rel="bookmark" title="CLR via C# - Chapter 4 Type Fundamentals">CLR via C# - Chapter 4 Type Fundamentals</a></li><li><a href="/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/" rel="bookmark" title="CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals">CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals</a></li><li><a href="/2022/10/21/csharp/clr-via-csharp/Chapter%206%20Type%20and%20Member%20Basics/" rel="bookmark" title="CLR via C# - Chapter 6 Type and Member Basics">CLR via C# - Chapter 6 Type and Member Basics</a></li><li><a href="/2022/10/24/csharp/clr-via-csharp/Chapter%207%20Constants%20and%20Fields/" rel="bookmark" title="CLR via C# - Chapter 7 Constants and Fields">CLR via C# - Chapter 7 Constants and Fields</a></li><li><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" rel="bookmark" title="CLR via C# - Chapter 8 Methods">CLR via C# - Chapter 8 Methods</a></li><li><a href="/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/" rel="bookmark" title="CLR via C# - Chapter 9 Parameters">CLR via C# - Chapter 9 Parameters</a></li><li><a href="/2022/10/28/csharp/clr-via-csharp/Chapter%2010%20Properties/" rel="bookmark" title="CLR via C# - Chapter 10 Properties">CLR via C# - Chapter 10 Properties</a></li><li><a href="/2022/10/29/csharp/clr-via-csharp/Chapter%2011%20Events/" rel="bookmark" title="CLR via C# - Chapter 11 Events">CLR via C# - Chapter 11 Events</a></li><li><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" rel="bookmark" title="CLR via C# - Chapter 12 Generics">CLR via C# - Chapter 12 Generics</a></li><li><a href="/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/" rel="bookmark" title="CLR via C# - Chapter 13 Interfaces">CLR via C# - Chapter 13 Interfaces</a></li><li><a href="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/" rel="bookmark" title="CLR via C# - Chapter 14 Chars, Strings, and Working with Text">CLR via C# - Chapter 14 Chars, Strings, and Working with Text</a></li><li><a href="/2022/11/17/csharp/clr-via-csharp/Chapter%2015%20Enumerated%20Types%20and%20Bit%20Flags/" rel="bookmark" title="CLR via C# - Chapter 15 Enumerated Types and Bit Flags">CLR via C# - Chapter 15 Enumerated Types and Bit Flags</a></li><li><a href="/2022/11/19/csharp/clr-via-csharp/Chapter%2016%20Arrays/" rel="bookmark" title="CLR via C# - Chapter 16 Arrays">CLR via C# - Chapter 16 Arrays</a></li><li><a href="/2022/11/21/csharp/clr-via-csharp/Chapter%2017%20Delegates/" rel="bookmark" title="CLR via C# - Chapter 17 Delegates">CLR via C# - Chapter 17 Delegates</a></li><li><a href="/2022/11/22/csharp/clr-via-csharp/Chapter%2018%20Custom%20Attributes/" rel="bookmark" title="CLR via C# - Chapter 18 Custom Attributes">CLR via C# - Chapter 18 Custom Attributes</a></li><li><a href="/2022/11/23/csharp/clr-via-csharp/Chapter%2019%20Nullable%20Value%20Types/" rel="bookmark" title="CLR via C# - Chapter 19 Nullable Value Types">CLR via C# - Chapter 19 Nullable Value Types</a></li><li><a href="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/" rel="bookmark" title="CLR via C# - Chapter 20 Exceptions and State Management">CLR via C# - Chapter 20 Exceptions and State Management</a></li><li><a href="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/" rel="bookmark" title="CLR via C# - Chapter 21 The Managed Heap and Garbage  Collection">CLR via C# - Chapter 21 The Managed Heap and Garbage Collection</a></li><li><a href="/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/" rel="bookmark" title="CLR via C# - Chapter 22 CLR Hosting and AppDomains">CLR via C# - Chapter 22 CLR Hosting and AppDomains</a></li><li><a href="/2022/11/29/csharp/clr-via-csharp/Chapter%2023%20Assembly%20Loading%20and%20Reflection/" rel="bookmark" title="CLR via C# - Chapter 23 Assembly Loading and Reflection">CLR via C# - Chapter 23 Assembly Loading and Reflection</a></li><li><a href="/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/" rel="bookmark" title="CLR via C# - Chapter 24 Runtime Serialization">CLR via C# - Chapter 24 Runtime Serialization</a></li><li><a href="/2022/12/06/csharp/clr-via-csharp/Chapter%2025%20Interoperating%20with%20WinRT%20%20Components/" rel="bookmark" title="CLR via C# - Chapter 25 Interoperating with WinRT Components">CLR via C# - Chapter 25 Interoperating with WinRT Components</a></li><li><a href="/2023/02/06/csharp/clr-via-csharp/Chapter%2026%20Thread%20Basics/" rel="bookmark" title="CLR via C# - Chapter 26 Thread Basics">CLR via C# - Chapter 26 Thread Basics</a></li><li><a href="/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations">CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations</a></li><li><a href="/2023/02/08/csharp/clr-via-csharp/Chapter%2028%20IO-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 28 IO-Bound Asynchronous Operations">CLR via C# - Chapter 28 IO-Bound Asynchronous Operations</a></li><li class="active"><a href="/2023/02/09/csharp/clr-via-csharp/Chapter%2029%20Primitive%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 29 Primitive Thread Synchronization">CLR via C# - Chapter 29 Primitive Thread Synchronization</a></li><li><a href="/2023/02/10/csharp/clr-via-csharp/Chapter%2030%20Hybrid%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 30 Hybrid Thread Synchronization">CLR via C# - Chapter 30 Hybrid Thread Synchronization</a></li></ul></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sakupinera" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Sakupinera</p><div class="description" itemprop="description">ä¿æŒä½ çš„å†³å¿ƒï¼</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">89</span> <span class="name">posts</span></a></div><div class="item categories"><a href="/categories/"><span class="count">17</span> <span class="name">categories</span></a></div><div class="item tags"><a href="/tags/"><span class="count">8</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nha3VwaW5lcmE=" title="https:&#x2F;&#x2F;github.com&#x2F;sakupinera"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9zYWt1cGluZXJh" title="https:&#x2F;&#x2F;twitter.com&#x2F;sakupinera"><i class="ic i-twitter"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQwNzIyOTA3MQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;407229071"><i class="ic i-cloud-music"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMjIzMDczOTg/c3BtX2lkX2Zyb209MzMzLjEwMDcuMC4w" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;22307398?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li><li class="item"><a href="/games/" rel="section"><i class="ic i-flag"></i>games</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-person"></i>About</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/02/08/csharp/clr-via-csharp/Chapter%2028%20IO-Bound%20Asynchronous%20Operations/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/02/10/csharp/clr-via-csharp/Chapter%2030%20Hybrid%20Thread%20Synchronization%20Constructs/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/21/csharp/clr-via-csharp/Chapter%2017%20Delegates/" title="CLR via C# - Chapter 17 Delegates">CLR via C# - Chapter 17 Delegates</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/UnityShader/" title="In UnityShader">UnityShader</a></div><span><a href="/2022/09/19/computer-graphics/unityshader/%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/" title="UnityShader - æ¸²æŸ“æµæ°´çº¿">UnityShader - æ¸²æŸ“æµæ°´çº¿</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2022/12/13/cpp/cpp-primer/Chapter%205%20Statements/" title="C++ Primer - Chapter 5 Statements">C++ Primer - Chapter 5 Statements</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/22/csharp/clr-via-csharp/Chapter%2018%20Custom%20Attributes/" title="CLR via C# - Chapter 18 Custom Attributes">CLR via C# - Chapter 18 Custom Attributes</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2023/01/09/cpp/cpp-primer/Chapter%2017%20Specialized%20Library%20Facilities/" title="C++ Primer - Chapter 17 Specialized Library Facilities">C++ Primer - Chapter 17 Specialized Library Facilities</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CSharp-in-a-Nutshell/" title="In CSharp-in-a-Nutshell">CSharp-in-a-Nutshell</a></div><span><a href="/2022/09/01/csharp/csharp-in-a-nutshell/%E7%AC%AC12%E7%AB%A0%20%E5%AF%B9%E8%B1%A1%E9%94%80%E6%AF%81%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" title="C# in a Nutshell - ç¬¬12ç«  å¯¹è±¡é”€æ¯ä¸åƒåœ¾å›æ”¶">C# in a Nutshell - ç¬¬12ç«  å¯¹è±¡é”€æ¯ä¸åƒåœ¾å›æ”¶</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/08/28/linux/learn-linux/%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/" title="LearnLinux - ç”¨æˆ·å’Œç”¨æˆ·ç»„ç®¡ç†">LearnLinux - ç”¨æˆ·å’Œç”¨æˆ·ç»„ç®¡ç†</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2023/01/05/cpp/cpp-primer/Chapter%2013%20Copy%20Control/" title="C++ Primer - Chapter 13 Copy Control">C++ Primer - Chapter 13 Copy Control</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/08/28/linux/learn-linux/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/" title="LearnLinux - æ–‡ä»¶ç³»ç»Ÿç®¡ç†">LearnLinux - æ–‡ä»¶ç³»ç»Ÿç®¡ç†</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/" title="CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals">CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 â€“ <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Sakupinera @ Hanamai Sora</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="Symbols count total">2.2m words</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="Reading time total">34:05</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/02/09/csharp/clr-via-csharp/Chapter 29 Primitive Thread Synchronization Constructs/",favicon:{show:"ï¼ˆâ—Â´3ï½€â—ï¼‰Goooood",hide:"(Â´Ğ”ï½€)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/shifuku.model.json"},display:{position:"left",width:250,height:500},mobile:{show:!1},react:{opacity:.9},log:!1})</script></body></html>