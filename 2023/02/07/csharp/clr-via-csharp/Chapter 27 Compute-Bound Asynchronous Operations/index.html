<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sakupinera" href="http://sakupinera.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sakupinera" href="http://sakupinera.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sakupinera" href="http://sakupinera.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="è¯»ä¹¦ç¬”è®°,C#"><link rel="canonical" href="http://sakupinera.github.io/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/"><title>CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations - CLR-via-CSharp - CSharp | Hanamai Sora = Sakupinera</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations</h1><div class="meta"><span class="item" title="Created: 2023-02-07 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2023-02-07T00:00:00+08:00">2023-02-07</time> </span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">Symbols count in article</span> <span>85k</span> <span class="text">words</span> </span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">Reading time</span> <span>1:17</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hanamai Sora</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s2.loli.net/2023/03/08/AK1D84aqsYghTOC.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/Z2QTWRnpq3aDLdM.png"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/tNhsmAqoTDncM1b.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/y7LRpQIrAdzbUek.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/IFz2iyDlkbhZKqV.png"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/udCBOQsY6PwAW1g.png"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/" itemprop="item" rel="index" title="In CSharp"><span itemprop="name">CSharp</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/CLR-via-CSharp/" itemprop="item" rel="index" title="In CLR-via-CSharp"><span itemprop="name">CLR-via-CSharp</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://sakupinera.github.io/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Sakupinera"><meta itemprop="description" content=", ä¿æŒä½ çš„å†³å¿ƒï¼"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakupinera"></span><div class="body md" itemprop="articleBody"><h1 id="chapter-27-compute-bound-asynchronous-operations"><a class="anchor" href="#chapter-27-compute-bound-asynchronous-operations">#</a> Chapter 27 Compute-Bound Asynchronous Operations</h1><h2 id="introducing-the-clrs-thread-pool"><a class="anchor" href="#introducing-the-clrs-thread-pool">#</a> Introducing the CLRâ€™s Thread Pool</h2><blockquote><p>As stated in the previous chapter, creating and destroying a thread is an expensive operation in terms of time. In addition, having lots of threads wastes memory resources and also hurts performance due to the operating system having to schedule and context switch between the runnable threads. To improve this situation, the CLR contains code to manage its own thread pool. You can think of a thread pool as being a set of threads that are available for your applicationâ€™s own use. There is one thread pool per CLR; this thread pool is shared by all AppDomains controlled by that CLR. If multiple CLRs load within a single process, then each CLR has its own thread pool.</p></blockquote><blockquote><p>When the CLR initializes, the thread pool has no threads in it. Internally, the thread pool maintains a queue of operation requests. When your application wants to perform an asynchronous operation, you call some method that appends an entry into the thread poolâ€™s queue. The thread poolâ€™s code will extract entries from this queue and dispatch the entry to a thread pool thread. If there are no threads in the thread pool, a new thread will be created. Creating a thread has a performance hit associated with it (as already discussed). However, when a thread pool thread has completed its task, the thread is not destroyed; instead, the thread is returned to the thread pool, where it sits idle waiting to respond to another request. Because the thread doesnâ€™t destroy itself, there is no added performance hit.</p></blockquote><blockquote><p>If your application makes many requests of the thread pool, the thread pool will try to service all of the requests by using just this one thread. However, if your application is queuing up several requests faster than the thread pool thread can handle them, additional threads will be created. Your application will eventually get to a point at which all of its requests can be handled by a small number of threads, so the thread pool should have no need to create a lot of threads.</p></blockquote><blockquote><p>If your application stops making requests of the thread pool, the pool may have a lot of threads in it that are doing nothing. This is wasteful of memory resources. So when a thread pool thread has been idle with nothing to do for some period of time (subject to change with different versions of the CLR), the thread wakes itself up and kills itself to free up resources. As the thread is killing itself, there is a performance hit. However, this probably doesnâ€™t matter, because the thread is killing itself because it has been idle, which means that your application isnâ€™t performing a lot of work.</p></blockquote><blockquote><p>The great thing about the thread pool is that it manages the tension between having a few threads, to keep from wasting resources, and having more threads, to take advantage of multiprocessors, hyperthreaded processors, and multi-core processors. And the thread pool is heuristic. If your application needs to perform many tasks and CPUs are available, the thread pool creates more threads. If your applicationâ€™s workload decreases, the thread pool threads kill themselves.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šåˆ›å»ºå’Œé”€æ¯çº¿ç¨‹æ˜¯ä¸€ä¸ªæ˜‚è´µçš„æ“ä½œï¼Œè¦è€—è´¹å¤§é‡æ—¶é—´ã€‚å¦å¤–ï¼Œå¤ªå¤šçš„çº¿ç¨‹ä¼šæµªè´¹å†…å­˜èµ„æºã€‚ç”±äºæ“ä½œç³»ç»Ÿå¿…é¡»è°ƒåº¦å¯è¿è¡Œçš„çº¿ç¨‹å¹¶æ‰§è¡Œä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œæ‰€ä»¥å¤ªå¤šçš„çº¿ç¨‹è¿˜å¯¹æ€§èƒ½ä¸åˆ©ã€‚ä¸ºäº†æ”¹å–„è¿™ä¸ªæƒ…å†µï¼ŒCLR åŒ…å«äº†ä»£ç æ¥ç®¡ç†å®ƒè‡ªå·±çš„çº¿ç¨‹æ± ã€‚æ¯ CLR ä¸€ä¸ªçº¿ç¨‹æ± ï¼Œè¿™ä¸ªçº¿ç¨‹æ± ç”± CLR æ§åˆ¶çš„æ‰€æœ‰ AppDomain å…±äº«ã€‚å¦‚æœä¸€ä¸ªè¿›ç¨‹ä¸­åŠ è½½äº†å¤šä¸ª CLRï¼Œé‚£ä¹ˆæ¯ä¸ª CLR éƒ½æœ‰å®ƒè‡ªå·±çš„çº¿ç¨‹æ± ã€‚CLR åˆå§‹åŒ–æ—¶ï¼Œçº¿ç¨‹æ± ä¸­æ˜¯æ²¡æœ‰çº¿ç¨‹çš„ã€‚åœ¨å†…éƒ¨ï¼Œçº¿ç¨‹æ± ç»´æŠ¤äº†ä¸€ä¸ªæ“ä½œè¯·æ±‚é˜Ÿåˆ—ã€‚åº”ç”¨ç¨‹åºæ‰§è¡Œä¸€ä¸ªå¼‚æ­¥æ“ä½œæ—¶ï¼Œå°±è°ƒç”¨æŸä¸ªæ–¹æ³•ï¼Œå°†ä¸€ä¸ªè®°å½•é¡¹ï¼ˆentryï¼‰è¿½åŠ åˆ°çº¿ç¨‹æ± çš„é˜Ÿåˆ—ä¸­ã€‚çº¿ç¨‹æ± çš„ä»£ç ä»è¿™ä¸ªé˜Ÿåˆ—ä¸­æå–è®°å½•é¡¹ï¼Œå°†è¿™ä¸ªè®°å½•é¡¹æ´¾å‘ï¼ˆdispatchï¼‰ç»™ä¸€ä¸ªçº¿ç¨‹æ± çº¿ç¨‹ã€‚ç„¶è€Œï¼Œå½“çº¿ç¨‹æ± çº¿ç¨‹å®Œæˆä»»åŠ¡åï¼Œçº¿ç¨‹ä¸ä¼šè¢«é”€æ¯ã€‚ç›¸åï¼Œçº¿ç¨‹ä¼šè¿”å›çº¿ç¨‹æ± ï¼Œåœ¨é‚£é‡Œè¿›å…¥ç©ºé—²çŠ¶æ€ï¼Œç­‰å¾…å“åº”å¦ä¸€ä¸ªè¯·æ±‚ã€‚ç”±äºçº¿ç¨‹ä¸é”€æ¯è‡ªèº«ï¼Œæ‰€ä»¥ä¸å†äº§ç”Ÿé¢å¤–çš„æ€§èƒ½æŸå¤±ã€‚å½“åº”ç”¨ç¨‹åºå‘å‡ºè¯·æ±‚çš„é€Ÿåº¦è¶…è¿‡äº†çº¿ç¨‹æ± çº¿ç¨‹å¤„ç†å®ƒä»¬çš„é€Ÿåº¦ï¼Œå°±ä¼šåˆ›å»ºé¢å¤–çš„çº¿ç¨‹ã€‚å½“ä¸€ä¸ªçº¿ç¨‹æ± çº¿ç¨‹é—²ç€æ²¡äº‹å„¿ä¸€æ®µæ—¶é—´ä¹‹å (ä¸åŒç‰ˆæœ¬çš„ CLR å¯¹è¿™ä¸ªæ—¶é—´çš„å®šä¹‰ä¸åŒ)ï¼Œçº¿ç¨‹ä¼šè‡ªå·±é†’æ¥ç»ˆæ­¢è‡ªå·±ä»¥é‡Šæ”¾èµ„æºã€‚çº¿ç¨‹ç»ˆæ­¢è‡ªå·±ä¼šäº§ç”Ÿä¸€å®šçš„æ€§èƒ½æŸå¤±ã€‚ç„¶è€Œï¼Œçº¿ç¨‹ç»ˆæ­¢è‡ªå·±æ˜¯å› ä¸ºå®ƒé—²çš„æ…Œï¼Œè¡¨æ˜åº”ç”¨ç¨‹åºæœ¬èº«å°±ä¹ˆæœ‰åšå¤ªå¤šçš„äº‹æƒ…ï¼Œæ‰€ä»¥è¿™ä¸ªæ€§èƒ½æŸå¤±å…³ç³»ä¸å¤§ã€‚çº¿ç¨‹æ± å¯ä»¥åªå®¹çº³å°‘é‡çº¿ç¨‹ï¼Œä»è€Œé¿å…æµªè´¹èµ„æºï¼›ä¹Ÿå¯ä»¥å®¹çº³æ›´å¤šçš„çº¿ç¨‹ï¼Œä»¥åˆ©ç”¨å¤šå¤„ç†å™¨ã€è¶…çº¿ç¨‹å¤„ç†å™¨å’Œå¤šæ ¸å¤„ç†å™¨ã€‚å®ƒèƒ½åœ¨è¿™ä¸¤ç§ä¸åŒçš„çŠ¶æ€ä¹‹é—´ä»å®¹åœ°åˆ‡æ¢ã€‚çº¿ç¨‹æ± æ˜¯å¯å‘å¼çš„ã€‚å¦‚æœåº”ç”¨ç¨‹åºéœ€è¦æ‰§è¡Œè®¸å¤šä»»åŠ¡ï¼ŒåŒæ—¶æœ‰å¯èƒ½çš„ CPUï¼Œé‚£ä¹ˆçº¿ç¨‹æ± ä¼šåˆ›å»ºæ›´å¤šçš„çº¿ç¨‹ã€‚åº”ç”¨ç¨‹åºè´Ÿè½½å‡è½»ï¼Œçº¿ç¨‹æ± çº¿ç¨‹å°±ç»ˆæ­¢å®ƒä»¬è‡ªå·±ã€‚</p><h2 id="performing-a-simple-compute-bound-operation"><a class="anchor" href="#performing-a-simple-compute-bound-operation">#</a> Performing a Simple Compute-Bound Operation</h2><blockquote><p>To queue an asynchronous compute-bound operation to the thread pool, you typically call one of the following methods defined by the ThreadPool class.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name">Boolean</span> <span class="token function">QueueUserWorkItem</span><span class="token punctuation">(</span><span class="token class-name">WaitCallback</span> callBack<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name">Boolean</span> <span class="token function">QueueUserWorkItem</span><span class="token punctuation">(</span><span class="token class-name">WaitCallback</span> callBack<span class="token punctuation">,</span> <span class="token class-name">Object</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>These methods queue a â€œwork itemâ€ and optional state data to the thread poolâ€™s queue, and then all of these methods return immediately. A work item is simply a method identified by the callback parameter that will be called by a thread pool thread. The method can be passed a single parameter specified via the state (the state data) argument. The version of QueueUserWorkItem without the state parameter passes null to the callback method. Eventually, some thread in the pool will process the work item, causing your method to be called. The callback method you write must match the System.Threading.WaitCallback delegate type, which is defined as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">delegate</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">WaitCallback</span><span class="token punctuation">(</span><span class="token class-name">Object</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>ğŸ’¡æ³¨æ„ï¼š <code>WaitCallback</code> å§”æ‰˜ã€ <code>TimerCallback</code> å§”æ‰˜ (å‚è§æœ¬ç«  27.8 èŠ‚ â€œæ‰§è¡Œå®šæ—¶è®¡ç®—é™åˆ¶æ“ä½œâ€ çš„è®¨è®º) å’Œ <code>ParameterizedThreadStart</code> å§”æ‰˜ (åœ¨ç¬¬ 26 ç«  â€œçº¿ç¨‹åŸºç¡€â€ ä¸­è®¨è®º) ç­¾åå®Œå…¨ä¸€è‡´ã€‚å®šä¹‰å’Œè¯¥ç­¾ååŒ¹é…çš„æ–¹æ³•åï¼Œä½¿ç”¨ <code>ThreadPool.QueueUserWorkItem</code> ã€ <code>System.Threading.Timer</code> å’Œ <code>System.Threading.Thread</code> å¯¹è±¡éƒ½å¯è°ƒç”¨è¯¥æ–¹æ³•ã€‚</p><blockquote><p>The following code demonstrates how to have a thread pool thread call a method asynchronously.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Threading</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Main thread: queuing an asynchronous operation"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> ThreadPool<span class="token punctuation">.</span><span class="token function">QueueUserWorkItem</span><span class="token punctuation">(</span>ComputeBoundOp<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Main thread: Doing other work here..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> Thread<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Simulating other work (10 seconds) </span></pre></td></tr><tr><td data-num="9"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Hit &lt;Enter> to end this program..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// This method's signature must match the WaitCallback delegate </span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ComputeBoundOp</span><span class="token punctuation">(</span><span class="token class-name">Object</span> state<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token comment">// This method is executed by a thread pool thread </span></pre></td></tr><tr><td data-num="15"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"In ComputeBoundOp: state=&#123;0&#125;"</span><span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> Thread<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Simulates other work (1 second) </span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token comment">// When this method returns, the thread goes back </span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token comment">// to the pool and waits for another task </span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When I compile and run this code, I get the following output.</p></blockquote><pre><code class="language-cmd">Main thread: queuing an asynchronous operation 
Main thread: Doing other work here... 
In ComputeBoundOp: state=5
</code></pre><blockquote><p>And, sometimes when I run this code, I get this output.</p></blockquote><pre><code class="language-cmd">Main thread: queuing an asynchronous operation 
In ComputeBoundOp: state=5 
Main thread: Doing other work here...
</code></pre><blockquote><p>The difference in the order of the lines in the output is attributed to the fact that the two methods are running asynchronously with respect to one another. The Windows scheduler determines which thread to schedule first, or it may schedule them both simultaneously if the application is running on a multi-CPU machine.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šä¸€æ—¦å›è°ƒæ–¹æ³•æŠ›å‡ºæœªå¤„ç†çš„å¼‚å¸¸ï¼ŒCLR ä¼šç»ˆæ­¢è¿›ç¨‹ (é™¤éå®¿ä¸»å¼ºåŠ äº†å®ƒè‡ªå·±çš„ç­–ç•¥)ã€‚æœªå¤„ç†å¼‚å¸¸çš„è¯¦æƒ…å·²åœ¨ç¬¬ 20 ç«  â€œå¼‚å¸¸å’ŒçŠ¶æ€ç®¡ç†â€ è¿›è¡Œäº†è®¨è®ºã€‚</p><p>ğŸ’¡æ³¨æ„ï¼šå¯¹äº Windows Store åº”ç”¨ï¼Œ <code>System.Threading.ThreadPool</code> ç±»æ˜¯æ²¡æœ‰å…¬å¼€çš„ã€‚ä½†åœ¨ä½¿ç”¨ <code>System.Threading.Tasks</code> å‘½åç©ºé—´ä¸­çš„ç±»å‹æ—¶ï¼Œè¿™ä¸ªç±»è¢«é—´æ¥åœ°ä½¿ç”¨ (è¯¦æƒ…å‚è§æœ¬ç« ç¨åçš„ 27.5 èŠ‚ â€œä»»åŠ¡â€)ã€‚</p><p>ğŸ’¡å°ç»“ï¼šè¦å°†ä¸€ä¸ªå¼‚æ­¥çš„è®¡ç®—é™åˆ¶æ“ä½œæ”¾åˆ°çº¿ç¨‹æ± çš„é˜Ÿåˆ—ä¸­ï¼Œé€šå¸¸å¯ä»¥è°ƒç”¨ <code>ThreadPool</code> ç±»å®šä¹‰çš„ <code>QueueUserWorkItem</code> æ–¹æ³•åŠå…¶é‡è½½ï¼Œè¿™äº›æ–¹æ³•å‘çº¿ç¨‹æ± çš„é˜Ÿåˆ—æ·»åŠ ä¸€ä¸ª â€œå·¥ä½œé¡¹â€(work item) ä»¥åŠå¯é€‰çš„çŠ¶æ€æ•°æ®ã€‚ç„¶åï¼Œæ‰€æœ‰æ–¹æ³•ä¼šç«‹å³è¿”å›ã€‚å·¥ä½œé¡¹å…¶å®å°±æ˜¯ç”± <code>callBack</code> å‚æ•°æ ‡è¯†çš„ä¸€ä¸ªæ–¹æ³•ï¼Œè¯¥æ–¹æ³•å°†ç”±çº¿ç¨‹æ± çº¿ç¨‹è°ƒç”¨ã€‚å¯å‘æ–¹æ³•ä¼ é€’ä¸€ä¸ª <code>state</code> å®å‚ (çŠ¶æ€æ•°æ®)ã€‚æ—  <code>state</code> å‚æ•°çš„é‚£ä¸ªç‰ˆæœ¬çš„ <code>QueueUserWorkItem</code> åˆ™å‘å›è°ƒæ–¹æ³•ä¼ é€’ <code>null</code> ã€‚æœ€ç»ˆï¼Œæ± ä¸­çš„æŸä¸ªçº¿ç¨‹ä¼šå¤„ç†å·¥ä½œé¡¹ï¼Œé€ æˆä½ æŒ‡å®šçš„æ–¹æ³•è¢«è°ƒç”¨ã€‚</p><h2 id="execution-contexts"><a class="anchor" href="#execution-contexts">#</a> Execution Contexts</h2><blockquote><p>Every thread has an execution context data structure associated with it. The execution context includes things such as security settings (compressed stack, Threadâ€™s Principal property, and Windows identity), host settings (see System.Threading.HostExecutionContextManager), and logical call context data (see System.Runtime.Remoting.Messaging.CallContextâ€™s LogicalSetData and LogicalGetData methods). When a thread executes code, some operations are affected by the values of the threadâ€™s execution context settings. This is certainly true for the security settings. Ideally, whenever a thread uses another (helper) thread to perform tasks, the issuing threadâ€™s execution context should flow (be copied) to the helper thread. This ensures that any operations performed by helper thread(s) are executing with the same security settings and host settings. It also ensures that any data stored in the initiating threadâ€™s logical call context is available to the helper thread.</p></blockquote><blockquote><p>By default, the CLR automatically causes the initiating threadâ€™s execution context to flow to any helper threads. This transfers context information to the helper thread, but it comes at a performance cost, because there is a lot of information in an execution context, and accumulating all of this information and then copying it for the helper thread takes a fair amount of time. If the helper thread then employs additional helper threads, then more execution context data structures have to be created and initialized as well.</p></blockquote><blockquote><p>In the System.Threading namespace, there is an ExecutionContext class that allows you to control how a threadâ€™s execution context flows from one thread to another. Here is what the class looks like.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">ExecutionContext</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IDisposable</span><span class="token punctuation">,</span> <span class="token class-name">ISerializable</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">SecurityCritical</span></span><span class="token punctuation">]</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">AsyncFlowControl</span> <span class="token function">SuppressFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">RestoreFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Boolean</span> <span class="token function">IsFlowSuppressed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// Less commonly used methods are not shown</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>You can use this class to suppress the flowing of an execution context, thereby improving your applicationâ€™s performance. The performance gains can be quite substantial for a server application. There is not much performance benefit for a client application, and the SuppressFlow method is marked with the [SecurityCritical] attribute, making it impossible to call in some client applications (like Microsoft Silverlight). Of course, you should suppress the flowing of execution context only if the helper thread does not need to access the context information. If the initiating threadâ€™s execution context does not flow to a helper thread, the helper thread will use whatever execution context it last associated with it. Therefore, the helper thread really shouldnâ€™t execute any code that relies on the execution context state (such as a userâ€™s Windows identity).</p></blockquote><blockquote><p>Here is an example showing how suppressing the flow of execution context affects data in a threadâ€™s logical call context when queuing a work item to the CLRâ€™s thread pool.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Put some data into the Main thread's logical call context</span></pre></td></tr><tr><td data-num="3"></td><td><pre> CallContext<span class="token punctuation">.</span><span class="token function">LogicalSetData</span><span class="token punctuation">(</span><span class="token string">"Name"</span><span class="token punctuation">,</span> <span class="token string">"Jeffrey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// Initiate some work to be done by a thread pool thread</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// The thread pool thread can access the logical call context data </span></pre></td></tr><tr><td data-num="6"></td><td><pre> ThreadPool<span class="token punctuation">.</span><span class="token function">QueueUserWorkItem</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="7"></td><td><pre> state <span class="token operator">=></span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Name=&#123;0&#125;"</span><span class="token punctuation">,</span> CallContext<span class="token punctuation">.</span><span class="token function">LogicalGetData</span><span class="token punctuation">(</span><span class="token string">"Name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Now, suppress the flowing of the Main thread's execution context</span></pre></td></tr><tr><td data-num="9"></td><td><pre> ExecutionContext<span class="token punctuation">.</span><span class="token function">SuppressFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// Initiate some work to be done by a thread pool thread</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// The thread pool thread CANNOT access the logical call context data</span></pre></td></tr><tr><td data-num="12"></td><td><pre> ThreadPool<span class="token punctuation">.</span><span class="token function">QueueUserWorkItem</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="13"></td><td><pre> state <span class="token operator">=></span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Name=&#123;0&#125;"</span><span class="token punctuation">,</span> CallContext<span class="token punctuation">.</span><span class="token function">LogicalGetData</span><span class="token punctuation">(</span><span class="token string">"Name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token comment">// Restore the flowing of the Main thread's execution context in case</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// it employs more thread pool threads in the future</span></pre></td></tr><tr><td data-num="16"></td><td><pre> ExecutionContext<span class="token punctuation">.</span><span class="token function">RestoreFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="18"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When I compile and run the preceding code, I get the following output.</p></blockquote><pre><code class="language-cmd">Name=Jeffrey
Name=
</code></pre><blockquote><p>Although this discussion has focused on suppressing the flow of execution context when calling ThreadPool.QueueUserWorkItem, this technique is also useful when using Task objects (discussed in the â€œTasksâ€ section of this chapter) and is also useful when initiating asynchronous I/O operations (discussed in Chapter 28, â€œI/O-Bound Asynchronous Operationsâ€).</p></blockquote><p>ğŸ’¡å°ç»“ï¼šæ¯ä¸ªçº¿ç¨‹éƒ½å…³è”äº†ä¸€ä¸ªæ‰§è¡Œä¸Šä¸‹æ–‡æ•°æ®ç»“æ„ã€‚æ‰§è¡Œä¸Šä¸‹æ–‡ï¼ˆexecution contextï¼‰åŒ…æ‹¬çš„ä¸œè¥¿æœ‰å®‰å…¨è®¾ç½®ï¼ˆå‹ç¼©æ ˆã€Thread çš„ Principal å±æ€§å’Œ Windows èº«ä»½ï¼‰ã€å®¿ä¸»è®¾ç½®ï¼ˆå‚è§ System.Threading.HostExecutionContextManagerï¼‰ä»¥åŠé€»è¾‘è°ƒç”¨ä¸Šä¸‹æ–‡æ•°æ®ï¼ˆå‚è§ System.Runtime.Remoting.Messaging.CallContext çš„ LogicalSetData å’Œ LogicalGetData æ–¹æ³•ï¼‰ã€‚çº¿ç¨‹æ‰§è¡Œå®ƒçš„æ“ä½œæ—¶ï¼Œä¸€äº›æ“ä½œä¼šæ”¶åˆ°çº¿ç¨‹æ‰§è¡Œä¸Šä¸‹æ–‡è®¾ç½®ï¼ˆå°¤å…¶æ˜¯å®‰å…¨è®¾ç½®ï¼‰çš„å½±å“ã€‚ç†æƒ³æƒ…å†µä¸‹ï¼Œæ¯å½“ä¸€ä¸ªçº¿ç¨‹ï¼ˆåˆå§‹çº¿ç¨‹ï¼‰ä½¿ç”¨å¦ä¸€ä¸ªçº¿ç¨‹ï¼ˆè¾…åŠ©çº¿ç¨‹ï¼‰æ‰§è¡Œä»»åŠ¡æ—¶ï¼Œå‰è€…çš„æ‰§è¡Œä¸Šä¸‹æ–‡åº”è¯¥æµå‘ï¼ˆå¤åˆ¶åˆ°ï¼‰è¾…åŠ©çº¿ç¨‹ã€‚è¿™å°±ç¡®ä¿äº†è¾…åŠ©çº¿ç¨‹æ‰§è¡Œçš„ä»»ä½•æ“ä½œä½¿ç”¨çš„æ˜¯ç›¸åŒçš„å®‰å…¨è®¾ç½®å’Œå®¿ä¸»è®¾ç½®ã€‚è¿˜ç¡®ä¿äº†åœ¨åˆå§‹çº¿ç¨‹çš„é€»è¾‘è°ƒç”¨ä¸Šä¸‹æ–‡ä¸­å­˜å‚¨çš„ä»»ä½•æ•°æ®éƒ½é€‚ç”¨äºè¾…åŠ©çº¿ç¨‹ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼ŒCLR è‡ªåŠ¨é€ æˆåˆå§‹çº¿ç¨‹çš„æ‰§è¡Œä¸Šä¸‹æ–‡ â€œæµå‘â€ ä»»ä½•è¾…åŠ©çº¿ç¨‹ã€‚è¿™é€ æˆå°†ä¸Šä¸‹æ–‡ä¿¡æ¯ä¼ ç»™è¾…åŠ©çº¿ç¨‹ï¼Œä½†è¿™ä¼šå¯¹æ€§èƒ½é€ æˆä¸€å®šå½±å“ã€‚è¿™æ˜¯å› ä¸ºæ‰§è¡Œä¸Šä¸‹æ–‡ä¸­åŒ…å«å¤§é‡ä¿¡æ¯ï¼Œè€Œæ”¶é›†æ‰€æœ‰è¿™äº›ä¿¡æ¯ï¼Œå†æŠŠå®ƒä»¬å¤åˆ¶åˆ°è¾…åŠ©çº¿ç¨‹ï¼Œè¦è€—è´¹ä¸å°‘æ—¶é—´ã€‚å¯ç”¨è¿™ä¸ªç±»é˜»æ­¢æ‰§è¡Œä¸Šä¸‹æ–‡æµåŠ¨ä»¥æå‡åº”ç”¨ç¨‹åºçš„æ€§èƒ½ã€‚å¯¹äºæœåŠ¡å™¨åº”ç”¨ç¨‹åºï¼Œæ€§èƒ½çš„æå‡å¯èƒ½éå¸¸æ˜¾è‘—ã€‚ä½†å®¢æˆ·ç«¯åº”ç”¨ç¨‹åºçš„æ€§èƒ½æå‡ä¸äº†å¤šå°‘ã€‚å¦å¤–ï¼Œç”±äº <code>SuppressFlow</code> æ–¹æ³•ç”¨ <code>[SecurityCritical]</code> ç‰¹æ€§è¿›è¡Œäº†æ ‡è¯†ï¼Œæ‰€ä»¥åœ¨æŸäº›å®¢æˆ·ç«¯åº”ç”¨ç¨‹åº (æ¯”å¦‚ Silverlight) ä¸­æ˜¯æ— æ³•è°ƒç”¨çš„ã€‚å½“ç„¶ï¼Œåªæœ‰åœ¨è¾…åŠ©çº¿ç¨‹ä¸éœ€è¦æˆ–è€…ä¸è®¿é—®ä¸Šä¸‹æ–‡ä¿¡æ¯æ—¶ï¼Œæ‰åº”é˜»æ­¢æ‰§è¡Œä¸Šä¸‹æ–‡çš„æµåŠ¨ã€‚å½“ç„¶ï¼Œåªæœ‰åœ¨è¾…åŠ©çº¿ç¨‹ä¸éœ€è¦æˆ–è€…ä¸è®¿é—®ä¸Šä¸‹æ–‡ä¿¡æ¯æ—¶ï¼Œæ‰åº”é˜»æ­¢æ‰§è¡Œä¸Šä¸‹æ–‡çš„æµåŠ¨ã€‚å¦‚æœåˆå§‹çº¿ç¨‹çš„æ‰§è¡Œä¸Šä¸‹æ–‡ä¸æµå‘è¾…åŠ©çº¿ç¨‹ï¼Œè¾…åŠ©çº¿ç¨‹ä¼šä½¿ç”¨ä¸Šä¸€æ¬¡å’Œå®ƒå…³è”çš„ä»»æ„æ‰§è¡Œä¸Šä¸‹æ–‡ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè¾…åŠ©çº¿ç¨‹ä¸åº”æ‰§è¡Œä»»ä½•è¦ä¾èµ–äºæ‰§è¡Œä¸Šä¸‹æ–‡çŠ¶æ€ (ä¸å¦‚ç”¨æˆ·çš„ Windows èº«ä»½) çš„ä»£ç ã€‚</p><h2 id="cooperative-cancellation-and-timeout"><a class="anchor" href="#cooperative-cancellation-and-timeout">#</a> Cooperative Cancellation and Timeout</h2><blockquote><p>The Microsoft .NET Framework offers a standard pattern for canceling operations. This pattern is cooperative, meaning that the operation that you want to cancel has to explicitly support being canceled. In other words, the code performing the operation that you want to cancel and the code that attempts to cancel the operation must both use the types mentioned in this section. It is nice when long-running compute-bound operations offer cancellation, so you should consider adding cancellation to your own compute-bound operations. In this section, Iâ€™ll explain how to accomplish this. But, first, let me explain the two main types provided in the Framework Class Library (FCL) that are part of the standard cooperative cancellation pattern.</p></blockquote><blockquote><p>To cancel an operation, you must first create a System.Threading.CancellationTokenSource object. This class looks like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">CancellationTokenSource</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IDisposable</span></span> <span class="token punctuation">&#123;</span> <span class="token comment">// A reference type</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token function">CancellationTokenSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Boolean</span> IsCancellationRequested <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">CancellationToken</span> Token <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Internally, calls Cancel passing false</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Cancel</span><span class="token punctuation">(</span><span class="token class-name">Boolean</span> throwOnFirstException<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>This object contains all the states having to do with managing cancellation. After constructing a CancellationTokenSource (a reference type), one or more CancellationToken (a value type) instances can be obtained by querying its Token property and passed around to your operations that allow themselves to be canceled. Here are the most useful members of the CancellationToken value type.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">struct</span> <span class="token class-name">CancellationToken</span> <span class="token punctuation">&#123;</span> <span class="token comment">// A value type</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">CancellationToken</span> None <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// Very convenient</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Boolean</span> IsCancellationRequested <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// Called by non-Task invoked operations</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ThrowIfCancellationRequested</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Called by Task-invoked operations</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// WaitHandle is signaled when the CancellationTokenSource is canceled</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">WaitHandle</span> WaitHandle <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// GetHashCode, Equals, operator== and operator!= members are not shown</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Boolean</span> CanBeCanceled <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// Rarely used</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">CancellationTokenRegistration</span> <span class="token function">Register</span><span class="token punctuation">(</span><span class="token class-name">Action<span class="token punctuation">&lt;</span>Object<span class="token punctuation">></span></span> callback<span class="token punctuation">,</span> <span class="token class-name">Object</span> state<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token class-name">Boolean</span> useSynchronizationContext<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Simpler overloads not shown</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>A CancellationToken instance is a lightweight value type because it contains a single private field: a reference to its CancellationTokenSource object. A compute-bound operationâ€™s loop can periodically call CancellationTokenâ€™s IsCancellationRequested property to know if the loop should terminate early, thereby ending the compute-bound operation. Of course, the benefit here is that CPU time is no longer being wasted on an operation whose result you know youâ€™re not interested in. Now, let me put all this together with some sample code.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">CancellationDemo</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">CancellationTokenSource</span> cts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">CancellationTokenSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// Pass the CancellationToken and the number-to-count-to into the operation</span></pre></td></tr><tr><td data-num="5"></td><td><pre> ThreadPool<span class="token punctuation">.</span><span class="token function">QueueUserWorkItem</span><span class="token punctuation">(</span>o <span class="token operator">=></span> <span class="token function">Count</span><span class="token punctuation">(</span>cts<span class="token punctuation">.</span>Token<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Press &lt;Enter> to cancel the operation."</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> cts<span class="token punctuation">.</span><span class="token function">Cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// If Count returned already, Cancel has no effect on it</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// Cancel returns immediately, and the method continues running here...</span></pre></td></tr><tr><td data-num="10"></td><td><pre> </pre></td></tr><tr><td data-num="11"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Count</span><span class="token punctuation">(</span><span class="token class-name">CancellationToken</span> token<span class="token punctuation">,</span> <span class="token class-name">Int32</span> countTo<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> count <span class="token operator">&lt;</span>countTo<span class="token punctuation">;</span> count<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>token<span class="token punctuation">.</span>IsCancellationRequested<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Count is cancelled"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// Exit the loop to stop the operation</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre> Thread<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// For demo, waste some time</span></pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Count is done"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>ğŸ’¡æ³¨æ„ï¼šè¦æ‰§è¡Œä¸€ä¸ªä¸å…è®¸è¢«å–æ¶ˆçš„æ“ä½œï¼Œå¯å‘è¯¥æ“ä½œä¼ é€’é€šè¿‡è°ƒç”¨ <code>CancellationToken</code> çš„é™æ€ <code>None</code> å±æ€§è€Œè¿”å›çš„ <code>CancellationToken</code> ã€‚è¯¥å±æ€§è¿”å›ä¸€ä¸ªç‰¹æ®Šçš„ <code>CancellationToken</code> å®ä¾‹ï¼Œå®ƒä¸å’Œä»»ä½• <code>CancellationTokenSource</code> å¯¹è±¡å…³è” (å®ä¾‹çš„ç§æœ‰å­—æ®µä¸º <code>null</code> )ã€‚ç”±äºæ²¡æœ‰ <code>CancellationTokenSource</code> ï¼Œæ‰€ä»¥æ²¡æœ‰ä»£ç èƒ½è°ƒç”¨ <code>Cancel</code> ã€‚ä¸€ä¸ªæ“ä½œå¦‚æœæŸ¥è¯¢è¿™ä¸ªç‰¹æ®Š <code>CancellationToken</code> çš„ <code>IsCancellationRequested</code> å±æ€§ï¼Œå°†æ€»æ˜¯è¿”å› <code>false</code> ã€‚ä½¿ç”¨æŸä¸ªç‰¹æ®Š <code>CancellationToken</code> å®ä¾‹æŸ¥è¯¢ <code>CancellationToken</code> çš„ <code>CanBeCanceled</code> å±æ€§ï¼Œå±æ€§ä¼šè¿”å› <code>false</code> ã€‚ç›¸åï¼Œå¯¹äºé€šè¿‡æŸ¥è¯¢ <code>CancellationTokenSource</code> å¯¹è±¡çš„ <code>Token</code> å±æ€§è€Œè·å¾—çš„å…¶ä»–æ‰€æœ‰ <code>CancellationToken</code> å®ä¾‹ï¼Œè¯¥å±æ€§ ( <code>CancellationToken</code> ) éƒ½ä¼šè¿”å› <code>true</code> ã€‚</p><blockquote><p>If youâ€™d like, you can call CancellationTokenSourceâ€™s Register method to register one or more methods to be invoked when a CancellationTokenSource is canceled. To this method, you pass an Action delegate, a state value that will be passed to the callback via the delegate, and a Boolean indicating whether or not to invoke the delegate by using the calling threadâ€™s SynchronizationContext. If you pass false for the useSynchronizationContext parameter, then the thread that calls Cancel will invoke all the registered methods sequentially. If you pass true for the useSynchronizationContext parameter, then the callbacks are sent (as opposed to posted) to the captured SynchronizationContext object that governs which thread invokes the callback. The SynchronizationContext class is discussed more in the â€œApplications and Their Threading Modelsâ€ section in Chapter 28.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šå‘è¢«å–æ¶ˆçš„ <code>CancellationTokenSource</code> ç™»è®°ä¸€ä¸ªå›è°ƒæ–¹æ³•ï¼Œå°†ç”±è°ƒç”¨ <code>Register</code> çš„çº¿ç¨‹è°ƒç”¨å›è°ƒæ–¹æ³• (å¦‚æœä¸º <code>useSynchronizationContext</code> å‚æ•°ä¼ é€’äº† <code>true</code> å€¼ï¼Œå°±å¯èƒ½è¦é€šè¿‡è°ƒç”¨çº¿ç¨‹çš„ <code>SynchronizationContext</code> è¿›è¡Œ)ã€‚</p><blockquote><p>If Register is called multiple times, then multiple callback methods will be invoked. These callback methods could throw an unhandled exception. If you call CancellationTokenSourceâ€™s Cancel, passing it true, then the first callback method that throws an unhandled exception stops the other callback methods from executing, and the exception thrown will be thrown from Cancel as well. If you call Cancel passing it false, then all registered callback methods are invoked. Any unhandled exceptions that occur are added to a collection. After all callback methods have executed, if any of them threw an unhandled exception, then Cancel throws an AggregateException with its InnerExceptions property set to the collection of exception objects that were thrown. If no registered callback methods threw an unhandled exception, then Cancel simply returns without throwing any exception at all.</p></blockquote><p>ğŸ’¡é‡è¦æç¤ºï¼šæ²¡æœ‰åŠæ³•å°† <code>AggregateException</code> çš„ <code>InnerExceptions</code> é›†åˆä¸­çš„ä¸€ä¸ªå¼‚å¸¸å¯¹è±¡å’Œç‰¹çš„æ“ä½œå¯¹åº”èµ·æ¥ï¼›ä½ åªçŸ¥é“æŸä¸ªæ“ä½œå‡ºé”™ï¼Œå¹¶é€šè¿‡å¼‚å¸¸ç±»å‹çŸ¥é“å‡ºäº†ä»€ä¹ˆé”™ã€‚è¦è·Ÿè¸ªé”™è¯¯çš„å…·ä½“ä½ç½®ï¼Œéœ€è¦æ£€æŸ¥å¼‚å¸¸å¯¹è±¡çš„ <code>StackTrace</code> å±æ€§ï¼Œå¹¶æ‰‹åŠ¨æ‰«æä½ çš„æºä»£ç ã€‚</p><blockquote><p>CancellationTokenâ€™s Register method returns a CancellationTokenRegistration, which looks like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">struct</span> <span class="token class-name">CancellationTokenRegistration</span> <span class="token punctuation">:</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token type-list"><span class="token class-name">IEquatable<span class="token punctuation">&lt;</span>CancellationTokenRegistration<span class="token punctuation">></span></span><span class="token punctuation">,</span> <span class="token class-name">IDisposable</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// GetHashCode, Equals, operator== and operator!= members are not shown</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>You can call Dispose to remove a registered callback from the CancellationTokenSource that it is associated with so that it does not get invoked when calling Cancel. Here is some code that demonstrates registering two callbacks with a single CancellationTokenSource.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token keyword">var</span></span> cts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">CancellationTokenSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>cts<span class="token punctuation">.</span>Token<span class="token punctuation">.</span><span class="token function">Register</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Canceled 1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>cts<span class="token punctuation">.</span>Token<span class="token punctuation">.</span><span class="token function">Register</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Canceled 2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// To test, let's just cancel it now and have the 2 callbacks execute</span></pre></td></tr><tr><td data-num="5"></td><td><pre>cts<span class="token punctuation">.</span><span class="token function">Cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>When I run this code, I get the following output as soon as the Cancel method is called.</p></blockquote><pre><code class="language-cmd">Canceled 2
Canceled 1
</code></pre><blockquote><p>Finally, you can create a new CancellationTokenSource object by linking a bunch of other CancellationTokenSource objects. This new CancellationTokenSource object will be canceled when any of the linked CancellationTokenSource objects are canceled. The following code demonstrates.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Create a CancellationTokenSource</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name"><span class="token keyword">var</span></span> cts1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">CancellationTokenSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>cts1<span class="token punctuation">.</span>Token<span class="token punctuation">.</span><span class="token function">Register</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"cts1 canceled"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// Create another CancellationTokenSource</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token class-name"><span class="token keyword">var</span></span> cts2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">CancellationTokenSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>cts2<span class="token punctuation">.</span>Token<span class="token punctuation">.</span><span class="token function">Register</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"cts2 canceled"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// Create a new CancellationTokenSource that is canceled when cts1 or ct2 is canceled</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token class-name"><span class="token keyword">var</span></span> linkedCts <span class="token operator">=</span> CancellationTokenSource<span class="token punctuation">.</span><span class="token function">CreateLinkedTokenSource</span><span class="token punctuation">(</span>cts1<span class="token punctuation">.</span>Token<span class="token punctuation">,</span> cts2<span class="token punctuation">.</span>Token<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>linkedCts<span class="token punctuation">.</span>Token<span class="token punctuation">.</span><span class="token function">Register</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"linkedCts canceled"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">// Cancel one of the CancellationTokenSource objects (I chose cts2)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>cts2<span class="token punctuation">.</span><span class="token function">Cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment">// Display which CancellationTokenSource objects are canceled</span></pre></td></tr><tr><td data-num="13"></td><td><pre>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"cts1 canceled=&#123;0&#125;, cts2 canceled=&#123;1&#125;, linkedCts canceled=&#123;2&#125;"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="14"></td><td><pre> cts1<span class="token punctuation">.</span>IsCancellationRequested<span class="token punctuation">,</span> cts2<span class="token punctuation">.</span>IsCancellationRequested<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="15"></td><td><pre>linkedCts<span class="token punctuation">.</span>IsCancellationRequested<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>When I run the preceding code, I get the following output.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>linkedCts canceled</pre></td></tr><tr><td data-num="2"></td><td><pre>cts2 canceled</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">cts1</span> canceled<span class="token operator">=</span>False<span class="token punctuation">,</span> <span class="token class-name">cts2</span> canceled<span class="token operator">=</span>True<span class="token punctuation">,</span> <span class="token class-name">linkedCts</span> canceled<span class="token operator">=</span>True</pre></td></tr></table></figure><blockquote><p>It is often valuable to cancel an operation after a period of time has elapsed. For example, imagine a server application that starts computing some work based on a client request. But the server application needs to respond to the client within two seconds, no matter what. In some scenarios, it is better to respond in a short period of time with an error or with partially computed results as opposed to waiting a long time for a complete result. Fortunately, CancellationTokenSource gives you a way to have it self-cancel itself after a period of time. To take advantage of this, you can either construct a CancellationTokenSource object by using one of the constructors that accepts a delay, or you can call CancellationTokenSourceâ€™s CancelAfter method.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">CancellationTokenSource</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IDisposable</span></span> <span class="token punctuation">&#123;</span> <span class="token comment">// A reference type</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token function">CancellationTokenSource</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> millisecondsDelay<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token function">CancellationTokenSource</span><span class="token punctuation">(</span><span class="token class-name">TimeSpan</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">CancelAfter</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> millisecondsDelay<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">CancelAfter</span><span class="token punctuation">(</span><span class="token class-name">TimeSpan</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>ğŸ’¡å°ç»“ï¼šMicrosoft .NET Framework æä¾›äº†æ ‡å‡†çš„å–æ¶ˆæ“ä½œæ¨¡å¼ã€‚è¿™ä¸ªæ¨¡å¼æ˜¯åä½œå¼çš„ï¼Œæ„å‘³ç€è¦å–æ¶ˆçš„æ“ä½œå¿…é¡»æ˜¾å¼æ”¯æŒå–æ¶ˆã€‚æ¢è¨€ä¹‹ï¼Œæ— è®ºæ‰§è¡Œæ“ä½œçš„ä»£ç ï¼Œè¿˜æ˜¯è¯•å›¾å–æ¶ˆæ“ä½œçš„ä»£ç ï¼Œè¿˜æ˜¯è¯•å›¾å–æ¶ˆæ“ä½œçš„ä»£ç ï¼Œéƒ½å¿…é¡»ä½¿ç”¨æœ¬èŠ‚æåˆ°çš„ç±»å‹ã€‚è¿™ä¸ªå¯¹è±¡åŒ…å«äº†å’Œç®¡ç†å–æ¶ˆæœ‰å…³çš„æ‰€æœ‰çŠ¶æ€ã€‚æ„é€ å¥½ä¸€ä¸ª <code>CancellationTokenSource</code> (ä¸€ä¸ªå¼•ç”¨ç±»å‹) ä¹‹åï¼Œå¯ä»å®ƒçš„ <code>Token</code> å±æ€§è·å¾—ä¸€ä¸ªæˆ–å¤šä¸ª <code>CancellationToken</code> (ä¸€ä¸ªå€¼ç±»å‹) å®ä¾‹ï¼Œå¹¶ä¼ ç»™ä½ çš„æ“ä½œï¼Œä½¿æ“ä½œå¯ä»¥å–æ¶ˆã€‚CancellationToken å®ä¾‹æ˜¯è½»é‡çº§å€¼ç±»å‹ï¼ŒåŒ…å«å•ä¸ªç§æœ‰å­—æ®µï¼Œå³å¯¹å…¶ CancellationTokenSource å¯¹è±¡çš„å¼•ç”¨ã€‚åœ¨è®¡ç®—é™åˆ¶æ“ä½œçš„å¾ªç¯ä¸­ï¼Œå¯å®šæ—¶è°ƒç”¨ <code>CancellationToken</code> çš„ <code>IsCancellationRequested</code> å±æ€§ï¼Œäº†è§£å¾ªç¯æ˜¯å¦åº”è¯¥æå‰ç»ˆæ­¢ï¼Œä»è€Œç»ˆæ­¢è®¡ç®—é™åˆ¶çš„æ“ä½œã€‚å¦‚æœæ„¿æ„ï¼Œå¯è°ƒç”¨ <code>CancellationTokenSource</code> çš„ <code>Register</code> æ–¹æ³•ç™»è®°ä¸€ä¸ªæˆ–å¤šä¸ªåœ¨å–æ¶ˆä¸€ä¸ª <code>CancellationTokenSource</code> æ—¶è°ƒç”¨çš„æ–¹æ³•ã€‚è¦å‘æ–¹æ³•ä¼ é€’ä¸€ä¸ª <code>Action&lt;Object&gt;</code> å§”æ‰˜ï¼›ä¸€ä¸ªè¦é€šè¿‡å§”æ‰˜ä¼ ç»™å›åˆ° (æ–¹æ³•) çš„çŠ¶æ€å€¼ï¼›ä»¥åŠä¸€ä¸ª <code>Boolean</code> å€¼ (åä¸º <code>useSynchronizationContext</code> )ï¼Œè¯¥å€¼æŒ‡æ˜æ˜¯å¦è¦ä½¿ç”¨è°ƒç”¨çº¿ç¨‹çš„ <code>SynchronizationContext</code> æ¥è°ƒç”¨å§”æ‰˜ã€‚å¦‚æœä¸º <code>useSynchronizationContext</code> å‚æ•°ä¼ é€’ <code>false</code> ï¼Œé‚£ä¹ˆè°ƒç”¨ <code>Cancel</code> çš„çº¿ç¨‹ä¼šé¡ºåºè°ƒç”¨å·²ç™»è®°çš„æ‰€æœ‰æ–¹æ³•ã€‚ä¸º <code>useSynchronizationContext</code> å‚æ•°ä¼ é€’ <code>true</code> ï¼Œåˆ™å›è°ƒ (æ–¹æ³•) ä¼šè¢« send (è€Œä¸æ˜¯ post) ç»™å·²æ•æ‰çš„ <code>SynchronizationContext</code> å¯¹è±¡ï¼Œåè€…å†³å®šç”±å“ªä¸ªçº¿ç¨‹è°ƒç”¨å›è°ƒ (æ–¹æ³•)ã€‚å¤šæ¬¡è°ƒç”¨ <code>Register</code> ï¼Œå¤šä¸ªå›è°ƒæ–¹æ³•éƒ½ä¼šè°ƒç”¨ã€‚è¿™äº›å›è°ƒæ–¹æ³•å¯èƒ½æŠ›å‡ºæœªå¤„ç†çš„å¼‚å¸¸ã€‚å¦‚æœè°ƒç”¨ <code>CancellationTokenSource</code> çš„ <code>Cancel</code> æ–¹æ³•ï¼Œå‘å®ƒä¼ é€’ <code>true</code> ï¼Œé‚£ä¹ˆæŠ›å‡ºäº†æœªå¤„ç†å¼‚å¸¸çš„ç¬¬ä¸€ä¸ªå›è°ƒæ–¹æ³•ä¼šé˜»æ­¢å…¶ä»–å›è°ƒæ–¹æ³•çš„æ‰§è¡Œï¼ŒæŠ›å‡ºçš„å¼‚å¸¸ä¹Ÿä¼šä» <code>Cancel</code> ä¸­æŠ›å‡ºã€‚å¦‚æœè°ƒç”¨ <code>Cancel</code> å¹¶å‘å®ƒä¼ é€’ <code>false</code> ï¼Œé‚£ä¹ˆç™»è®°çš„æ‰€æœ‰å›è°ƒæ–¹æ³•éƒ½ä¼šè°ƒç”¨ã€‚æ‰€æœ‰æœªå¤„ç†çš„å¼‚å¸¸éƒ½ä¼šæ·»åŠ åˆ°ä¸€ä¸ªé›†åˆä¸­ã€‚æ‰€æœ‰å›è°ƒæ–¹æ³•éƒ½æ‰§è¡Œå¥½åï¼Œå…¶ä¸­ä»»ä½•ä¸€ä¸ªæŠ›å‡ºäº†æœªå¤„ç†çš„å¼‚å¸¸ï¼Œ <code>Cancel</code> å°±ä¼šæŠ›å‡ºä¸€ä¸ª <code>AggregateException</code> ï¼Œè¯¥å¼‚å¸¸å®ä¾‹çš„ <code>InnerExceptions</code> å±æ€§è¢«è®¾ä¸ºå·²æŠ›å‡ºçš„æ‰€æœ‰å¼‚å¸¸å¯¹è±¡çš„é›†åˆã€‚å¦‚æœç™»è®°çš„æ‰€æœ‰å›è°ƒæ–¹æ³•éƒ½æ²¡æœ‰æŠ›å‡ºæœªå¤„ç†çš„å¼‚å¸¸ï¼Œé‚£ä¹ˆ <code>Cancel</code> ç›´æ¥è¿”å›ï¼Œä¸æŠ›å‡ºä»»ä½•å¼‚å¸¸ã€‚ <code>CancellationToken</code> çš„ <code>Register</code> æ–¹æ³•è¿”å›ä¸€ä¸ª <code>CancellationTokenRegistration</code> ï¼Œå¯ä»¥è°ƒç”¨ <code>Dispose</code> ä»å…³è”çš„ <code>CancellationTokenSource</code> ä¸­åˆ é™¤å·²ç™»è®°çš„å›è°ƒï¼›è¿™æ ·ä¸€æ¥ï¼Œåœ¨è°ƒç”¨ <code>Cancel</code> æ—¶ï¼Œä¾¿ä¸ä¼šå†è°ƒç”¨è¿™ä¸ªå›è°ƒã€‚å¯ä»¥é€šè¿‡é“¾æ¥å¦ä¸€ç»„ <code>CancellationTokenSource</code> æ¥æ–°å»ºä¸€ä¸ª <code>CancellationTokenSource</code> å¯¹è±¡ã€‚ä»»ä½•ä¸€ä¸ªé“¾æ¥çš„ <code>CancellationTokenSource</code> è¢«å–æ¶ˆï¼Œè¿™ä¸ªæ–°çš„ <code>CancellationTokenSource</code> å¯¹è±¡å°±ä¼šè¢«å–æ¶ˆã€‚ <code>CancellationTokenSource</code> æä¾›äº†åœ¨æŒ‡å®šæ—¶é—´åè‡ªåŠ¨å–æ¶ˆçš„æœºåˆ¶ã€‚ä¸ºäº†åˆ©ç”¨è¿™ä¸ªæœºåˆ¶ï¼Œè¦ä¹ˆç”¨æ¥å—å»¶æ—¶å‚æ•°çš„æ„é€ æ„é€ ä¸€ä¸ª <code>CancellationTokenSource</code> å¯¹è±¡ï¼Œè¦ä¹ˆè°ƒç”¨ <code>CancellationTokenSource</code> çš„ <code>CancelAfter</code> æ–¹æ³•ã€‚</p><h2 id="tasks"><a class="anchor" href="#tasks">#</a> Tasks</h2><blockquote><p>Calling ThreadPoolâ€™s QueueUserWorkItem method to initiate an asynchronous compute-bound operation is very simple. However, this technique has many limitations. The biggest problem is that there is no built-in way for you to know when the operation has completed, and there is no way to get a return value back when the operation completes. To address these limitations and more, Microsoft introduced the concept of tasks, and you use them via types in the System.Threading.Tasks namespace.</p></blockquote><blockquote><p>So, instead of calling ThreadPoolâ€™s QueueUserWorkItem method, you can do the same via tasks.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>ThreadPool<span class="token punctuation">.</span><span class="token function">QueueUserWorkItem</span><span class="token punctuation">(</span>ComputeBoundOp<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Calling QueueUserWorkItem</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">new</span> <span class="token constructor-invocation class-name">Task</span><span class="token punctuation">(</span>ComputeBoundOp<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Equivalent of preceding using Task</span></pre></td></tr><tr><td data-num="3"></td><td><pre>Task<span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">ComputeBoundOp</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Another equivalent</span></pre></td></tr></table></figure><blockquote><p>In the second line of preceding code, I am creating the Task object and then immediately calling Start to schedule the task to run. Naturally, you can create the Task object and then call Start on it later. You could imagine code that creates a Task object and then passes it to some other method that decides when to call Start to schedule the task. Because it is common to create a Task object and then immediately call Start on it, you can call Taskâ€™s convenient static Run method as shown on the last line of the preceding code.</p></blockquote><blockquote><p>When creating a Task, you call a constructor, passing it an Action or an Action delegate that indicates the operation that you want performed. If you pass a method that expects an Object, then you must also pass to Taskâ€™s constructor the argument that you ultimately want passed to the operation. When calling Run, you can pass it an Action or Func delegate indicating the operation you want performed. When calling a constructor or when calling Run, you can optionally pass a CancellationToken, which allows the Task to be canceled before it has been scheduled (see the â€œCanceling a Taskâ€ section later in this chapter).</p></blockquote><blockquote><p>You can also optionally pass to the constructor some TaskCreationOptions flags that control how the Task executes. TaskCreationOptions is an enumerated type defining a set of flags that you can bitwise-OR together. It is defined as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Flags</span><span class="token punctuation">,</span> <span class="token class-name">Serializable</span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">TaskCreationOptions</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> None <span class="token operator">=</span> <span class="token number">0x0000</span><span class="token punctuation">,</span><span class="token comment">// The default</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// Hints to the TaskScheduler that you want this task to run sooner than later.</span></pre></td></tr><tr><td data-num="5"></td><td><pre> PreferFairness <span class="token operator">=</span> <span class="token number">0x0001</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Hints to the TaskScheduler that it should more aggressively create thread pool threads.</span></pre></td></tr><tr><td data-num="7"></td><td><pre> LongRunning <span class="token operator">=</span> <span class="token number">0x0002</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Always honored: Associates a Task with its parent Task (discussed shortly)</span></pre></td></tr><tr><td data-num="9"></td><td><pre> AttachedToParent <span class="token operator">=</span> <span class="token number">0x0004</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// If a task attempts to attach to this parent task, it is a normal task, not a child task.</span></pre></td></tr><tr><td data-num="11"></td><td><pre> DenyChildAttach <span class="token operator">=</span> <span class="token number">0x0008</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// Forces child tasks to use the default scheduler as opposed to the parentâ€™s scheduler.</span></pre></td></tr><tr><td data-num="13"></td><td><pre> HideScheduler <span class="token operator">=</span> <span class="token number">0x0010</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Some of these flags are hints that may or may not be honored by the TaskScheduler that is being used to schedule a Task; the AttachedToParent, DenyChildAttach, and HideScheduler flags are always honored, because they have nothing to do with the TaskScheduler itself. TaskScheduler objects are discussed later in the â€œTask Schedulersâ€ section.</p></blockquote><h3 id="waiting-for-a-task-to-complete-and-getting-its-result"><a class="anchor" href="#waiting-for-a-task-to-complete-and-getting-its-result">#</a> Waiting for a Task to Complete and Getting Its Result</h3><blockquote><p>With tasks, it is also possible to wait for them to complete and then get their result. Letâ€™s say that we have a Sum method that is computationally intensive if n is a large value.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">Sum</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Int32</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> n<span class="token operator">--</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">checked</span> <span class="token punctuation">&#123;</span> sum <span class="token operator">+=</span> n<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// if n is large, this will throw System.OverflowException</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">return</span> sum<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>We can now construct a Task object (which is derived from Task), and we pass for the generic TResult argument the compute-bound operationâ€™s return type. Now, after starting the task, we can wait for it to complete and then get its result by using the following code.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Create a Task (it does not start running now)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Task<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">></span></span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Task<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">></span></span><span class="token punctuation">(</span>n <span class="token operator">=></span> <span class="token function">Sum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Int32<span class="token punctuation">)</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// You can start the task sometime later</span></pre></td></tr><tr><td data-num="4"></td><td><pre>t<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// Optionally, you can explicitly wait for the task to complete</span></pre></td></tr><tr><td data-num="6"></td><td><pre>t<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// FYI: Overloads exist accepting timeout/CancellationToken</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// You can get the result (the Result property internally calls Wait)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"The Sum is: "</span> <span class="token operator">+</span> t<span class="token punctuation">.</span>Result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// An Int32 value</span></pre></td></tr></table></figure><p>ğŸ’¡é‡è¦æç¤ºï¼šçº¿ç¨‹è°ƒç”¨ <code>Wait</code> æ–¹æ³•æ—¶ï¼Œç³»ç»Ÿæ£€æŸ¥çº¿ç¨‹è¦ç­‰å¾…çš„ <code>Task</code> æ˜¯å¦å·²å¼€å§‹æ‰§è¡Œã€‚å¦‚æœæ˜¯ï¼Œè°ƒç”¨ <code>Wait</code> çš„çº¿ç¨‹æ¥æ‰§è¡Œ <code>Task</code> ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè°ƒç”¨ <code>Wait</code> çš„çº¿ç¨‹ä¸ä¼šé˜»å¡ï¼›å®ƒä¼šæ‰§è¡Œ <code>Task</code> å¹¶ç«‹å³è¿”å›ã€‚å¥½å¤„åœ¨äºï¼Œæ²¡æœ‰çº¿ç¨‹ä¼šè¢«é˜»å¡ï¼Œæ‰€ä»¥å‡å°‘äº†å¯¹èµ„æºçš„å ç”¨ (å› ä¸ºä¸éœ€è¦åˆ›å»ºä¸€ä¸ªçº¿ç¨‹æ¥æ›¿ä»£è¢«é˜»å¡çš„çº¿ç¨‹)ï¼Œå¹¶æå‡äº†æ€§èƒ½ (å› ä¸ºä¸éœ€è¦èŠ±æ—¶é—´åˆ›å»ºçº¿ç¨‹ï¼Œä¹Ÿæ²¡æœ‰ä¸Šä¸‹æ–‡åˆ‡æ¢)ã€‚ä¸å¥½çš„åœ°æ–¹åœ¨äºï¼Œå‡å¦‚çº¿ç¨‹åœ¨è°ƒç”¨ <code>Wait</code> å‰å·²è·å¾—äº†ä¸€ä¸ªçº¿ç¨‹åŒæ­¥é”ï¼Œè€Œ <code>Task</code> è¯•å›¾è·å–åŒä¸€ä¸ªé”ï¼Œå°±ä¼šé€ æˆæ­»é”çš„çº¿ç¨‹ï¼</p><blockquote><p>If the compute-bound task throws an unhandled exception, the exception will be swallowed, stored in a collection, and the thread pool thread is allowed to return to the thread pool. When the Wait method or the Result property is invoked, these members will throw a System.AggregateException object.</p></blockquote><blockquote><p>The AggregateException type is used to encapsulate a collection of exception objects (which can happen if a parent task spawns multiple child tasks that throw exceptions). It contains an InnerExceptions property that returns a ReadOnlyCollection object. Do not confuse the InnerExceptions property with the InnerException property, which the AggregateException class inherits from the System.Exception base class. For the preceding example, element 0 of AggregateExceptionâ€™s InnerExceptions property would refer to the actual System.OverflowException object thrown by the compute-bound method (Sum).</p></blockquote><blockquote><p>As a convenience, AggregateException overrides Exceptionâ€™s GetBaseException method. AggregateExceptionâ€™s implementation returns the innermost AggregateException that is the root cause of the problem (assuming that there is just one innermost exception in the collection). AggregateException also offers a Flatten method that creates a new AggregateException, whose InnerExceptions property contains a list of exceptions produced by walking the original AggregateExceptionâ€™s inner exception hierarchy. Finally, AggregateException also provides a Handle method that invokes a callback method for each exception contained in the AggregateException. The callback can then decide, for each exception, how to handle the exception; the callback returns true to consider the exception handled and false if not. If, after calling Handle, at least one exception is not handled, then a new AggregateException object is created containing just the unhandled exceptions and the new AggregateException object is thrown. Later in this chapter, I show examples using the Flatten and Handle methods.</p></blockquote><p>ğŸ’¡é‡è¦æç¤ºï¼šå¦‚æœä¸€è‡´ä¸è°ƒç”¨ <code>Wait</code> æˆ– <code>Result</code> ï¼Œæˆ–è€…ä¸€ç›´ä¸æŸ¥è¯¢ <code>Task</code> çš„ <code>Exception</code> å±æ€§ï¼Œä»£ç å°±ä¸€ç›´æ³¨æ„ä¸åˆ°è¿™ä¸ªå¼‚å¸¸çš„å‘ç”Ÿã€‚è¿™å½“ç„¶ä¸å¥½ï¼Œå› ä¸ºç¨‹åºé‡åˆ°äº†æœªé¢„æ–™åˆ°çš„é—®é¢˜ï¼Œè€Œä½ å±…ç„¶æ²¡æ³¨æ„åˆ°ã€‚ä¸ºäº†å¸®åŠ©ä½ æ£€æµ‹æ²¡æœ‰è¢«æ³¨æ„åˆ°ã€‚ä¸ºäº†å¸®åŠ©ä½ æ£€æµ‹æ²¡æœ‰è¢«æ³¨æ„åˆ°çš„å¼‚å¸¸ï¼Œå¯ä»¥å‘ <code>TaskScheduler</code> çš„é™æ€ <code>UnobservedTaskException</code> äº‹ä»¶ç™»è®°ä¸€ä¸ªå›è°ƒæ–¹æ³•ã€‚æ¯æ¬¡æ”¾ä¸€ä¸ª <code>Task</code> è¢«åƒåœ¾å›æ”¶æ—¶ï¼Œå¦‚æœå­˜åœ¨ä¸€ä¸ªæ²¡æœ‰è¢«æ³¨æ„åˆ°çš„å¼‚å¸¸ï¼ŒCLR çš„ç»ˆç»“å™¨çº¿ç¨‹å°±ä¼šå¼•å‘è¿™ä¸ªäº‹ä»¶ã€‚ä¸€æ—¦å¼•å‘ï¼Œå°±ä¼šå‘ä½ çš„äº‹ä»¶å¤„ç†æ–¹æ³•ä¼ é€’ä¸€ä¸ª <code>UnobservedTaskExceptionEventArgs</code> å¯¹è±¡ï¼Œå…¶ä¸­åŒ…å«ä½ æ²¡æœ‰æ³¨æ„åˆ°çš„ <code>AggregateException</code> ã€‚</p><blockquote><p>In addition to waiting for a single task, the Task class also offers two static methods that allow a thread to wait on an array of Task objects. Taskâ€™s static WaitAny method blocks the calling thread until any of the Task objects in the array have completed. This method returns an Int32 index into the array indicating which Task object completed, causing the thread to wake and continue running. The method returns -1 if the timeout occurs and throws an OperationCanceledException if WaitAny is canceled via a CancellationToken.</p></blockquote><blockquote><p>Similarly, the Task class has a static WaitAll method that blocks the calling thread until all the Task objects in the array have completed. The WaitAll method returns true if all the Task objects complete and false if a timeout occurs; an OperationCanceledException is thrown if WaitAll is canceled via a CancellationToken.</p></blockquote><h3 id="canceling-a-task"><a class="anchor" href="#canceling-a-task">#</a> Canceling a Task</h3><blockquote><p>Of course, you can use a CancellationTokenSource to cancel a Task. First, we must revise our Sum method so that it accepts a CancellationToken.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">Sum</span><span class="token punctuation">(</span><span class="token class-name">CancellationToken</span> ct<span class="token punctuation">,</span> <span class="token class-name">Int32</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Int32</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> n<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// The following line throws OperationCanceledException when Cancel </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// is called on the CancellationTokenSource referred to by the token</span></pre></td></tr><tr><td data-num="6"></td><td><pre> ct<span class="token punctuation">.</span><span class="token function">ThrowIfCancellationRequested</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">checked</span> <span class="token punctuation">&#123;</span> sum <span class="token operator">+=</span> n<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// if n is large, this will throw System.OverflowException</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">return</span> sum<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In this code, the compute-bound operationâ€™s loop periodically checks to see if the operation has been canceled by calling CancellationTokenâ€™s ThrowIfCancellationRequested method. This method is similar to CancellationTokenâ€™s IsCancellationRequested property shown earlier in the â€œCooperative Cancellation and Timeoutâ€ section. However, ThrowIfCancellationRequested throws an OperationCanceledException if the CancellationTokenSource has been canceled. The reason for throwing an exception is because, unlike work items initiated with ThreadPoolâ€™s QueueUserWorkItem method, tasks have the notion of having completed and a task can even return a value. So, there needs to be a way to distinguish a completed task from a canceled task, and having the task throw an exception lets you know that the task did not run all the way to completion.</p></blockquote><blockquote><p>Now, we will create the CancellationTokenSource and Task objects as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">CancellationTokenSource</span> cts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">CancellationTokenSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Task<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">></span></span> t <span class="token operator">=</span> Task<span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">Sum</span><span class="token punctuation">(</span>cts<span class="token punctuation">.</span>Token<span class="token punctuation">,</span> <span class="token number">1000000000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cts<span class="token punctuation">.</span>Token<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// Sometime later, cancel the CancellationTokenSource to cancel the Task</span></pre></td></tr><tr><td data-num="4"></td><td><pre>cts<span class="token punctuation">.</span><span class="token function">Cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// This is an asynchronous request, the Task may have completed already</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// If the task got canceled, Result will throw an AggregateException</span></pre></td></tr><tr><td data-num="7"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"The sum is: "</span> <span class="token operator">+</span> t<span class="token punctuation">.</span>Result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// An Int32 value</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">AggregateException</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// Consider any OperationCanceledException objects as handled. </span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// Any other exceptions cause a new AggregateException containing</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// only the unhandled exceptions to be thrown</span></pre></td></tr><tr><td data-num="13"></td><td><pre> x<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span>e <span class="token operator">=></span> e <span class="token keyword">is</span> <span class="token class-name">OperationCanceledException</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token comment">// If all the exceptions were handled, the following executes</span></pre></td></tr><tr><td data-num="15"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Sum was canceled"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When creating a Task, you can associate a CancellationToken with it by passing it to Taskâ€™s constructor (as shown in the preceding code). If the CancellationToken gets canceled before the Task is scheduled, the Task gets canceled and never executes at all.2 But if the Task has already been scheduled (by calling the Start method), then the Taskâ€™s code must explicitly support cancellation if it allows its operation to be canceled while executing. Unfortunately, while a Task object has a CancellationToken associated with it, there is no way to access it, so you must somehow get the same CancellationToken that was used to create the Task object into the Taskâ€™s code itself. The easiest way to write this code is to use a lambda expression and â€œpassâ€ the CancellationToken as a closure variable (as Iâ€™ve done in the previous code example).</p></blockquote><h3 id="starting-a-new-task-automatically-when-another-task-completes"><a class="anchor" href="#starting-a-new-task-automatically-when-another-task-completes">#</a> Starting a New Task Automatically When Another Task Completes</h3><blockquote><p>In order to write scalable software, you must not have your threads block. This means that calling Wait or querying a taskâ€™s Result property when the task has not yet finished running will most likely cause the thread pool to create a new thread, which increases resource usage and hurts performance. Fortunately, there is a better way to find out when a task has completed running. When a task completes, it can start another task. Here is a rewrite of the earlier code that doesnâ€™t block any threads.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Create and start a Task, continue with another task</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Task<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">></span></span> t <span class="token operator">=</span> Task<span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">Sum</span><span class="token punctuation">(</span>CancellationToken<span class="token punctuation">.</span>None<span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// ContinueWith returns a Task but you usually don't care</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token class-name">Task</span> cwt <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">ContinueWith</span><span class="token punctuation">(</span>task <span class="token operator">=></span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"The sum is: "</span> <span class="token operator">+</span> task<span class="token punctuation">.</span>Result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>Now, when the task executing Sum completes, this task will start another task (also on some thread pool thread) that displays the result. The thread that executes the preceding code does not block waiting for either of these two tasks to complete; the thread is allowed to execute other code or, if it is a thread pool thread itself, it can return to the pool to perform other operations. Note that the task executing Sum could complete before ContinueWith is called. This will not be a problem because the ContinueWith method will see that the Sum task is complete and it will immediately start the task that displays the result.</p></blockquote><blockquote><p>Also, note that ContinueWith returns a reference to a new Task object (which my code placed in the cwt variable). Of course, you can invoke various members (like Wait, Result, or even ContinueWith) using this Task object, but usually you will ignore this Task object and will not save a reference to it in a variable.</p></blockquote><blockquote><p>I should also mention that Task objects internally contain a collection of ContinueWith tasks. So you can actually call ContinueWith several times using a single Task object. When the task completes, all the ContinueWith tasks will be queued to the thread pool. In addition, when calling ContinueWith, you can specify a bitwise ORâ€™d set of TaskContinuationOptions. The first six flagsâ€”None, PreferFairness, LongRunning, AttachedToParent, DenyChildAttach, and HideSchedulerâ€”are identical to the flags offered by the TaskCreationOptions enumerated type shown earlier. Here is what the TaskContinuationOptions type looks like.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Flags</span><span class="token punctuation">,</span> <span class="token class-name">Serializable</span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">TaskContinuationOptions</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> None <span class="token operator">=</span> <span class="token number">0x0000</span><span class="token punctuation">,</span><span class="token comment">// The default</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// Hints to the TaskScheduler that you want this task to run sooner than later.</span></pre></td></tr><tr><td data-num="5"></td><td><pre> PreferFairness <span class="token operator">=</span> <span class="token number">0x0001</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Hints to the TaskScheduler that it should more aggressively create thread pool threads.</span></pre></td></tr><tr><td data-num="7"></td><td><pre> LongRunning <span class="token operator">=</span> <span class="token number">0x0002</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Always honored: Associates a Task with its parent Task (discussed shortly)</span></pre></td></tr><tr><td data-num="9"></td><td><pre> AttachedToParent <span class="token operator">=</span> <span class="token number">0x0004</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// If a task attempts to attach to this parent task, an InvalidOperationException is thrown.</span></pre></td></tr><tr><td data-num="11"></td><td><pre> DenyChildAttach <span class="token operator">=</span> <span class="token number">0x0008</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// Forces child tasks to use the default scheduler as opposed to the parentâ€™s scheduler.</span></pre></td></tr><tr><td data-num="13"></td><td><pre> HideScheduler <span class="token operator">=</span> <span class="token number">0x0010</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token comment">// Prevents completion of the continuation until the antecedent has completed.</span></pre></td></tr><tr><td data-num="15"></td><td><pre> LazyCancellation <span class="token operator">=</span> <span class="token number">0x0020</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token comment">// This flag indicates that you want the thread that executed the first task to also</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token comment">// execute the ContinueWith task. If the first task has already completed, then the</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token comment">// thread calling ContinueWith will execute the ContinueWith task.</span></pre></td></tr><tr><td data-num="19"></td><td><pre> ExecuteSynchronously <span class="token operator">=</span> <span class="token number">0x80000</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token comment">// These flags indicate under what circumstances to run the ContinueWith task</span></pre></td></tr><tr><td data-num="21"></td><td><pre> NotOnRanToCompletion <span class="token operator">=</span> <span class="token number">0x10000</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="22"></td><td><pre> NotOnFaulted <span class="token operator">=</span> <span class="token number">0x20000</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="23"></td><td><pre> NotOnCanceled <span class="token operator">=</span> <span class="token number">0x40000</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token comment">// These flags are convenient combinations of the above three flags</span></pre></td></tr><tr><td data-num="25"></td><td><pre> OnlyOnCanceled <span class="token operator">=</span> NotOnRanToCompletion <span class="token operator">|</span> NotOnFaulted<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="26"></td><td><pre> OnlyOnFaulted <span class="token operator">=</span> NotOnRanToCompletion <span class="token operator">|</span> NotOnCanceled<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="27"></td><td><pre> OnlyOnRanToCompletion <span class="token operator">=</span> NotOnFaulted <span class="token operator">|</span> NotOnCanceled<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When you call ContinueWith, you can indicate that you want the new task to execute only if the first task is canceled by specifying the TaskContinuationOptions.OnlyOnCanceled flag. Similarly, you have the new task execute only if the first task throws an unhandled exception using the TaskContinuationOptions.OnlyOnFaulted flag. And, of course, you can use the TaskContinuationOptions.OnlyOnRanToCompletion flag to have the new task execute only if the first task runs all the way to completion without being canceled or throwing an unhandled exception. By default, if you do not specify any of these flags, then the new task will run regardless of how the first task completes. When a Task completes, any of its continue-with tasks that do not run are automatically canceled. Here is an example that puts all of this together.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Create and start a Task, continue with multiple other tasks</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Task<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">></span></span> t <span class="token operator">=</span> Task<span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">Sum</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// Each ContinueWith returns a Task but you usually don't care</span></pre></td></tr><tr><td data-num="4"></td><td><pre>t<span class="token punctuation">.</span><span class="token function">ContinueWith</span><span class="token punctuation">(</span>task <span class="token operator">=></span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"The sum is: "</span> <span class="token operator">+</span> task<span class="token punctuation">.</span>Result<span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre> TaskContinuationOptions<span class="token punctuation">.</span>OnlyOnRanToCompletion<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>t<span class="token punctuation">.</span><span class="token function">ContinueWith</span><span class="token punctuation">(</span>task <span class="token operator">=></span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Sum threw: "</span> <span class="token operator">+</span> task<span class="token punctuation">.</span>Exception<span class="token punctuation">.</span>InnerException<span class="token punctuation">)</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> TaskContinuationOptions<span class="token punctuation">.</span>OnlyOnFaulted<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>t<span class="token punctuation">.</span><span class="token function">ContinueWith</span><span class="token punctuation">(</span>task <span class="token operator">=></span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Sum was canceled"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> TaskContinuationOptions<span class="token punctuation">.</span>OnlyOnCanceled<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="a-task-may-start-child-tasks"><a class="anchor" href="#a-task-may-start-child-tasks">#</a> A Task May Start Child Tasks</h3><blockquote><p>Finally, tasks support parent/child relationships, as demonstrated by the following code.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Task<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">></span></span> parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Task<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> results <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Int32</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Create an array for the results</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// This tasks creates and starts 3 child tasks</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Task</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> results<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">Sum</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> TaskCreationOptions<span class="token punctuation">.</span>AttachedToParent<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Task</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> results<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">Sum</span><span class="token punctuation">(</span><span class="token number">20000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> TaskCreationOptions<span class="token punctuation">.</span>AttachedToParent<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Task</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> results<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">Sum</span><span class="token punctuation">(</span><span class="token number">30000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> TaskCreationOptions<span class="token punctuation">.</span>AttachedToParent<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// Returns a reference to the array (even though the elements may not be initialized yet)</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">return</span> results<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">// When the parent and its children have run to completion, display the results</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token class-name"><span class="token keyword">var</span></span> cwt <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">ContinueWith</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="12"></td><td><pre> parentTask <span class="token operator">=></span> Array<span class="token punctuation">.</span><span class="token function">ForEach</span><span class="token punctuation">(</span>parentTask<span class="token punctuation">.</span>Result<span class="token punctuation">,</span> Console<span class="token punctuation">.</span>WriteLine<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment">// Start the parent Task so it can start its children</span></pre></td></tr><tr><td data-num="14"></td><td><pre>parent<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>Here, the parent task creates and starts three Task objects. By default, Task objects created by another task are top-level tasks that have no relationship to the task that creates them. However, the TaskCreationOptions.AttachedToParent flag associates a Task with the Task that creates it so that the creating task is not considered finished until all its children (and grandchildren) have finished running. When creating a Task by calling the ContinueWith method, you can make the continuewith task be a child by specifying the TaskContinuationOptions.AttachedToParent flag.</p></blockquote><h3 id="inside-a-task"><a class="anchor" href="#inside-a-task">#</a> Inside a Task</h3><blockquote><p>Each Task object has a set of fields that make up the taskâ€™s state. There is an Int32 ID (see Taskâ€™s read-only Id property), an Int32 representing the execution state of the Task, a reference to the parent task, a reference to the TaskScheduler specified when the Task was created, a reference to the callback method, a reference to the object that is to be passed to the callback method (queryable via Taskâ€™s read-only AsyncState property), a reference to an ExecutionContext, and a reference to a ManualResetEventSlim object. In addition, each Task object has a reference to some supplementary state that is created on demand. The supplementary state includes a CancellationToken, a collection of ContinueWithTask objects, a collection of Task objects for child tasks that have thrown unhandled exceptions, and more. My point is that although tasks provide you a lot of features, there is some cost to tasks because memory must be allocated for all this state. If you donâ€™t need the additional features offered by tasks, then your program will use resources more efficiently if you use ThreadPool.QueueUserWorkItem.</p></blockquote><blockquote><p>The Task and Task classes implement the IDisposable interface, allowing you to call Dispose when you are done with the Task object. Today, all the Dispose method does is close the ManualResetEventSlim object. However, it is possible to define classes derived from Task and Task, and these classes could allocate their own resources, which would be freed in their override of the Dispose method. I recommend that developers not explicitly call Dispose on a Task object in their code; instead, just let the garbage collector clean up any resources when it determines that they are no longer in use.</p></blockquote><blockquote><p>Youâ€™ll notice that each Task object contains an Int32 field representing a Taskâ€™s unique ID. When you create a Task object, the field is initialized to zero. Then the first time you query Taskâ€™s read-only Id property, the property assigns a unique Int32 value to this field and returns it from the property. Task IDs start at 1 and increment by 1 as each ID is assigned. Just looking at a Task object in the Microsoft Visual Studio debugger will cause the debugger to display the Taskâ€™s ID, forcing the Task to be assigned an ID.</p></blockquote><blockquote><p>The idea behind the ID is that each Task can be identified by a unique value. In fact, Visual Studio shows you these task IDs in its Parallel Tasks and Parallel Stacks windows. But because you donâ€™t assign the IDs yourself in your code, it is practically impossible to correlate an ID number with what your code is doing. While running a taskâ€™s code, you can query Taskâ€™s static CurrentId property, which returns a nullable Int32 (Int32?). You can also call this from Visual Studioâ€™s Watch window or Immediate window while debugging to get the ID for the code that you are currently stepping through. Then you can find your task in the Parallel Tasks/Stacks windows. If you query the CurrentId property while a task is not executing, it returns null.</p></blockquote><blockquote><p>During a Task objectâ€™s existence, you can learn where it is in its lifecycle by querying Taskâ€™s readonly Status property. This property returns a TaskStatus value that is defined as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">TaskStatus</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// These flags indicate the state of a Task during its lifetime:</span></pre></td></tr><tr><td data-num="3"></td><td><pre> Created<span class="token punctuation">,</span> <span class="token comment">// Task created explicitly; you can manually Start() this task</span></pre></td></tr><tr><td data-num="4"></td><td><pre> WaitingForActivation<span class="token punctuation">,</span><span class="token comment">// Task created implicitly; it starts automatically</span></pre></td></tr><tr><td data-num="5"></td><td><pre> WaitingToRun<span class="token punctuation">,</span> <span class="token comment">// The task was scheduled but isnâ€™t running yet</span></pre></td></tr><tr><td data-num="6"></td><td><pre> Running<span class="token punctuation">,</span> <span class="token comment">// The task is actually running</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// The task is waiting for children to complete before it considers itself complete</span></pre></td></tr><tr><td data-num="8"></td><td><pre> WaitingForChildrenToComplete<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// A task's final state is one of these:</span></pre></td></tr><tr><td data-num="10"></td><td><pre> RanToCompletion<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="11"></td><td><pre> Canceled<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="12"></td><td><pre> Faulted</pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When you first construct a Task object, its status is Created. Later, when the task is started, its status changes to WaitingToRun. When the Task is actually running on a thread, its status changes to Running. When the task stops running and is waiting for any child tasks, the status changes to WaitingForChildrenToComplete. When a task is completely finished, it enters one of three final states: RanToCompletion, Canceled, or Faulted. When a Task runs to completion, you can query the taskâ€™s result via Taskâ€™s Result property. When a Task or Task faults, you can obtain the unhandled exception that the task threw by querying Taskâ€™s Exception property; which always returns an AggregateException object whose collection contains the set of unhandled exceptions.</p></blockquote><blockquote><p>For convenience, Task offers several read-only, Boolean properties: IsCanceled, IsFaulted, and IsCompleted. Note that IsCompleted returns true when the Task is in the RanToCompletion, Canceled, or Faulted state. The easiest way to determine if a Task completed successfully is to use code like the following.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>task<span class="token punctuation">.</span>Status <span class="token operator">==</span> TaskStatus<span class="token punctuation">.</span>RanToCompletion<span class="token punctuation">)</span> <span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr></table></figure><blockquote><p>A Task object is in the WaitingForActivation state if that Task is created by calling one of these functions: ContinueWith, ContinueWhenAll, ContinueWhenAny, or FromAsync. A Task created by constructing a TaskCompletionSource object is also created in the WaitingForActivation state. This state means that the Taskâ€™s scheduling is controlled by the task infrastructure. For example, you cannot explicitly start a Task object that was created by calling ContinueWith. This Task will start automatically when its antecedent task has finished executing.</p></blockquote><h3 id="task-factories"><a class="anchor" href="#task-factories">#</a> Task Factories</h3><blockquote><p>Occasionally, you might want to create a bunch of Task objects that share the same configuration. To keep you from having to pass the same parameters to each Taskâ€™s constructor over and over again, you can create a task factory that encapsulates the common configuration. The System.Threading. Tasks namespace defines a TaskFactory type as well as a TaskFactory type. Both of these types are derived from System.Object; that is, they are peers of each other.</p></blockquote><blockquote><p>If you want to create a bunch of tasks that return void, then you will construct a TaskFactory. If you want to create a bunch of tasks that have a specific return type, then you will construct a TaskFactory where you pass the taskâ€™s desired return type for the generic TResult argument. When you create one of these task factory classes, you pass to its constructor the defaults that you want the tasks that the factory creates to have. Specifically, you pass to the task factory the CancellationToken, TaskScheduler, TaskCreationOptions, and TaskContinuationOptions settings that you want factory-created tasks to have.</p></blockquote><blockquote><p>Here is some sample code demonstrating the use of a TaskFactory.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Task</span> parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Task</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> cts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">CancellationTokenSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> tf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">TaskFactory<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">></span></span><span class="token punctuation">(</span>cts<span class="token punctuation">.</span>Token<span class="token punctuation">,</span> TaskCreationOptions<span class="token punctuation">.</span>AttachedToParent<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> TaskContinuationOptions<span class="token punctuation">.</span>ExecuteSynchronously<span class="token punctuation">,</span> TaskScheduler<span class="token punctuation">.</span>Default<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// This task creates and starts 3 child tasks</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> childTasks <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> tf<span class="token punctuation">.</span><span class="token function">StartNew</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">Sum</span><span class="token punctuation">(</span>cts<span class="token punctuation">.</span>Token<span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="8"></td><td><pre> tf<span class="token punctuation">.</span><span class="token function">StartNew</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">Sum</span><span class="token punctuation">(</span>cts<span class="token punctuation">.</span>Token<span class="token punctuation">,</span> <span class="token number">20000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="9"></td><td><pre> tf<span class="token punctuation">.</span><span class="token function">StartNew</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">Sum</span><span class="token punctuation">(</span>cts<span class="token punctuation">.</span>Token<span class="token punctuation">,</span> Int32<span class="token punctuation">.</span>MaxValue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// Too big, throws OverflowException</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// If any of the child tasks throw, cancel the rest of them</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> task <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> task <span class="token operator">&lt;</span> childTasks<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> task<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre> childTasks<span class="token punctuation">[</span>task<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">ContinueWith</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="14"></td><td><pre> t <span class="token operator">=></span> cts<span class="token punctuation">.</span><span class="token function">Cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> TaskContinuationOptions<span class="token punctuation">.</span>OnlyOnFaulted<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// When all children are done, get the maximum value returned from the </span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token comment">// non-faulting/canceled tasks. Then pass the maximum value to another </span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token comment">// task that displays the maximum result</span></pre></td></tr><tr><td data-num="18"></td><td><pre> tf<span class="token punctuation">.</span><span class="token function">ContinueWhenAll</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="19"></td><td><pre> childTasks<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="20"></td><td><pre> completedTasks <span class="token operator">=></span> </pre></td></tr><tr><td data-num="21"></td><td><pre> completedTasks<span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>t <span class="token operator">=></span> t<span class="token punctuation">.</span>Status <span class="token operator">==</span> TaskStatus<span class="token punctuation">.</span>RanToCompletion<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Max</span><span class="token punctuation">(</span>t <span class="token operator">=></span> t<span class="token punctuation">.</span>Result<span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="22"></td><td><pre> CancellationToken<span class="token punctuation">.</span>None<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token punctuation">.</span><span class="token function">ContinueWith</span><span class="token punctuation">(</span>t <span class="token operator">=></span>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"The maximum is: "</span> <span class="token operator">+</span> t<span class="token punctuation">.</span>Result<span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="24"></td><td><pre> TaskContinuationOptions<span class="token punctuation">.</span>ExecuteSynchronously<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token comment">// When the children are done, show any unhandled exceptions too</span></pre></td></tr><tr><td data-num="27"></td><td><pre>parent<span class="token punctuation">.</span><span class="token function">ContinueWith</span><span class="token punctuation">(</span>p <span class="token operator">=></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre> <span class="token comment">// I put all this text in a StringBuilder and call Console.WriteLine just once </span></pre></td></tr><tr><td data-num="29"></td><td><pre> <span class="token comment">// because this task could execute concurrently with the task above &amp; I don't </span></pre></td></tr><tr><td data-num="30"></td><td><pre> <span class="token comment">// want the tasks' output interspersed</span></pre></td></tr><tr><td data-num="31"></td><td><pre> <span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">StringBuilder</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="32"></td><td><pre> <span class="token string">"The following exception(s) occurred:"</span> <span class="token operator">+</span> Environment<span class="token punctuation">.</span>NewLine<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre> <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> e <span class="token keyword">in</span> p<span class="token punctuation">.</span>Exception<span class="token punctuation">.</span><span class="token function">Flatten</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>InnerExceptions<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="34"></td><td><pre> sb<span class="token punctuation">.</span><span class="token function">AppendLine</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> TaskContinuationOptions<span class="token punctuation">.</span>OnlyOnFaulted<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token comment">// Start the parent Task so it can start its children</span></pre></td></tr><tr><td data-num="38"></td><td><pre>parent<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>With this code, I am creating a TaskFactory object that I will use to create three Task objects. I want to configure the child tasks all the same way: each Task object shares the same CancellationTokenSource token, tasks are considered children of their parent, all continue-with tasks created by the TaskFactory execute synchronously, and all Task objects created by this TaskFactory use the default TaskScheduler.</p></blockquote><blockquote><p>Then I create an array consisting of the three child Task objects, all created by calling TaskFactoryâ€™s StartNew method. This method conveniently creates and starts each child task. In a loop, I tell each child task that throws an unhandled exception to cancel all the other child tasks that are still running. Finally, using the TaskFactory, I call ContinueWhenAll, which creates a Task that runs when all the child tasks have completed running. Because this task is created with the TaskFactory, it will also be considered a child of the parent task and it will execute synchronously using the default TaskScheduler. However, I want this task to run even if the other child tasks were canceled, so I override the TaskFactoryâ€™s CancellationToken by passing in CancellationToken. None, which prevents this task from being cancelable at all. Finally, when the task that processes all the results is complete, I create another task that displays the highest value returned from all the child tasks.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šè°ƒç”¨ <code>TaskFactory</code> æˆ– <code>TaskFactory&lt;TResult&gt;</code> çš„é™æ€ <code>ContinueWhenAll</code> å’Œ <code>ContinueWhenAny</code> æ–¹æ³•æ—¶ï¼Œä»¥ä¸‹ <code>TaskContinuationOption</code> æ ‡å¿—æ˜¯éæ³•çš„ï¼š <code>NotOnRanToCompletion</code> ï¼Œ <code>NotOnFaulted</code> å’Œ <code>NotOnCanceled</code> ã€‚å½“ç„¶ï¼ŒåŸºäºè¿™äº›æ ‡å¿—ç»„åˆèµ·æ¥çš„æ ‡å¿— ( <code>OnlyOnCanceled</code> ï¼Œ <code>OnlyOnFaulted</code> å’Œ <code>OnlyOnRanToCompletion</code> ) ä¹Ÿæ˜¯éæ³•çš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæ— è®ºå‰ç½®ä»»åŠ¡æ˜¯å¦‚ä½•å®Œæˆçš„ï¼Œ <code>ContinueWhenAll</code> å’Œ <code>ContinueWhenAny</code> éƒ½ä¼šæ‰§è¡Œå»¶ç»­ä»»åŠ¡ã€‚</p><h3 id="task-schedulers"><a class="anchor" href="#task-schedulers">#</a> Task Schedulers</h3><blockquote><p>The task infrastructure is very flexible, and TaskScheduler objects are a big part of this flexibility. A TaskScheduler object is responsible for executing scheduled tasks and also exposes task information to the Visual Studio debugger. The FCL ships with two TaskScheduler-derived types: the thread pool task scheduler and a synchronization context task scheduler. By default, all applications use the thread pool task scheduler. This task scheduler schedules tasks to the thread poolâ€™s worker threads and is discussed in more detail in this chapterâ€™s â€œHow the Thread Pool Manages Its Threadsâ€ section. You can get a reference to the default task scheduler by querying TaskSchedulerâ€™s static Default property.</p></blockquote><blockquote><p>The synchronization context task scheduler is typically used for applications sporting a graphical user interface, such as Windows Forms, Windows Presentation Foundation (WPF), Silverlight, and Windows Store applications. This task scheduler schedules all tasks onto the applicationâ€™s GUI thread so that all the task code can successfully update UI components like buttons, menu items, and so on. The synchronization context task scheduler does not use the thread pool at all. You can get a reference to a synchronization context task scheduler by querying TaskSchedulerâ€™s static FromCurrentSynchronizationContext method.</p></blockquote><blockquote><p>Here is a simple Windows Forms application that demonstrates the use of the synchronization context task scheduler.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">MyForm</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Form</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">TaskScheduler</span> m_syncContextTaskScheduler<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token function">MyForm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// Get a reference to a synchronization context task scheduler</span></pre></td></tr><tr><td data-num="5"></td><td><pre> m_syncContextTaskScheduler <span class="token operator">=</span> TaskScheduler<span class="token punctuation">.</span><span class="token function">FromCurrentSynchronizationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> Text <span class="token operator">=</span> <span class="token string">"Synchronization Context Task Scheduler Demo"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> Visible <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> Width <span class="token operator">=</span> <span class="token number">600</span><span class="token punctuation">;</span> Height <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">CancellationTokenSource</span> m_cts<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">protected</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">OnMouseClick</span><span class="token punctuation">(</span><span class="token class-name">MouseEventArgs</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>m_cts <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// An operation is in flight, cancel it</span></pre></td></tr><tr><td data-num="12"></td><td><pre> m_cts<span class="token punctuation">.</span><span class="token function">Cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> m_cts <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// An operation is not in flight, start it</span></pre></td></tr><tr><td data-num="15"></td><td><pre> Text <span class="token operator">=</span> <span class="token string">"Operation running"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre> m_cts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">CancellationTokenSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token comment">// This task uses the default task scheduler and executes on a thread pool thread</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token class-name">Task<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">></span></span> t <span class="token operator">=</span> Task<span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">Sum</span><span class="token punctuation">(</span>m_cts<span class="token punctuation">.</span>Token<span class="token punctuation">,</span> <span class="token number">20000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m_cts<span class="token punctuation">.</span>Token<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token comment">// These tasks use the sync context task scheduler and execute on the GUI thread</span></pre></td></tr><tr><td data-num="20"></td><td><pre> t<span class="token punctuation">.</span><span class="token function">ContinueWith</span><span class="token punctuation">(</span>task <span class="token operator">=></span> Text <span class="token operator">=</span> <span class="token string">"Result: "</span> <span class="token operator">+</span> task<span class="token punctuation">.</span>Result<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="21"></td><td><pre> CancellationToken<span class="token punctuation">.</span>None<span class="token punctuation">,</span> TaskContinuationOptions<span class="token punctuation">.</span>OnlyOnRanToCompletion<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="22"></td><td><pre> m_syncContextTaskScheduler<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre> t<span class="token punctuation">.</span><span class="token function">ContinueWith</span><span class="token punctuation">(</span>task <span class="token operator">=></span> Text <span class="token operator">=</span> <span class="token string">"Operation canceled"</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="24"></td><td><pre> CancellationToken<span class="token punctuation">.</span>None<span class="token punctuation">,</span> TaskContinuationOptions<span class="token punctuation">.</span>OnlyOnCanceled<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="25"></td><td><pre> m_syncContextTaskScheduler<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre> t<span class="token punctuation">.</span><span class="token function">ContinueWith</span><span class="token punctuation">(</span>task <span class="token operator">=></span> Text <span class="token operator">=</span> <span class="token string">"Operation faulted"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="27"></td><td><pre> CancellationToken<span class="token punctuation">.</span>None<span class="token punctuation">,</span> TaskContinuationOptions<span class="token punctuation">.</span>OnlyOnFaulted<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="28"></td><td><pre> m_syncContextTaskScheduler<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre> <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">OnMouseClick</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When you click in the client area of this form, a compute-bound task will start executing on a thread pool thread. This is good because the GUI thread is not blocked during this time and can therefore respond to other UI operations. However, the code executed by the thread pool thread should not attempt to update UI components or else an InvalidOperationException will be thrown.</p></blockquote><blockquote><p>When the compute-bound task is done, one of the three continue-with tasks will execute. These tasks are all issued against the synchronization context task scheduler corresponding to the GUI thread, and this task scheduler queues the tasks to the GUI thread, allowing the code executed by these tasks to update UI components successfully. All of these tasks update the formâ€™s caption via the inherited Text property.</p></blockquote><blockquote><p>Because the compute-bound work (Sum) is running on a thread pool thread, the user can interact with the UI to cancel the operation. In my simple code example, I allow the user to cancel the operation by clicking in the formâ€™s client area while an operation is running.</p></blockquote><blockquote><p>You can, of course, define your own class derived from TaskScheduler if you have special task scheduling needs. Microsoft has provided a bunch of sample code for tasks and includes the source code for a bunch of task schedulers in the Parallel Extensions Extras package, which can be downloaded from here: <span class="exturl" data-url="aHR0cDovL2NvZGUubXNkbi5taWNyb3NvZnQuY29tL1BhckV4dFNhbXBsZXM=">http://code.msdn.microsoft.com/ParExtSamples</span>. Here are some of the task schedulers included in this package:</p><ul><li><p>IOTaskScheduler This task scheduler queues tasks to the thread poolâ€™s I/O threads instead of its worker threads.</p></li><li><p>LimitedConcurrencyLevelTaskScheduler This task scheduler allows no more than n (a constructor parameter) tasks to execute simultaneously.</p></li><li><p>OrderedTaskScheduler This task scheduler allows only one task to execute at a time. This class is derived from LimitedConcurrencyLevelTaskScheduler and just passes 1 for n.</p></li><li><p>PrioritizingTaskScheduler This task scheduler queues tasks to the CLRâ€™s thread pool. After this has occurred, you can call Prioritize to indicate that a Task should be processed before all normal tasks (if it hasnâ€™t been processed already). You can call Deprioritize to make a Task be processed after all normal tasks.</p></li><li><p>ThreadPerTaskScheduler This task scheduler creates and starts a separate thread for each task; it does not use the thread pool at all.</p></li></ul></blockquote><p>ğŸ’¡å°ç»“ï¼šå¾ˆå®¹æ˜“è°ƒç”¨ <code>ThreadPool</code> çš„ <code>QueueUserWorkItem</code> æ–¹æ³•å‘èµ·ä¸€æ¬¡å¼‚æ­¥çš„è®¡ç®—é™åˆ¶æ“ä½œã€‚ä½†è¿™ä¸ªæŠ€æœ¯æœ‰è®¸å¤šé™åˆ¶ã€‚æœ€å¤§çš„é—®é¢˜æ˜¯æ²¡æœ‰å†…å»ºçš„æœºåˆ¶è®©ä½ çŸ¥é“æ“ä½œåœ¨ä»€ä¹ˆæ—¶å€™å®Œæˆï¼Œä¹Ÿæ²¡æœ‰æœºåˆ¶åœ¨æ“ä½œå®Œæˆæ—¶è·å¾—è¿”å›å€¼ã€‚ä¸ºäº†å…‹æœè¿™äº›é™åˆ¶ (å¹¶è§£å†³å…¶ä»–ä¸€äº›é—®é¢˜)ï¼ŒMicrosoft å¼•å…¥äº†ä»»åŠ¡çš„æ¦‚å¿µã€‚æˆ‘ä»¬é€šè¿‡ <code>System.Threading.Tasks</code> å‘½åç©ºé—´ä¸­çš„ç±»å‹æ¥ä½¿ç”¨ä»»åŠ¡ã€‚æ— è®ºè°ƒç”¨æ„é€ å™¨è¿˜æ˜¯ <code>Run</code> ï¼Œéƒ½å¯é€‰æ‹©ä¼ é€’ä¸€ä¸ª <code>CancellationToken</code> ï¼Œå®ƒä½¿ <code>Task</code> èƒ½åœ¨è°ƒåº¦å‰å–æ¶ˆã€‚è¿˜å¯é€‰æ‹©å‘æ„é€ å™¨ä¼ é€’ä¸€äº› <code>TaskCreationOptions</code> æ ‡å¿—æ¥æ§åˆ¶ <code>Task</code> çš„æ‰§è¡Œæ–¹å¼ã€‚ <code>TaskCreationOptions</code> æšä¸¾ç±»å‹è¿˜å®šä¹‰äº†ä¸€ç»„å¯æŒ‰ä½ OR çš„æ ‡å¿—ã€‚æœ‰çš„æ ‡å¿—åªæ˜¯ â€œæè®®â€ï¼Œ <code>TaskScheduler</code> åœ¨è°ƒåº¦ä¸€ä¸ª <code>Task</code> æ—¶ï¼Œå¯èƒ½ä¼šã€ä¹Ÿå¯èƒ½ä¸ä¼šé‡‡çº³è¿™äº›æè®®ã€‚ä¸è¿‡ï¼Œ <code>AttachedToParent</code> ï¼Œ <code>DenyChildAttach</code> å’Œ <code>HideScheduler</code> æ€»æ˜¯å¾—ä»¥é‡‡çº³ï¼Œå› ä¸ºå®ƒä»¬å’Œ <code>TaskScheduler</code> æœ¬èº«æ— å…³ã€‚å¦‚æœè®¡ç®—é™åˆ¶çš„ä»»åŠ¡æŠ›å‡ºæœªå¤„ç†çš„å¼‚å¸¸ï¼Œå¼‚å¸¸ä¼šè¢« â€œåå™¬â€ å¹¶å­˜å‚¨åˆ°ä¸€ä¸ªé›†åˆä¸­ï¼Œè€Œçº¿ç¨‹æ± çº¿ç¨‹å¯ä»¥è¿”å›åˆ°çº¿ç¨‹æ± ä¸­ã€‚è°ƒç”¨ <code>Wait</code> æ–¹æ³•æˆ–è€… <code>Result</code> å±æ€§æ—¶ï¼Œè¿™äº›æˆå‘˜ä¼šæŠ›å‡ºä¸€ä¸ª <code>System.AggregateException</code> å¯¹è±¡ã€‚ <code>AggregateException</code> ç±»å‹å°è£…äº†å¼‚å¸¸å¯¹è±¡çš„ä¸€ä¸ªé›†åˆ (å¦‚æœçˆ¶ä»»åŠ¡ç”Ÿæˆäº†å¤šä¸ªå­ä»»åŠ¡ï¼Œè€Œå¤šä¸ªå­ä»»åŠ¡éƒ½æŠ›å‡ºäº†å¼‚å¸¸ï¼Œè¿™ä¸ªé›†åˆä¾¿å¯èƒ½åŒ…å«å¤šä¸ªå¼‚å¸¸)ã€‚è¯¥ç±»å‹çš„ <code>InnerExceptions</code> å±æ€§è¿”å›ä¸€ä¸ª <code>ReadOnlyCollection&lt;Exception&gt;</code> å¯¹è±¡ã€‚ä¸è¦æ··æ·† <code>InnerExceptions</code> å±æ€§å’Œ <code>InnerException</code> å±æ€§ï¼Œåè€…æ˜¯ <code>AggregateException</code> ç±»ä» <code>System.Exception</code> åŸºç±»ç»§æ‰¿çš„ã€‚é™¤äº†ç­‰å¾…å•ä¸ªä»»åŠ¡ï¼Œ <code>Task</code> ç±»è¿˜æä¾›äº†ä¸¤ä¸ªé™æ€æ–¹æ³•ï¼Œå…è®¸çº¿ç¨‹ç­‰å¾…ä¸€ä¸ª <code>Task</code> å¯¹è±¡æ•°ç»„ã€‚å…¶ä¸­ï¼Œ <code>Task</code> çš„é™æ€ <code>WaitAny</code> æ–¹æ³•ä¼šé˜»å¡è°ƒç”¨çº¿ç¨‹ï¼Œç›´åˆ°æ•°ç»„ä¸­çš„ä»»ä½• <code>Task</code> å¯¹è±¡å®Œæˆã€‚æ–¹æ³•è¿”å› <code>Int32</code> æ•°ç»„ç´¢å¼•å€¼ï¼ŒæŒ‡æ˜å®Œæˆçš„æ˜¯å“ªä¸ª <code>Task</code> å¯¹è±¡ã€‚æ–¹æ³•è¿”å›åï¼Œçº¿ç¨‹è¢«å”¤é†’å¹¶ç»§ç»­è¿è¡Œã€‚å¦‚æœå‘ç”Ÿè¶…æ—¶ï¼Œæ–¹æ³•å°†è¿”å› <code>-1</code> ã€‚å¦‚æœ <code>WaitAny</code> é€šè¿‡ä¸€ä¸ª <code>CancellationToken</code> å–æ¶ˆï¼Œä¼šæŠ›å‡ºä¸€ä¸ª <code>OperationCanceledException</code> ã€‚ç±»ä¼¼åœ°ï¼Œ <code>Task</code> ç±»è¿˜æœ‰ä¸€ä¸ªé™æ€ <code>WaitAll</code> æ–¹æ³•ï¼Œå®ƒé˜»å¡è°ƒç”¨çº¿ç¨‹ï¼Œç›´åˆ°æ•°ç»„ä¸­çš„æ‰€æœ‰ <code>Task</code> å¯¹è±¡å®Œæˆã€‚å¦‚æœæ‰€æœ‰ <code>Task</code> å¯¹è±¡éƒ½å®Œæˆï¼Œ <code>WaitAll</code> æ–¹æ³•è¿”å› <code>true</code> ã€‚å‘ç”Ÿè¶…æ—¶åˆ™è¿”å› <code>false</code> ã€‚å¦‚æœ <code>WaitAll</code> é€šè¿‡ä¸€ä¸ª <code>CancellationToken</code> å–æ¶ˆï¼Œä¼šæŠ›å‡ºä¸€ä¸ª <code>OperationCanceledException</code> ã€‚å¯ç”¨ä¸€ä¸ª <code>CancellationTokenSource</code> å–æ¶ˆ <code>Task</code> ã€‚ <code>CancellationToken</code> çš„ <code>ThrowIfCancellationRequested</code> æ–¹æ³•å®šæ—¶æ£€æŸ¥æ“ä½œæ˜¯å¦å·²å–æ¶ˆã€‚è¿™ä¸ªæ–¹æ³•ä¸ <code>CancellationToken</code> çš„ <code>IsCancellationRequested</code> å±æ€§ç›¸ä¼¼ã€‚å¦‚æœ <code>CancellationTokenSource</code> å·²ç»å–æ¶ˆï¼Œ <code>ThrowIfCancellationRequested</code> ä¼šæŠ›å‡ºä¸€ä¸ª <code>OperationCanceledException</code> ã€‚ä¹‹æ‰€ä»¥é€‰æ‹©æŠ›å‡ºå¼‚å¸¸ï¼Œæ˜¯å› ä¸ºå’Œ <code>ThreadPool</code> çš„ <code>QueueUserWorkItem</code> æ–¹æ³•åˆå§‹åŒ–çš„å·¥ä½œé¡¹ä¸åŒï¼Œä»»åŠ¡æœ‰åŠæ³•è¡¨ç¤ºå®Œæˆï¼Œä»»åŠ¡ç”šè‡³èƒ½è¿”å›ä¸€ä¸ªå€¼ã€‚æ‰€ä»¥ï¼Œéœ€è¦é‡‡å–ä¸€ç§æ–¹å¼å°†å·²å®Œæˆçš„ä»»åŠ¡å’Œå‡ºé”™çš„ä»»åŠ¡åŒºåˆ†å¼€ã€‚è€Œè®©ä»»åŠ¡æŠ›å‡ºå¼‚å¸¸ï¼Œå°±å¯ä»¥çŸ¥é“ä»»åŠ¡æ²¡æœ‰ä¸€ç›´è¿è¡Œåˆ°ç»“æŸã€‚å¯åœ¨åˆ›å»º <code>Task</code> æ—¶å°†ä¸€ä¸ª <code>CancellationToken</code> ä¼ ç»™æ„é€ å™¨ (å¦‚ä¸Šä¾‹æ‰€ç¤º)ï¼Œä»è€Œå°†ä¸¤è€…å…³è”ã€‚å¦‚æœ <code>CancellationToken</code> åœ¨ <code>Task</code> è°ƒåº¦å‰å–æ¶ˆï¼Œ <code>Task</code> ä¼šè¢«å–æ¶ˆï¼Œæ°¸è¿œéƒ½ä¸æ‰§è¡Œã€‚ä½†å¦‚æœ <code>Task</code> å·²è°ƒåº¦ (é€šè¿‡è°ƒç”¨ <code>Start</code> æ–¹æ³•)ï¼Œé‚£ä¹ˆ <code>Task</code> çš„ä»£ç åªæœ‰æ˜¾ç¤ºæ”¯æŒå–æ¶ˆï¼Œå…¶æ“ä½œæ‰èƒ½åœ¨æ‰§è¡ŒæœŸé—´å–æ¶ˆã€‚é—æ†¾çš„æ˜¯ï¼Œè™½ç„¶ <code>Task</code> å¯¹è±¡å…³è”äº†ä¸€ä¸ª <code>CancellationToken</code> ï¼Œä½†å´æ²¡æœ‰åŠæ³•è®¿é—®å®ƒã€‚å› æ­¤ï¼Œå¿…é¡»åœ¨ <code>Task</code> çš„ä»£ç ä¸­è·å¾—åˆ›å»º <code>Task</code> å¯¹è±¡æ—¶çš„åŒä¸€ä¸ª <code>CancellationToken</code> ã€‚ä¸ºæ­¤ï¼Œæœ€ç®€å•çš„åŠæ³•å°±æ˜¯ä½¿ç”¨ä¸€ä¸ª lambda è¡¨è¾¾å¼ï¼Œå°† <code>CancellationToken</code> ä½œä¸ºé—­åŒ…å˜é‡ â€œä¼ é€’â€ã€‚ä¼¸ç¼©æ€§å¥½çš„è½¯ä»¶ä¸åº”è¯¥ä½¿çº¿ç¨‹é˜»å¡ã€‚è°ƒç”¨ <code>Wait</code> ï¼Œæˆ–è€…åœ¨ä»»åŠ¡å°šæœªå®Œæˆæ—¶æŸ¥è¯¢ä»»åŠ¡çš„ <code>Result</code> å±æ€§ï¼Œææœ‰å¯èƒ½é€ æˆçº¿ç¨‹æ± åˆ›å»ºæ–°çº¿ç¨‹ï¼Œè¿™å¢å¤§äº†èµ„æºçš„æ¶ˆè€—ï¼Œä¹Ÿä¸åˆ©äºæ€§èƒ½å’Œä¼¸ç¼©æ€§ã€‚å¹¸å¥½ï¼Œæœ‰æ›´å¥½çš„åŠæ³•å¯ä»¥çŸ¥é“ä¸€ä¸ªä»»åŠ¡åœ¨ä»€ä¹ˆæ—¶å€™ç»“æŸè¿è¡Œã€‚ä»»åŠ¡å®Œæˆæ—¶å¯å¯åŠ¨å¦ä¸€ä¸ªä»»åŠ¡ã€‚çº¿ç¨‹ä¸ä¼šè¿›å…¥é˜»å¡çŠ¶æ€å¹¶ç­‰å¾…è¿™ä¸¤ä¸ªä»»åŠ¡ä¸­çš„ä»»ä½•ä¸€ä¸ªå®Œæˆã€‚ç›¸åï¼Œçº¿ç¨‹å¯ä»¥æ‰§è¡Œå…¶ä»–ä»£ç ã€‚å¦‚æœçº¿ç¨‹æœ¬èº«å°±æ˜¯ä¸€ä¸ªçº¿ç¨‹æ± çº¿ç¨‹ï¼Œå®ƒå¯ä»¥è¿”å›æ± ä¸­ä»¥æ‰§è¡Œå…¶ä»–æ“ä½œã€‚å¦å¤–ï¼Œ <code>Task</code> å¯¹è±¡å†…éƒ¨åŒ…å«äº† <code>ContinueWith</code> ä»»åŠ¡çš„ä¸€ä¸ªé›†åˆã€‚æ‰€ä»¥ï¼Œå®é™…å¯ä»¥ç”¨ä¸€ä¸ª <code>Task</code> å¯¹è±¡æ¥å¤šæ¬¡è°ƒç”¨ <code>ContinueWith</code> ã€‚ä»»åŠ¡å®Œæˆæ—¶ï¼Œæ‰€æœ‰ <code>ContinueWith</code> ä»»åŠ¡éƒ½ä¼šè¿›å…¥çº¿ç¨‹æ± çš„é˜Ÿåˆ—ä¸­ã€‚æ­¤å¤–ï¼Œå¯åœ¨è°ƒç”¨ <code>ContinueWith</code> æ—¶ä¼ é€’å¯¹ä¸€ç»„ <code>TaskContinuationOptions</code> æšä¸¾å€¼è¿›è¡ŒæŒ‰ä½ OR è¿ç®—çš„ç»“æœã€‚å‰ 6 ä¸ªæ ‡å¿— ( <code>None</code> ï¼Œ <code>PreferFairness</code> ï¼Œ <code>LongRunning</code> ï¼Œ <code>AttachedToParent</code> ï¼Œ <code>DenyChildAttach</code> å’Œ <code>HideScheduler</code> ) ä¸ä¹‹å‰æè¿°çš„ <code>TaskCreationOptions</code> æšä¸¾ç±»å‹æä¾›çš„æ ‡å¿—å®Œå…¨ä¸€è‡´ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œå¦‚æœä¸æŒ‡å®šä¸Šè¿°ä»»ä½•æ ‡å¿—ï¼Œåˆ™æ–°ä»»åŠ¡æ— è®ºå¦‚ä½•éƒ½ä¼šè¿è¡Œï¼Œä¸ç®¡ç¬¬ä¸€ä¸ªä»»åŠ¡å¦‚ä½•å®Œæˆã€‚ä¸€ä¸ª <code>Task</code> å®Œæˆæ—¶ï¼Œå®ƒçš„æ‰€æœ‰æœªè¿è¡Œçš„å»¶ç»­ä»»åŠ¡éƒ½è¢«è‡ªåŠ¨å–æ¶ˆã€‚ä¸€ä¸ªä»»åŠ¡åˆ›å»ºçš„ä¸€ä¸ªæˆ–å¤šä¸ª <code>Task</code> å¯¹è±¡é»˜è®¤æ˜¯é¡¶çº§ä»»åŠ¡ï¼Œå®ƒä»¬ä¸åˆ›å»ºå®ƒä»¬çš„ä»»åŠ¡æ— å…³ã€‚ä½† <code>TaskCreationOptions.AttachedToParent</code> æ ‡å¿—å°†ä¸€ä¸ª <code>Task</code> å’Œåˆ›å»ºå®ƒçš„ <code>Task</code> å…³è”ï¼Œç»“æœæ˜¯é™¤éæ‰€æœ‰å­ä»»åŠ¡ (ä»¥åŠå­ä»»åŠ¡çš„å­ä»»åŠ¡) ç»“æŸè¿è¡Œï¼Œå¦åˆ™åˆ›å»ºä»»åŠ¡ (çˆ¶ä»»åŠ¡) ä¸è®¤ä¸ºå·²ç»ç»“æŸã€‚è°ƒç”¨ <code>ContinueWith</code> æ–¹æ³•åˆ›å»º <code>Task</code> æ—¶ï¼Œå¯æŒ‡å®š <code>TaskCreationOptions.AttachedToParent</code> æ ‡å¿—å°†å»¶ç»­ä»»åŠ¡æŒ‡å®šæˆå­ä»»åŠ¡ã€‚æ¯ä¸ª <code>Task</code> å¯¹è±¡éƒ½æœ‰ä¸€ç»„å­—æ®µï¼Œè¿™äº›å­—æ®µæ„æˆäº†ä»»åŠ¡çš„çŠ¶æ€ã€‚å…¶ä¸­åŒ…æ‹¬ä¸€ä¸ª <code>Int32 ID</code> (å‚è§ <code>Task</code> çš„åªè¯» <code>Id</code> å±æ€§)ã€ä»£è¡¨ <code>Task</code> æ‰§è¡ŒçŠ¶æ€çš„ä¸€ä¸ª <code>Int32</code> ã€å¯¹çˆ¶ä»»åŠ¡çš„å¼•ç”¨ã€å¯¹ <code>Task</code> åˆ›å»ºæ—¶æŒ‡å®šçš„ <code>TaskScheduler</code> çš„å¼•ç”¨ã€å¯¹å›è°ƒæ–¹æ³•çš„å¼•ç”¨ã€å¯¹è¦ä¼ ç»™å›è°ƒæ–¹æ³•çš„å¯¹è±¡çš„å¼•ç”¨ (å¯é€šè¿‡ <code>Task</code> çš„åªè¯» <code>AsyncState</code> å±æ€§æŸ¥è¯¢)ã€å¯¹ <code>ExecutionContext</code> çš„å¼•ç”¨ä»¥åŠå¯¹ <code>ManualResetEventSlim</code> å¯¹è±¡çš„å¼•ç”¨ã€‚å¦å¤–ï¼Œæ¯ä¸ª <code>Task</code> å¯¹è±¡éƒ½æœ‰å¯¹æ ¹æ®éœ€è¦åˆ›å»ºçš„è¡¥å……çŠ¶æ€çš„å¼•ç”¨ã€‚è¡¥å……çŠ¶æ€åŒ…å«ä¸€ä¸ª <code>CancellationToken</code> ã€ä¸€ä¸ª <code>ContinueWithTask</code> å¯¹è±¡é›†åˆã€ä¸ºæŠ›å‡ºæœªå¤„ç†å¼‚å¸¸çš„å­ä»»åŠ¡è€Œå‡†å¤‡çš„ä¸€ä¸ª <code>Task</code> å¯¹è±¡é›†åˆç­‰ã€‚è¯´äº†è¿™ä¹ˆå¤šï¼Œé‡ç‚¹ä¸éœ€è¦ä»»åŠ¡çš„é™„åŠ åŠŸèƒ½ï¼Œé‚£ä¹ˆä½¿ç”¨ <code>ThreadPool.QueueUserWorkItem</code> èƒ½è·å¾—æ›´å¥½çš„èµ„æºåˆ©ç”¨ç‡ã€‚ <code>Task</code> å’Œ <code>Task&lt;TResult&gt;</code> ç±»å®ç°äº† <code>IDisposable</code> æ¥å£ï¼Œå…è®¸åœ¨ç”¨å®Œ <code>Task</code> å¯¹è±¡åè°ƒç”¨ <code>Dispose</code> ã€‚å¦‚ä»Šï¼Œæ‰€æœ‰ <code>Dispose</code> æ–¹æ³•æ‰€åšçš„éƒ½æ˜¯å…³é—­ <code>ManualResetEventSlim</code> å¯¹è±¡ã€‚ä½†å¯å®šä¹‰ä» <code>Task</code> å’Œ <code>Task&lt;TResult&gt;</code> æ´¾ç”Ÿçš„ç±»ï¼Œåœ¨è¿™äº›ç±»ä¸­åˆ†é…å®ƒä»¬è‡ªå·±çš„èµ„æºï¼Œå¹¶åœ¨å®ƒä»¬é‡å†™çš„ <code>Dispose</code> æ–¹æ³•ä¸­é‡Šæ”¾è¿™äº›èµ„æºã€‚ä¸è¦åœ¨ä»£ç ä¸­ä¸º <code>Task</code> å¯¹è±¡æ˜¾å¼è°ƒç”¨ <code>Dispose</code> ï¼›ç›¸åï¼Œåº”è¯¥è®©åƒåœ¾å›æ”¶å™¨è‡ªå·±æ¸…ç†ä»»ä½•ä¸å†éœ€è¦çš„èµ„æºã€‚æ¯ä¸ª <code>Task</code> å¯¹è±¡éƒ½åŒ…å«ä»£è¡¨ <code>Task</code> å”¯ä¸€ ID çš„ <code>Int32</code> å­—æ®µã€‚åˆ›å»º <code>Task</code> å¯¹è±¡æ—¶è¯¥å­—æ®µåˆå§‹åŒ–ä¸ºé›¶ã€‚é¦–æ¬¡æŸ¥è¯¢ <code>Task</code> çš„åªè¯» <code>Id</code> å±æ€§æ—¶ï¼Œå±æ€§å°†ä¸€ä¸ªå”¯ä¸€çš„ <code>Int32</code> å€¼åˆ†é…ç»™è¯¥å­—æ®µï¼Œå¹¶è¿”å›è¯¥å€¼ã€‚ä»»åŠ¡ ID ä» 1 å¼€å§‹ï¼Œæ²¡åˆ†é…ä¸€ä¸ª ID éƒ½é€’å¢ 1ã€‚åœ¨ä¸€ä¸ª <code>Task</code> å¯¹è±¡çš„å­˜åœ¨æœŸé—´ï¼Œå¯æŸ¥è¯¢ <code>Task</code> çš„åªè¯» <code>Status</code> å±æ€§äº†è§£å®ƒåœ¨å…¶ç”Ÿå­˜æœŸçš„ä»€ä¹ˆä½ç½®ã€‚é¦–æ¬¡æ„é€  <code>Task</code> å¯¹è±¡æ—¶ï¼Œå®ƒçš„çŠ¶æ€æ˜¯ <code>Created</code> ã€‚ä»¥åï¼Œå½“ä»»åŠ¡å¯åŠ¨æ—¶ï¼Œå®ƒçš„çŠ¶æ€å˜æˆ <code>WaitingToRun</code> ã€‚ <code>Task</code> å®é™…åœ¨ä¸€ä¸ªçº¿ç¨‹ä¸Šè¿è¡Œæ—¶ï¼Œå®ƒçš„çŠ¶æ€å˜æˆ <code>Running</code> ã€‚ä»»åŠ¡åœæ­¢è¿è¡Œï¼ŒçŠ¶æ€å˜æˆ <code>WaitingForChildrenToComplete</code> ã€‚ä»»åŠ¡å®Œæˆæ—¶è¿›å…¥ä¸€ä¸‹çŠ¶æ€ä¹‹ä¸€ï¼š <code>RanToCompletion</code> (è¿è¡Œå®Œæˆ)ï¼Œ <code>Canceled</code> (å–æ¶ˆ) æˆ– <code>Faulted</code> (å‡ºé”™)ã€‚å¦‚æœè¿è¡Œå®Œæˆï¼Œå¯é€šè¿‡ <code>Task&lt;TResult&gt;</code> çš„ <code>Result</code> å±æ€§æ¥æŸ¥è¯¢ä»»åŠ¡ç»“æœã€‚ <code>Task</code> æˆ– <code>Task&lt;TResult&gt;</code> å‡ºé”™æ—¶ï¼Œå¯æŸ¥è¯¢ <code>Task</code> çš„ <code>Exception</code> å±æ€§æ¥è·å¾—ä»»åŠ¡æŠ›å‡ºçš„æœªå¤„ç†å¼‚å¸¸ï¼›è¯¥å±æ€§æ€»æ˜¯è¿”å›ä¸€ä¸ª <code>AggregateException</code> å¯¹è±¡ï¼Œå¯¹è±¡çš„ <code>InnerException</code> é›†åˆåŒ…å«äº†æ‰€æœ‰æœªå¤„ç†çš„å¼‚å¸¸ã€‚ä¸ºç®€åŒ–ç¼–ç ï¼Œ <code>Task</code> æä¾›äº†å‡ ä¸ªåªè¯» <code>Boolean</code> å±æ€§ï¼ŒåŒ…æ‹¬ <code>IsCanceled</code> ï¼Œ <code>IsFaulted</code> å’Œ <code>IsCompleted</code> ã€‚æ³¨æ„å½“ <code>Task</code> å¤„äº <code>RanToCompletion</code> ï¼Œ <code>Canceled</code> æˆ– <code>Faulted</code> çŠ¶æ€æ—¶ï¼Œ <code>IsCompleted</code> è¿”å› <code>true</code> ã€‚è°ƒç”¨ <code>ContinueWith</code> ï¼Œ <code>ContinueWhenAll</code> ï¼Œ <code>ContinueWhenAny</code> æˆ– <code>FromAsync</code> ç­‰æ–¹æ³•æ¥åˆ›å»ºçš„ <code>Task</code> å¯¹è±¡å¤„äº <code>WaitingForActivation</code> è£…å¡«ã€‚è¯¥çŠ¶æ€æ„å‘³ç€ <code>Task</code> çš„è°ƒåº¦ç”±ä»»åŠ¡åŸºç¡€ç»“æ„æ§åˆ¶ã€‚ä¾‹å¦‚ï¼Œä¸å¯æ˜¾å¼å¯åŠ¨é€šè¿‡è°ƒç”¨ <code>ContinueWith</code> æ¥åˆ›å»ºçš„å¯¹è±¡ï¼Œè¯¥ <code>Task</code> åœ¨å®ƒçš„å‰ç½®ä»»åŠ¡ (antecedent task) æ‰§è¡Œå®Œæ¯•åè‡ªåŠ¨å¯åŠ¨ã€‚æœ‰æ—¶éœ€è¦åˆ›å»ºä¸€ç»„å…±äº«ç›¸åŒé…ç½®çš„ <code>Task</code> å¯¹è±¡ã€‚ä¸ºé¿å…æœºæ¢°åœ°å°†ç›¸åŒçš„å‚æ•°ä¼ ç»™æ¯ä¸ª <code>Task</code> çš„æ„é€ å™¨ï¼Œå¯åˆ›å»ºä¸€ä¸ªä»»åŠ¡å·¥å‚æ¥å°è£…é€šç”¨çš„é…ç½®ã€‚ <code>System.Threading.Tasks</code> å‘½åç©ºé—´å®šä¹‰äº†ä¸€ä¸ª <code>TaskFactory</code> ç±»å‹å’Œä¸€ä¸ª <code>TaskFactory&lt;TResult&gt;</code> ç±»å‹ã€‚ä¸¤ä¸ªç±»å‹éƒ½æ´¾ç”Ÿè‡ª <code>System.Object</code> ï¼›ä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒä»¬æ˜¯å¹³çº§çš„ã€‚è¦åˆ›å»ºä¸€ç»„è¿”å› <code>void</code> çš„ä»»åŠ¡ï¼Œå°±æ„é€ ä¸€ä¸ª <code>TaskFactory</code> ï¼›è¦åˆ›å»ºä¸€ç»„å…·æœ‰ç‰¹å®šè¿”å›ç±»å‹çš„ä»»åŠ¡ï¼Œå°±æ„é€ ä¸€ä¸ª <code>TaskFactory&lt;TResult&gt;</code> ï¼Œå¹¶é€šè¿‡æ³›å‹ <code>TResult</code> å®å‚ä¼ é€’ä»»åŠ¡çš„è¿”å›ç±»å‹ã€‚åˆ›å»ºä¸Šè¿°ä»»ä½•å·¥å‚ç±»æ—¶ï¼Œè¦å‘æ„é€ å™¨ä¼ é€’å·¥å‚åˆ›å»ºçš„æ‰€æœ‰ä»»åŠ¡éƒ½å…·æœ‰çš„é»˜è®¤å€¼ã€‚å…·ä½“åœ°è¯´ï¼Œè¦å‘ä»»åŠ¡å·¥å‚ä¼ é€’å¸Œæœ›ä»»åŠ¡å…·æœ‰çš„ <code>CancellationToken</code> ï¼Œ <code>TaskScheduler</code> ï¼Œ <code>TaskCreationOptions</code> å’Œ <code>TaskContinuationOptions</code> è®¾ç½®ã€‚ä»»åŠ¡åŸºç¡€ç»“æ„éå¸¸çµæ´»ï¼Œå…¶ä¸­ <code>TaskScheduler</code> å¯¹è±¡åŠŸä¸å¯æ²¡ã€‚ <code>TaskScheduler</code> å¯¹è±¡è´Ÿè´£æ‰§è¡Œè¢«è°ƒåº¦çš„ä»»åŠ¡ï¼ŒåŒæ—¶å‘ Visual Studio è°ƒè¯•å™¨å…¬å¼€ä»»åŠ¡ä¿¡æ¯ã€‚FCL æä¾›äº†ä¸¤ä¸ªæ´¾ç”Ÿè‡ª <code>TaskScheduler</code> çš„ç±»å‹ï¼šçº¿ç¨‹æ± ä»»åŠ¡è°ƒåº¦å™¨ (thread pool task scheduler)ï¼Œå’ŒåŒæ­¥ä¸Šä¸‹æ–‡ä»»åŠ¡è°ƒåº¦å™¨ (synchronization context task scheduler)ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œæ‰€æœ‰åº”ç”¨ç¨‹åºä½¿ç”¨çš„éƒ½æ˜¯çº¿ç¨‹æ± ä»»åŠ¡è°ƒåº¦å™¨ã€‚è¿™ä¸ªä»»åŠ¡è°ƒåº¦å™¨å°†ä»»åŠ¡è°ƒåº¦ç»™çº¿ç¨‹æ± çš„å·¥ä½œè€…çº¿ç¨‹ã€‚å¯æŸ¥è¯¢ <code>TaskScheduler</code> çš„é™æ€ <code>Default</code> å±æ€§æ¥è·å¾—å¯¹é»˜è®¤ä»»åŠ¡è°ƒåº¦å™¨çš„å¼•ç”¨ã€‚</p><h2 id="parallels-static-for-foreach-and-invoke-methods"><a class="anchor" href="#parallels-static-for-foreach-and-invoke-methods">#</a> Parallelâ€™s Static For, ForEach, and Invoke Methods</h2><blockquote><p>There are some common programming scenarios that can potentially benefit from the improved performance possible with tasks. To simplify programming, the static System.Threading.Tasks. Parallel class encapsulates these common scenarios while using Task objects internally. For example, instead of processing all the items in a collection like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// One thread performs all this work sequentially</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token function">DoWork</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>you can instead get multiple thread pool threads to assist in performing this work by using the Parallel classâ€™s For method.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// The thread poolâ€™s threads process the work in parallel</span></pre></td></tr><tr><td data-num="2"></td><td><pre>Parallel<span class="token punctuation">.</span><span class="token function">For</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> i <span class="token operator">=></span> <span class="token function">DoWork</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>Similarly, if you have a collection, instead of doing this:</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// One thread performs all this work sequentially</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> item <span class="token keyword">in</span> collection<span class="token punctuation">)</span> <span class="token function">DoWork</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>you can do this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// The thread pool's threads process the work in parallel</span></pre></td></tr><tr><td data-num="2"></td><td><pre>Parallel<span class="token punctuation">.</span><span class="token function">ForEach</span><span class="token punctuation">(</span>collection<span class="token punctuation">,</span> item <span class="token operator">=></span> <span class="token function">DoWork</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>If you can use either For or ForEach in your code, then it is recommended that you use For because it executes faster.</p></blockquote><blockquote><p>And finally, if you have several methods that you need to execute, you could execute them all sequentially, like this:</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// One thread executes all the methods sequentially</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">Method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">Method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">Method3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>or you could execute them in parallel, like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// The thread poolâ€™s threads execute the methods in parallel</span></pre></td></tr><tr><td data-num="2"></td><td><pre>Parallel<span class="token punctuation">.</span><span class="token function">Invoke</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">Method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">Method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">Method3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>All of Parallelâ€™s methods have the calling thread participate in the processing of the work, which is good in terms of resource usage because we wouldnâ€™t want the calling thread to just suspend itself while waiting for thread pool threads to do all the work. However, if the calling thread finishes its work before the thread pool threads complete their part of the work, then the calling thread will suspend itself until all the work is done, which is also good because this gives you the same semantics as youâ€™d have when using a for or foreach loop: the thread doesnâ€™t continue running until all the work is done. Also note that if any operation throws an unhandled exception, the Parallel method you called will ultimately throw an AggregateException.</p></blockquote><blockquote><p>Of course, you should not go through all your source code replacing for loops with calls to Parallel.For and foreach loops with calls to Parallel.ForEach. When calling the Parallel method, there is an assumption that it is OK for the work items to be performed concurrently. Therefore, do not use the Parallel methods if the work must be processed in sequential order. Also, avoid work items that modify any kind of shared data because the data could get corrupted if it is manipulated by multiple threads simultaneously. Normally, you would fix this by adding thread synchronization locks around the data access, but if you do this, then one thread at a time can access the data and you would lose the benefit of processing multiple items in parallel.</p></blockquote><blockquote><p>In addition, there is overhead associated with the Parallel methods; delegate objects have to be allocated, and these delegates are invoked once for each work item. If you have lots of work items that can be processed by multiple threads, then you might gain a performance increase. Also, if you have lots of work to do for each item, then the performance hit of calling through the delegate is negligible. You will actually hurt your performance if you use the Parallel methods for just a few work items or for work items that are processed very quickly.</p></blockquote><blockquote><p>I should mention that Parallelâ€™s For, ForEach, and Invoke methods all have overloads that accept a ParallelOptions object, which looks like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ParallelOptions</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token function">ParallelOptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// Allows cancellation of the operation</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">CancellationToken</span> CancellationToken <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// Default=CancellationToken.None</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// Allows you to specify the maximum number of work items </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// that can be operated on concurrently</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> MaxDegreeOfParallelism <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// Default=-1 (# of available CPUs)</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Allows you to specify which TaskScheduler to use</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">TaskScheduler</span> TaskScheduler <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// Default=TaskScheduler.Default</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In addition, there are overloads of the For and ForEach methods that let you pass three delegates:</p><ul><li><p>The task local initialization delegate (localInit) is invoked once for each task participating in the work. This delegate is invoked before the task is asked to process a work item.</p></li><li><p>The body delegate (body) is invoked once for each item being processed by the various threads participating in the work.</p></li><li><p>The task local finally delegate (localFinally) is invoked once for each task participating in the work. This delegate is invoked after the task has processed all the work items that will be dispatched to it. It is even invoked if the body delegate code experiences an unhandled exception.</p></li></ul></blockquote><blockquote><p>Here is some sample code that demonstrates the use of the three delegates by adding up the bytes for all files contained within a directory.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name">Int64</span> <span class="token function">DirectoryBytes</span><span class="token punctuation">(</span><span class="token class-name">String</span> path<span class="token punctuation">,</span> <span class="token class-name">String</span> searchPattern<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">SearchOption</span> searchOption<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> files <span class="token operator">=</span> Directory<span class="token punctuation">.</span><span class="token function">EnumerateFiles</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> searchPattern<span class="token punctuation">,</span> searchOption<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">Int64</span> masterTotal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token class-name">ParallelLoopResult</span> result <span class="token operator">=</span> Parallel<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">ForEach</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> Int64<span class="token punctuation">></span></span></span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="6"></td><td><pre> files<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span> <span class="token comment">// localInit: Invoked once per task at start</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Initialize that this task has seen 0 bytes</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// Set taskLocalTotal initial value to 0</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">(</span>file<span class="token punctuation">,</span> loopState<span class="token punctuation">,</span> index<span class="token punctuation">,</span> taskLocalTotal<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span> <span class="token comment">// body: Invoked once per work item</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// Get this file's size and add it to this task's running total</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token class-name">Int64</span> fileLength <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token class-name">FileStream</span> fs <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre> fs <span class="token operator">=</span> File<span class="token punctuation">.</span><span class="token function">OpenRead</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre> fileLength <span class="token operator">=</span> fs<span class="token punctuation">.</span>Length<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* Ignore any files we can't access */</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>fs <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> fs<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token keyword">return</span> taskLocalTotal <span class="token operator">+</span> fileLength<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="23"></td><td><pre> taskLocalTotal <span class="token operator">=></span> <span class="token punctuation">&#123;</span> <span class="token comment">// localFinally: Invoked once per task at end</span></pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token comment">// Atomically add this task's total to the "master" total</span></pre></td></tr><tr><td data-num="25"></td><td><pre> Interlocked<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">ref</span> masterTotal<span class="token punctuation">,</span> taskLocalTotal<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre> <span class="token keyword">return</span> masterTotal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Each task maintains its own running total (in the taskLocalTotal variable) for the files that it is given. As each task completes its work, the master total is updated in a thread-safe way by calling the Interlocked.Add method (discussed in Chapter 29, â€œPrimitive Thread Synchronization Constructsâ€). Because each task has its own running total, no thread synchronization is required during the processing of the items. Because thread synchronization would hurt performance, not requiring thread synchronization is good. Itâ€™s only after each task returns that masterTotal has to be updated in a thread-safe way, so the performance hit of calling Interlocked.Add occurs only once per task instead of once per work item.</p></blockquote><blockquote><p>Youâ€™ll notice that the body delegate is passed a ParallelLoopState object, which looks like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ParallelLoopState</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Boolean</span> IsStopped <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Break</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int64<span class="token punctuation">?</span></span> LowestBreakIteration<span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Boolean</span> IsExceptional <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Boolean</span> ShouldExitCurrentIteration <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Each task participating in the work gets its own ParallelLoopState object, and it can use this object to interact with the other task participating in the work. The Stop method tells the loop to stop processing any more work, and future querying of the IsStopped property will return true. The Break method tells the loop to stop processing any items that are beyond the current item. For example, letâ€™s say that ForEach is told to process 100 items and Break is called while processing the fifth item, then the loop will make sure that the first five items are processed before ForEach returns. Note, however, that additional items may have been processed. The LowestBreakIteration property returns the lowest item number whose processing called the Break method. The LowestBreakIteration property returns null if Break was never called.</p></blockquote><blockquote><p>The IsException property returns true if the processing of any item resulted in an unhandled exception. If the processing of an item takes a long time, your code can query the ShouldExitCurrentIteration property to see if it should exit prematurely. This property returns true if Stop was called, Break was called, the CancellationTokenSource (referred to by the ParallelOptionâ€™s CancellationToken property) is canceled, or if the processing of an item resulted in an unhandled exception.</p></blockquote><blockquote><p>Parallelâ€™s For and ForEach methods both return a ParallelLoopResult instance, which looks like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">struct</span> <span class="token class-name">ParallelLoopResult</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Returns false if the operation was ended prematurely</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Boolean</span> IsCompleted <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int64<span class="token punctuation">?</span></span> LowestBreakIteration<span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>You can examine the properties to determine the result of the loop. If IsCompleted returns true, then the loop ran to completion and all the items were processed. If IsCompleted is false and LowestBreakIteration is null, then some thread participating in the work called the Stop method. If IsCompleted is false and LowestBreakIteration is not null, then some thread participating in the work called the Break method and the Int64 value returned from LowestBreakIteration indicates the index of the lowest item guaranteed to have been processed. If an exception is thrown, then you should catch an AggregateException in order to recover gracefully.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šä¸€äº›å¸¸è§çš„ç¼–ç¨‹æƒ…å½¢å¯é€šè¿‡ä»»åŠ¡æå‡æ€§èƒ½ã€‚ä¸ºç®€åŒ–ç¼–ç¨‹ï¼Œé™æ€ <code>System.Threading.Tasks.Parallel</code> ç±»å°è£…äº†è¿™äº›æƒ…å½¢ï¼Œå®ƒå†…éƒ¨ä½¿ç”¨ <code>Task</code> å¯¹è±¡ã€‚ <code>Parallel</code> çš„æ‰€æœ‰æ–¹æ³•éƒ½è®©è°ƒç”¨çº¿ç¨‹å‚ä¸å¤„ç†ã€‚ä»èµ„æºåˆ©ç”¨çš„è§’åº¦è¯´ï¼Œè¿™æ˜¯ä¸€ä»¶å¥½äº‹ï¼Œå› ä¸ºæˆ‘ä»¬ä¸å¸Œæœ›è°ƒç”¨çº¿ç¨‹åœä¸‹æ¥ (é˜»å¡)ï¼Œç­‰çº¿ç¨‹æ± çº¿ç¨‹åšå®Œæ‰€æœ‰å·¥ä½œæ‰èƒ½ç»§ç»­ã€‚ç„¶è€Œï¼Œå¦‚æœè°ƒç”¨çº¿ç¨‹åœ¨çº¿ç¨‹æ± çº¿ç¨‹å®Œæˆè‡ªå·±é¢é‚£ä¸€éƒ¨åˆ†å·¥ä½œä¹‹å‰å®Œæˆå·¥ä½œï¼Œè°ƒç”¨çº¿ç¨‹ä¼šå°†è‡ªå·±æŒ‚èµ·ï¼Œç›´åˆ°æ‰€æœ‰å·¥ä½œå®Œæˆå·¥ä½œã€‚è¿™ä¹Ÿæ˜¯ä¸€ä»¶å¥½äº‹ï¼Œå› ä¸ºè¿™æä¾›äº†å’Œä½¿ç”¨æ™®é€š <code>for</code> æˆ– <code>foreach</code> å¾ªç¯æ—¶ç›¸åŒçš„è¯­ä¹‰ï¼šçº¿ç¨‹è¦åœ¨æ‰€æœ‰å·¥ä½œå®Œæˆåæ‰ç»§ç»­è¿è¡Œã€‚è¿˜è¦æ³¨æ„ï¼Œå¦‚æœä»»ä½•æ“ä½œæŠ›å‡ºæœªå¤„ç†çš„å¼‚å¸¸ï¼Œä½ è°ƒç”¨çš„ <code>Parallel</code> æ–¹æ³•æœ€åä¼šæŠ›å‡ºä¸€ä¸ª <code>AggregateException</code> ã€‚ä½†è¿™å¹¶ä¸æ˜¯è¯´éœ€è¦å¯¹è‡ªå·±çš„æºä»£ç è¿›è¡Œå…¨æ–‡æ›¿æ¢ï¼Œå°† <code>for</code> å¾ªç¯æ›¿æ¢æˆå¯¹ <code>Parallel.For</code> çš„è°ƒç”¨ï¼Œå°† <code>foreach</code> å¾ªç¯æ›¿æ¢æˆå¯¹ <code>Parallel.ForEach</code> çš„è°ƒç”¨ã€‚è°ƒç”¨ <code>Parallel</code> çš„æ–¹æ³•æ—¶æœ‰ä¸€ä¸ªå¾ˆé‡è¦çš„å‰ææ¡ä»¶ï¼šå·¥ä½œé¡¹å¿…é¡»èƒ½å¹¶è¡Œæ‰§è¡Œï¼æ‰€ä»¥ï¼Œå¦‚æœå·¥ä½œå¿…é¡»é¡ºåºæ‰§è¡Œï¼Œå°±ä¸è¦ä½¿ç”¨ <code>Parallel</code> çš„æ–¹æ³•ã€‚å¦å¤–ï¼Œè¦é¿å…ä¼šä¿®æ”¹ä»»ä½•å…±äº«æ•°æ®çš„å·¥ä½œé¡¹ï¼Œå¦åˆ™å¤šä¸ªçº¿ç¨‹åŒæ—¶å¤„ç†å¯èƒ½ä¼šæŸåæ•°æ®ã€‚è§£å†³è¿™ä¸ªé—®é¢˜ä¸€èˆ¬çš„åŠæ³•æ˜¯å›´ç»•æ•°æ®è®¿é—®æ·»åŠ çº¿ç¨‹åŒæ­¥é”ã€‚ä½†è¿™æ ·ä¸€æ¬¡å°±åªèƒ½æœ‰ä¸€ä¸ªçº¿ç¨‹è®¿é—®æ•°æ®ï¼Œæ— æ³•äº«å—å¹¶è¡Œå¤„ç†å¤šä¸ªé¡¹æ‰€å¸¦æ¥çš„å¥½å¤„ã€‚å¦å¤–ï¼Œ <code>Parallel</code> çš„æ–¹æ³•æœ¬èº«ä¹Ÿæœ‰å¼€é”€ï¼›å§”æ‰˜å¯¹è±¡å¿…é¡»åˆ†é…ï¼Œè€Œé’ˆå¯¹æ¯ä¸ªå·¥ä½œé¡¹éƒ½è¦è°ƒç”¨ä¸€æ¬¡è¿™äº›å§”æ‰˜ã€‚å¦‚æœæœ‰å¤§é‡å¯ç”±å¤šä¸ªçº¿ç¨‹å¤„ç†çš„å·¥ä½œé¡¹ï¼Œé‚£ä¹ˆä¹Ÿè®¸èƒ½è·å¾—æ€§èƒ½çš„æå‡ã€‚å¦å¤–ï¼Œå¦‚æœæ¯ä¸€é¡¹éƒ½æ¶‰åŠå¤§é‡å·¥ä½œï¼Œé‚£ä¹ˆé€šè¿‡å§”æ‰˜æ¥è°ƒç”¨æ‰€äº§ç”Ÿçš„æ€§èƒ½æŸå¤±æ˜¯å¯ä»¥å¿½ç•¥ä¸è®¡çš„ã€‚ä½†å¦‚æœåªä¸ºåŒºåŒºå‡ ä¸ªå·¥ä½œé¡¹ä½¿ç”¨ <code>Parallel</code> çš„æ–¹æ³•ï¼Œæˆ–è€…ä¸ºå¤„ç†å¾—éå¸¸å¿«çš„å·¥ä½œé¡¹ä½¿ç”¨ <code>Parallel</code> çš„æ–¹æ³•ï¼Œå°±ä¼šå¾—ä¸å¿å¤±ï¼Œåè€Œé™ä½æ€§èƒ½ã€‚</p><h2 id="parallel-language-integrated-query"><a class="anchor" href="#parallel-language-integrated-query">#</a> Parallel Language Integrated Query</h2><blockquote><p>Microsoftâ€™s Language Integrated Query (LINQ) feature offers a convenient syntax for performing queries over collections of data. Using LINQ, you can easily filter items, sort items, return a projected set of items, and much more. When you use LINQ to Objects, only one thread processes all the items in your data collection sequentially; we call this a sequential query. You can potentially improve the performance of this processing by using Parallel LINQ, which can turn your sequential query into a parallel query, which internally uses tasks (queued to the default TaskScheduler) to spread the processing of the collectionâ€™s items across multiple CPUs so that multiple items are processed concurrently. Like Parallelâ€™s methods, you will get the most benefit from Parallel LINQ if you have many items to process or if the processing of each item is a lengthy compute-bound operation.</p></blockquote><blockquote><p>The static System.Linq.ParallelEnumerable class (defined in System.Core.dll) implements all of the Parallel LINQ functionality, and so you must import the System.Linq namespace into your source code via C#â€™s using directive. In particular, this class exposes parallel versions of all the standard LINQ operators such as Where, Select, SelectMany, GroupBy, Join, OrderBy, Skip, Take, and so on. All of these methods are extension methods that extend the System.Linq. ParallelQuery type. To have your LINQ to Objects query invoke the parallel versions of these methods, you must convert your sequential query (based on IEnumerable or IEnumerable) to a parallel query (based on ParallelQuery or ParallelQuery) using ParallelEnumerableâ€™s AsParallel extension method, which looks like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">ParallelQuery<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">></span></span> <span class="token generic-method"><span class="token function">AsParallel</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>TSource<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">></span></span> source<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">ParallelQuery</span> <span class="token function">AsParallel</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">IEnumerable</span> source<span class="token punctuation">)</span></pre></td></tr></table></figure><blockquote><p>Here is an example of a sequential query that has been converted to a parallel query. This query returns all the obsolete methods defined within an assembly.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ObsoleteMethods</span><span class="token punctuation">(</span><span class="token class-name">Assembly</span> assembly<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> query <span class="token operator">=</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">from</span> type <span class="token keyword">in</span> assembly<span class="token punctuation">.</span><span class="token function">GetExportedTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">AsParallel</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">from</span> method <span class="token keyword">in</span> type<span class="token punctuation">.</span><span class="token function">GetMethods</span><span class="token punctuation">(</span>BindingFlags<span class="token punctuation">.</span>Public <span class="token operator">|</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> BindingFlags<span class="token punctuation">.</span>Instance <span class="token operator">|</span> BindingFlags<span class="token punctuation">.</span>Static<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">let</span> obsoleteAttrType <span class="token operator">=</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">ObsoleteAttribute</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">where</span> <span class="token class-name">Attribute</span><span class="token punctuation">.</span><span class="token function">IsDefined</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> obsoleteAttrType<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">orderby</span> type<span class="token punctuation">.</span>FullName</pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">let</span> obsoleteAttrObj <span class="token operator">=</span> <span class="token punctuation">(</span>ObsoleteAttribute<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> Attribute<span class="token punctuation">.</span><span class="token function">GetCustomAttribute</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> obsoleteAttrType<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">select</span> String<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"Type=&#123;0&#125;\nMethod=&#123;1&#125;\nMessage=&#123;2&#125;\n"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="12"></td><td><pre> type<span class="token punctuation">.</span>FullName<span class="token punctuation">,</span> method<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> obsoleteAttrObj<span class="token punctuation">.</span>Message<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token comment">// Display the results</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> result <span class="token keyword">in</span> query<span class="token punctuation">)</span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Although uncommon, within a query you can switch from performing parallel operations back to performing sequential operations by calling ParallelEnumerableâ€™s AsSequential method.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">IEnumerable<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">></span></span> <span class="token generic-method"><span class="token function">AsSequential</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>TSource<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">ParallelQuery<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">></span></span> source<span class="token punctuation">)</span></pre></td></tr></table></figure><blockquote><p>This method basically turns a ParallelQuery back to an IEnumerable so that operations performed after calling AsSequential are performed by just one thread.</p></blockquote><blockquote><p>Normally, the resulting data produced by a LINQ query is evaluated by having some thread execute a foreach statement (as shown earlier). This means that just one thread iterates over all the queryâ€™s results. If you want to have the queryâ€™s results processed in parallel, then you should process the resulting query by using ParallelEnumerableâ€™s ForAll method.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">ForAll</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>TSource<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">ParallelQuery<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">></span></span> source<span class="token punctuation">,</span> <span class="token class-name">Action<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">></span></span> action<span class="token punctuation">)</span></pre></td></tr></table></figure><blockquote><p>This method allows multiple threads to process the results simultaneously. I could modify my code earlier to use this method as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Display the results</span></pre></td></tr><tr><td data-num="2"></td><td><pre>query<span class="token punctuation">.</span><span class="token function">ForAll</span><span class="token punctuation">(</span>Console<span class="token punctuation">.</span>WriteLine<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>However, having multiple threads call Console.WriteLine simultaneously actually hurts performance, because the Console class internally synchronizes threads, ensuring that only one at a time can access the console window. This prevents text from multiple threads from being interspersed, making the output unintelligible. Use the ForAll method when you intend to perform calculations on each result.</p></blockquote><blockquote><p>Because Parallel LINQ processes items by using multiple threads, the items are processed concurrently and the results are returned in an unordered fashion. If you need to have Parallel LINQ preserve the order of items as they are processed, then you can call ParallelEnumerableâ€™s AsOrdered method. When you call this method, threads will process items in groups and then the groups are merged back together, preserving the order; this will hurt performance. The following operators produce unordered operations: Distinct, Except, Intersect, Union, Join, GroupBy, GroupJoin, and ToLookup. If you want to enforce ordering again after one of these operators, just call the AsOrdered method.</p></blockquote><blockquote><p>The following operators produce ordered operations: OrderBy, OrderByDescending, ThenBy, and ThenByDescending. If you want to go back to unordered processing again to improve performance after one of these operators, just call the AsUnordered method.</p></blockquote><blockquote><p>Parallel LINQ offers some additional ParallelEnumerable methods that you can call to control how the query is processed.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">ParallelQuery<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">></span></span> <span class="token generic-method"><span class="token function">WithCancellation</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>TSource<span class="token punctuation">></span></span></span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">this</span> <span class="token class-name">ParallelQuery<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">></span></span> source<span class="token punctuation">,</span> CancellationTokencancellationToken<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">ParallelQuery<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">></span></span> <span class="token generic-method"><span class="token function">WithDegreeOfParallelism</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>TSource<span class="token punctuation">></span></span></span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">this</span> <span class="token class-name">ParallelQuery<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">></span></span> source<span class="token punctuation">,</span> Int32degreeOfParallelism<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">ParallelQuery<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">></span></span> <span class="token generic-method"><span class="token function">WithExecutionMode</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>TSource<span class="token punctuation">></span></span></span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">this</span> <span class="token class-name">ParallelQuery<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">></span></span> source<span class="token punctuation">,</span> ParallelExecutionModeexecutionMode<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">ParallelQuery<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">></span></span> <span class="token generic-method"><span class="token function">WithMergeOptions</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>TSource<span class="token punctuation">></span></span></span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">this</span> <span class="token class-name">ParallelQuery<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">></span></span> source<span class="token punctuation">,</span> ParallelMergeOptionsmergeOptions<span class="token punctuation">)</span></pre></td></tr></table></figure><blockquote><p>Obviously, the WithCancellation method allows you to pass a CancellationToken so that the query processing can be stopped prematurely. The WithDegreeOfParallelism method specifies the maximum number of threads allowed to process the query; it does not force the threads to be created if not all of them are necessary. Usually you will not call this method, and, by default, the query will execute using one thread per core. However, you could call WIthDegreeOfParallelism, passing a number that is smaller than the number of available cores if you want to keep some cores available for doing other work. You could also pass a number that is greater than the number of cores if the query performs synchronous I/O operations because threads will be blocking during these operations. This wastes more threads but can produce the final result in less time. You might consider doing this in a client application, but Iâ€™d highly recommend against performing synchronous I/O operations in a server application.</p></blockquote><blockquote><p>Parallel LINQ analyzes a query and then decides how to best process it. Sometimes processing a query sequentially yields better performance. This is usually true when using any of these operations: Concat, ElementAt(OrDefault), First(OrDefault), Last(OrDefault), Skip(While), Take(While), or Zip. It is also true when using overloads of Select(Many) or Where that pass a position index into your selector or predicate delegate. However, you can force a query to be processed in parallel by calling WithExecutionMode, passing it one of the ParallelExecutionMode flags.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">ParallelExecutionMode</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> Default <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment">// Let Parallel LINQ decide to best process the query</span></pre></td></tr><tr><td data-num="3"></td><td><pre> ForceParallelism <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">// Force the query to be processed in parallel</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>As mentioned before, Parallel LINQ has multiple threads processing items, and then the results must be merged back together. You can control how the items are buffered and merged by calling WithMergeOptions, passing it one of the ParallelMergeOptions flags.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">ParallelMergeOptions</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> Default <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment">// Same as AutoBuffered today (could change in the future)</span></pre></td></tr><tr><td data-num="3"></td><td><pre> NotBuffered <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">// Results are processed as ready</span></pre></td></tr><tr><td data-num="4"></td><td><pre> AutoBuffered <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token comment">// Each thread buffers some results before processed</span></pre></td></tr><tr><td data-num="5"></td><td><pre> FullyBuffered <span class="token operator">=</span> <span class="token number">3</span> <span class="token comment">// Each thread buffers all results before processed</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>These options basically give you some control over speed versus memory consumption. NotBuffered saves memory but processes items slower. FullyBuffered consumes more memory while running fastest. AutoBuffered is the compromise in between NotBuffered and FullyBuffered. Really, the best way to know which of these to choose for any given query is to try them all and compare their performance results, or just accept the default, which tends to work pretty well for many queries. See the following blog posts for more information about how Parallel LINQ partitions work across CPU cores:</p><ul><li><p><span class="exturl" data-url="aHR0cDovL2Jsb2dzLm1zZG4uY29tL3BmeHRlYW0vYXJjaGl2ZS8yMDA5LzA1LzI4Lzk2NDg2NzIuYXNweA==">http://blogs.msdn.com/pfxteam/archive/2009/05/28/9648672.aspx</span></p></li><li><p><span class="exturl" data-url="aHR0cDovL2Jsb2dzLm1zZG4uY29tL3BmeHRlYW0vYXJjaGl2ZS8yMDA5LzA2LzEzLzk3NDEwNzIuYXNweA==">http://blogs.msdn.com/pfxteam/archive/2009/06/13/9741072.aspx</span></p></li></ul></blockquote><p>ğŸ’¡å°ç»“ï¼šMicrosoft çš„è¯­è¨€é›†æˆæŸ¥è¯¢ (Language Integrated Queryï¼ŒLINQ) åŠŸèƒ½æä¾›äº†ä¸€ä¸ªç®€æ·çš„è¯­æ³•æ¥æŸ¥è¯¢æ•°æ®é›†åˆã€‚å¯ç”¨ LINQ è½»æ¾å¯¹æ•°æ®é¡¹è¿›è¡Œç­›é€‰ã€æ’åºã€æŠ•å°„ç­‰æ“ä½œã€‚ä½¿ç”¨ LINQ to Objects æ—¶ï¼Œåªæœ‰ä¸€ä¸ªçº¿ç¨‹é¡ºåºå¤„ç†æ•°æ®é›†åˆä¸­çš„æ‰€æœ‰é¡¹ï¼›æˆ‘ä»¬ç§°ä¹‹ä¸º<strong>é¡ºåºæŸ¥è¯¢</strong> (sequential query)ã€‚è¦æé«˜å¤„ç†æ€§èƒ½ï¼Œå¯ä»¥ä½¿ç”¨<strong>å¹¶è¡Œ LINQ</strong> (Parallel LINQ)ï¼Œå®ƒå°†é¡ºåºæŸ¥è¯¢è½¬æ¢æˆå¹¶è¡ŒæŸ¥è¯¢ï¼Œåœ¨å†…éƒ¨ä½¿ç”¨ä»»åŠ¡ (æ’é˜Ÿç»™é»˜è®¤ <code>TaskScheduler</code> )ï¼Œå°†é›†åˆä¸­çš„æ•°æ®é¡¹çš„å¤„ç†å·¥ä½œåˆ†æ•£åˆ°å¤šä¸ª CPU ä¸Šï¼Œä»¥ä¾¿å¹¶å‘å¤„ç†å¤šä¸ªæ•°æ®é¡¹ã€‚å’Œ <code>Parallel</code> çš„æ–¹æ³•ç›¸ä¼¼ï¼Œè¦åŒæ—¶å¤„ç†å¤§é‡é¡¹ï¼Œæˆ–è€…æ¯ä¸€é¡¹çš„å¤„ç†è¿‡ç¨‹éƒ½æ˜¯ä¸€ä¸ªè€—æ—¶çš„è®¡ç®—é™åˆ¶çš„æ“ä½œï¼Œé‚£ä¹ˆèƒ½ä»å¹¶è¡Œ LINQ è·å¾—æœ€å¤§çš„æ”¶ç›Šã€‚</p><h2 id="performing-a-periodic-compute-bound-operation"><a class="anchor" href="#performing-a-periodic-compute-bound-operation">#</a> Performing a Periodic Compute-Bound Operation</h2><blockquote><p>The System.Threading namespace defines a Timer class, which you can use to have a thread pool thread call a method periodically. When you construct an instance of the Timer class, you are telling the thread pool that you want a method of yours called back at a future time that you specify. The Timer class offers several constructors, all quite similar to each other.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Timer</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">MarshalByRefObject</span><span class="token punctuation">,</span> <span class="token class-name">IDisposable</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Timer</span><span class="token punctuation">(</span><span class="token class-name">TimerCallback</span> callback<span class="token punctuation">,</span> <span class="token class-name">Object</span> state<span class="token punctuation">,</span> <span class="token class-name">Int32</span> dueTime<span class="token punctuation">,</span> <span class="token class-name">Int32</span> period<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Timer</span><span class="token punctuation">(</span><span class="token class-name">TimerCallback</span> callback<span class="token punctuation">,</span> <span class="token class-name">Object</span> state<span class="token punctuation">,</span> <span class="token class-name">UInt32</span> dueTime<span class="token punctuation">,</span> <span class="token class-name">UInt32</span> period<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Timer</span><span class="token punctuation">(</span><span class="token class-name">TimerCallback</span> callback<span class="token punctuation">,</span> <span class="token class-name">Object</span> state<span class="token punctuation">,</span> <span class="token class-name">Int64</span> dueTime<span class="token punctuation">,</span> <span class="token class-name">Int64</span> period<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Timer</span><span class="token punctuation">(</span><span class="token class-name">TimerCallback</span> callback<span class="token punctuation">,</span> <span class="token class-name">Object</span> state<span class="token punctuation">,</span> <span class="token class-name">Timespan</span> dueTime<span class="token punctuation">,</span> <span class="token class-name">TimeSpan</span> period<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>All four constructors construct a Timer object identically. The callback parameter identifies the method that you want called back by a thread pool thread. Of course, the callback method that you write must match the System.Threading.TimerCallback delegate type, which is defined as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">delegate</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">TimerCallback</span><span class="token punctuation">(</span><span class="token class-name">Object</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>The constructorâ€™s state parameter allows you to pass state data to the callback method each time it is invoked; you can pass null if you have no state data to pass. You use the dueTime parameter to tell the CLR how many milliseconds to wait before calling your callback method for the very first time. You can specify the number of milliseconds by using a signed or unsigned 32-bit value, a signed 64- bit value, or a TimeSpan value. If you want the callback method called immediately, specify 0 for the dueTime parameter. The last parameter, period, allows you to specify how long, in milliseconds, to wait before each successive call to the callback method. If you pass Timeout.Infinite (-1) for this parameter, a thread pool thread will call the callback method just once.</p></blockquote><blockquote><p>Internally, the thread pool has just one thread that it uses for all Timer objects. This thread knows when the next Timer objectâ€™s time is due. When the next Timer object is due, the thread wakes up, and internally calls ThreadPoolâ€™s QueueUserWorkItem to enter an entry into the thread poolâ€™s queue, causing your callback method to get called. If your callback method takes a long time to execute, the timer could go off again. This could cause multiple thread pool threads to be executing your callback method simultaneously. To work around this problem, I recommend the following: construct the Timer specifying Timeout.Infinite for the period parameter. Now, the timer will fire only once. Then, in your callback method, call the Change method specifying a new due time and again specify Timeout.Infinite for the period parameter. Here is what the Change method overloads look like.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Timer</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">MarshalByRefObject</span><span class="token punctuation">,</span> <span class="token class-name">IDisposable</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Boolean</span> <span class="token function">Change</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> dueTime<span class="token punctuation">,</span> <span class="token class-name">Int32</span> period<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Boolean</span> <span class="token function">Change</span><span class="token punctuation">(</span><span class="token class-name">UInt32</span> dueTime<span class="token punctuation">,</span> <span class="token class-name">UInt32</span> period<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Boolean</span> <span class="token function">Change</span><span class="token punctuation">(</span><span class="token class-name">Int64</span> dueTime<span class="token punctuation">,</span> <span class="token class-name">Int64</span> period<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Boolean</span> <span class="token function">Change</span><span class="token punctuation">(</span><span class="token class-name">TimeSpan</span> dueTime<span class="token punctuation">,</span> <span class="token class-name">TimeSpan</span> period<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The Timer class also offers a Dispose method that allows you to cancel the timer altogether and optionally signal the kernel object identified by the notifyObject parameter when all pending callbacks for the time have completed. Here is what the Dispose method overloads look like.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Timer</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">MarshalByRefObject</span><span class="token punctuation">,</span> <span class="token class-name">IDisposable</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Boolean</span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Boolean</span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token class-name">WaitHandle</span> notifyObject<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>ğŸ’¡é‡è¦æç¤ºï¼š <code>Timer</code> å¯¹è±¡è¢«åƒåœ¾å›æ”¶æ—¶ï¼Œå®ƒçš„ç»ˆç»“ä»£ç å‘Šè¯‰çº¿ç¨‹æ± å–æ¶ˆè®¡æ—¶å™¨ï¼Œä½¿å®ƒä¸å†è§¦å‘ã€‚æ‰€ä»¥ï¼Œä½¿ç”¨ <code>Timer</code> å¯¹è±¡æ—¶ï¼Œè¦ç¡®å®šæœ‰ä¸€ä¸ªå˜é‡åœ¨ä¿æŒ <code>Timer</code> å¯¹è±¡çš„å­˜æ´»ï¼Œå¦åˆ™å¯¹ä½ çš„å›è°ƒæ–¹æ³•çš„è°ƒç”¨å°±ä¼šåœæ­¢ã€‚21.1.3 èŠ‚ â€œåƒåœ¾å›æ”¶ä¸è°ƒè¯•â€ å¯¹æ­¤è¿›è¡Œäº†è¯¦ç»†è®¨è®ºå’Œæ¼”ç¤ºã€‚</p><blockquote><p>The following code demonstrates how to have a thread pool thread call a method starting immediately and then every two seconds thereafter.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">TimerDemo</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Timer</span> s_timer<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Checking status every 2 seconds"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// Create the Timer ensuring that it never fires. This ensures that</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// s_timer refers to it BEFORE Status is invoked by a thread pool thread</span></pre></td></tr><tr><td data-num="7"></td><td><pre> s_timer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Timer</span><span class="token punctuation">(</span>Status<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> Timeout<span class="token punctuation">.</span>Infinite<span class="token punctuation">,</span> Timeout<span class="token punctuation">.</span>Infinite<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Now that s_timer is assigned to, we can let the timer fire knowing</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// that calling Change in Status will not throw a NullReferenceException</span></pre></td></tr><tr><td data-num="10"></td><td><pre> s_timer<span class="token punctuation">.</span><span class="token function">Change</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Timeout<span class="token punctuation">.</span>Infinite<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Prevent the process from terminating</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token comment">// This method's signature must match the TimerCallback delegate</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Status</span><span class="token punctuation">(</span><span class="token class-name">Object</span> state<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// This method is executed by a thread pool thread</span></pre></td></tr><tr><td data-num="16"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"In Status at &#123;0&#125;"</span><span class="token punctuation">,</span> DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre> Thread<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Simulates other work (1 second)</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token comment">// Just before returning, have the Timer fire again in 2 seconds</span></pre></td></tr><tr><td data-num="19"></td><td><pre> s_timer<span class="token punctuation">.</span><span class="token function">Change</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">,</span> Timeout<span class="token punctuation">.</span>Infinite<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token comment">// When this method returns, the thread goes back</span></pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token comment">// to the pool and waits for another work item</span></pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>If you have an operation you want performed periodically, there is another way you can structure your code by taking advantage of Taskâ€™s static Delay method along with C#â€™s async and await keywords (discussed extensively in Chapter 28). Here is a rewrite of the preceding code demonstrating this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DelayDemo</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Checking status every 2 seconds"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token function">Status</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Prevent the process from terminating</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// This method can take whatever parameters you desire</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">async</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Status</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Checking status at &#123;0&#125;"</span><span class="token punctuation">,</span> DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// Put code to check status here...</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// At end of loop, delay 2 seconds without blocking a thread</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">await</span> Task<span class="token punctuation">.</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// await allows thread to return</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token comment">// After 2 seconds, some thread will continue after await to loop around</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="so-many-timers-so-little-time"><a class="anchor" href="#so-many-timers-so-little-time">#</a> So Many Timers, So Little Time</h3><blockquote><p>Unfortunately, the FCL actually ships with several timers, and it is not clear to most programmers what makes each timer unique. Let me attempt to explain:</p><ul><li><p>System.Threadingâ€™s Timer class This is the timer discussed in the previous section, and it is the best timer to use when you want to perform periodic background tasks on a thread pool thread.</p></li><li><p>System.Windows.Formsâ€™s Timer class Constructing an instance of this class tells Windows to associate a timer with the calling thread (see the Win32 SetTimer function). When this timer goes off, Windows injects a timer message (WM_TIMER) into the threadâ€™s message queue. The thread must execute a message pump that extracts these messages and dispatches them to the desired callback method. Notice that all of the work is done by just one threadâ€”the thread that sets the timer is guaranteed to be the thread that executes the callback method. This also means that your timer method will not be executed by multiple threads concurrently.</p></li><li><p>System.Windows.Threadingâ€™s DispatcherTimer class This class is the equivalent of the System.Windows.Formsâ€™s Timer class for Silverlight and WPF applications.</p></li><li><p>Windows.UI.Xamlâ€™s DispatcherTimer class This class is the equivalent of the System. Windows.Formsâ€™s Timer class for Windows Store apps.</p></li><li><p>System.Timersâ€™s Timer class This timer is basically a wrapper around System.Threadingâ€™s Timer class that causes the CLR to queue events into the thread pool when the timer comes due. The System.Timers.Timer class is derived from System.ComponentModelâ€™s Component class, which allows these timer objects to be placed on a design surface in Visual Studio. Also, it exposes properties and events, allowing it to be used more easily from Visual Studioâ€™s designer. This class was added to the FCL years ago while Microsoft was still sorting out the threading and timer stuff. This class probably should have been removed so that everyone would be using the System.Threading.Timer class instead. In fact, I never use the System. Timers.Timer class, and Iâ€™d discourage you from using it, too, unless you really want a timer on a design surface.</p></li></ul></blockquote><p>ğŸ’¡å°ç»“ï¼š <code>System.Threading</code> å‘½åç©ºé—´å®šä¹‰äº†ä¸€ä¸ª <code>Timer</code> ç±»ï¼Œå¯ç”¨å®ƒè®©ä¸€ä¸ªçº¿ç¨‹æ± çº¿ç¨‹å®šæ—¶è°ƒç”¨ä¸€ä¸ªæ–¹æ³•ã€‚æ„é€  <code>Timer</code> ç±»çš„å®ä¾‹ç›¸å½“äºå‘Šè¯‰çº¿ç¨‹æ± ï¼šåœ¨å°†æ¥æŸä¸ªæ—¶é—´ (å…·ä½“ç”±ä½ æŒ‡å®š) å›è°ƒä½ çš„ä¸€ä¸ªæ–¹æ³•ã€‚åœ¨å†…éƒ¨ï¼Œçº¿ç¨‹æ± ä¸ºæ‰€æœ‰ <code>Timer</code> å¯¹è±¡åªä½¿ç”¨äº†ä¸€ä¸ªçº¿ç¨‹ã€‚è¿™ä¸ªçº¿ç¨‹çŸ¥é“ä¸‹ä¸€ä¸ª <code>Timer</code> å¯¹è±¡åœ¨ä»€ä¹ˆæ—¶å€™åˆ°æœŸ (è®¡æ—¶å™¨è¿˜æœ‰å¤šä¹…è§¦å‘)ã€‚ä¸‹ä¸€ä¸ª <code>Timer</code> å¯¹è±¡åˆ°æœŸæ—¶ï¼Œçº¿ç¨‹å°±ä¼šå”¤é†’ï¼Œåœ¨å†…éƒ¨è°ƒç”¨ <code>ThreadPool</code> çš„ <code>QueueUserWorkItem</code> ï¼Œ å°†ä¸€ä¸ªå·¥ä½œé¡¹æ·»åŠ åˆ°çº¿ç¨‹æ± çš„é˜Ÿåˆ—ä¸­ï¼Œä½¿ä½ çš„å›è°ƒæ–¹æ³•å¾—åˆ°è°ƒç”¨ã€‚å¦‚æœå›è°ƒæ–¹æ³•çš„æ‰§è¡Œæ—¶é—´å¾ˆé•¿ï¼Œè®¡æ—¶å™¨å¯èƒ½ (åœ¨ä¸Šä¸ªå›è°ƒè¿˜æ²¡æœ‰å®Œæˆçš„æ—¶å€™) å†æ¬¡è§¦å‘ã€‚è¿™å¯èƒ½é€ æˆå¤šä¸ªçº¿ç¨‹æ± çº¿ç¨‹åŒæ—¶æ‰§è¡Œä½ çš„å›è°ƒæ–¹æ³•ã€‚ä¸ºè§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘çš„å»ºè®®æ˜¯ï¼šæ„é€  <code>Timer</code> æ—¶ï¼Œä¸º <code>period</code> å‚æ•°æŒ‡å®š <code>Timeout.Infinite</code> ã€‚è¿™æ ·ï¼Œè®¡æ—¶å™¨å°±åªè§¦å‘ä¸€æ¬¡ã€‚ç„¶åï¼Œåœ¨ä½ çš„å›è°ƒæ–¹æ³•ä¸­ï¼Œè°ƒç”¨ <code>Change</code> æ–¹æ³•æ¥æŒ‡å®šä¸€ä¸ªæ–°çš„ <code>dueTime</code> ï¼Œå¹¶å†æ¬¡ä¸º <code>period</code> å‚æ•°æŒ‡å®š <code>Timeout.Infinite</code> ã€‚ <code>Timer</code> ç±»è¿˜æä¾›äº†ä¸€ä¸ª <code>Dispose</code> æ–¹æ³•ï¼Œå…è®¸å®Œå…¨å–æ¶ˆè®¡æ—¶å™¨ï¼Œå¹¶å¯åœ¨å½“æ—¶å¤„äº pending çŠ¶æ€çš„æ‰€æœ‰å›è°ƒå®Œæˆä¹‹åï¼Œå‘ <code>notifyObject</code> å‚æ•°æ ‡è¯†çš„å†…æ ¸å¯¹è±¡å‘å‡ºä¿¡å·ã€‚</p><h2 id="how-the-thread-pool-manages-its-threads"><a class="anchor" href="#how-the-thread-pool-manages-its-threads">#</a> How the Thread Pool Manages Its Threads</h2><blockquote><p>Now Iâ€™d like to talk about how the thread pool code manages worker and I/O threads. However, I donâ€™t want to go into a lot of detail, because the internal implementation has changed greatly over the years with each version of the CLR, and it will continue changing with future versions. It is best to think of the thread pool as a black box. The black box is not perfect for any one application, because it is a general purpose thread-scheduling technology designed to work with a large myriad of applications; it will work better for some applications than for others. It works very well today, and I highly recommend that you trust it, because it would be very hard for you to produce a thread pool that works better than the one shipping in the CLR. And, over time, most applications should improve as the thread pool code internally changes how it manages threads.</p></blockquote><h3 id="setting-thread-pool-limits"><a class="anchor" href="#setting-thread-pool-limits">#</a> Setting Thread Pool Limits</h3><blockquote><p>The CLR allows developers to set a maximum number of threads that the thread pool will create. However, it turns out that thread pools should never place an upper limit on the number of threads in the pool because starvation or deadlock might occur. Imagine queuing 1,000 work items that all block on an event that is signaled by the 1,001st item. If youâ€™ve set a maximum of 1,000 threads, the 1,001st work item wonâ€™t be executed, and all 1,000 threads will be blocked forever, forcing end users to terminate the application and lose all their work. Also, it is very unusual for developers to artificially limit the resources that they have available to their application. For example, would you ever start your application and tell the system youâ€™d like to restrict the amount of memory that the application can use or limit the amount of network bandwidth that your application can use? Yet, for some reason, developers feel compelled to limit the number of threads that the thread pool can have.</p></blockquote><blockquote><p>Because customers have had starvation and deadlock issues, the CLR team has steadily increased the default maximum number of threads that the thread pool can have. The default maximum is now about 1,000 threads, which is effectively limitless because a 32-bit process has at most 2 GB of usable address space within it. After a bunch of Win32 DLLs load, the CLR DLLs load, the native heap and the managed heap is allocated, there is approximately 1.5 GB of address space left over. Because each thread requires more than 1 MB of memory for its user-mode stack and thread environment block (TEB), the most threads you can get in a 32-bit process is about 1,360. Attempting to create more threads than this will result in an OutOfMemoryException being thrown. Of course, a 64-bit process offers 8 terabytes of address space, so you could theoretically create hundreds of thousands of threads. But allocating anywhere near this number of threads is really just a waste of resources, especially when the ideal number of threads to have is equal to the number of CPUs in the machine. What the CLR team should do is remove the limits entirely, but they canâ€™t do this now because doing so might break some applications that expect thread pool limits to exist.</p></blockquote><blockquote><p>The System.Threading.ThreadPool class offers several static methods that you can call to manipulate the number of threads in the thread pool: GetMaxThreads, SetMaxThreads, GetMinThreads, SetMinThreads, and GetAvailableThreads. I highly recommend that you do not call any of these methods. Playing with thread pool limits usually results in making an application perform worse, not better. If you think that your application needs hundreds or thousands of threads, there is something seriously wrong with the architecture of your application and the way that itâ€™s using threads. This chapter and Chapter 28 demonstrate the proper way to use threads.</p></blockquote><h3 id="how-worker-threads-are-managed"><a class="anchor" href="#how-worker-threads-are-managed">#</a> How Worker Threads Are Managed</h3><blockquote><p>Figure 27-1 shows the various data structures that make up the worker threads' part of the thread pool. The ThreadPool.QueueUserWorkItem method and the Timer class always queue work items to the global queue. Worker threads pull items from this queue using a first-in-first-out (FIFO) algorithm and process them. Because multiple worker threads can be removing items from the global queue simultaneously, all worker threads contend on a thread synchronization lock to ensure that two or more threads donâ€™t take the same work item. This thread synchronization lock can become a bottleneck in some applications, thereby limiting scalability and performance to some degree.</p></blockquote><p><img data-src="/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/image-20230206220449823.png" alt="image-20230206220449823"></p><blockquote><p>Now letâ€™s talk about Task objects scheduled using the default TaskScheduler (obtained by querying TaskSchedulerâ€™s static Default property).4 When a non-worker thread schedules a Task, the Task is added to the global queue. But, each worker thread has its own local queue, and when a worker thread schedules a Task, the Task is added to calling the threadâ€™s local queue.</p></blockquote><blockquote><p>When a worker thread is ready to process an item, it always checks its local queue for a Task first. If a Task exists, the worker thread removes the Task from its local queue and processes the item. Note that a worker thread pulls tasks from its local queue by using a last-in-first-out (LIFO) algorithm. Because a worker thread is the only thread allowed to access the head of its own local queue, no thread synchronization lock is required and adding and removing Tasks from the queue is very fast. A side effect of this behavior is that Tasks are executed in the reverse order that they were queued.</p></blockquote><p>ğŸ’¡é‡è¦æç¤ºï¼šçº¿ç¨‹æ± ä»æ¥ä¸ä¿è¯æ’é˜Ÿä¸­çš„å·¥ä½œé¡¹çš„å¤„ç†é¡ºåºã€‚è¿™æ˜¯åˆç†çš„ï¼Œå°¤å…¶æ˜¯è€ƒè™‘åˆ°å¤šä¸ªçº¿ç¨‹å¯èƒ½åŒæ—¶å¤„ç†å·¥ä½œé¡¹ã€‚ä½†ä¸Šè¿°å‰¯ä½œç”¨ä½¿è¿™ä¸ªé—®é¢˜å˜å¾—æ¶åŒ–äº†ã€‚ä½ å¿…é¡»ä¿è¯è‡ªå·±çš„åº”ç”¨ç¨‹åºå¯¹äºå·¥ä½œé¡¹æˆ– <code>Task</code> çš„æ‰§è¡Œé¡ºåºä¸ä½œä»»ä½•é¢„è®¾ã€‚</p><blockquote><p>If a worker thread sees that its local queue is empty, then the worker thread will attempt to steal a Task from another worker threadâ€™s local queue. Tasks are stolen from the tail of a local queue and require that a thread synchronization lock be taken, which hurts performance a little bit. Of course, the hope is that stealing rarely occurs, so this lock is taken rarely. If all the local queues are empty, then the worker thread will extract an item from the global queue (taking its lock) using the FIFO algorithm. If the global queue is empty, then the worker thread puts itself to sleep waiting for something to show up. If it sleeps for a long time, then it will wake itself up and destroy itself, allowing the system to reclaim the resources (kernel object, stacks, TEB) that were used by the thread.</p></blockquote><blockquote><p>The thread pool will quickly create worker threads so that the number of worker threads is equal to the value pass to ThreadPoolâ€™s SetMinThreads method. If you never call this method (and itâ€™s recommended that you never call this method), then the default value is equal to the number of CPUs that your process is allowed to use as determined by your processâ€™s affinity mask. Usually your process is allowed to use all the CPUs on the machine, so the thread pool will quickly create worker threads up to the number of CPUs on the machine. After this many threads have been created, the thread pool monitors the completion rate of work items and if items are taking a long time to complete (the meaning of which is not documented), it creates more worker threads. If items start completing quickly, then worker threads will be destroyed.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šCLR å…è®¸å¼€å‘äººå‘˜è®¾ç½®çº¿ç¨‹æ± è¦åˆ›å»ºçš„æœ€å¤§çº¿ç¨‹æ•°ã€‚ä½†å®è·µè¯æ˜ï¼Œçº¿ç¨‹æ± æ°¸è¿œéƒ½ä¸åº”è¯¥è®¾ç½®çº¿ç¨‹æ•°ä¸Šé™ï¼Œå› ä¸ºå¯èƒ½å‘ç”Ÿé¥¥é¥¿æˆ–æ­»é”ã€‚ <code>System.Threading.ThreadPool</code> ç±»æä¾›äº†å‡ ä¸ªé™æ€æ–¹æ³•ï¼Œå¯è°ƒç”¨å®ƒä»¬è®¾ç½®å’ŒæŸ¥è¯¢çº¿ç¨‹æ± çš„çº¿ç¨‹æ•°ï¼š <code>GetMaxThreads</code> ï¼Œ <code>SetMaxThreads</code> ï¼Œ <code>GetMinThreads</code> ï¼Œ <code>SetMinThreads</code> å’Œ <code>GetAvailableThreads</code> ã€‚å¼ºçƒˆå»ºè®®ä¸è¦è°ƒç”¨ä¸Šè¿°ä»»ä½•æ–¹æ³•ã€‚é™åˆ¶çº¿ç¨‹æ± çš„çº¿ç¨‹æ•°ï¼Œä¸€èˆ¬éƒ½åªä¼šé€ æˆåº”ç”¨ç¨‹åºçš„æ€§èƒ½å˜å¾—æ›´å·®ï¼Œè€Œä¸æ˜¯æ›´å¥½ã€‚å¦‚æœè®¤ä¸ºè‡ªå·±çš„åº”ç”¨ç¨‹åºéœ€è¦å‡ ç™¾æˆ–å‡ åƒä¸ªçº¿ç¨‹ï¼Œè¡¨æ˜ä½ çš„åº”ç”¨ç¨‹åºçš„æ¶æ„å’Œä½¿ç”¨çº¿ç¨‹çš„æ–¹å¼å·²å‡ºç°ä¸¥é‡é—®é¢˜ã€‚ <code>ThreadPool.QueueUserWorkItem</code> æ–¹æ³•å’Œ <code>Timer</code> ç±»æ€»æ˜¯å°†å·¥ä½œé¡¹æ”¾åˆ°å…¨å±€é˜Ÿåˆ—ä¸­ã€‚å·¥ä½œè€…çº¿ç¨‹é‡‡ç”¨ä¸€ä¸ªå…ˆå…¥å…ˆå‡º (first-in-first-outï¼ŒFIFO) ç®—æ³•å°†å·¥ä½œé¡¹ä»è¿™ä¸ªé˜Ÿåˆ—ä¸­å–å‡ºï¼Œå¹¶å¤„ç†å®ƒä»¬ã€‚ç”±äºå¤šä¸ªå·¥ä½œè€…çº¿ç¨‹å¯èƒ½åŒæ—¶ä»å…¨å±€é˜Ÿåˆ—ä¸­æ‹¿èµ°å·¥ä½œé¡¹ï¼Œæ‰€ä»¥æ‰€æœ‰å·¥ä½œè€…çº¿ç¨‹éƒ½ç«äº‰ä¸€ä¸ªçº¿ç¨‹åŒæ­¥é”ï¼Œä»¥ä¿è¯ä¸¤ä¸ªæˆ–å¤šä¸ªçº¿ç¨‹ä¸ä¼šè·å–åŒä¸€ä¸ªå·¥ä½œé¡¹ã€‚è¿™ä¸ªçº¿ç¨‹åŒæ­¥é”åœ¨æŸäº›åº”ç”¨ç¨‹åºä¸­å¯èƒ½æˆä¸ºç“¶é¢ˆï¼Œå¯¹ä¼¸ç¼©æ€§å’Œæ€§èƒ½é€ æˆæŸç§ç¨‹åº¦çš„é™åˆ¶ã€‚ä½¿ç”¨é»˜è®¤ <code>TaskScheduler</code> (æŸ¥è¯¢ <code>TaskScheduler</code> çš„é™æ€ <code>Default</code> å±æ€§è·å¾—) æ¥è°ƒåº¦çš„ <code>Task</code> å¯¹è±¡ï¼Œéå·¥ä½œè€…çº¿ç¨‹è°ƒåº¦ä¸€ä¸ª <code>Task</code> æ—¶ï¼Œè¯¥ <code>Task</code> è¢«æ·»åŠ åˆ°å…¨å±€é˜Ÿåˆ—ã€‚ä½†æ¯ä¸ªå·¥ä½œè€…çº¿ç¨‹éƒ½æœ‰è‡ªå·±çš„æœ¬åœ°é˜Ÿåˆ—ã€‚å·¥ä½œè€…çº¿ç¨‹è°ƒåº¦ä¸€ä¸ª <code>Task</code> æ—¶ï¼Œè¯¥ <code>Task</code> è¢«æ·»åŠ åˆ°è°ƒç”¨çº¿ç¨‹çš„æœ¬åœ°é˜Ÿåˆ—ã€‚å·¥ä½œè€…çº¿ç¨‹å‡†å¤‡å¥½å¤„ç†å·¥ä½œé¡¹æ—¶ï¼Œå®ƒæ€»æ˜¯å…ˆæ£€æŸ¥æœ¬åœ°é˜Ÿåˆ—æ¥æŸ¥æ‰¾ä¸€ä¸ª <code>Task</code> ã€‚å­˜åœ¨ä¸€ä¸ª <code>Task</code> ï¼Œå·¥ä½œè€…çº¿ç¨‹å°±ä»æœ¬åœ°é˜Ÿåˆ—ç§»é™¤ <code>Task</code> å¹¶å¤„ç†å·¥ä½œé¡¹ã€‚è¦æ³¨æ„çš„æ˜¯ï¼Œå·¥ä½œè€…çº¿ç¨‹é‡‡ç”¨åå…¥å…ˆå‡º (LIFO) ç®—æ³•å°†ä»»åŠ¡ä»æœ¬åœ°é˜Ÿåˆ—å–å‡ºã€‚ç”±äºå·¥ä½œè€…çº¿ç¨‹æ˜¯å”¯ä¸€å…è®¸è®¿é—®å®ƒè‡ªå·±çš„æœ¬åœ°é˜Ÿåˆ—å¤´çš„çº¿ç¨‹ï¼Œæ‰€ä»¥æ— éœ€åŒæ­¥é”ï¼Œè€Œä¸”åœ¨é˜Ÿåˆ—ä¸­æ·»åŠ å’Œåˆ é™¤ <code>Task</code> çš„é€Ÿåº¦éå¸¸å¿«ã€‚è¿™ä¸ªè¡Œä¸ºçš„å‰¯ä½œç”¨æ˜¯ <code>Task</code> æŒ‰ç…§å’Œè¿›å…¥é˜Ÿåˆ—æ—¶ç›¸åçš„é¡ºåºæ‰§è¡Œã€‚å¦‚æœå·¥ä½œè€…çº¿ç¨‹å‘ç°å®ƒçš„æœ¬åœ°é˜Ÿåˆ—å˜ç©ºäº†ï¼Œä¼šå°è¯•ä»å¦ä¸€ä¸ªå·¥ä½œè€…çº¿ç¨‹çš„æœ¬åœ°é˜Ÿåˆ— â€œå·â€ ä¸€ä¸ª <code>Task</code> ã€‚ è¿™ä¸ª <code>Task</code> æ˜¯ä»æœ¬åœ°é˜Ÿåˆ—çš„å°¾éƒ¨ â€œå·â€ èµ°çš„ï¼Œå¹¶è¦æ±‚è·å–ä¸€ä¸ªçº¿ç¨‹åŒæ­¥é”ï¼Œè¿™å¯¹æ€§èƒ½æœ‰å°‘è®¸å½±å“ã€‚å½“ç„¶ï¼Œå¸Œæœ›è¿™ç§ â€œå·ç›—â€ è¡Œä¸ºå¾ˆå°‘å‘ç”Ÿï¼Œä»è€Œå¾ˆå°‘éœ€è¦è·å–é”ã€‚å¦‚æœæ‰€æœ‰æœ¬åœ°é˜Ÿåˆ—éƒ½å˜ç©ºï¼Œé‚£ä¹ˆå·¥ä½œè€…çº¿ç¨‹ä¼šä½¿ç”¨ FIFO ç®—æ³•ï¼Œä»å…¨å±€é˜Ÿåˆ—æå–ä¸€ä¸ªå·¥ä½œé¡¹ (å–å¾—å®ƒçš„é”)ã€‚å¦‚æœå…¨å±€é˜Ÿåˆ—ä¹Ÿä¸ºç©ºï¼Œå·¥ä½œè€…çº¿ç¨‹ä¼šè¿›å…¥ç¡çœ çŠ¶æ€ï¼Œç­‰å¾…äº‹æƒ…çš„å‘ç”Ÿã€‚å¦‚æœç¡çœ äº†å¤ªé•¿æ—¶é—´ï¼Œå®ƒä¼šè‡ªå·±é†’æ¥ï¼Œå¹¶é”€æ¯è‡ªèº«ï¼Œå…è®¸ç³»ç»Ÿå›æ”¶çº¿ç¨‹ä½¿ç”¨çš„èµ„æº (å†…æ ¸å¯¹è±¡ã€æ ˆã€TEB ç­‰)ã€‚çº¿ç¨‹æ± ä¼šå¿«é€Ÿåˆ›å»ºå·¥ä½œè€…çº¿ç¨‹ï¼Œä½¿å·¥ä½œè€…çº¿ç¨‹çš„æ•°é‡ç­‰äºä¼ ç»™ <code>ThreadPool</code> çš„ <code>SetMinThreads</code> æ–¹æ³•çš„å€¼ã€‚å¦‚æœä»ä¸è°ƒç”¨è¿™ä¸ªæ–¹æ³• (ä¹Ÿå»ºè®®ä½ æ°¸è¿œä¸è°ƒç”¨è¿™ä¸ªæ–¹æ³•)ï¼Œé‚£ä¹ˆé»˜è®¤å€¼ç­‰äºä½ çš„è¿›ç¨‹å…è®¸ä½¿ç”¨çš„ CPU æ•°é‡ï¼Œè¿™æ˜¯ç”±è¿›ç¨‹çš„ affinity mask (å…³è”æ©ç ) å†³å®šçš„ã€‚é€šå¸¸ï¼Œä½ çš„è¿›ç¨‹å…è®¸ä½¿ç”¨æœºå™¨ä¸Šçš„æ‰€æœ‰ CPUï¼Œæ‰€ä»¥çº¿ç¨‹æ± åˆ›å»ºçš„å·¥ä½œè€…çº¿ç¨‹æ•°é‡å¾ˆå¿«å°±ä¼šè¾¾åˆ°æœºå™¨çš„ CPU æ•°ã€‚åˆ›å»ºäº†è¿™ä¹ˆå¤š (CPU æ•°é‡) çš„çº¿ç¨‹åï¼Œçº¿ç¨‹æ± ä¼šç›‘è§†å·¥ä½œé¡¹çš„å®Œæˆé€Ÿåº¦ã€‚å¦‚æœå·¥ä½œé¡¹å®Œæˆçš„æ—¶é—´å¤ªé•¿ (å…·ä½“å¤šé•¿æ²¡æœ‰æ­£å¼å…¬å¸ƒ)ï¼Œçº¿ç¨‹æ± ä¼šåˆ›å»ºæ›´å¤šçš„å·¥ä½œè€…çº¿ç¨‹ã€‚å¦‚æœå·¥ä½œé¡¹çš„å®Œæˆé€Ÿåº¦å¼€å§‹å˜å¿«ï¼Œå·¥ä½œè€…çº¿ç¨‹ä¼šè¢«é”€æ¯ã€‚</p><div class="tags"><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> è¯»ä¹¦ç¬”è®°</a> <a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C#</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2023-02-10 21:45:29" itemprop="dateModified" datetime="2023-02-10T21:45:29+08:00">2023-02-10</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(ï¿£â–½ï¿£)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Sakupinera WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Sakupinera Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Sakupinera PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Sakupinera <i class="ic i-at"><em>@</em></i>Sakupinera</li><li class="link"><strong>Post link: </strong><a href="http://sakupinera.github.io/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/" title="CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations">http://sakupinera.github.io/2023/02/07/csharp/clr-via-csharp/Chapter 27 Compute-Bound Asynchronous Operations/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/02/06/csharp/clr-via-csharp/Chapter%2026%20Thread%20Basics/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;03&#x2F;08&#x2F;tNhsmAqoTDncM1b.jpg" title="CLR via C# - Chapter 26 Thread Basics"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 26 Thread Basics</h3></a></div><div class="item right"><a href="/2023/02/08/csharp/clr-via-csharp/Chapter%2028%20IO-Bound%20Asynchronous%20Operations/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;03&#x2F;08&#x2F;Z2QTWRnpq3aDLdM.png" title="CLR via C# - Chapter 28 IO-Bound Asynchronous Operations"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 28 IO-Bound Asynchronous Operations</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-27-compute-bound-asynchronous-operations"><span class="toc-number">1.</span> <span class="toc-text">Chapter 27 Compute-Bound Asynchronous Operations</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#introducing-the-clrs-thread-pool"><span class="toc-number">1.1.</span> <span class="toc-text">Introducing the CLRâ€™s Thread Pool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#performing-a-simple-compute-bound-operation"><span class="toc-number">1.2.</span> <span class="toc-text">Performing a Simple Compute-Bound Operation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#execution-contexts"><span class="toc-number">1.3.</span> <span class="toc-text">Execution Contexts</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cooperative-cancellation-and-timeout"><span class="toc-number">1.4.</span> <span class="toc-text">Cooperative Cancellation and Timeout</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tasks"><span class="toc-number">1.5.</span> <span class="toc-text">Tasks</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#waiting-for-a-task-to-complete-and-getting-its-result"><span class="toc-number">1.5.1.</span> <span class="toc-text">Waiting for a Task to Complete and Getting Its Result</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#canceling-a-task"><span class="toc-number">1.5.2.</span> <span class="toc-text">Canceling a Task</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#starting-a-new-task-automatically-when-another-task-completes"><span class="toc-number">1.5.3.</span> <span class="toc-text">Starting a New Task Automatically When Another Task Completes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#a-task-may-start-child-tasks"><span class="toc-number">1.5.4.</span> <span class="toc-text">A Task May Start Child Tasks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inside-a-task"><span class="toc-number">1.5.5.</span> <span class="toc-text">Inside a Task</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#task-factories"><span class="toc-number">1.5.6.</span> <span class="toc-text">Task Factories</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#task-schedulers"><span class="toc-number">1.5.7.</span> <span class="toc-text">Task Schedulers</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#parallels-static-for-foreach-and-invoke-methods"><span class="toc-number">1.6.</span> <span class="toc-text">Parallelâ€™s Static For, ForEach, and Invoke Methods</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#parallel-language-integrated-query"><span class="toc-number">1.7.</span> <span class="toc-text">Parallel Language Integrated Query</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#performing-a-periodic-compute-bound-operation"><span class="toc-number">1.8.</span> <span class="toc-text">Performing a Periodic Compute-Bound Operation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#so-many-timers-so-little-time"><span class="toc-number">1.8.1.</span> <span class="toc-text">So Many Timers, So Little Time</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#how-the-thread-pool-manages-its-threads"><span class="toc-number">1.9.</span> <span class="toc-text">How the Thread Pool Manages Its Threads</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#setting-thread-pool-limits"><span class="toc-number">1.9.1.</span> <span class="toc-text">Setting Thread Pool Limits</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#how-worker-threads-are-managed"><span class="toc-number">1.9.2.</span> <span class="toc-text">How Worker Threads Are Managed</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"><ul><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/" rel="bookmark" title="CLR via C# - Chapter 1 The CLRâ€™s Execution Model">CLR via C# - Chapter 1 The CLRâ€™s Execution Model</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/" rel="bookmark" title="CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types">CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%203%20Shared%20Assemblies%20and%20Strongly%20Named%20Assemblies/" rel="bookmark" title="CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies">CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies</a></li><li><a href="/2022/09/27/csharp/clr-via-csharp/Chapter%204%20Type%20Fundamentals/" rel="bookmark" title="CLR via C# - Chapter 4 Type Fundamentals">CLR via C# - Chapter 4 Type Fundamentals</a></li><li><a href="/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/" rel="bookmark" title="CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals">CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals</a></li><li><a href="/2022/10/21/csharp/clr-via-csharp/Chapter%206%20Type%20and%20Member%20Basics/" rel="bookmark" title="CLR via C# - Chapter 6 Type and Member Basics">CLR via C# - Chapter 6 Type and Member Basics</a></li><li><a href="/2022/10/24/csharp/clr-via-csharp/Chapter%207%20Constants%20and%20Fields/" rel="bookmark" title="CLR via C# - Chapter 7 Constants and Fields">CLR via C# - Chapter 7 Constants and Fields</a></li><li><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" rel="bookmark" title="CLR via C# - Chapter 8 Methods">CLR via C# - Chapter 8 Methods</a></li><li><a href="/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/" rel="bookmark" title="CLR via C# - Chapter 9 Parameters">CLR via C# - Chapter 9 Parameters</a></li><li><a href="/2022/10/28/csharp/clr-via-csharp/Chapter%2010%20Properties/" rel="bookmark" title="CLR via C# - Chapter 10 Properties">CLR via C# - Chapter 10 Properties</a></li><li><a href="/2022/10/29/csharp/clr-via-csharp/Chapter%2011%20Events/" rel="bookmark" title="CLR via C# - Chapter 11 Events">CLR via C# - Chapter 11 Events</a></li><li><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" rel="bookmark" title="CLR via C# - Chapter 12 Generics">CLR via C# - Chapter 12 Generics</a></li><li><a href="/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/" rel="bookmark" title="CLR via C# - Chapter 13 Interfaces">CLR via C# - Chapter 13 Interfaces</a></li><li><a href="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/" rel="bookmark" title="CLR via C# - Chapter 14 Chars, Strings, and Working with Text">CLR via C# - Chapter 14 Chars, Strings, and Working with Text</a></li><li><a href="/2022/11/17/csharp/clr-via-csharp/Chapter%2015%20Enumerated%20Types%20and%20Bit%20Flags/" rel="bookmark" title="CLR via C# - Chapter 15 Enumerated Types and Bit Flags">CLR via C# - Chapter 15 Enumerated Types and Bit Flags</a></li><li><a href="/2022/11/19/csharp/clr-via-csharp/Chapter%2016%20Arrays/" rel="bookmark" title="CLR via C# - Chapter 16 Arrays">CLR via C# - Chapter 16 Arrays</a></li><li><a href="/2022/11/21/csharp/clr-via-csharp/Chapter%2017%20Delegates/" rel="bookmark" title="CLR via C# - Chapter 17 Delegates">CLR via C# - Chapter 17 Delegates</a></li><li><a href="/2022/11/22/csharp/clr-via-csharp/Chapter%2018%20Custom%20Attributes/" rel="bookmark" title="CLR via C# - Chapter 18 Custom Attributes">CLR via C# - Chapter 18 Custom Attributes</a></li><li><a href="/2022/11/23/csharp/clr-via-csharp/Chapter%2019%20Nullable%20Value%20Types/" rel="bookmark" title="CLR via C# - Chapter 19 Nullable Value Types">CLR via C# - Chapter 19 Nullable Value Types</a></li><li><a href="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/" rel="bookmark" title="CLR via C# - Chapter 20 Exceptions and State Management">CLR via C# - Chapter 20 Exceptions and State Management</a></li><li><a href="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/" rel="bookmark" title="CLR via C# - Chapter 21 The Managed Heap and Garbage  Collection">CLR via C# - Chapter 21 The Managed Heap and Garbage Collection</a></li><li><a href="/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/" rel="bookmark" title="CLR via C# - Chapter 22 CLR Hosting and AppDomains">CLR via C# - Chapter 22 CLR Hosting and AppDomains</a></li><li><a href="/2022/11/29/csharp/clr-via-csharp/Chapter%2023%20Assembly%20Loading%20and%20Reflection/" rel="bookmark" title="CLR via C# - Chapter 23 Assembly Loading and Reflection">CLR via C# - Chapter 23 Assembly Loading and Reflection</a></li><li><a href="/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/" rel="bookmark" title="CLR via C# - Chapter 24 Runtime Serialization">CLR via C# - Chapter 24 Runtime Serialization</a></li><li><a href="/2022/12/06/csharp/clr-via-csharp/Chapter%2025%20Interoperating%20with%20WinRT%20%20Components/" rel="bookmark" title="CLR via C# - Chapter 25 Interoperating with WinRT Components">CLR via C# - Chapter 25 Interoperating with WinRT Components</a></li><li><a href="/2023/02/06/csharp/clr-via-csharp/Chapter%2026%20Thread%20Basics/" rel="bookmark" title="CLR via C# - Chapter 26 Thread Basics">CLR via C# - Chapter 26 Thread Basics</a></li><li class="active"><a href="/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations">CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations</a></li><li><a href="/2023/02/08/csharp/clr-via-csharp/Chapter%2028%20IO-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 28 IO-Bound Asynchronous Operations">CLR via C# - Chapter 28 IO-Bound Asynchronous Operations</a></li><li><a href="/2023/02/09/csharp/clr-via-csharp/Chapter%2029%20Primitive%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 29 Primitive Thread Synchronization">CLR via C# - Chapter 29 Primitive Thread Synchronization</a></li><li><a href="/2023/02/10/csharp/clr-via-csharp/Chapter%2030%20Hybrid%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 30 Hybrid Thread Synchronization">CLR via C# - Chapter 30 Hybrid Thread Synchronization</a></li></ul></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sakupinera" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Sakupinera</p><div class="description" itemprop="description">ä¿æŒä½ çš„å†³å¿ƒï¼</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">86</span> <span class="name">posts</span></a></div><div class="item categories"><a href="/categories/"><span class="count">13</span> <span class="name">categories</span></a></div><div class="item tags"><a href="/tags/"><span class="count">6</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nha3VwaW5lcmE=" title="https:&#x2F;&#x2F;github.com&#x2F;sakupinera"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9zYWt1cGluZXJh" title="https:&#x2F;&#x2F;twitter.com&#x2F;sakupinera"><i class="ic i-twitter"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQwNzIyOTA3MQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;407229071"><i class="ic i-cloud-music"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMjIzMDczOTg/c3BtX2lkX2Zyb209MzMzLjEwMDcuMC4w" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;22307398?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li><li class="item"><a href="/games/" rel="section"><i class="ic i-flag"></i>Games</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-person"></i>About</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/02/06/csharp/clr-via-csharp/Chapter%2026%20Thread%20Basics/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/02/08/csharp/clr-via-csharp/Chapter%2028%20IO-Bound%20Asynchronous%20Operations/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2022/12/15/cpp/cpp-primer/Chapter%207%20Classes/" title="C++ Primer - Chapter 7 Classes">C++ Primer - Chapter 7 Classes</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2023/01/04/cpp/cpp-primer/Chapter%2012%20Dynamic%20Memory/" title="C++ Primer - Chapter 12 Dynamic Memory">C++ Primer - Chapter 12 Dynamic Memory</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CSharp-in-a-Nutshell/" title="In CSharp-in-a-Nutshell">CSharp-in-a-Nutshell</a></div><span><a href="/2022/09/04/csharp/csharp-in-a-nutshell/%E7%AC%AC14%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%BC%82%E6%AD%A5/" title="C# in a Nutshell - ç¬¬14ç«  å¹¶å‘ä¸å¼‚æ­¥">C# in a Nutshell - ç¬¬14ç«  å¹¶å‘ä¸å¼‚æ­¥</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2023/02/06/csharp/clr-via-csharp/Chapter%2026%20Thread%20Basics/" title="CLR via C# - Chapter 26 Thread Basics">CLR via C# - Chapter 26 Thread Basics</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/10/21/computer-graphics/games101/%E6%B8%B2%E6%9F%93%E4%B8%AD%E7%9A%84%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/" title="GAMES101 - Advanced Topics in Renderingï¼ˆæ¸²æŸ“ä¸­çš„é«˜çº§ä¸»é¢˜ï¼‰">GAMES101 - Advanced Topics in Renderingï¼ˆæ¸²æŸ“ä¸­çš„é«˜çº§ä¸»é¢˜ï¼‰</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/09/05/linux/learn-linux/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/" title="LearnLinux - Linuxç³»ç»Ÿç®¡ç†">LearnLinux - Linuxç³»ç»Ÿç®¡ç†</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2023/01/05/cpp/cpp-primer/Chapter%2013%20Copy%20Control/" title="C++ Primer - Chapter 13 Copy Control">C++ Primer - Chapter 13 Copy Control</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/" title="CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types">CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/09/05/linux/learn-linux/%E5%90%AF%E5%8A%A8%E7%AE%A1%E7%90%86/" title="LearnLinux - å¯åŠ¨ç®¡ç†">LearnLinux - å¯åŠ¨ç®¡ç†</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/09/05/linux/learn-linux/Linux%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/" title="LearnLinux - LinuxæœåŠ¡ç®¡ç†">LearnLinux - LinuxæœåŠ¡ç®¡ç†</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 â€“ <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Sakupinera @ Hanamai Sora</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="Symbols count total">2.2m words</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="Reading time total">33:30</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/02/07/csharp/clr-via-csharp/Chapter 27 Compute-Bound Asynchronous Operations/",favicon:{show:"ï¼ˆâ—Â´3ï½€â—ï¼‰Goooood",hide:"(Â´Ğ”ï½€)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/shifuku.model.json"},display:{position:"left",width:250,height:500},mobile:{show:!1},react:{opacity:.9},log:!1})</script></body></html>