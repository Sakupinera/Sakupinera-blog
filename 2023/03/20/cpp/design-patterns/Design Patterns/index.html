<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sakupinera" href="http://sakupinera.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sakupinera" href="http://sakupinera.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sakupinera" href="http://sakupinera.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="学习笔记"><link rel="canonical" href="http://sakupinera.github.io/2023/03/20/cpp/design-patterns/Design%20Patterns/"><title>设计模式（Design Patterns） - Design-Patterns | Hanamai Sora = Sakupinera</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">设计模式（Design Patterns）</h1><div class="meta"><span class="item" title="Created: 2023-03-20 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2023-03-20T00:00:00+08:00">2023-03-20</time> </span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">Symbols count in article</span> <span>14k</span> <span class="text">words</span> </span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">Reading time</span> <span>12 mins.</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hanamai Sora</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s2.loli.net/2023/03/08/Y2t3E6QUohFwG1R.png"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/Z2QTWRnpq3aDLdM.png"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/yO4CQpnLWhEzMsx.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/cNIvjwsl174ibOo.png"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/3EGdFBS1HMzVQjJ.png"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/utEsOX73wkq1ycI.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Design-Patterns/" itemprop="item" rel="index" title="In Design-Patterns"><span itemprop="name">Design-Patterns</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://sakupinera.github.io/2023/03/20/cpp/design-patterns/Design%20Patterns/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Sakupinera"><meta itemprop="description" content=", 保持你的决心！"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakupinera"></span><div class="body md" itemprop="articleBody"><h1 id="设计模式design-patterns"><a class="anchor" href="#设计模式design-patterns">#</a> 设计模式（Design Patterns）</h1><h2 id="初步认识设计模式"><a class="anchor" href="#初步认识设计模式">#</a> 初步认识设计模式</h2><h3 id="什么是设计模式"><a class="anchor" href="#什么是设计模式">#</a> 什么是设计模式</h3><p>每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。</p><h3 id="从面向对象谈起"><a class="anchor" href="#从面向对象谈起">#</a> 从面向对象谈起</h3><p>底层思维：向下，如何把握机器底层从微观理解对象构造。</p><ul><li>语言构造</li><li>编译转换</li><li>内存模型</li><li>运行时机制</li></ul><p>向下：深入理解三大面向对象机制</p><ul><li>封装，隐藏内部实现</li><li>继承，复用现有代码</li><li>多态，改写对象行为</li></ul><p>抽象思维：向上，如何将我们的周围世界抽象为程序代码。</p><ul><li>面向对象</li><li>组件封装</li><li>设计模式</li><li>架构模式</li></ul><p>向上：深刻把握面向对象机制多带来的抽象意义，理解如何使用这些机制来表达现实世界，掌握什么是 “好的面向对象设计”。</p><h3 id="软件设计固有的复杂性"><a class="anchor" href="#软件设计固有的复杂性">#</a> 软件设计固有的复杂性</h3><p>建筑商从来不会去想给一栋已建好的 100 层高的楼房底下再新修一个小地下室 —— 这样做花费极大而且注定要失败。然而令人惊奇的是，软件系统的用户在要求作出类似改变时却不会仔细考虑，而且他们认为这只是需要简单编程的事。	-- Object-Oriented Analysis and Design with Applications</p><h3 id="软件设计复杂的根本原因"><a class="anchor" href="#软件设计复杂的根本原因">#</a> 软件设计复杂的根本原因</h3><p><mark>变化</mark>：</p><ul><li><p>客户需求的变化</p></li><li><p>技术平台的变化</p></li><li><p>开发团队的变化</p></li><li><p>市场环境的变化</p></li><li><p>......</p></li></ul><h3 id="如何解决复杂性"><a class="anchor" href="#如何解决复杂性">#</a> 如何解决复杂性？</h3><p>▶️分解：</p><ul><li>分而治之，将大问题分解为多个小问题，将复杂问题分解为多个简单问题。</li></ul><p>▶️抽象：</p><ul><li>更高层次来讲，人们处理复杂性有一个通用的技术，即抽象。又不不饿能掌握全部的复杂对象，我们选择忽视它的非本质细节，而去处理泛化和理想化了的对象模型。</li></ul><h3 id="软件设计的目标"><a class="anchor" href="#软件设计的目标">#</a> 软件设计的目标</h3><p>什么是好的软件设计？软件设计的金科玉律：<mark>复用</mark>！</p><h3 id="面向对象设计为什么"><a class="anchor" href="#面向对象设计为什么">#</a> 面向对象设计，为什么？</h3><p>变化是复用的天敌！面向对象设计最大的优势在于：<mark>低于变化</mark>！</p><h3 id="重新认识面向对象"><a class="anchor" href="#重新认识面向对象">#</a> 重新认识面向对象</h3><p>▶️理解隔离变化</p><ul><li>从宏观层面来看，面向对象的构建方式更能适应软件的变化，能将变化所带来的影响减为最小。</li></ul><p>▶️各司其职</p><ul><li>从微观层面来看，面向对象的方式更强调各个类的 “责任”</li><li>由于需求变化导致的新增类型不应该影响原来类型的实现 -- 是所谓各负其责</li></ul><p>▶️对象是什么？</p><ul><li>从语言实现层面来看，对象封装了代码和数据</li><li>从规格层面讲，对象是一系列可被使用的公共接口</li><li>从概念层面讲，对象是某种拥有责任的抽象</li></ul><h3 id="面向对象设计原则"><a class="anchor" href="#面向对象设计原则">#</a> 面向对象设计原则</h3><p>▶️依赖倒置原则（DIP）</p><ul><li>高层模块（稳定）不应该依赖于底层模块（变化），二者都应该依赖于抽象（稳定）。</li><li>抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）。</li></ul><p>▶️开放封闭原则（OCP）</p><ul><li>对扩展开放，对更改封闭。</li><li>类模块应该是可以扩展的，但是不可修改。</li></ul><p>▶️单一职责原则（SRP）</p><ul><li>一个类应该仅有一个引起它变化的原因。</li><li>变化的方向隐含着类的责任。</li></ul><p>▶️Liskov 替换原则（LSP）</p><ul><li>子类必须能够替换它们的基类（IS-A）。</li><li>继承表达类型抽象。</li></ul><p>▶️接口隔离原则（ISP）</p><ul><li>不应该强迫客户程序依赖它们不用的方法。</li><li>接口应该小而完备。</li></ul><p>▶️优先使用对象组合，而不是类继承</p><ul><li>类继承通常位 “白箱复用”，对象组合通常为 “黑箱复用”。</li><li>继承在某种程度上破坏了封装性，父类子类耦合度高。</li><li>而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。</li></ul><p>▶️封装变化点</p><ul><li>使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。</li></ul><p>▶️针对接口编程，而不是针对实现编程</p><ul><li>不将变量类型声明为某个特定的具体类，而是声明为某个接口。</li><li>客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。</li><li>减少类型中各部分的依赖关系，从而实现 “高内聚，松耦合” 的类型设计方案。</li></ul><h3 id="将设计原则提升为设计经验"><a class="anchor" href="#将设计原则提升为设计经验">#</a> 将设计原则提升为设计经验</h3><p>▶️ 1. 设计习语 Design Idioms</p><ul><li>Design Idioms 描述与特定编程语言相关的低层模式，技巧，习惯，习惯用法。</li></ul><p>▶️ 2. 设计模式 Design Patterns</p><ul><li>Design Patterns 主要描述的是 “类与相互通信的对象之间的组织关系，博爱阔它们的角色、职责、协作方式等方面。</li></ul><p>▶️ 3. 架构模式 Architectural Patterns</p><ul><li>Architectural Patterns 描述系统中与基本结构组织关系密切相关的高层模式，包括子系统划分，职责，以及如何组织它们之间关系的规则。</li></ul><h2 id="gof-23-模式分类"><a class="anchor" href="#gof-23-模式分类">#</a> GOF-23 模式分类</h2><p>▶️从目的来看：</p><ul><li>创建型（Creational）模式：将对象的部分创建工作延迟到子类或者其他对象，从而应对需求变化为对象创建时具体类型的实现引来的冲击。</li><li>结构型（Structural）模式：通过类继承或者对象组合获得更灵活的结构，从而应对需求变化为对象的结构带来的冲击。</li><li>行为型（Behavioral）模式：通过类继承或者对象组合来划分类与对象间的职责，从而应对需求变化为多个交互的对象带来的冲击。</li></ul><p>▶️从范围来看：</p><ul><li>类模式处理类与子类的静态关系。</li><li>对象模式处理对象间的动态关系。</li></ul><h3 id="从封装变化角度对模式分类"><a class="anchor" href="#从封装变化角度对模式分类">#</a> 从封装变化角度对模式分类</h3><p>▶️对象协作：</p><p>现代软件专业分工之后的第一个结果是 “框架与应用程序的划分”，“组件协作” 模式通过晚期绑定，来实现框架与应用程序之间的松耦合，是两者之间协作时常用的模式。</p><p>典型模式：</p><ul><li>Template Method</li><li>Strategy</li><li>Observer/Event</li></ul><p>▶️单一职责：</p><p>在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，这时候的关键是划清责任。</p><p>典型模式：</p><ul><li>Decorator</li><li>Bridge</li></ul><p>▶️对象创建：</p><p>通过 “对象创建” 模式绕开 new，来避免对象创建（new）过程中所导致的紧耦合（依赖具体类） ，从而支持对象创建的稳定。它是接口抽象之后的第一步工作。</p><p>典型模式：</p><ul><li>Factory Method</li><li>Abstract Factory</li><li>Prototype</li><li>Builder</li></ul><p>▶️对象性能：</p><p>面向对象很好地解决了 “抽象” 的问题，但是必不可免地要付出一定的代价。对于通常情况来讲，面向对象的成本大都可以忽略不计。但是某些情况，面向对象所带来的成本必须谨慎处理。</p><p>典型模式：</p><ul><li>Singleton</li><li>Flyweight</li></ul><p>▶️接口隔离：</p><p>在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题、甚至根本无法实现。采用添加一层间接（稳定）接口，来隔离本来互相紧密关联的接口是一种常见的解决方案。</p><p>典型模式：</p><ul><li>Facade</li><li>Proxy</li><li>Mediator</li><li>Adapter</li></ul><p>▶️状态变化：</p><p>在组件构建过程中，某些对象的状态经常面临变化，如何对这些变化进行有效的管理？同时又维持高层模块的稳定？“状态变化” 模式为这一问题提供了一种解决方案。</p><p>典型模式：</p><ul><li>Memento</li><li>State</li></ul><p>▶️数据结构：</p><p>常常有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大地破坏组件的复用。这时候，将这些特定数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案。</p><p>典型模式：</p><ul><li>Composite</li><li>Iterator</li><li>Chain of Responsibility</li></ul><p>▶️行为变化：</p><p>在组件的构建过程中，组件行为的变化经常导致组件本身剧烈的变化。“行为变化” 模式将组件的行为和组件本身进行解耦，从而支持组件行为的变化，实现两者之间的松耦合。</p><ul><li>Command</li><li>Visitor</li></ul><p>▶️领域问题：</p><p>在特定领域中，某些变化虽然频繁，但可以抽象为某种规则。这时候，结合特定领域，将问题抽象为语法规则，从而给出在该领域下的一般性解决方案。</p><ul><li>Interpreter</li></ul><h3 id="重构获得模式-refactoring-to-patterns"><a class="anchor" href="#重构获得模式-refactoring-to-patterns">#</a> 重构获得模式 Refactoring to Patterns</h3><p>设计模式的应用不要先入为主，一上来就是用设计模式是对设计模式的最大误用。没有一步到位的设计模式。敏捷软件开发实践中提倡的 “Refactoring to Patterns” 是目前普遍公认的最好的使用设计模式的方法。</p><h3 id="重构关键技法"><a class="anchor" href="#重构关键技法">#</a> 重构关键技法</h3><ul><li>静态 -&gt; 动态</li><li>早绑定 -&gt; 晚绑定</li><li>继承 -&gt; 组合</li><li>编译时依赖 -&gt; 运行时依赖</li><li>紧耦合 -&gt; 松耦合</li></ul><h2 id="template-method模板方法"><a class="anchor" href="#template-method模板方法">#</a> Template Method（模板方法）</h2><h3 id="动机motivation"><a class="anchor" href="#动机motivation">#</a> 动机（Motivation）</h3><p>在软件构建过程中，对于某一项任务，它常常又稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如构架与应用之间的关系）而无法和任务的整体结构同时实现。</p><p>如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求？</p><h3 id="模式定义"><a class="anchor" href="#模式定义">#</a> 模式定义</h3><p>定义一个操作中的算法的骨架（稳定），而将一些步骤延迟（变化）到子类中。Template Method 使得子类可以不改变复用一个算法的结构即可重定义（override 重写）该算法的某些特定步骤。</p><h3 id="结构structure"><a class="anchor" href="#结构structure">#</a> 结构（Structure）</h3><p><img data-src="/2023/03/20/cpp/design-patterns/Design%20Patterns/image-20230318154005634.png" alt="image-20230318154005634"></p><h3 id="要点总结"><a class="anchor" href="#要点总结">#</a> 要点总结</h3><ul><li>Template Method 模式是一种非常基础性的设计模式，在面向对象系统中有着大量的应用。它用最简洁的机制（虚函数的多态性）为很多应用程序框架提供了灵活的扩展点，是代码复用的方面的基本实现结构。</li><li>出了可以灵活应对子步骤的变化外，” 不要调用我，让我来调用你 “的反向控制结构是 Template Method 的典型应用。</li><li>在具体实现方面，被 Template Method 调用的虚方法可以具有实现，也可以没有任何实现（抽象方法、纯虚方法），但一般推荐将它们设置为 protected 方法。</li></ul><h2 id="strategy策略模式"><a class="anchor" href="#strategy策略模式">#</a> Strategy（策略模式）</h2><p>在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂；而且有时候支持不使用的算法也是一个性能负担。</p><p>如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？</p><h3 id="模式定义-2"><a class="anchor" href="#模式定义-2">#</a> 模式定义</h3><p>定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序（稳定）而变化（扩展，子类化）。</p><h3 id="结构structure-2"><a class="anchor" href="#结构structure-2">#</a> 结构（Structure）</h3><p><img data-src="/2023/03/20/cpp/design-patterns/Design%20Patterns/image-20230318160016068.png" alt="image-20230318160016068"></p><h3 id="要点总结-2"><a class="anchor" href="#要点总结-2">#</a> 要点总结</h3><ul><li>Strategy 及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换。</li><li>Strategy 模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需要 Strategy 模式。</li><li>如果 Strategy 对象没有实例变量，那么各个上下文可以共享同一个 Strategy 对象，从而节省对象开销。</li></ul><h2 id="observerevent观察者模式"><a class="anchor" href="#observerevent观察者模式">#</a> Observer/Event（观察者模式）</h2><h3 id="动机motivation-2"><a class="anchor" href="#动机motivation-2">#</a> 动机（Motivation）</h3><p>在软件构建过程中，我们需要为某些对象建立一种 “通知依赖关系” 一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密，将使软件不能很好地抵御变化。</p><p>使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。</p><h3 id="模式定义-3"><a class="anchor" href="#模式定义-3">#</a> 模式定义</h3><p>定义对象间的一种一对多（变化）的依赖关系，以便当一个对象（Subject）的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。</p><h3 id="结构structure-3"><a class="anchor" href="#结构structure-3">#</a> 结构（Structure）</h3><p><img data-src="/2023/03/20/cpp/design-patterns/Design%20Patterns/image-20230318170214324.png" alt="image-20230318170214324"></p><h3 id="要点总结-3"><a class="anchor" href="#要点总结-3">#</a> 要点总结</h3><p>使用面向对象的抽象，Observer 模式使得我们可以独立地改变目标与观察者，从而使二者之间的依赖关系达致松耦合。</p><p>目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播。</p><p>观察者自己决定是否需要订阅通知，目标对象对此一无所知。</p><p>Observer 模式是基于事件的 UI 框架中非常常用的设计模式，也是 MVC 模式的一个重要组成部分。</p><h2 id="decorator装饰模式"><a class="anchor" href="#decorator装饰模式">#</a> Decorator（装饰模式）</h2><h3 id="动机motivation-3"><a class="anchor" href="#动机motivation-3">#</a> 动机（Motivation）</h3><p>在某些情况下我们可能会 “过度地使用继承来扩展对象的功能”，由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀。</p><p>如何使 “对象功能的扩展” 能够根据需要来动态地实现？同时避免 “扩展功能的增多” 带来的子类膨胀问题？从而使得任何 “功能扩展变化” 所导致的影响将为最低？</p><h3 id="模式定义-4"><a class="anchor" href="#模式定义-4">#</a> 模式定义</h3><p>动态（组合）地给一个对象增加一些额外的职责。就增加功能而言， Decorator 模式比生成子类（继承）更为灵活（消除重复代码 &amp; 减少子类个数）。</p><h3 id="结构structure-4"><a class="anchor" href="#结构structure-4">#</a> 结构（Structure）</h3><p><img data-src="/2023/03/20/cpp/design-patterns/Design%20Patterns/image-20230318175409319.png" alt="image-20230318175409319"></p><h3 id="要点总结-4"><a class="anchor" href="#要点总结-4">#</a> 要点总结</h3><p>通过采用组合而非继承的手法， Decorator 模式实现了在运行时动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的 “灵活性差” 和 “多子类衍生问题”。</p><p>Decorator 类在接口上表现为 is-a Component 的继承关系，即 Decorator 类继承了 Component 类所具有的接口。但在实现上又表现为 has-a Component 的组合关系，即 Decorator 类又使用了另外一个 Component 类。</p><p>Decorator 模式的目的并非解决 “多子类衍生的多继承” 问题，Decorator 模式应用的要点在于解决 “主体类在多个方向上的扩展功能”—— 是为 “装饰” 的含义。</p><h2 id="bridge桥模式"><a class="anchor" href="#bridge桥模式">#</a> Bridge（桥模式）</h2><h3 id="动机motivation-4"><a class="anchor" href="#动机motivation-4">#</a> 动机（Motivation）</h3><p>由于某些类型的固有的实现逻辑，使得它们具有两个变化的维度乃至多个纬度的变化。</p><p>如何应对这种 “多维度的变化”? 如何利用面向对象技术来使得类型可以轻松地沿着两个乃至多个方向变化，而不引入额外的复杂度？</p><h3 id="模式定义-5"><a class="anchor" href="#模式定义-5">#</a> 模式定义</h3><p>将抽象部分（业务功能）与实现部分（平台实现）分离，使它们都可以独立地变化。</p><h3 id="结构structure-5"><a class="anchor" href="#结构structure-5">#</a> 结构（Structure）</h3><p><img data-src="/2023/03/20/cpp/design-patterns/Design%20Patterns/image-20230318182235171.png" alt="image-20230318182235171"></p><h3 id="要点总结-5"><a class="anchor" href="#要点总结-5">#</a> 要点总结</h3><p>Bridge 模式使用 “对象间的组合关系” 解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自纬度的变化，即 “子类化” 它们。</p><p>Bridge 模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则（即一个类只有一个变化的原因），复用性比较差。一 Bridge 模式是比多继承方案更好的解决方法。</p><p>Bridge 模式的应用一般在 “两个非常强的变化维度”，有时一个类也有多于两个的变化维度，这时可以使用 Bridge 的扩展模式。</p><h2 id="factory-method工厂方法"><a class="anchor" href="#factory-method工厂方法">#</a> Factory Method（工厂方法）</h2><h3 id="动机motivation-5"><a class="anchor" href="#动机motivation-5">#</a> 动机（Motivation）</h3><p>在软件系统中，经常面临着创建对象的工作；由于需求的变化，需要创建的对象的具体类型经常变化。</p><p>如何应对这种变化？如何绕过常规的对象创建方法（new），提供一种 “封装机制” 来避免客户程序和这种 “具体对象创建工作” 的紧耦合？</p><h3 id="模式定义-6"><a class="anchor" href="#模式定义-6">#</a> 模式定义</h3><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使得一个类的实例化延迟（目的：解耦，手段：虚函数）到子类。</p><h3 id="结构structure-6"><a class="anchor" href="#结构structure-6">#</a> 结构（Structure）</h3><p><img data-src="/2023/03/20/cpp/design-patterns/Design%20Patterns/image-20230318184811812.png" alt="image-20230318184811812"></p><h3 id="要点总结-6"><a class="anchor" href="#要点总结-6">#</a> 要点总结</h3><p>Factory Method 模式用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系（new）会导致软件的脆弱。</p><p>Factory Method 模式通过面向对象的手法，将所要创建的具体对象工作延迟到子类，从而实现一种扩展（而非更改）的策略，较好地解决了这种紧耦合关系。</p><p>Factory Method 模式解决 “单个对象” 的需求变化。缺点在于要求创建方法 / 参数相同。</p><h2 id="abstract-factory抽象工厂"><a class="anchor" href="#abstract-factory抽象工厂">#</a> Abstract Factory（抽象工厂）</h2><h3 id="动机motivation-6"><a class="anchor" href="#动机motivation-6">#</a> 动机（Motivation）</h3><p>在软件系统中，经常面临着 “一系列相互依赖的对象” 的创建工作；同时，由于需求的变化，往往存在更多系列对象的创建工作。</p><p>如何应对这种变化？如何绕过常规的对象创建方法（new），提供一种 “封装机制” 来避免客户程序和这种 “多系列具体对象创建工作” 的紧耦合？</p><h3 id="模式定义-7"><a class="anchor" href="#模式定义-7">#</a> 模式定义</h3><p>提供一个接口，让该接口负责创建一系列 “相关或者相互依赖的对象”，无需指定它们具体的类。</p><h3 id="结构structure-7"><a class="anchor" href="#结构structure-7">#</a> 结构（Structure）</h3><p><img data-src="/2023/03/20/cpp/design-patterns/Design%20Patterns/image-20230318192228052.png" alt="image-20230318192228052"></p><h3 id="要点总结-7"><a class="anchor" href="#要点总结-7">#</a> 要点总结</h3><p>如果没有应对 “多系列对象构建” 的需求变化，则没有必要使用 Abstract Factory 模式，这时候使用简单的工厂完全可以。</p><p>“系列对象” 指的是在某一特定系列下的对象之间有相互依赖、或作用的关系。不同系列的对象之间不能相互依赖。</p><p>Abstract Factory 模式主要在于应对 “新系列” 的需求变动。其缺点在于难以应对 “新对象” 的需求变动。</p><h2 id="prototype原型模式"><a class="anchor" href="#prototype原型模式">#</a> Prototype（原型模式）</h2><h3 id="动机motivation-7"><a class="anchor" href="#动机motivation-7">#</a> 动机（Motivation）</h3><p>在软件系统中，经常面临着 “某些结构复杂的对象” 的创建工作；由于需求的变化，这些对象经常面临着剧烈的变化，但是它们却拥有比较稳定一致的接口。</p><p>如何应对这种变化？如何向 “客户程序（使用这些对象的程序）” 隔离出 “这些易变对象”，从而使得 “依赖这些易变对象的客户程序” 不随着需求改变而改变？</p><h3 id="模式定义-8"><a class="anchor" href="#模式定义-8">#</a> 模式定义</h3><p>使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。</p><h3 id="结构structure-8"><a class="anchor" href="#结构structure-8">#</a> 结构（Structure）</h3><p><img data-src="/2023/03/20/cpp/design-patterns/Design%20Patterns/image-20230319134245796.png" alt="image-20230319134245796"></p><h3 id="要点总结-8"><a class="anchor" href="#要点总结-8">#</a> 要点总结</h3><p>Prototype 模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些 “易变类” 拥有 “稳定的接口”。</p><p>Prototype 模式对于 “如何创建易变类的实体对象” 采用 “原型克隆” 的方法来做，它使得我们可以非常灵活地动态创建 “拥有某些稳定接口” 的新对象 —— 所需工作仅仅是注册一个新类的对象（即原型），然后在任何需要的地方 Clone。</p><p>Prototype 模式中的 Clone 方法可以利用某些框架中的序列化来实现深拷贝。</p><h2 id="builder构建器"><a class="anchor" href="#builder构建器">#</a> Builder（构建器）</h2><h3 id="动机motivation-8"><a class="anchor" href="#动机motivation-8">#</a> 动机（Motivation）</h3><p>在软件系统中，有时候面临着 “一个复杂对象” 的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p><p>如何应对这种变化？如何提供一种 “封装机制” 来隔离出 “复杂对象的各个部分” 的变化，从而保持系统中的 “稳定构建算法” 不随着需求改变而改变？</p><h3 id="模式定义-9"><a class="anchor" href="#模式定义-9">#</a> 模式定义</h3><p>将一个复杂对象的构建与其表示相分离，使得同样的构建过程（稳定）可以创建不同的表示（变化）。</p><h3 id="结构structure-9"><a class="anchor" href="#结构structure-9">#</a> 结构（Structure）</h3><p><img data-src="/2023/03/20/cpp/design-patterns/Design%20Patterns/image-20230319155607760.png" alt="image-20230319155607760"></p><h3 id="要点总结-9"><a class="anchor" href="#要点总结-9">#</a> 要点总结</h3><p>Builder 模式主要用于 “分步骤构建一个复杂的对象”。在这其中 “分，步骤” 是一个稳定的算法，而复杂对象的各个部分则经常变化。</p><p>变化点在哪里，封装哪里 - Builder 模式主要在于应对 “复杂对象各个部分” 的频繁需求变动。其缺点在于难以应对 “分步骤构建算法” 的需求变动。</p><p>在 Builder 模式中，要注意不同语言中构造器内调用虚函数的差别（C++ vs. C#）。</p><h2 id="singleton单件模式"><a class="anchor" href="#singleton单件模式">#</a> Singleton（单件模式）</h2><h3 id="动机motivation-9"><a class="anchor" href="#动机motivation-9">#</a> 动机（Motivation）</h3><p>在软件系统中，经常有这样一些特殊的类，必须保证它们在系统中只存在一个实例，才能确保它们的逻辑正确性、以及良好的效率。</p><p>如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？</p><p>这应该是类设计者的责任，而不是使用者的责任。</p><h3 id="模式定义-10"><a class="anchor" href="#模式定义-10">#</a> 模式定义</h3><p>保证一个类仅有一个实例，并提供一个该实例的全局访问点。</p><h3 id="结构structure-10"><a class="anchor" href="#结构structure-10">#</a> 结构（Structure）</h3><p><img data-src="/2023/03/20/cpp/design-patterns/Design%20Patterns/image-20230319163055869.png" alt="image-20230319163055869"></p><h3 id="要点总结-10"><a class="anchor" href="#要点总结-10">#</a> 要点总结</h3><p>Singleton 模式中的实例构造器可以设置为 protected 以允许子类派生。</p><p>Singleton 模式一般不要支持拷贝构造函数和 Clone 接口，因为这有可能导致多个对象实例，与 Singleton 模式的初衷违背。</p><p>如何实现多线程环境下安全的 Singleton? 注意对双检查锁的正确实现。</p><h2 id="flyweight享元模式"><a class="anchor" href="#flyweight享元模式">#</a> Flyweight（享元模式）</h2><h3 id="动机motivation-10"><a class="anchor" href="#动机motivation-10">#</a> 动机（Motivation）</h3><p>在软件系统采用纯粹对象方案的问题在于大量细粒度的对象会很快充斥在系统中，从而带来很高的运行时代价 -- 主要指内存需求方面的代价。</p><p>如何在避免大量细粒度对象问题的同时，让外部客户程序仍然能够透明地使用面向对象的方式来进行操作？</p><h3 id="模式定义-11"><a class="anchor" href="#模式定义-11">#</a> 模式定义</h3><p>运用共享技术有效地支持大量细粒度的对象。</p><h3 id="结构structure-11"><a class="anchor" href="#结构structure-11">#</a> 结构（Structure）</h3><p><img data-src="/2023/03/20/cpp/design-patterns/Design%20Patterns/image-20230319163713933.png" alt="image-20230319163713933"></p><h3 id="要点总结-11"><a class="anchor" href="#要点总结-11">#</a> 要点总结</h3><p>面向对象很好地解决了抽象性的问题，但是作为一个运行在机器中的程序实体，我们需要考虑对象的代价问题。Flyweight 主要解决面向对象的代价问题，一般不触及面向对象的抽象性问题。</p><p>Flyweight 采用对象共享的做法来降低系统中对象的个数，从而降低细粒度对象给系统带来的内存压力。在具体实现方面，要注意对象状态的处理。</p><p>对象的数量太大从而导致对象内存开销加大 —— 什么样的数量才算大？这需要我们仔细的根据具体应用情况进行评估，而不能凭空臆断。</p><h2 id="facade门面模式"><a class="anchor" href="#facade门面模式">#</a> Facade（门面模式）</h2><h3 id="动机motivation-11"><a class="anchor" href="#动机motivation-11">#</a> 动机（Motivation）</h3><p><img data-src="/2023/03/20/cpp/design-patterns/Design%20Patterns/image-20230319165543373.png" alt="image-20230319165543373"></p><p>上述 A 方案的问题在于组件的客户和组件中各种复杂的子系统有了过多的耦合，随着外部客户程序和各子系统的演化，这种过多的耦合面临很多变化的挑战。</p><p>如何简化外部客户程序和系统间的交互接口？如何将外部客户程序的演化和内部子系统的变化之间的依赖相互解耦？</p><h3 id="模式定义-12"><a class="anchor" href="#模式定义-12">#</a> 模式定义</h3><p>为子系统中的一组接口提供一个一致（稳定）的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用（复用）。</p><h3 id="结构structure-12"><a class="anchor" href="#结构structure-12">#</a> 结构（Structure）</h3><p><img data-src="/2023/03/20/cpp/design-patterns/Design%20Patterns/image-20230319165854874.png" alt="image-20230319165854874"></p><h3 id="要点总结-12"><a class="anchor" href="#要点总结-12">#</a> 要点总结</h3><p>从客户程序的角度来看，Facade 模式简化了整个组件系统的接口，对于组件内部与外部客户程序来说，达到了一种 “解耦” 的效果内部子系统的任何变化不会影响到 Facade 接口的变化。</p><p>Facade 设计模式更注重从架构的层次去看整个系统，而不是单个类的层次。Facade 很多时候更是一种架构设计模式。Facade 设计模式并非一个集装箱，可以任意地放进任何多个对象。</p><p>Facade 模式中组件的内部应该是 “相互耦合关系比较大的一系列组件”，而不是一个简单的功能集合。</p><h2 id="proxy代理模式"><a class="anchor" href="#proxy代理模式">#</a> Proxy（代理模式）</h2><h3 id="动机motivation-12"><a class="anchor" href="#动机motivation-12">#</a> 动机（Motivation）</h3><p>在面向对象系统中，有些对象由于某种原因（比如对象创建的开销很大，或者某些操作需要安全控制，或者需要进程外的访问等）直接访问会给使用者、或者系统结构带来很多麻烦。</p><p>如何在不失去透明操作对象的同时来管理 / 控制这些对象特有的复杂性？增加一层间接层是软件开发中常见的解决方式。</p><h3 id="模式定义-13"><a class="anchor" href="#模式定义-13">#</a> 模式定义</h3><p>为其他对象提供一种代理以控制（隔离，使用接口）对这个对象的访问。</p><h3 id="结构structure-13"><a class="anchor" href="#结构structure-13">#</a> 结构（Structure）</h3><p><img data-src="/2023/03/20/cpp/design-patterns/Design%20Patterns/image-20230319171028001.png" alt="image-20230319171028001"></p><h3 id="要点总结-13"><a class="anchor" href="#要点总结-13">#</a> 要点总结</h3><p>“增加一层间接层” 是软件系统中对许多复杂问题的一种常见解决方法。在面向对象系统中，直接使用某些对象会带来很多问题，作为间接层的 proxy 对象便是解决这一问题的常用手段。</p><p>具体 proxy 设计模式的实现方法、实现粒度都相差很大，有些可能对单个对象做细粒度的控制，如 copy-on-write 技术，有些可能对组件模块提供抽象代理层，在架构层次对对象做 proxy。</p><p>Proxy 并不一定要求保持接口完整的一致性，只要能够实现间接控制，有时候损及一些透明性是可以接受的。</p><h2 id="adapter适配器"><a class="anchor" href="#adapter适配器">#</a> Adapter（适配器）</h2><h3 id="动机motivation-13"><a class="anchor" href="#动机motivation-13">#</a> 动机（Motivation）</h3><p>在软件系统中，由于应用环境的变化，常常需要将 “一些现存的对象” 放在新的环境中应用，但是新环境要求的接口是这些现存对象，所不满足的。</p><p>如何应对这种 “迁移的变化”？如何既能利用现有对象的良好实现，同时又能满足新的应用环境所要求的接口？</p><h3 id="模式定义-14"><a class="anchor" href="#模式定义-14">#</a> 模式定义</h3><p>将一个类的接口转换成客户希望的另一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><h3 id="结构structure-14"><a class="anchor" href="#结构structure-14">#</a> 结构（Structure）</h3><p><img data-src="/2023/03/20/cpp/design-patterns/Design%20Patterns/image-20230319172104852.png" alt="image-20230319172104852"></p><h3 id="要点总结-14"><a class="anchor" href="#要点总结-14">#</a> 要点总结</h3><p>Adapter 模式主要应用于 “希望复用一些现存的类，但是接口又与复用环境要求不一致的情况”，在遗留代码复用、类库迁移等方面非常有用。</p><p>GoF 23 定义了两种 Adapter 模式的实现结构：对象适配器和类适配器。但类适配器采用 “多继承” 的实现方式，一般不推荐使用。对象适配器采用 “对象组合” 的方式，更符合松耦合精神。</p><p>Adapter 模式可以实现的非常灵活，不必拘泥于 GoF 23 中定义的两种结构。例如，完全可以将 Adapter 模式中的 “现存对象” 作为新的接口方法参数，来达到适配的目的。</p><h2 id="mediator中介者"><a class="anchor" href="#mediator中介者">#</a> Mediator（中介者）</h2><h3 id="动机motivation-14"><a class="anchor" href="#动机motivation-14">#</a> 动机（Motivation）</h3><p>在软件构建过程中，经常会出现多个对象互相关联交互的情况，对象之间常常会维持一种复杂的引用关系，如果遇到一些需求的更改，这种直接的引用关系将面临不断的变化。</p><p>在这种情况下，我们可使用一个 “中介对象” 来管理对象间的关联关系，避免相互交互的对象之间的紧耦合引用关系，从而更好地抵御变化。</p><h3 id="模式定义-15"><a class="anchor" href="#模式定义-15">#</a> 模式定义</h3><p>用一个中介对象来封装（封装变化）一系列的对象交互。中介者使各对象不需要显式的相互引用（编译时依赖→运行时依赖），从而使其耦合松散（管理变化），而且可以独立地改变它们之间的交互。</p><h3 id="结构structure-15"><a class="anchor" href="#结构structure-15">#</a> 结构（Structure）</h3><p><img data-src="/2023/03/20/cpp/design-patterns/Design%20Patterns/image-20230319180113216.png" alt="image-20230319180113216"></p><h3 id="要点总结-15"><a class="anchor" href="#要点总结-15">#</a> 要点总结</h3><p>将多个对象间复杂的关联关系解耦， Mediator 模式将多个对象间的控制逻辑进行集中管理，变 “多个对象互相关联” 为 “多个对象和一个中介者关联”，简化了系统的维护，抵御了可能的变化。</p><p>随着控制逻辑的复杂化， Mediator 具体对象的实现可能相当复杂。这时候可以对 Mediator 对象进行分解处理。</p><p>Facade 模式是解耦系统间（单向）的对象关联关系；Mediator 模式是解耦系统内各个对象之间（双向）的关联关系。</p><h2 id="state状态模式"><a class="anchor" href="#state状态模式">#</a> State（状态模式）</h2><h3 id="动机motivation-15"><a class="anchor" href="#动机motivation-15">#</a> 动机（Motivation）</h3><p>在软件构建过程中，某些对象的状态如果改变，其行为也会随之而发生变化，比如文档处于只读状态，其支持的行为和读写状态支持的行为就可能完全不同。</p><p>如何在运行时根据对象的状态来透明地更改对象的行为？而不会为对象操作和状态转化之间引入紧耦合？</p><h3 id="模式定义-16"><a class="anchor" href="#模式定义-16">#</a> 模式定义</h3><p>允许一个对象在其内部状态改变时改变它的行为。从而使对象看起来似乎修改了其行为。</p><h3 id="结构structure-16"><a class="anchor" href="#结构structure-16">#</a> 结构（Structure）</h3><p><img data-src="/2023/03/20/cpp/design-patterns/Design%20Patterns/image-20230319183131177.png" alt="image-20230319183131177"></p><h3 id="要点总结-16"><a class="anchor" href="#要点总结-16">#</a> 要点总结</h3><p>State 模式将所有与一个特定状态相关的行为都放入一个 State 的子类对象中，在对象状态切换时，切换相应的对象；但同时维持 State 的接口，这样实现了具体操作与状态转换之间的解耦。</p><p>为不同的状态引入不同的对象使得状态转换变得更加明确，而且可以保证不会出现状态不一致的情况，因为转换是原子性的 —— 即要么彻底转换过来，要么不转换。</p><p>如果 State 对象没有实例变量，那么各个上下文可以共享同一个 State 对象，从而节省对象开销。</p><h2 id="memento备忘录"><a class="anchor" href="#memento备忘录">#</a> Memento（备忘录）</h2><h3 id="动机motivation-16"><a class="anchor" href="#动机motivation-16">#</a> 动机（Motivation）</h3><p>在软件构建过程中，某些对象的状态在转换过程中，可能由于某种需要，要求程序能够回溯到对象之前处于某个点时的状态。如果使用一些公有接口来让其他对象得到对象的状态，便会暴露对象的细节实现。</p><p>如何实现对象状态的良好保存与恢复？但同时又不会因此而破坏对象本身的封装性。</p><h3 id="模式定义-17"><a class="anchor" href="#模式定义-17">#</a> 模式定义</h3><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。</p><h3 id="结构structure-17"><a class="anchor" href="#结构structure-17">#</a> 结构（Structure）</h3><p><img data-src="/2023/03/20/cpp/design-patterns/Design%20Patterns/image-20230319185145722.png" alt="image-20230319185145722"></p><h3 id="要点总结-17"><a class="anchor" href="#要点总结-17">#</a> 要点总结</h3><p>备忘录（Memento）存储原发器（Originator）对象的内部状态，在需要时恢复原发器状态。</p><p>Memento 模式的核心是信息隐藏，即 Originator 需要向外接隐藏信息，保持其封装性。但同时又需要将状态保持到外界（Memento）。</p><p>由于现代语言运行时（如 C#、Java 等）都具有相当的对象序列化支持，因此往往采用效率较高、又较容易正确实现的序列化方案来实现 Memento 模式。</p><h2 id="composite组合模式"><a class="anchor" href="#composite组合模式">#</a> Composite（组合模式）</h2><h3 id="动机motivation-17"><a class="anchor" href="#动机motivation-17">#</a> 动机（Motivation）</h3><p>在软件在某些情况下，客户代码过多地依赖于对象容器复杂的内部实现结构，对象容器内部实现结构（而非抽象接口）的变化将引起客户代码的频繁变化，带来了代码的维护性、扩展性等弊端。</p><p>如何将 “客户代码与复杂的对象容器结构” 解耦？让对象容器自己来实现自身的复杂结构，从而使得客户代码就像处理简单对象一样来处理复杂的对象容器？</p><h3 id="模式定义-18"><a class="anchor" href="#模式定义-18">#</a> 模式定义</h3><p>将对象组合成树形结构以表示 “部分 - 整体” 的层次结构。Composite 使得用户对单个对象和组合对象的使用具有一致性（稳定）。</p><h3 id="结构structure-18"><a class="anchor" href="#结构structure-18">#</a> 结构（Structure）</h3><p><img data-src="/2023/03/20/cpp/design-patterns/Design%20Patterns/image-20230320092054885.png" alt="image-20230320092054885"></p><h3 id="要点总结-18"><a class="anchor" href="#要点总结-18">#</a> 要点总结</h3><p>Composite 模式采用树形结构来实现普遍存在的对象容器，从而将 “一对多” 的关系转化为 “一对一” 的关系，使得客户代码可以一致地（复用）处理对象和对象容器，无需关心处理的是单个的对象，还是组合的对象容器。</p><p>将 “客户代码与复杂的对象容器结构” 解耦是 Composite 的核心思想，解耦之后，客户代码将与纯粹的抽象接口 -— 而非对象容器的内部实现结构 -- 发生依赖，从而更能 “应对变化”。</p><p>Composite 模式在具体实现中，可以让父对象中的子对象反向追溯；如果父对象有频繁的遍历需求，可使用缓存技巧来改善效率。</p><h2 id="iterator迭代器"><a class="anchor" href="#iterator迭代器">#</a> Iterator（迭代器）</h2><h3 id="动机motivation-18"><a class="anchor" href="#动机motivation-18">#</a> 动机（Motivation）</h3><p>在软件构建过程中，集合对象内部结构常常变化各异。但对于这些集合对象，我们希望在不暴露其内部结构的同时，可以让外部客户代码透明地访问其中包含的元素；同时这种 “透明遍历” 也为 “同一种算法在多种集合对象上进行操作” 提供了可能。</p><p>使用面向对象技术将这种遍历机制抽象为 “迭代器对象” 为 “应对变化中的集合对象” 提供了一种优雅的方式。</p><h3 id="模式定义-19"><a class="anchor" href="#模式定义-19">#</a> 模式定义</h3><p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露（稳定）该对象的内部表示。</p><h3 id="结构structure-19"><a class="anchor" href="#结构structure-19">#</a> 结构（Structure）</h3><p><img data-src="/2023/03/20/cpp/design-patterns/Design%20Patterns/image-20230320092135992.png" alt="image-20230320092135992"></p><h3 id="要点总结-19"><a class="anchor" href="#要点总结-19">#</a> 要点总结</h3><p>迭代抽象：访问一个聚合对象的内容而无需暴露它的内部表示。</p><p>迭代多态：为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。</p><p>迭代器的健壮性考虑：遍历的同时更改迭代器所在的集合结构，会导致问题。</p><h2 id="chain-of-responsibility职责链"><a class="anchor" href="#chain-of-responsibility职责链">#</a> Chain of Responsibility（职责链）</h2><h3 id="动机motivation-19"><a class="anchor" href="#动机motivation-19">#</a> 动机（Motivation）</h3><p>在软件构建过程中，一个请求可能被多个对象处理，但是每个请求在运行时只能有一个接受者，如果显式指定，将必不可少地带来一请求发送者与接受者的紧耦合。</p><p>如何使请求的发送者不需要指定具体的接受者？让请求的接受者自己在运行时决定来处理请求，从而使两者解耦。</p><h3 id="模式定义-20"><a class="anchor" href="#模式定义-20">#</a> 模式定义</h3><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。</p><h3 id="结构structure-20"><a class="anchor" href="#结构structure-20">#</a> 结构（Structure）</h3><p><img data-src="/2023/03/20/cpp/design-patterns/Design%20Patterns/image-20230320092214650.png" alt="image-20230320092214650"></p><h3 id="要点总结-20"><a class="anchor" href="#要点总结-20">#</a> 要点总结</h3><p>Chain of Responsibility 模式的应用场合在于 “一个请求可能有多个接受者，但是最后真正的接受者只有一个”，这时候请求发送者与接受者的耦合有可能出现 “变化脆弱” 的症状，职责链的目的就是将二者解耦，从而更好地应对变化。</p><p>应用了 Chain of Responsibility 模式后，对象的职责分派将更具灵活性。我们可以在运行时动态添加 / 修改请求的处理职责。</p><p>如果请求传递到职责链的末尾仍得不到处理，应该有一个合理的缺省机制。这也是每一个接受对象的责任，而不是发出请求的对象的责任。</p><h2 id="cammand命令模式"><a class="anchor" href="#cammand命令模式">#</a> Cammand（命令模式）</h2><h3 id="动机motivation-20"><a class="anchor" href="#动机motivation-20">#</a> 动机（Motivation）</h3><p>在软件构建过程中，“行为请求者” 与 “行为实现者” 通常呈现一种 “紧耦合”。但在某些场合 -- 比如需要对行为进行 “记录、撤销 / 重（undo/redo）、事务” 等处理，这种无法抵御变化的紧耦合是不合适的。</p><p>在这种情况下，如何将 “行为请求者” 与 “行为实现者” 解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</p><h3 id="模式定义-21"><a class="anchor" href="#模式定义-21">#</a> 模式定义</h3><p>将一个请求（行为）封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</p><h3 id="结构structure-21"><a class="anchor" href="#结构structure-21">#</a> 结构（Structure）</h3><p><img data-src="/2023/03/20/cpp/design-patterns/Design%20Patterns/image-20230320092306793.png" alt="image-20230320092306793"></p><h3 id="要点总结-21"><a class="anchor" href="#要点总结-21">#</a> 要点总结</h3><p>Command 模式的根本目的在于将 “行为请求者” 与 “行为实现者” 解耦，在面向对象语言中，常见的实现手段是 “将行为抽象为对象”。</p><p>实现 Command 接口的具体命令对象 <code>ConcreteCommand</code> 有时候根据需要可能会保存一些额外的状态信息。通过使用 Composite 模式，可以将多个 “命令” 封装为一个 “复合命令” <code>MacroCommand</code> 。</p><p>Command 模式与 C++ 中的函数对象有些类似。但两者定义行为接口的规范有所区别： Command 以面向对象中的 “接口 - 实现” 来定义行为接口规范，更严格，但有性能损失；C++ 函数对象以函数签名来定义行为接口规范，更灵活，性能更高。</p><h2 id="vistor访问器"><a class="anchor" href="#vistor访问器">#</a> Vistor（访问器）</h2><h3 id="动机motivation-21"><a class="anchor" href="#动机motivation-21">#</a> 动机（Motivation）</h3><p>在软件构建过程中，由于需求的改变，某些类层次结构中常常需要增加新的行为（方法） ，如果直接在基类中做这样的更改，将会给子类带来很繁重的变更负担，甚至破坏原有设计。</p><p>如何在不更改类层次结构的前提下，在运行时根据需要透明地为类层次结构上的各个类动态添加新的操作，从而避免上述问题？</p><h3 id="模式定义-22"><a class="anchor" href="#模式定义-22">#</a> 模式定义</h3><p>表示一个作用于某对象结构中的各元素的操作。使得可以在不改变（稳定）各元素的类的前提下定义（扩展）作用于这些元素的新操作（变化）。</p><h3 id="结构structure-22"><a class="anchor" href="#结构structure-22">#</a> 结构（Structure）</h3><p><img data-src="/2023/03/20/cpp/design-patterns/Design%20Patterns/image-20230320092521965.png" alt="image-20230320092521965"></p><h3 id="要点总结-22"><a class="anchor" href="#要点总结-22">#</a> 要点总结</h3><p>Visitor 模式通过所谓双重分发（double dispatch）来实现在不更改（不添加新的操作 - 编译时） Element 类层次结构的前提下，在运行时透明地为类层次结构上的各个类动态添加新的操作（支持变化）。</p><p>所谓双重分发即 Visitor 模式中间包括了两个多态分发（注意其中的。多态机制）：第一个为 accept 方法的多态辨析；第二个为 <code>visitElementX</code> 方法的多态辨析。</p><p>Visitor 模式的最大缺点在于扩展类层次结构（增添新的 Element 子类），会导致 Visitor 类的改变。因此 Visitor 模式适用于 “Element 类。层次结构稳定，而其中的操作却经常面临频繁改动”。</p><h2 id="interpreter解析器"><a class="anchor" href="#interpreter解析器">#</a> Interpreter（解析器）</h2><h3 id="动机motivation-22"><a class="anchor" href="#动机motivation-22">#</a> 动机（Motivation）</h3><p>在软件构建过程中，如果某一特定领域的问题比较复杂，类似的结构不断重复出现，如果使用普通的编程方式来实现将面临非常频繁的变化。</p><p>在这种情况下，将特定领域的问题表达为某种语法规则下的句子，然后构建一个解释器来解释这样的句子，从而达到解决问题的目的。</p><h3 id="模式定义-23"><a class="anchor" href="#模式定义-23">#</a> 模式定义</h3><p>给定一个语言，定义它的文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释语言中的句子。</p><h3 id="结构structure-23"><a class="anchor" href="#结构structure-23">#</a> 结构（Structure）</h3><p><img data-src="/2023/03/20/cpp/design-patterns/Design%20Patterns/image-20230320093646767.png" alt="image-20230320093646767"></p><h3 id="要点总结-23"><a class="anchor" href="#要点总结-23">#</a> 要点总结</h3><p>Interpreter 模式的应用场合是 Interpreter 模式应用中的难点，只有满足 “业务规则频繁变化，且类似的结构不断重复出现，并且容易抽象为语法规则的问题” 才适合使用 Interpreter 模式。</p><p>使用 Interpreter 模式来表示文法规则，从而可以使用面向对象技巧来方便地 “扩展” 文法。</p><p>Interpreter 模式比较适合简单的文法表示，对于复杂的文法表示，Interpreter 模式会产生比较大的类层次结构，需要求助于语法分析生成器这样的标准工具。</p><h2 id="设计模式总结"><a class="anchor" href="#设计模式总结">#</a> 设计模式总结</h2><p><mark>管理变化，提高复用！</mark></p><p><mark>分解 vs. 抽象</mark></p><p><mark>八大原则</mark></p><p><mark>重构技法</mark></p><div class="tags"><a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 学习笔记</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2023-03-23 08:31:58" itemprop="dateModified" datetime="2023-03-23T08:31:58+08:00">2023-03-23</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Sakupinera WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Sakupinera Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Sakupinera PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Sakupinera <i class="ic i-at"><em>@</em></i>Sakupinera</li><li class="link"><strong>Post link: </strong><a href="http://sakupinera.github.io/2023/03/20/cpp/design-patterns/Design%20Patterns/" title="设计模式（Design Patterns）">http://sakupinera.github.io/2023/03/20/cpp/design-patterns/Design Patterns/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/02/10/csharp/clr-via-csharp/Chapter%2030%20Hybrid%20Thread%20Synchronization%20Constructs/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;03&#x2F;08&#x2F;rkHPIpA3EmFKe7i.png" title="CLR via C# - Chapter 30 Hybrid Thread Synchronization"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 30 Hybrid Thread Synchronization</h3></a></div><div class="item right"><a href="/2023/03/21/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;03&#x2F;08&#x2F;EXaiHD39BF7QWok.jpg" title="计算机网络"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i> Network</span><h3>计算机网络</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Fdesign-patterns"><span class="toc-number">1.</span> <span class="toc-text">设计模式（Design Patterns）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">初步认识设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.1.</span> <span class="toc-text">什么是设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%B0%88%E8%B5%B7"><span class="toc-number">1.1.2.</span> <span class="toc-text">从面向对象谈起</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%9B%BA%E6%9C%89%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7"><span class="toc-number">1.1.3.</span> <span class="toc-text">软件设计固有的复杂性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%A4%8D%E6%9D%82%E7%9A%84%E6%A0%B9%E6%9C%AC%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.1.4.</span> <span class="toc-text">软件设计复杂的根本原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%A4%8D%E6%9D%82%E6%80%A7"><span class="toc-number">1.1.5.</span> <span class="toc-text">如何解决复杂性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">1.1.6.</span> <span class="toc-text">软件设计的目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.7.</span> <span class="toc-text">面向对象设计，为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.8.</span> <span class="toc-text">重新认识面向对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.1.9.</span> <span class="toc-text">面向对象设计原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E6%8F%90%E5%8D%87%E4%B8%BA%E8%AE%BE%E8%AE%A1%E7%BB%8F%E9%AA%8C"><span class="toc-number">1.1.10.</span> <span class="toc-text">将设计原则提升为设计经验</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gof-23-%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">GOF-23 模式分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%B0%81%E8%A3%85%E5%8F%98%E5%8C%96%E8%A7%92%E5%BA%A6%E5%AF%B9%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB"><span class="toc-number">1.2.1.</span> <span class="toc-text">从封装变化角度对模式分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%9E%84%E8%8E%B7%E5%BE%97%E6%A8%A1%E5%BC%8F-refactoring-to-patterns"><span class="toc-number">1.2.2.</span> <span class="toc-text">重构获得模式 Refactoring to Patterns</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%9E%84%E5%85%B3%E9%94%AE%E6%8A%80%E6%B3%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">重构关键技法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#template-method%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">Template Method（模板方法）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BAmotivation"><span class="toc-number">1.3.1.</span> <span class="toc-text">动机（Motivation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84structure"><span class="toc-number">1.3.3.</span> <span class="toc-text">结构（Structure）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#strategy%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">Strategy（策略模式）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-2"><span class="toc-number">1.4.1.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84structure-2"><span class="toc-number">1.4.2.</span> <span class="toc-text">结构（Structure）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-2"><span class="toc-number">1.4.3.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#observerevent%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.</span> <span class="toc-text">Observer&#x2F;Event（观察者模式）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BAmotivation-2"><span class="toc-number">1.5.1.</span> <span class="toc-text">动机（Motivation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-3"><span class="toc-number">1.5.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84structure-3"><span class="toc-number">1.5.3.</span> <span class="toc-text">结构（Structure）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-3"><span class="toc-number">1.5.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#decorator%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.</span> <span class="toc-text">Decorator（装饰模式）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BAmotivation-3"><span class="toc-number">1.6.1.</span> <span class="toc-text">动机（Motivation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-4"><span class="toc-number">1.6.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84structure-4"><span class="toc-number">1.6.3.</span> <span class="toc-text">结构（Structure）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-4"><span class="toc-number">1.6.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bridge%E6%A1%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.</span> <span class="toc-text">Bridge（桥模式）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BAmotivation-4"><span class="toc-number">1.7.1.</span> <span class="toc-text">动机（Motivation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-5"><span class="toc-number">1.7.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84structure-5"><span class="toc-number">1.7.3.</span> <span class="toc-text">结构（Structure）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-5"><span class="toc-number">1.7.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#factory-method%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.</span> <span class="toc-text">Factory Method（工厂方法）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BAmotivation-5"><span class="toc-number">1.8.1.</span> <span class="toc-text">动机（Motivation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-6"><span class="toc-number">1.8.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84structure-6"><span class="toc-number">1.8.3.</span> <span class="toc-text">结构（Structure）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-6"><span class="toc-number">1.8.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#abstract-factory%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82"><span class="toc-number">1.9.</span> <span class="toc-text">Abstract Factory（抽象工厂）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BAmotivation-6"><span class="toc-number">1.9.1.</span> <span class="toc-text">动机（Motivation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-7"><span class="toc-number">1.9.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84structure-7"><span class="toc-number">1.9.3.</span> <span class="toc-text">结构（Structure）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-7"><span class="toc-number">1.9.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#prototype%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.10.</span> <span class="toc-text">Prototype（原型模式）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BAmotivation-7"><span class="toc-number">1.10.1.</span> <span class="toc-text">动机（Motivation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-8"><span class="toc-number">1.10.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84structure-8"><span class="toc-number">1.10.3.</span> <span class="toc-text">结构（Structure）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-8"><span class="toc-number">1.10.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#builder%E6%9E%84%E5%BB%BA%E5%99%A8"><span class="toc-number">1.11.</span> <span class="toc-text">Builder（构建器）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BAmotivation-8"><span class="toc-number">1.11.1.</span> <span class="toc-text">动机（Motivation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-9"><span class="toc-number">1.11.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84structure-9"><span class="toc-number">1.11.3.</span> <span class="toc-text">结构（Structure）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-9"><span class="toc-number">1.11.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#singleton%E5%8D%95%E4%BB%B6%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.12.</span> <span class="toc-text">Singleton（单件模式）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BAmotivation-9"><span class="toc-number">1.12.1.</span> <span class="toc-text">动机（Motivation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-10"><span class="toc-number">1.12.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84structure-10"><span class="toc-number">1.12.3.</span> <span class="toc-text">结构（Structure）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-10"><span class="toc-number">1.12.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#flyweight%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.13.</span> <span class="toc-text">Flyweight（享元模式）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BAmotivation-10"><span class="toc-number">1.13.1.</span> <span class="toc-text">动机（Motivation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-11"><span class="toc-number">1.13.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84structure-11"><span class="toc-number">1.13.3.</span> <span class="toc-text">结构（Structure）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-11"><span class="toc-number">1.13.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#facade%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.14.</span> <span class="toc-text">Facade（门面模式）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BAmotivation-11"><span class="toc-number">1.14.1.</span> <span class="toc-text">动机（Motivation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-12"><span class="toc-number">1.14.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84structure-12"><span class="toc-number">1.14.3.</span> <span class="toc-text">结构（Structure）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-12"><span class="toc-number">1.14.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#proxy%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.15.</span> <span class="toc-text">Proxy（代理模式）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BAmotivation-12"><span class="toc-number">1.15.1.</span> <span class="toc-text">动机（Motivation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-13"><span class="toc-number">1.15.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84structure-13"><span class="toc-number">1.15.3.</span> <span class="toc-text">结构（Structure）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-13"><span class="toc-number">1.15.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#adapter%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">1.16.</span> <span class="toc-text">Adapter（适配器）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BAmotivation-13"><span class="toc-number">1.16.1.</span> <span class="toc-text">动机（Motivation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-14"><span class="toc-number">1.16.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84structure-14"><span class="toc-number">1.16.3.</span> <span class="toc-text">结构（Structure）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-14"><span class="toc-number">1.16.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mediator%E4%B8%AD%E4%BB%8B%E8%80%85"><span class="toc-number">1.17.</span> <span class="toc-text">Mediator（中介者）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BAmotivation-14"><span class="toc-number">1.17.1.</span> <span class="toc-text">动机（Motivation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-15"><span class="toc-number">1.17.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84structure-15"><span class="toc-number">1.17.3.</span> <span class="toc-text">结构（Structure）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-15"><span class="toc-number">1.17.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#state%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.18.</span> <span class="toc-text">State（状态模式）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BAmotivation-15"><span class="toc-number">1.18.1.</span> <span class="toc-text">动机（Motivation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-16"><span class="toc-number">1.18.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84structure-16"><span class="toc-number">1.18.3.</span> <span class="toc-text">结构（Structure）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-16"><span class="toc-number">1.18.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#memento%E5%A4%87%E5%BF%98%E5%BD%95"><span class="toc-number">1.19.</span> <span class="toc-text">Memento（备忘录）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BAmotivation-16"><span class="toc-number">1.19.1.</span> <span class="toc-text">动机（Motivation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-17"><span class="toc-number">1.19.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84structure-17"><span class="toc-number">1.19.3.</span> <span class="toc-text">结构（Structure）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-17"><span class="toc-number">1.19.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#composite%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.20.</span> <span class="toc-text">Composite（组合模式）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BAmotivation-17"><span class="toc-number">1.20.1.</span> <span class="toc-text">动机（Motivation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-18"><span class="toc-number">1.20.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84structure-18"><span class="toc-number">1.20.3.</span> <span class="toc-text">结构（Structure）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-18"><span class="toc-number">1.20.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iterator%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.21.</span> <span class="toc-text">Iterator（迭代器）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BAmotivation-18"><span class="toc-number">1.21.1.</span> <span class="toc-text">动机（Motivation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-19"><span class="toc-number">1.21.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84structure-19"><span class="toc-number">1.21.3.</span> <span class="toc-text">结构（Structure）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-19"><span class="toc-number">1.21.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chain-of-responsibility%E8%81%8C%E8%B4%A3%E9%93%BE"><span class="toc-number">1.22.</span> <span class="toc-text">Chain of Responsibility（职责链）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BAmotivation-19"><span class="toc-number">1.22.1.</span> <span class="toc-text">动机（Motivation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-20"><span class="toc-number">1.22.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84structure-20"><span class="toc-number">1.22.3.</span> <span class="toc-text">结构（Structure）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-20"><span class="toc-number">1.22.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cammand%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.23.</span> <span class="toc-text">Cammand（命令模式）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BAmotivation-20"><span class="toc-number">1.23.1.</span> <span class="toc-text">动机（Motivation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-21"><span class="toc-number">1.23.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84structure-21"><span class="toc-number">1.23.3.</span> <span class="toc-text">结构（Structure）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-21"><span class="toc-number">1.23.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vistor%E8%AE%BF%E9%97%AE%E5%99%A8"><span class="toc-number">1.24.</span> <span class="toc-text">Vistor（访问器）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BAmotivation-21"><span class="toc-number">1.24.1.</span> <span class="toc-text">动机（Motivation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-22"><span class="toc-number">1.24.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84structure-22"><span class="toc-number">1.24.3.</span> <span class="toc-text">结构（Structure）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-22"><span class="toc-number">1.24.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#interpreter%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-number">1.25.</span> <span class="toc-text">Interpreter（解析器）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BAmotivation-22"><span class="toc-number">1.25.1.</span> <span class="toc-text">动机（Motivation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-23"><span class="toc-number">1.25.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84structure-23"><span class="toc-number">1.25.3.</span> <span class="toc-text">结构（Structure）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-23"><span class="toc-number">1.25.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="toc-number">1.26.</span> <span class="toc-text">设计模式总结</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"><ul><li class="active"><a href="/2023/03/20/cpp/design-patterns/Design%20Patterns/" rel="bookmark" title="设计模式（Design Patterns）">设计模式（Design Patterns）</a></li></ul></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sakupinera" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Sakupinera</p><div class="description" itemprop="description">保持你的决心！</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">86</span> <span class="name">posts</span></a></div><div class="item categories"><a href="/categories/"><span class="count">13</span> <span class="name">categories</span></a></div><div class="item tags"><a href="/tags/"><span class="count">6</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nha3VwaW5lcmE=" title="https:&#x2F;&#x2F;github.com&#x2F;sakupinera"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9zYWt1cGluZXJh" title="https:&#x2F;&#x2F;twitter.com&#x2F;sakupinera"><i class="ic i-twitter"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQwNzIyOTA3MQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;407229071"><i class="ic i-cloud-music"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMjIzMDczOTg/c3BtX2lkX2Zyb209MzMzLjEwMDcuMC4w" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;22307398?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li><li class="item"><a href="/games/" rel="section"><i class="ic i-flag"></i>Games</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-person"></i>About</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/02/10/csharp/clr-via-csharp/Chapter%2030%20Hybrid%20Thread%20Synchronization%20Constructs/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/03/21/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" title="CLR via C# - Chapter 8 Methods">CLR via C# - Chapter 8 Methods</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2022/12/15/cpp/cpp-primer/Chapter%207%20Classes/" title="C++ Primer - Chapter 7 Classes">C++ Primer - Chapter 7 Classes</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/17/csharp/clr-via-csharp/Chapter%2015%20Enumerated%20Types%20and%20Bit%20Flags/" title="CLR via C# - Chapter 15 Enumerated Types and Bit Flags">CLR via C# - Chapter 15 Enumerated Types and Bit Flags</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/09/02/linux/learn-linux/Shell%E5%9F%BA%E7%A1%80/" title="LearnLinux - Shell基础">LearnLinux - Shell基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2023/01/07/cpp/cpp-primer/Chapter%2015%20Object-Oriented%20Programming/" title="C++ Primer - Chapter 15 Object-Oriented Programming">C++ Primer - Chapter 15 Object-Oriented Programming</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2023/01/10/cpp/cpp-primer/Chapter%2018%20Tools%20for%20Large%20Programs/" title="C++ Primer - Chapter 18 Tools for Large Programs">C++ Primer - Chapter 18 Tools for Large Programs</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/10/09/computer-graphics/games101/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/" title="GAMES101 - Ray Tracing（光线追踪）">GAMES101 - Ray Tracing（光线追踪）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2022/12/14/cpp/cpp-primer/Chapter%206%20Functions/" title="C++ Primer - Chapter 6 Functions">C++ Primer - Chapter 6 Functions</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/09/06/computer-graphics/games101/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%A6%82%E8%BF%B0/" title="GAMES101 - 计算机图形学概述">GAMES101 - 计算机图形学概述</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/09/05/linux/learn-linux/%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/" title="LearnLinux - 备份与恢复">LearnLinux - 备份与恢复</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Sakupinera @ Hanamai Sora</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="Symbols count total">2.2m words</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="Reading time total">33:30</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/03/20/cpp/design-patterns/Design Patterns/",favicon:{show:"（●´3｀●）Goooood",hide:"(´Д｀)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/shifuku.model.json"},display:{position:"left",width:250,height:500},mobile:{show:!1},react:{opacity:.9},log:!1})</script></body></html>