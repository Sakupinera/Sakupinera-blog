<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sakupinera" href="http://sakupinera.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sakupinera" href="http://sakupinera.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sakupinera" href="http://sakupinera.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="读书笔记,C#"><link rel="canonical" href="http://sakupinera.github.io/2022/09/04/csharp/csharp-in-a-nutshell/%E7%AC%AC14%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%BC%82%E6%AD%A5/"><title>C# in a Nutshell - 第 14 章 并发与异步 - CSharp-in-a-Nutshell - CSharp | Hanamai Sora = Sakupinera</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">C# in a Nutshell - 第 14 章 并发与异步</h1><div class="meta"><span class="item" title="Created: 2022-09-04 21:20:13"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2022-09-04T21:20:13+08:00">2022-09-04</time> </span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">Symbols count in article</span> <span>24k</span> <span class="text">words</span> </span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">Reading time</span> <span>22 mins.</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hanamai Sora</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s2.loli.net/2023/03/08/jV3gF2wSUYTdtsp.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/DFUCvo21fTb5mwG.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/XtZcHusj92O56kz.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/OQq9sc7VlKfnvGL.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/GkbQv5EIRZBXgDn.png"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/AK1D84aqsYghTOC.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/" itemprop="item" rel="index" title="In CSharp"><span itemprop="name">CSharp</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/CSharp-in-a-Nutshell/" itemprop="item" rel="index" title="In CSharp-in-a-Nutshell"><span itemprop="name">CSharp-in-a-Nutshell</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://sakupinera.github.io/2022/09/04/csharp/csharp-in-a-nutshell/%E7%AC%AC14%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%BC%82%E6%AD%A5/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Sakupinera"><meta itemprop="description" content=", 保持你的决心！"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakupinera"></span><div class="body md" itemprop="articleBody"><h1 id="并发与异步"><a class="anchor" href="#并发与异步">#</a> 并发与异步</h1><h2 id="概述"><a class="anchor" href="#概述">#</a> 概述</h2><p>最常见的并发场景包括：</p><ul><li>编写快速响应的用户界面</li><li>处理同时出现的请求</li><li>并行编程</li><li>预测执行</li></ul><p>这种程序同时执行代码的机制称为多线程。CLR 和操作系统都支持多线程，它是并发的概念基础。</p><h2 id="线程"><a class="anchor" href="#线程">#</a> 线程</h2><p>线程是一个可以独立执行的执行路径。</p><h3 id="创建线程"><a class="anchor" href="#创建线程">#</a> 创建线程</h3><p>客户端程序（控制台、WPF、UWP 或者 Windows Forms）再启动时都会从操作系统自动创建一个线程（主线程）。除非（直接或者间接地）手动创建多个线程，否则该应用程序就是一个单线程的应用程序。</p><p>要创建并启动一个线程，需要首先实例化 Thread 对象并调用 Start 方法。Thread 的最简单的构造器接受一个 ThreadStart 委托：一个无参数的方法，表示执行的起始位置。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// NB: All samples in this chapter assume the following namespace imports:</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Threading</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">ThreadTest</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Thread</span> <span class="token punctuation">(</span>WriteY<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Kick off a new thread</span></pre></td></tr><tr><td data-num="9"></td><td><pre> t<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// running WriteY()</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// Simultaneously, do something on the main thread.</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> Console<span class="token punctuation">.</span>Write <span class="token punctuation">(</span><span class="token string">"x"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">WriteY</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> Console<span class="token punctuation">.</span>Write <span class="token punctuation">(</span><span class="token string">"y"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token comment">// Typical Output:</span></pre></td></tr><tr><td data-num="19"></td><td><pre>xxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy</pre></td></tr><tr><td data-num="20"></td><td><pre>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxyyyyyyyyyyyyy</pre></td></tr><tr><td data-num="21"></td><td><pre>yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxx</pre></td></tr><tr><td data-num="22"></td><td><pre>xxxxxxxxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy</pre></td></tr><tr><td data-num="23"></td><td><pre>yyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr></table></figure><p>在单核计算机上，操作系统会为每一个线程划分时间片（Windows 系统的典型值为 20 毫秒）来模拟并发执行。因此上述代码会出现连续的 x 和 y。而在多核心的计算机上，两个线程可以并行执行（会和计算机上其他执行的进程进行竞争），因此虽然我们还是会得到连续的 x 和 y，但这却是由于 Console 处理并发请求的机制导致的。</p><p><img data-src="Figure14_1.JPG" alt="image"></p><p>线程是抢占式的。它的执行和其他线程的代码是交错执行的。</p><p>线程一旦启动，其 IsAlive 属性就会返回 true，直至线程停止。当 Thread 的构造函数接收的委托执行完毕后，线程就会停止。线程停止后就无法再启动了。</p><p>每一个线程都有一个 Name 属性用于调试用途。</p><h3 id="汇合与休眠"><a class="anchor" href="#汇合与休眠">#</a> 汇合与休眠</h3><p>调用 Thread 的 Join 方法可以等待其他线程结束：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Thread</span> <span class="token punctuation">(</span>Go<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> t<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> t<span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token string">"Thread t has ended!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>调用 Join 时可以指定一个超时时间（以毫秒为单位或者使用 TimeSpan 定义）。如果线程再指定时间内正常结束，则返回 true；如果超时则返回 false。</p><p>Thread.Sleep (0) 将会导致线程立即放弃自己的时间片，自觉地将 CPU 交于其他的线程。Thread.Yield () 执行相同的操作，但是它只会将资源交给同一个处理器上运行的线程。</p><p>如果在代码的任意位置插入 Thread.Yield () 导致程序失败，则代码一定存在缺陷。</p><p>在等待线程 Sleep 或者 Join 的过程中，线程是阻塞的。</p><h3 id="阻塞"><a class="anchor" href="#阻塞">#</a> 阻塞</h3><p>线程由于特定原因暂定执行，那么它就是阻塞的。阻塞的线程会立刻交出它的处理器时间片，并从此开始不再消耗处理器时间，直至阻塞条件结束。</p><p>当线程被阻塞或者接触阻塞时，操作系统就会进行一次上下文切换。这会导致细小的开销，一般在 1~2 微妙。</p><p><strong>I/O 密集和计算密集</strong></p><p>如果一个操作的绝大部分时间都在等待事件的发生，则称为 I/O 密集。I/O 密集操作一般都会涉及输入或者输出，但是这并非硬性要求。日入 Thread.Sleep 也是一种 I/O 密集的操作。相反，如果操作的大部分时间都用于执行大量的 CPU 操作，则称为计算密集。</p><p><strong>阻塞和自旋</strong></p><p>I/O 密集操作主要表现为以下两种形式：要么在当前线程同步进行等待，直至操作完成（例如 Console.ReadLine、Thread.Sleep 以及 Thread.Join）；要么异步进行操作，在操作完成的时候或者之后某个时刻触发回调函数。</p><p>同步的 I/O 密集操作大部分时间都花费在阻塞线程上，但是也可能在一个定期循环中自旋：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">while</span> <span class="token punctuation">(</span>DateTime<span class="token punctuation">.</span>Now <span class="token operator">&lt;</span> nextStartTime<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre> Thread<span class="token punctuation">.</span>Sleep <span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>虽然有更好的办法实现这种效果（例如使用定时器或者使用信号发送结构），但宁外一种选择是令线程持续性自旋：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">while</span> <span class="token punctuation">(</span>DateTime<span class="token punctuation">.</span>Now <span class="token operator">&lt;</span> nextStartTime<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>一般来说，上述做法非常浪费处理器时间。因为 CLR 和操作系统都会认为这个线程正在执行重要的运算，因此就会为其分配响应的资源。因此从效果上来说我们将一个 I/O 密集的操作转变成了一个计算密集型操作。</p><p>自选和阻塞有一些细微的差别。首先，非常短暂的自旋在条件可以很快得到满足的场景（例如几微妙）下是非常的高效的，因为它避免了上下文切换带来的延迟和开销。其次，阻塞并非零开销。这是因为每一个线程在存活时会占用 1MB 左右的内存，并对 CLR 和操作系统带来持续性的管理开销。因此，阻塞可能会给繁重的 I/O 密集型程序（例如要处理成百上千的并发操作）带来麻烦。这些程序更适于使用回调的方式，在等待时完全解除这些线程。</p><h3 id="本地状态与共享状态"><a class="anchor" href="#本地状态与共享状态">#</a> 本地状态与共享状态</h3><p>CLR 为每一个线程分配了独立的内存栈，从而保证了局部变量的隔离。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Thread</span> <span class="token punctuation">(</span>Go<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Call Go() on a new thread</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token function">Go</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Call Go() on the main thread</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Go</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Declare and use a local variable - 'cycles'</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> cycles <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> cycles <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> cycles<span class="token operator">++</span><span class="token punctuation">)</span> Console<span class="token punctuation">.</span>Write <span class="token punctuation">(</span><span class="token char">'?'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>如果不同的线程拥有同一个对象的引用，则这些线程之间就共享了数据：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">ThreadTest</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name"><span class="token keyword">bool</span></span> _done<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token class-name">ThreadTest</span> tt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ThreadTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Create a common instance</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Thread</span> <span class="token punctuation">(</span>tt<span class="token punctuation">.</span>Go<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> tt<span class="token punctuation">.</span><span class="token function">Go</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Go</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Note that this is an instance method</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>_done<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> _done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token string">"Done"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>编译器会将 Lambda 表达式捕获的局部变量或匿名委托转换为字段，因此它们也可以被共享：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name"><span class="token keyword">bool</span></span> done <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">ThreadStart</span> action <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>done<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token string">"Done"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Thread</span> <span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>上述语句的问题是，当一个线程在判断 if 语句的时候，另一个线程有可能在 done 设置为 true 前就已经开始执行 WriteLine 语句了。</p><p>上述例子展示了共享写状态可能引起间歇性错误，这也是多线程中经常被诟病的问题。下面将介绍如何通过锁机制来避免这种问题。然而，最好的方式时避免使用共享状态。稍后还将介绍如何通过异步编程的方式来解决这个问题。</p><h3 id="锁与线程安全"><a class="anchor" href="#锁与线程安全">#</a> 锁与线程安全</h3><p>在读写共享字段时首先获得一个排他锁可以修正之前示例的问题。使用 C# 的 lock 语句就可以实现这个目标：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">ThreadSafe</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">static</span> <span class="token class-name"><span class="token keyword">bool</span></span> _done<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">static</span> <span class="token keyword">readonly</span> <span class="token class-name"><span class="token keyword">object</span></span> _locker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name"><span class="token keyword">object</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Thread</span> <span class="token punctuation">(</span>Go<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token function">Go</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Go</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">lock</span> <span class="token punctuation">(</span>_locker<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>_done<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token string">"Done"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> _done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>当两个线程同时竞争一个锁时（它可以是任意引用类型的对象，这里是_locker），一个线程会进行等待（阻塞），直到锁被释放。</p><p>即使是变量自增操作也并不是线程安全的：底层处理器也会采用独立的读 - 自增 - 写操作来执行 x++ 这种表达式。</p><p>锁并非保证线程安全的灵丹妙药，人们很容易忘记在访问字段时加锁，而且锁本身也存在一些问题（例如死锁）。</p><h3 id="向线程传递数据"><a class="anchor" href="#向线程传递数据">#</a> 向线程传递数据</h3><p>Thread 对象的重载构造器可以接受以下两种委托的任意一种。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">delegate</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ThreadStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">delegate</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> ParameterizedThreadStart <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span></span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="异常处理"><a class="anchor" href="#异常处理">#</a> 异常处理</h3><p>线程执行和线程创建时所处的 try/catch/finally 语句块无关。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">try</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Thread</span> <span class="token punctuation">(</span>Go<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// We'll never get here!</span></pre></td></tr><tr><td data-num="10"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token string">"Exception!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>本例中的 try/catch 语句是无效的。新创建的线程会被未处理的 NullReference-Exception 异常影响。如果将每一个线程看作独立的执行路径，那么就可以理解上述行为了。</p><p>解决方法是将异常处理移到 Go 方法内：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Thread</span> <span class="token punctuation">(</span>Go<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Go</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">try</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">throw</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// The NullReferenceException will get caught below</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// Typically log the exception, and/or signal another thread</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token comment">// that we've come unstuck</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="前台线程与后台线程"><a class="anchor" href="#前台线程与后台线程">#</a> 前台线程与后台线程</h3><p>一般情况下，显示创建的线程称为前台线程。只要有一个前台线程还在运行，应用程序就仍然保持运行状态。而后台线程则不然。当所有前台线程结束时，应用程序就会停止，且所有运行的后台线程也会随之终止。</p><p>线程的前台 / 后台状态和线程的优先级（执行时间的分配）无关。</p><p>可以使用线程的 IsBackground 属性来查询或修改线程的前后台状态：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> Main <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Thread</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Thread</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">.</span>Length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> worker<span class="token punctuation">.</span>IsBackground <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> worker<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>如果进程以上述方式终止，则后台程序执行栈上的任何 finally 语句块都无法执行。如果应用程序需要在 finally 或者 using 块中执行清理逻辑，例如删除临时文件，那么可以在应用程序结束时显式等待后台线程汇合或触发信号发送结构来避免上述问题。<mark>无论采用哪一种方法，都需要指定一个超时时间来抛弃哪些无法按时结束的问题线程。否则用户只能通过 “任务管理器”（UNIX 用户则通过 kill 命令）来终止应用程序了。</mark></p><p>前台线程则不需要这样的处理，但是必须注意尽量避免出现线程无法结束的 bug。活跃的前台线程是导致应用程序无法正常退出的常见原因之一。</p><h3 id="线程的优先级"><a class="anchor" href="#线程的优先级">#</a> 线程的优先级</h3><h3 id="信号发送"><a class="anchor" href="#信号发送">#</a> 信号发送</h3><p>有时一个线程需要等待来自其他线程的通知，即所谓的信号发送。最简单的信号发送结构是 ManualResetEvent。调用 ManualResetEvent 的 WaitOne 方法可以阻塞当前线程，直到其他线程调用 Set “打开” 了信号。以下的示例启动了一个线程，并等待 ManualResetEvent。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token keyword">var</span></span> signal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ManualResetEvent</span> <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">new</span> <span class="token constructor-invocation class-name">Thread</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token string">"Waiting for signal..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> signal<span class="token punctuation">.</span><span class="token function">WaitOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> signal<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token string">"Got signal!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>Thread<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>signal<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "Open" the signal</span></pre></td></tr></table></figure><p>在 Set 调用后，信号发送结构仍然会保持 “打开” 状态，可以调用 Reset 方法再次将其 “关闭”。</p><h3 id="富客户端应用程序的线程"><a class="anchor" href="#富客户端应用程序的线程">#</a> 富客户端应用程序的线程</h3><p>如果想要在工作线程上更新 UI，就必须将请求发送给 UI 线程，这种技术称为封送（marshal）。实现该操作的底层方式有：</p><ul><li>在 WPF 钟，调用元素的 Dispatcher 对象的 BeginInvoke 或 Invoke 方法。</li><li>在 UWP 应用钟，可以调用 Dispatcher 对象的 RunAsync 或 Invoke 方法。</li><li>在 Windows Forms 应用中：调用控件的 BeginInvoke 或 Invoke 方法。</li></ul><p>使用 Invoke 可以从方法中直接得到返回值。如果不需要返回值，则可以使用 BeginInvoke/RunAsync，它们不会阻塞调用者，也不会造成死锁。</p><p>可以想象，当调用 Application.Run 时会执行如下的伪代码：</p><pre><code>while (!thisApplication.Ended)
&#123;
 wait for something to appear in message queue
 Got something: what kind of message is it?
 Keyboard/mouse message -&gt; fire an event handler
 User BeginInvoke message -&gt; execute delegate
 User Invoke message -&gt; execute delegate &amp; post result
&#125;
</code></pre><blockquote><p><strong>多个 UI 线程</strong></p><p>UI 线程也可以有多个，但是每一个线程要对应不同的窗口。最有代表性的场景是一个应用程序有多个顶级窗口，通常称之为单文档界面（Single Document Interface，SDI）应用程序，例如 Microsoft Word。每一个 SDI 窗口通常在任务栏上将自己显示为独立的应用程序，且对比其他的 SDI 窗口在功能上完全独立。为每一个窗口指定独立的 UI 线程，可以使每一个窗口都有更好的独立响应能力。</p></blockquote><h3 id="同步上下文"><a class="anchor" href="#同步上下文">#</a> 同步上下文</h3><p>System.ComponentModel 命名空间下有一个 SynchronizationContext 抽象类，它实现了一般性的线程封送功能。</p><h3 id="线程池"><a class="anchor" href="#线程池">#</a> 线程池</h3><p>每当启动一个线程，都需要一定的时间（几百微秒）来创建新的局部变量栈。而线程池通过预先创建一个可回收线程的池子来降低这个开销。线程池对开发高性能的并行程序与控制细粒度的并发都是非常必要的。它可以支持运行一些短暂的操作而不会收到线程启动开销的影响。</p><p>使用线程池中的线程时还需要考虑以下问题：</p><ul><li>线程池中线程的 Name 属性是无法进行设置的，因此会增加代码调试的难度（但可以在调试时使用 Visual Studio 的 Threads 窗口附加一个描述信息）。</li><li>线程池中的线程都是后台线程。</li><li>阻塞线程池中的线程将影响性能。</li></ul><p>我们可以任意设置线程池中线程的优先级，而当将线程归还线程池时其优先级会恢复为普通级别。</p><p>Thread.CurrentThread.IsThreadPoolThread 属性可用于确认当前运行的线程是否是一个线程池线程。</p><p><strong>进入线程池</strong></p><p>在线程池上运行代码的最简单方式是调用 Task.Run：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//	Task is in System.Threading.Tasks</span></pre></td></tr><tr><td data-num="2"></td><td><pre>Task<span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Hello from the thread pool"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>.NET Framework4.0 之前没有 Task 类，因可以调用 ThreadPool.QueueUserWorkItem：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>ThreadPool<span class="token punctuation">.</span><span class="token function">QueueUserWorkItem</span><span class="token punctuation">(</span>notUsed <span class="token operator">=></span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>以下使用场合均隐式使用了线程池：</p><ul><li><span class="exturl" data-url="aHR0cDovL0FTUC5ORVQ=">ASP.NET</span> Core 和 Web API 应用服务</li><li>System.Timers.Timer 和 System.Threading.Timer</li><li>第 23 章中介绍的并行编程结构</li><li>BackgroundWorker 类（已弃用）</li></ul><p><strong>线程池的整洁性</strong></p><p>线程池还有另外一个功能，那就是保证临时性的计算密集作业不会导致 CPU 超负荷。所谓超负荷指激活的线程数目多于 CPU 核心数量，导致操作系统必须按时间片执行线程调度。超负荷会影响性能，因为划分时间片需要大量的上下文切换开销，并可能使 CPU 的缓存失效。而这些都是现代处理器实现高性能的必要条件。</p><p>CLR 通过将任务进行排队，并控制任务启动数量来皮面线程池超负荷。它首先运行与硬件核心数量相同的并发任务，然后通过爬山算法调整并发数量，在一个方向上不停地调整工作负载。如果吞吐量有所改善，它就维持这个方向（反之则调换到另一个方向）。哪怕计算机上有多个进程活动，它仍能够运行在最优性能曲线上。</p><p>如果满足以下两个条件，则 CLR 的策略将得到最好的效果：</p><ul><li>大多数工作项的运行时间非常短暂（小于 250 毫秒或者理想情况下小于 100 毫秒）。这样 CLR 就会有大量的机会进行测量和调整。</li><li>线程池中不会出现大量以阻塞为主的作业。</li></ul><p>阻塞是非常麻烦的。因为它会让 CLR 错误地认为它占用了大量的 CPU。CLR 会检测并进行补偿（向线程池中注入更多的线程），但这可能使线程池受到后续超负荷的影响。此外，由于 CLR 会限制注入新线程的速度，因此这也会增加延迟，特别是应用程序生命周期的前期（在客户端操作系统上更加严重，因为在客户端操作系统需要更低的资源消耗）。</p><p>因此，如果希望尽可能提高 CPU 的利用率，则请务必保持线程池的整洁性。</p><h2 id="任务"><a class="anchor" href="#任务">#</a> 任务</h2><p>线程是创建并发的底层工具，因此它有一定的局限性。特别是：</p><ul><li>虽然在线程启动时不难向其中传递数据，但是当线程 Join 后却难以从中得到 “返回值”。通常不得不创建一些共享字段（来得到 “返回值”）。此外，捕获和处理线程中操作抛出的异常也是非常麻烦的。</li><li>在线程完成后，就无法再次启动它，相反只能够将其 Join（并阻塞当前操作线程）。</li></ul><p>这些局限性会影响颗粒度并发性的实现。换言之，这种方式难以将小的并发组合成大的并发操作（这对于异步编程而言非常重要），并会增加手动同步处理（例如使用锁、信号发送等）的依赖，而且很容易造成问题。</p><p>Task 类可以解决所有这些问题。与线程相比，Task 是一个更高级的抽象概念，它代表了一个并发操作，而该操作并不一定以带线程完成。Task 是可以组合的（可以将它们通过延续（continuation）操作串联在一起）。我们可以使用线程池减少启动延迟，也可以通过 TaskCompletionSource 采用回调的方式避免多个线程同时等待 I/O 密集型操作。</p><p>Task 类是 Framework4.0 时作为并行编程库的组成部分引入的。然而它们后来经历了许多改进（通过使用等待器（awaiter）），从而在常见的并发场景中发挥了越来越大的作用。Task 类也是 C# 异步功能的基础类型。</p><h3 id="启动任务"><a class="anchor" href="#启动任务">#</a> 启动任务</h3><p>启动一个基于线程的 Task 的最简单方式是使用 Task.Run（Task 类位于 System.Threading.Tasks 命名空间）静态方法。调用时只需传入一个 Action 委托：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>Task<span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Foo"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>任务默认使用线程池中的线程（它们都是后台线程）。这意味着当主线程结束时，所有的任务也会随之停止。因此，要在控制台应用程序中运行这些例子，必须在启动任务后阻塞主线程（例如在任务对象上调用 Wait，或者调用 Console.WriteLine 方法）：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> Task<span class="token punctuation">.</span>Run <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token string">"Foo"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>采用这种方式调用 Task.Run 的效果与限免启动线程的方式很相似（唯一的不同是没有隐式使用线程池）：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">new</span> <span class="token constructor-invocation class-name">Thread</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token string">"Foo"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>Task.Run 会返回一个 Task 对象，它可以用于监控任务的执行过程。这一点与 Thread 对象不同（注意，我们没有在 Task.Run 之后调用 Start，因为 Task.Run 创建的任务是 “热” 任务；相反，如果要创建 “冷” 任务，则必须调用 Task 的构造器，但是这种方式在实践中很少见到。</p><p><strong>Wait 方法</strong></p><p>调用 Task 的 Wait 方法可以阻塞当前方法，直到任务完成，这和调用线程对象的 Join 方法类似：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Task</span> task <span class="token operator">=</span> Task<span class="token punctuation">.</span>Run <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> Thread<span class="token punctuation">.</span>Sleep <span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token string">"Foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>task<span class="token punctuation">.</span>IsCompleted<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// False</span></pre></td></tr><tr><td data-num="7"></td><td><pre>task<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Blocks until task is complete</span></pre></td></tr></table></figure><p>可以在 Wait 中指定一个超时时间和取消令牌（可选）来提前终止等待状态。</p><p><strong>长任务</strong></p><p>默认情况下，CLR 会将任务运行在线程池线程上，这种线程非常适合执行短小的计算密集的任务。如果要执行长时间阻塞的操作，则可以按照以下方式避免使用线程池线程：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Task</span> task <span class="token operator">=</span> Task<span class="token punctuation">.</span>Factory<span class="token punctuation">.</span>StartNew <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="2"></td><td><pre> TaskCreationOptions<span class="token punctuation">.</span>LongRunning<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在线程池上运行一个长时间执行的任务并不会造成问题；但是如果要并行运行多个长时间运行的任务（特别是会造成阻塞的任务），则会对性能造成影响。在这种情况下，相比于使用 TaskCreationOptions.LongRunning 而言，更好的方案是：</p><ul><li>如果运行的是 I/O 密集型任务，则使用 TaskCompletionSource 和异步函数通过回调函数而非使用线程实现并发性。</li><li>如果任务是计算密集型，则使用生产者 / 消费者队列可以控制这些任务造成的并发数量，避免出现线程和进程饥饿问题。</li></ul><h3 id="返回值"><a class="anchor" href="#返回值">#</a> 返回值</h3><p>Task 有一个泛型子类 Task&lt;TResult&gt;，它允许任务返回一个值。如果在调用 Task.Run 时传入一个 Func&lt;TResult &gt; 委托（或者兼容的 Lambda 表达式）替代 Action 就可以获得一个 Task&lt;TResult &gt; 对象：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Task<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span> task <span class="token operator">=</span> Task<span class="token punctuation">.</span>Run <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token string">"Foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// ...</span></pre></td></tr></table></figure><p>此后，通过查询 Result 属性就可以获得任务的返回值。如果当前任务还没有执行完毕，调用该属性会阻塞当前线程，直到任务结束。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token keyword">int</span></span> result <span class="token operator">=</span> task<span class="token punctuation">.</span>Result<span class="token punctuation">;</span> <span class="token comment">// Blocks if not already finished</span></pre></td></tr><tr><td data-num="2"></td><td><pre>Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span></pre></td></tr></table></figure><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Task<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span> primeNumberTask <span class="token operator">=</span> Task<span class="token punctuation">.</span>Run <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span></pre></td></tr><tr><td data-num="2"></td><td><pre> Enumerable<span class="token punctuation">.</span>Range <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3000000</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Count <span class="token punctuation">(</span>n <span class="token operator">=></span></pre></td></tr><tr><td data-num="3"></td><td><pre> Enumerable<span class="token punctuation">.</span>Range <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>Math<span class="token punctuation">.</span><span class="token function">Sqrt</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>All <span class="token punctuation">(</span>i <span class="token operator">=></span> n <span class="token operator">%</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token string">"Task running..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token string">"The answer is "</span> <span class="token operator">+</span> primeNumberTask<span class="token punctuation">.</span>Result<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>可以将 Task&lt;TResult&gt; 理解为一个 “未来值”，它封装了 Result 并将在以后生效。</p><h3 id="异常"><a class="anchor" href="#异常">#</a> 异常</h3><p>任务可以方便地传播异常，这和线程是截然不同的。因此，如果任务中的代码抛出一个未处理异常（换言之，如果任务出错），那么调用 Wait () 或者访问 Task&lt;TResult&gt; 的 Result 属性时，该异常就会被重新抛出：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Start a Task that throws a NullReferenceException:</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Task</span> task <span class="token operator">=</span> Task<span class="token punctuation">.</span>Run <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span> <span class="token keyword">throw</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">try</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> task<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">AggregateException</span> aex<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>aex<span class="token punctuation">.</span>InnerException <span class="token keyword">is</span> <span class="token class-name">NullReferenceException</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token string">"Null!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">else</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">throw</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>(为了适应并行编程场景，CLR 会将异常包装为一个 AggregateException)</p><p>使用 Task 的 IsFaulted 和 IsCanceled 属性可以在不抛出异常的情况下检测出错的任务。如果两个属性都返回了 false，则说明没有错误发生；如果 IsCanceled 为 true，则说明任务抛出了 OperationCanceledException；如果 IsFaulted 为 true，则说明任务抛出了其他类型的异常，通过 Exception 属性可以了解该异常的信息。</p><p><strong>异常和自治任务</strong></p><p>自治任务指那些可以 “运行并忘记” 的任务（这些任务不需要调用 Wait () 或访问其 Result 属性，也不需要进行任务的延续）。对于自治任务，最好在任务代码中显式声明异常处理代码，防止出现和线程类似的难以察觉的错误。</p><p>如果异常仅导致无法获得一些不重要的结果，那么忽略异常是最好的方式。</p><p>如果异常反应了程序的重大缺陷，就绝不能忽略异常。</p><p>使用静态时间 TaskScheduler.UnobservedTaskException 可以在全局范围订阅未观测的异常。处理这个事件并将错误记录在日志中，是一个有效的处理异常的方式。</p><p>未观测异常之间也存在一些细微的差异：</p><ul><li>如果在等待任务时设置了超时时间，则在超时时间后发生的错误将产生未观测异常。</li><li>在错误发生后，如果检查任务的 Exception 属性，则该异常就成了已观测到的异常。</li></ul><h3 id="延续"><a class="anchor" href="#延续">#</a> 延续</h3><p>延续会告知任务在完全后继续执行后续的操作。延续通常由回调方法实现操作完成后执行。给任务附加延续的方法有两种。第一种方法尤其重要，因为 C# 的异步功能正是使用了这种方法。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Task<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span> primeNumberTask <span class="token operator">=</span> Task<span class="token punctuation">.</span>Run <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span></pre></td></tr><tr><td data-num="2"></td><td><pre> Enumerable<span class="token punctuation">.</span>Range <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3000000</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Count <span class="token punctuation">(</span>n <span class="token operator">=></span></pre></td></tr><tr><td data-num="3"></td><td><pre> Enumerable<span class="token punctuation">.</span>Range <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>Math<span class="token punctuation">.</span><span class="token function">Sqrt</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>All <span class="token punctuation">(</span>i <span class="token operator">=></span> n <span class="token operator">%</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token class-name"><span class="token keyword">var</span></span> awaiter <span class="token operator">=</span> primeNumberTask<span class="token punctuation">.</span><span class="token function">GetAwaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>awaiter<span class="token punctuation">.</span>OnCompleted <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token class-name"><span class="token keyword">int</span></span> result <span class="token operator">=</span> awaiter<span class="token punctuation">.</span><span class="token function">GetResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Writes result</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>调用任务的 GetAwaiter 方法将返回一个 awaiter 对象。这个对象的 OnCompleted 方法告直先导任务（primeNumberTask）当它执行完毕（或者出现错误）时调用一个委托。将延续附加到一个已执行完毕的任务上是完全没有问题的，此时，延续的逻辑将会立即执行。</p><p>等待器（awaiter）可以是任意暴露了 OnCompleted 和 GetResult 方法以及 IsCompleted 属性的对象。它不需要特定的接口或者继承特定基类来同一这些成员。</p><p>如果先导任务出现错误，则延续代码调用 awaiter.GetResult () 时会重新抛出异常。当然也可以访问先导任务的 result 属性而不是调用 GetResult 方法。但如果先导任务失败，调用 GetResult 方法就可以直接得到原始的异常，而不是包装后的 Aggregate-Exception。</p><p>对于非泛型任务，GetResult 的返回值为 void，这个函数的用途完全是为了重新抛出异常。</p><p>如果提供了同步上下文，则 OnCompleted 就会自动捕获它，并将延续提交到这个上下文中。如果不希望这么做，可以使用 ConfigureAwait 方法来避免这种行为：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token keyword">var</span></span> awaiter <span class="token operator">=</span> primeNumberTask<span class="token punctuation">.</span>ConfigureAwait <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetAwaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>如果并未提供任何同步上下文，或者调用了 COnfigureAwait (false)，延续代码一般会运行在先导任务运行的线程上，从而避免不必要的开销。</p><p>另一种附加延续的方式是调用任务对象的 ContinueWith 方法：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>primeNumberTask<span class="token punctuation">.</span>ContinueWith <span class="token punctuation">(</span>antecedent <span class="token operator">=></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name"><span class="token keyword">int</span></span> result <span class="token operator">=</span> antecedent<span class="token punctuation">.</span>Result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Writes 123</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>ContinueWith 方法本身会返回一个 Task 对象，因此它非常适用于添加更多的延续。然而，如果任务出现错误，我们必须直接处理 AggregateException；如果需要将延续封送到 UI 应用程序上还需要书写额外的代码。而在非 UI 上下文中，若希望延续任务和先导任务执行在同一个线程上，还需要指定 TaskContinuationOptions.ExecuteSynchronously。否则，它就会去请求线程池。ContinueWith 更适用于并行编程场景。</p><h3 id="taskcompletionsource类"><a class="anchor" href="#taskcompletionsource类">#</a> TaskCompletionSource 类</h3><p>前面介绍了如何使用 Task.Run 创建一个任务，并在线程池线程（或者非线程池线程）上运行特定委托。而另一种创建任务的方法是使用 TaskCompletionSource。</p><p>它不但可以利用任务的所有优点（能够传递返回值、异常或延续），而且不需要在操作执行期间阻塞线程。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TaskCompletionSource<span class="token punctuation">&lt;</span>TResult<span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> SetResult <span class="token punctuation">(</span><span class="token class-name">TResult</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> SetException <span class="token punctuation">(</span><span class="token class-name">Exception</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SetCanceled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">bool</span></span> TrySetResult <span class="token punctuation">(</span><span class="token class-name">TResult</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">bool</span></span> TrySetException <span class="token punctuation">(</span><span class="token class-name">Exception</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">bool</span></span> <span class="token function">TrySetCanceled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">bool</span></span> TrySetCanceled <span class="token punctuation">(</span><span class="token class-name">CancellationToken</span> cancellationToken<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>下面的例子会在等待 5 秒钟后输出 42：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token keyword">var</span></span> tcs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">TaskCompletionSource<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">new</span> <span class="token constructor-invocation class-name">Thread</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span> Thread<span class="token punctuation">.</span>Sleep <span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> tcs<span class="token punctuation">.</span>SetResult <span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token punctuation">&#123;</span> IsBackground <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token class-name">Task<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span> task <span class="token operator">=</span> tcs<span class="token punctuation">.</span>Task<span class="token punctuation">;</span> <span class="token comment">// Our "slave" task.</span></pre></td></tr><tr><td data-num="6"></td><td><pre>Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>task<span class="token punctuation">.</span>Result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 42</span></pre></td></tr></table></figure><p>使用 TaskCompletionSource，我们就可以编写自己的 Run 方法了：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token return-type class-name">Task<span class="token punctuation">&lt;</span>TResult<span class="token punctuation">></span></span> <span class="token generic-method"><span class="token function">Run</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>TResult<span class="token punctuation">></span></span></span> <span class="token punctuation">(</span><span class="token class-name">Func<span class="token punctuation">&lt;</span>TResult<span class="token punctuation">></span></span> function<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> tcs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">TaskCompletionSource<span class="token punctuation">&lt;</span>TResult<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Thread</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span> tcs<span class="token punctuation">.</span>SetResult <span class="token punctuation">(</span><span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> tcs<span class="token punctuation">.</span>SetException <span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">return</span> tcs<span class="token punctuation">.</span>Task<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token class-name">Task<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span> task <span class="token operator">=</span> Run <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span> Thread<span class="token punctuation">.</span>Sleep <span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>调用该方法和调用 Task.Factory.StartNew 并传递 TaskCreationOptions.LongRunning 参数是等价的。它们都会请求一个非线程池线程。</p><p>TaskCompletionSource 的真正作用是创建不绑定线程的任务。我们可以使用 Timer 类，由 CLR（进而由操作系统）在 x 毫秒后触发一个事件，而无需使用线程：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token return-type class-name">Task<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span> <span class="token function">GetAnswerToLife</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> tcs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">TaskCompletionSource<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// Create a timer that fires once in 5000 ms:</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> timer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">System<span class="token punctuation">.</span>Timers<span class="token punctuation">.</span>Timer</span> <span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> AutoReset <span class="token operator">=</span> <span class="token boolean">false</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> timer<span class="token punctuation">.</span>Elapsed <span class="token operator">+=</span> <span class="token keyword">delegate</span> <span class="token punctuation">&#123;</span> timer<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> tcs<span class="token punctuation">.</span>SetResult <span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> timer<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">return</span> tcs<span class="token punctuation">.</span>Task<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>以上代码会返回一个在 5 秒钟后完成的任务，其结果为 42。通过给任务附加延续，就可以在不阻塞任何线程的情况下打印出这个结果：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token keyword">var</span></span> awaiter <span class="token operator">=</span> <span class="token function">GetAnswerToLife</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetAwaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>awaiter<span class="token punctuation">.</span>OnCompleted <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>awaiter<span class="token punctuation">.</span><span class="token function">GetResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>TaskCompletionSource 不需要使用线程，意味着只有当延续启动时（5 秒钟后）才会创建线程。</p><p>如果请求的速度超过了处理的速度，那么线程池就会进行排队，并以最优的 CPU 并行原则处理这些请求。这种方法最适合处理执行时间短暂的线程密集的作业，而本例正符合这个特点。</p><h3 id="taskdelay方法"><a class="anchor" href="#taskdelay方法">#</a> Task.Delay 方法</h3><p>Delay 实际上也是 Task 类的一个静态方法：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>Task<span class="token punctuation">.</span>Delay <span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetAwaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>OnCompleted <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// or:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>Task<span class="token punctuation">.</span>Delay <span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ContinueWith <span class="token punctuation">(</span>ant <span class="token operator">=></span> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>Task.Delay 是 Thread.Sleep 的异步版本。</p><h2 id="异步原则"><a class="anchor" href="#异步原则">#</a> 异步原则</h2><h3 id="同步操作与异步操作"><a class="anchor" href="#同步操作与异步操作">#</a> 同步操作与异步操作</h3><p>同步操作先完成其工作再返回调用者。</p><p>异步操作的大部分工作则是再返回给调用者之后完成的。</p><p>我们平时编写和调用的大多数方法都是同步方法，而异步方法则并不常见，并且异步调用需要并发创建，因为其工作对于调用者来说是并行的。异步方法通常都会非常迅速（甚至会立即）返回给调用者，因此它们也称为非阻塞方法。</p><p>到目前为止，我们学习的异步方法都是通用方法：</p><ul><li>Thread.Start</li><li>Task.Run</li><li>给任务附加延续的方法</li></ul><h3 id="什么是异步编程"><a class="anchor" href="#什么是异步编程">#</a> 什么是异步编程</h3><p>异步编程的原则是以异步的方式编写运行时间很长（或者可能很长）的函数。这和编写长时间运行的函数的传统同步方法正好相反。它会在新的线程或者任务上调用这些函数，从而实现所需的并发性。</p><p>异步方法的不同点在于并发性是在长时间运行的方法内启动的，而不是从这个方法外启动的。这样做有两个优点：</p><ul><li>I/O 密集的并发性的实现不需要绑定线程，因此可以提高可伸缩性和效率。</li><li>富客户端应用程序可以减少工作线程的代码，因此可以简化线程安全性的实现。</li></ul><p>在传统的同步调用图中，如果出现一个运行时间很长的操作，就必须将整个调用图转移到一个工作线程中以保持 UI 的响应性。因此，最终会得到一个跨越很多方法的并发操作（细粒度并发性），此时需要考虑途中每一个方法的线程安全性。</p><p>使用异步调用图，就可以在真正需要的时候再启动线程。这种方式产生细粒度的并发性，即由一系列小的并发操作组成，而在这些操作之间可插入 UI 线程的执行过程。</p><p>为了利用这一点，I/O 和计算密集型操作都应当采用异步方式实现。常用的经验法则是任何超过 50 毫秒的响应都用异步的方式处理。</p><h3 id="异步编程与延续"><a class="anchor" href="#异步编程与延续">#</a> 异步编程与延续</h3><p>任务非常适合进行异步编程，因为它支持延续，这对异步性是非常必要的。</p><h2 id="c的异步函数"><a class="anchor" href="#c的异步函数">#</a> C# 的异步函数</h2><p>async 和 await 关键字令我们用同步的代码风格编写异步代码，极大地去除了异步编程的复杂性。</p><h3 id="等待"><a class="anchor" href="#等待">#</a> 等待</h3><p>await 关键字可以简单地附加延续。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token keyword">var</span></span> result <span class="token operator">=</span> <span class="token keyword">await</span> expression<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">statement</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>编译器会将上述代码转换为下面具有相同功能的代码：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token keyword">var</span></span> awaiter <span class="token operator">=</span> expression<span class="token punctuation">.</span><span class="token function">GetAwaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>awaiter<span class="token punctuation">.</span>OnCompleted <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> result <span class="token operator">=</span> awaiter<span class="token punctuation">.</span><span class="token function">GetResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token function">statement</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>我们再来回顾一下前面用于计算素数个数的异步方法：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token return-type class-name">Task<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span> GetPrimesCountAsync <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> start<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> count<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">return</span> Task<span class="token punctuation">.</span>Run <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span></pre></td></tr><tr><td data-num="4"></td><td><pre> ParallelEnumerable<span class="token punctuation">.</span>Range <span class="token punctuation">(</span>start<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">.</span>Count <span class="token punctuation">(</span>n <span class="token operator">=></span></pre></td></tr><tr><td data-num="5"></td><td><pre> Enumerable<span class="token punctuation">.</span>Range <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>Math<span class="token punctuation">.</span><span class="token function">Sqrt</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>All <span class="token punctuation">(</span>i <span class="token operator">=></span> n <span class="token operator">%</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>使用 await 关键字，就可以调用该方法了：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token keyword">int</span></span> result <span class="token operator">=</span> <span class="token keyword">await</span> GetPrimesCountAsync <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>为了完成编译，必须在上述代码所在方法上添加 async 修饰符：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">async</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">DisplayPrimesCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name"><span class="token keyword">int</span></span> result <span class="token operator">=</span> <span class="token keyword">await</span> GetPrimesCountAsync <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>async 修饰符只支持返回类型为 void 以及 Task 或 Task&lt;TResult&gt; 的方法（或 Lambda 表达式）。</p><p>async 修饰符和 unsafe 修饰符类似，都不会对方法签名或者公共元数据产生影响。它只影响方法内部的实现细节，因此再接口上添加 async 是没有意义的。但是这种方式也是合法的。</p><p>添加了 async 修饰符的方法称为异步函数，因为通常它们本身也是异步的。</p><p>当遇到 await 表达式时，通常情况下执行过程会返回到调用者上，就像是迭代器中的 yield return 一样。但是，运行时再返回之前会在等待的任务上附加一个延续，保证任务结束时执行点会跳回到方法中，并继续执行剩余的代码。如果任务出错，则会重新抛出异常；如果顺利结束，则用返回值为 await 表达式赋值。</p><p>awaiter 等待的表达式通常情况下是一个任务。但实际上，只要该对象拥有 GetAwaiter 方法，且该方法的返回值为等待器（这个对象需要实现 INotifyCompletion.Oncompleted 方法，具有返回恰当类型的 GetResult 方法和一个 bool 类型的 IsCompleted 属性），则编译器都可以接受。</p><p>注意，上例的 await 表达式返回一个 int 值。因为该表达式的类型为 Task&lt;int&gt;（其 GetAwaiter ().GetResult () 方法返回值为 int）。</p><p>等待非泛型的任务也是合法的，它会生成一个 void 表达式：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">await</span> Task<span class="token punctuation">.</span>Delay <span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token string">"Five seconds passed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>获取本地状态</strong></p><p>await 表达式的最大优势在于它几乎可以出现在代码的任意位置。具体来讲，await 表达式可以在任何（异步函数的）表达式中出现，但不能出现在 lock 表达式或者 unsafe 上下文中。</p><p><strong>UI 上的等待处理</strong></p><p><strong>与粗粒度并发的比较</strong></p><h3 id="编写异步函数"><a class="anchor" href="#编写异步函数">#</a> 编写异步函数</h3><p>要编写异步函数，可将返回类型由 void 更改为 Task。这样方法本身就可以进行异步调用（并且是可等待的）。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">PrintAnswerToLife</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// We can return Task instead of void</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">await</span> Task<span class="token punctuation">.</span>Delay <span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name"><span class="token keyword">int</span></span> answer <span class="token operator">=</span> <span class="token number">21</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>answer<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>需要注意的是方法体内并不需要显示返回一个任务。编译器会负责生成 Task，并在方法完成之前或出现未处理的异常时触发 Task。这样就很容易创建异步调用链：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">Go</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">await</span> <span class="token function">PrintAnswerToLife</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token string">"Done"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>编译器会展开异步函数，将任务对象返回，并使用 TaskCompletionSource 创建一个新的任务对象。</p><p>除了这些细微的区别外，我们还可以将 PrintAnswerToLife 方法展开为如下的功能等价实现：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token return-type class-name">Task</span> <span class="token function">PrintAnswerToLife</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> tcs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">TaskCompletionSource<span class="token punctuation">&lt;</span><span class="token keyword">object</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> awaiter <span class="token operator">=</span> Task<span class="token punctuation">.</span>Delay <span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetAwaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> awaiter<span class="token punctuation">.</span>OnCompleted <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">try</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> awaiter<span class="token punctuation">.</span><span class="token function">GetResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Re-throw any exceptions</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token class-name"><span class="token keyword">int</span></span> answer <span class="token operator">=</span> <span class="token number">21</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>answer<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> tcs<span class="token punctuation">.</span>SetResult <span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> tcs<span class="token punctuation">.</span>SetException <span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token keyword">return</span> tcs<span class="token punctuation">.</span>Task<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在富客户端场景下，若执行点并没有在 UI 线程上，则它会返回 UI 线程。在其他场景下，它会继续在延续所有的线程上运行。因此，不同于 UI 线程初始化后的初次回弹，第二种情况下跳出异步调用图不会发生任何延迟开销。</p><p><strong>返回 Task&lt;TResult&gt;</strong></p><p>异步函数中若方法体返回 TResult，则函数的返回值为 Task&lt;TResult&gt;：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">async</span> <span class="token return-type class-name">Task<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span> <span class="token function">GetAnswerToLife</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">await</span> Task<span class="token punctuation">.</span>Delay <span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name"><span class="token keyword">int</span></span> answer <span class="token operator">=</span> <span class="token number">21</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">return</span> answer<span class="token punctuation">;</span> <span class="token comment">// Method has return type Task&lt;int> we return int</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在实现内部，这段代码在激活 TaskCompletionSource 时会传递一个值而不是 null。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">Go</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">await</span> <span class="token function">PrintAnswerToLife</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token string">"Done"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">PrintAnswerToLife</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token class-name"><span class="token keyword">int</span></span> answer <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">GetAnswerToLife</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>answer<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">async</span> <span class="token return-type class-name">Task<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span> <span class="token function">GetAnswerToLife</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">await</span> Task<span class="token punctuation">.</span>Delay <span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token class-name"><span class="token keyword">int</span></span> answer <span class="token operator">=</span> <span class="token number">21</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token keyword">return</span> answer<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>使用 C# 异步函数进行程序设计的基本原则：</p><ol><li>首先以同步方法实现方法。</li><li>其次，将同步方法调用改为异步方法调用，并使用 await。</li><li>除 “最顶层级” 的方法（通常是 UI 控件事件处理器）外，将异步方法的返回类型修改为 Task 或者 Task&lt;TResult&gt;，使其成为可等待的方法。</li></ol><p>由于编译器能够为异步函数创建任务，因此，除非要进行 I/O 密集并发的底层编程（这种情形是比较少见的），一般情况下无需显式实例化 TaskCompletionSource 类型。对于计算密集型的并发方法，则可以使用 Task.Run 创建任务。</p><p><strong>执行异步调用图</strong></p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">Go</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> task <span class="token operator">=</span> <span class="token function">PrintAnswerToLife</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">await</span> task<span class="token punctuation">;</span> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token string">"Done"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">PrintAnswerToLife</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> task <span class="token operator">=</span> <span class="token function">GetAnswerToLife</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token class-name"><span class="token keyword">int</span></span> answer <span class="token operator">=</span> <span class="token keyword">await</span> task<span class="token punctuation">;</span> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>answer<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">async</span> <span class="token return-type class-name">Task<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span> <span class="token function">GetAnswerToLife</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> task <span class="token operator">=</span> Task<span class="token punctuation">.</span>Delay <span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">await</span> task<span class="token punctuation">;</span> <span class="token class-name"><span class="token keyword">int</span></span> answer <span class="token operator">=</span> <span class="token number">21</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token keyword">return</span> answer<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>由于和同步调用采用了同一种模式，因此整个执行流和之前的同步调用图是完全匹配的。我们在每一个异步方法调用后都会立即 await，这样就形成了一个无并发（无重叠执行）的调用图。每一个 await 表达式都在执行过程中形成了一个 “缺口”，而之后的程序都可以在缺口处恢复执行。</p><p><strong>并行性</strong></p><p>调用异步方法但不等待就可以令异步方法和后续代码并行执行。</p><p>也可以使用相同的法则以并行方式执行两个异步操作：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token keyword">var</span></span> task1 <span class="token operator">=</span> <span class="token function">PrintAnswerToLife</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name"><span class="token keyword">var</span></span> task2 <span class="token operator">=</span> <span class="token function">PrintAnswerToLife</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">await</span> task1<span class="token punctuation">;</span> <span class="token keyword">await</span> task2<span class="token punctuation">;</span></pre></td></tr></table></figure><p>通过 await 两个任务结束并行执行。后续将会介绍如何使用 WhenAll 任务组合器来优化这个模式。</p><p>在伪并发操作下，唯一能够抢占的位置就是 await 语句。这就使得我们可以定义一个共享字段_x，并在 GetAnswerToLife 中无须任何锁保护就能够对其进行自增操作：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">async</span> <span class="token return-type class-name">Task<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span> <span class="token function">GetAnswerToLife</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> _x<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">await</span> Task<span class="token punctuation">.</span>Delay <span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">return</span> <span class="token number">21</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>但是我们无法假定_x 在 await 前后均保持相同的值。</p><h3 id="异步lambda表达式"><a class="anchor" href="#异步lambda表达式">#</a> 异步 Lambda 表达式</h3><p>一般的具备名称的方法都可以成为异步方法：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">NamedMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">await</span> Task<span class="token punctuation">.</span>Delay <span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token string">"Foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>而只要添加了 async 关键字，匿名的方法（Lambda 表达式及匿名方法）也可以异步执行：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Func<span class="token punctuation">&lt;</span>Task<span class="token punctuation">></span></span> unnamed <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">await</span> Task<span class="token punctuation">.</span>Delay <span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token string">"Foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>它们可以采用相同的方式进行调用和等待：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">await</span> <span class="token function">NamedMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">await</span> <span class="token function">unnamed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>异步 Lambda 表达式可以附加到事件处理器：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>myButton<span class="token punctuation">.</span>Click <span class="token operator">+=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span>sender<span class="token punctuation">,</span> args<span class="token punctuation">)</span> <span class="token operator">=></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">await</span> Task<span class="token punctuation">.</span>Delay <span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> myButton<span class="token punctuation">.</span>Content <span class="token operator">=</span> <span class="token string">"Done"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>异步的 Lambda 表达式也可以返回 Task&lt;TResult&gt;：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Func<span class="token punctuation">&lt;</span>Task<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span><span class="token punctuation">></span></span> unnamed <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">await</span> Task<span class="token punctuation">.</span>Delay <span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">return</span> <span class="token number">123</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token class-name"><span class="token keyword">int</span></span> answer <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">unnamed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="异步流c-8"><a class="anchor" href="#异步流c-8">#</a> 异步流（C# 8）</h3><p>在 C# 8 之前，我们可以使用 yield return 实现迭代器，也可以用 await 书写异步函数。但是无法将两者结合，实现一个可以等待的迭代器，即一种异步生成元素的方法。C# 8 引入异步流解决了这个问题。</p><h3 id="winrt中的异步方法"><a class="anchor" href="#winrt中的异步方法">#</a> WinRT 中的异步方法</h3><h3 id="异步与同步上下文"><a class="anchor" href="#异步与同步上下文">#</a> 异步与同步上下文</h3><h3 id="优化"><a class="anchor" href="#优化">#</a> 优化</h3><h2 id="异步模式"><a class="anchor" href="#异步模式">#</a> 异步模式</h2><h3 id="取消操作"><a class="anchor" href="#取消操作">#</a> 取消操作</h3><p>通常，并发操作在启动后必须能够取消（可能是出于用户的请求）。使用取消标志即可以轻松实现这个功能。例如，可以将该功能封装为以下类：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">CancellationToken</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">bool</span></span> IsCancellationRequested <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">private</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> IsCancellationRequested <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ThrowIfCancellationRequested</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>IsCancellationRequested<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">OperationCanceledException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>然后，再按照下面的方式编写一个可取消的异步方法：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">async</span> <span class="token return-type class-name">Task</span> Foo <span class="token punctuation">(</span><span class="token class-name">CancellationToken</span> cancellationToken<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">await</span> Task<span class="token punctuation">.</span>Delay <span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> cancellationToken<span class="token punctuation">.</span><span class="token function">ThrowIfCancellationRequested</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>将取消令牌传递给 Foo 方法后，调用者只需调用取消令牌上的 Cancel 方法即可。该方法将 IsCancellationRequested 设置为 true。Foo 随后会因此而失败，并抛出 Operation-CanceledException（该异常正是为这种情形而设计的，它定义于 System 命名空间中）。</p><p>这种模式在不考虑线程安全性（需要在读 / 写 IsCancellationRequested 时添加锁操作）时是很高效的。CLR 提供了一个实现类似功能的类型 CancellationToken。然而 Cancel 方法却未定义在 CancellationToken 类上，而是定义在了另一个 CancellationTokenSource 类上。这种分离具有一定的安全性：即只能通过 CancellationToken 对象的方法检查取消操作，而不能启动取消操作。</p><p>要获得一个取消令牌，首先要实例化一个 CancellationTokenSource：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token keyword">var</span></span> cancelSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">CancellationTokenSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>它有一个 Token 属性，可以返回一个 CancellationToken。因此，可以按照以下方式调用 Foo 方法：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token keyword">var</span></span> cancelSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">CancellationTokenSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Task</span> foo <span class="token operator">=</span> Foo <span class="token punctuation">(</span>cancelSource<span class="token punctuation">.</span>Token<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">(</span>some <span class="token class-name">time</span> later<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>cancelSource<span class="token punctuation">.</span><span class="token function">Cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在 CLR 中，大部分异步方法都支持取消令牌，其中包括 Delay。如果修改 Foo，使其将令牌传递到 Delay 方法中，那么请求到达后任务会马上停止（而不会等到一秒钟以后）：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">async</span> <span class="token return-type class-name">Task</span> Foo <span class="token punctuation">(</span><span class="token class-name">CancellationToken</span> cancellationToken<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">await</span> Task<span class="token punctuation">.</span>Delay <span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> cancellationToken<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>注意，我们无须调用 ThrowIfCancellationRequested 方法，因为 Task.Delay 方法中已经包含了该操作。取消令牌会顺利地沿着调用栈向下进行传递（就像取消请求会通过异常的方式沿着调用栈向上级联传播一样）。</p><h3 id="进度报告"><a class="anchor" href="#进度报告">#</a> 进度报告</h3><p>CLR 拥有一对专门针对进度报告的类型：IProgress&lt;T&gt; 接口和 Progress&lt;T &gt; 类（实现了 IProgress&lt;T &gt; 接口）。它们作用是包装一个委托，以便使 UI 应用程序可以通过同步上下文安全地报告进度。</p><h3 id="基于任务的异步模式"><a class="anchor" href="#基于任务的异步模式">#</a> 基于任务的异步模式</h3><p>.NET Core 提供了大量的返回任务的异步方法，因此它们都可以 await（主要和 I/O 相关）。大部分方法采用了一种基于任务的异步模式（Task-based Asynchronous Pattern，TAP），该模式是到目前为止最合理的一种方式。一个 TAP 方法：</p><ul><li>返回一个 “热”（正在运行中的）Task 或者 Task&lt;TResult&gt;。</li><li>拥有 Async 后缀（除非是一些特殊情况，例如任务组合器）。</li><li>若支持取消操作或进度报告，则需要拥有接受 CancellationToken 或者 IProgress&lt;T&gt; 的重载。</li><li>快速返回调用者（初始同步阶段非常短小）。</li><li>对于 I/O 密集型任务不绑定线程。</li></ul><p>如前面所述，TAP 方法易于通过 C# 的异步函数实现。</p><h3 id="任务组合器"><a class="anchor" href="#任务组合器">#</a> 任务组合器</h3><p>同一协议的异步函数（它们均返回任务）的优点之一是可以使用并编写任务组合器，即一些和任务的具体用途无关的可以将任务进行组合的函数。</p><p>CLR 包含两种任务组合器：Task.WhenAny 和 Task.WhenAll。在介绍它们之前，我们先定义如下方法：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">async</span> <span class="token return-type class-name">Task<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span> <span class="token function">Delay1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">await</span> Task<span class="token punctuation">.</span>Delay <span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">async</span> <span class="token return-type class-name">Task<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span> <span class="token function">Delay2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">await</span> Task<span class="token punctuation">.</span>Delay <span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">async</span> <span class="token return-type class-name">Task<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span> <span class="token function">Delay3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">await</span> Task<span class="token punctuation">.</span>Delay <span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>WhenAny</strong></p><p>Task.WhenAny 方法会在任务组中的任意一个任务完成时返回这个任务。例如，以下任务会在一秒钟内完成：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Task<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span> winningTask <span class="token operator">=</span> <span class="token keyword">await</span> Task<span class="token punctuation">.</span>WhenAny <span class="token punctuation">(</span><span class="token function">Delay1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Delay2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Delay3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token string">"Done"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>winningTask<span class="token punctuation">.</span>Result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//</span></pre></td></tr></table></figure><p>我们等待的 Task.WhenAny 返回的任务将会是所有任务中第一个完成的任务。上述示例是非阻塞的（包括最后访问 Result 属性，因为那个时候任务已经完成了）。但即便如此也建议对 winningTask 进行 await 操作：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token keyword">await</span> winningTask<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span></pre></td></tr></table></figure><p>因为这样做的话，任何重新抛出的异常就不需要包装在 AggregateException 异常中了。</p><p>事实上，我们可以直接在一次操作中进行所有的等待操作：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token keyword">int</span></span> answer <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">await</span> Task<span class="token punctuation">.</span>WhenAny <span class="token punctuation">(</span><span class="token function">Delay1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Delay2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Delay3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>如果在这个过程中，有一个并非第一个结束的任务发生了失败，除非我们等待了这个任务（或查询相应任务的 Exception 属性），否则这个异常会成为未观测的异常。</p><p>WhenAny 方法可以在原本不支持超时和取消的操作中添加超时和取消功能：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Task<span class="token punctuation">&lt;</span><span class="token keyword">string</span><span class="token punctuation">></span></span> task <span class="token operator">=</span> <span class="token function">SomeAsyncFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Task</span> winner <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token punctuation">(</span>Task<span class="token punctuation">.</span>WhenAny <span class="token punctuation">(</span>task<span class="token punctuation">,</span> Task<span class="token punctuation">.</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>winner <span class="token operator">!=</span> task<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">TimeoutException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token class-name"><span class="token keyword">string</span></span> result <span class="token operator">=</span> <span class="token keyword">await</span> task<span class="token punctuation">;</span> <span class="token comment">// Unwrap result/re-throw</span></pre></td></tr></table></figure><p>注意，由于上述例子在调用 WhenAny 时使用了不同类型的任务，因此完成的任务只能作为一个普通的 Task 而非 Task&lt;string&gt;。</p><p><strong>WhenAll</strong></p><p>Task.WhenAll 返回一个任务，该任务仅当参数中的所有任务全部完成时才完成。以下示例中的任务将在 3 秒之后完成（同时延时了分叉 / 汇合模式）：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">await</span> Task<span class="token punctuation">.</span>WhenAll <span class="token punctuation">(</span><span class="token function">Delay1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Delay2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Delay3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>若不使用 WhenAll 而是一次等待 task1、task2 和 task3，则可以得到相似的结果：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Task</span> task1 <span class="token operator">=</span> <span class="token function">Delay1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> task2 <span class="token operator">=</span> <span class="token function">Delay2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> task3 <span class="token operator">=</span> <span class="token function">Delay3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">await</span> task1<span class="token punctuation">;</span> <span class="token keyword">await</span> task2<span class="token punctuation">;</span> <span class="token keyword">await</span> task3<span class="token punctuation">;</span></pre></td></tr></table></figure><p>三次等待的效率一般来说是等于一次等待的，除此之外，这两种方式的区别在于，如果 task1 出错，那么就无法等待 task2 和 task3，导致它们中间发生的异常成为未观测的异常。</p><p>相反，Task.WhenAll 只在所有的任务完成后才会完成，即使中间出现了错误也一样。如果多个任务发生了错误，那么这些异常会组合到任务的 AggregateException 中（这也是 AggreateException 真正发挥作用的时候，你可以从中得到所有的异常）。但是如果等待该组合任务的话，则只会抛出第一个异常。因此如果要查看所有异常，必须采用如下的写法：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Task</span> task1 <span class="token operator">=</span> Task<span class="token punctuation">.</span>Run <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span> <span class="token keyword">throw</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Task</span> task2 <span class="token operator">=</span> Task<span class="token punctuation">.</span>Run <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span> <span class="token keyword">throw</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">Task</span> all <span class="token operator">=</span> Task<span class="token punctuation">.</span>WhenAll <span class="token punctuation">(</span>task1<span class="token punctuation">,</span> task2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">try</span> <span class="token punctuation">&#123;</span> <span class="token keyword">await</span> all<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">catch</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>all<span class="token punctuation">.</span>Exception<span class="token punctuation">.</span>InnerExceptions<span class="token punctuation">.</span>Count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>对一系列 Task&lt;TResult&gt; 任务调用 WhenAll 会返回一个 Task&lt;TResult []&gt;，即所有任务的结果组合。如果执行等待操作，则该返回值为 TResult [] 类型：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Task<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span> task1 <span class="token operator">=</span> Task<span class="token punctuation">.</span>Run <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Task<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span> task2 <span class="token operator">=</span> Task<span class="token punctuation">.</span>Run <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> results <span class="token operator">=</span> <span class="token keyword">await</span> Task<span class="token punctuation">.</span>WhenAll <span class="token punctuation">(</span>task1<span class="token punctuation">,</span> task2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#123; 1, 2 &#125;</span></pre></td></tr></table></figure><h3 id="异步锁"><a class="anchor" href="#异步锁">#</a> 异步锁</h3><h2 id="旧有的异步编程模式"><a class="anchor" href="#旧有的异步编程模式">#</a> 旧有的异步编程模式</h2><p>这些模式已经很少使用了，这里不做介绍。</p><div class="tags"><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 读书笔记</a> <a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C#</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2022-09-10 12:25:46" itemprop="dateModified" datetime="2022-09-10T12:25:46+08:00">2022-09-10</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Sakupinera WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Sakupinera Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Sakupinera PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Sakupinera <i class="ic i-at"><em>@</em></i>Sakupinera</li><li class="link"><strong>Post link: </strong><a href="http://sakupinera.github.io/2022/09/04/csharp/csharp-in-a-nutshell/%E7%AC%AC14%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%BC%82%E6%AD%A5/" title="C# in a Nutshell - 第 14 章 并发与异步">http://sakupinera.github.io/2022/09/04/csharp/csharp-in-a-nutshell/第14章 并发与异步/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/09/04/linux/learn-linux/Shell%E7%BC%96%E7%A8%8B/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;03&#x2F;08&#x2F;nishJ3GEKoDLIbw.jpg" title="LearnLinux - Shell编程"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i> Learn-Linux</span><h3>LearnLinux - Shell编程</h3></a></div><div class="item right"><a href="/2022/09/05/linux/learn-linux/Linux%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;03&#x2F;08&#x2F;hr2Sybs5CRvjFdI.png" title="LearnLinux - Linux服务管理"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i> Learn-Linux</span><h3>LearnLinux - Linux服务管理</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%BC%82%E6%AD%A5"><span class="toc-number">1.</span> <span class="toc-text">并发与异步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">创建线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E5%90%88%E4%B8%8E%E4%BC%91%E7%9C%A0"><span class="toc-number">1.2.2.</span> <span class="toc-text">汇合与休眠</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E"><span class="toc-number">1.2.3.</span> <span class="toc-text">阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E7%8A%B6%E6%80%81%E4%B8%8E%E5%85%B1%E4%BA%AB%E7%8A%B6%E6%80%81"><span class="toc-number">1.2.4.</span> <span class="toc-text">本地状态与共享状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">1.2.5.</span> <span class="toc-text">锁与线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E7%BA%BF%E7%A8%8B%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.6.</span> <span class="toc-text">向线程传递数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.2.7.</span> <span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%8F%B0%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.8.</span> <span class="toc-text">前台线程与后台线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.2.9.</span> <span class="toc-text">线程的优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E5%8F%91%E9%80%81"><span class="toc-number">1.2.10.</span> <span class="toc-text">信号发送</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.11.</span> <span class="toc-text">富客户端应用程序的线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">1.2.12.</span> <span class="toc-text">同步上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.2.13.</span> <span class="toc-text">线程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.3.</span> <span class="toc-text">任务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.3.1.</span> <span class="toc-text">启动任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.3.2.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">1.3.3.</span> <span class="toc-text">异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E7%BB%AD"><span class="toc-number">1.3.4.</span> <span class="toc-text">延续</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#taskcompletionsource%E7%B1%BB"><span class="toc-number">1.3.5.</span> <span class="toc-text">TaskCompletionSource 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#taskdelay%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.6.</span> <span class="toc-text">Task.Delay 方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%8E%9F%E5%88%99"><span class="toc-number">1.4.</span> <span class="toc-text">异步原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%93%8D%E4%BD%9C%E4%B8%8E%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.1.</span> <span class="toc-text">同步操作与异步操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="toc-number">1.4.2.</span> <span class="toc-text">什么是异步编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%BB%B6%E7%BB%AD"><span class="toc-number">1.4.3.</span> <span class="toc-text">异步编程与延续</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c%E7%9A%84%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">C# 的异步函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%BE%85"><span class="toc-number">1.5.1.</span> <span class="toc-text">等待</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.2.</span> <span class="toc-text">编写异步函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.5.3.</span> <span class="toc-text">异步 Lambda 表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%B5%81c-8"><span class="toc-number">1.5.4.</span> <span class="toc-text">异步流（C# 8）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#winrt%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.5.</span> <span class="toc-text">WinRT 中的异步方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">1.5.6.</span> <span class="toc-text">异步与同步上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">1.5.7.</span> <span class="toc-text">优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.</span> <span class="toc-text">异步模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E6%B6%88%E6%93%8D%E4%BD%9C"><span class="toc-number">1.6.1.</span> <span class="toc-text">取消操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%BA%A6%E6%8A%A5%E5%91%8A"><span class="toc-number">1.6.2.</span> <span class="toc-text">进度报告</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.3.</span> <span class="toc-text">基于任务的异步模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%BB%84%E5%90%88%E5%99%A8"><span class="toc-number">1.6.4.</span> <span class="toc-text">任务组合器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E9%94%81"><span class="toc-number">1.6.5.</span> <span class="toc-text">异步锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A7%E6%9C%89%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.</span> <span class="toc-text">旧有的异步编程模式</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"><ul><li><a href="/2022/08/29/csharp/csharp-in-a-nutshell/%E7%AC%AC2%E7%AB%A0%20%E5%9C%A8CSharp%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%9E%8B/" rel="bookmark" title="C# in a Nutshell - 第2章 C#语言基础">C# in a Nutshell - 第2章 C#语言基础</a></li><li><a href="/2022/08/29/csharp/csharp-in-a-nutshell/%E7%AC%AC3%E7%AB%A0%20%E5%9C%A8CSharp%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%9E%8B/" rel="bookmark" title="C# in a Nutshell - 第3章 在C#中创建类型">C# in a Nutshell - 第3章 在C#中创建类型</a></li><li><a href="/2022/08/29/csharp/csharp-in-a-nutshell/%E7%AC%AC4%E7%AB%A0%20CSharp%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/" rel="bookmark" title="C# in a Nutshell - 第4章 C#的高级特性">C# in a Nutshell - 第4章 C#的高级特性</a></li><li><a href="/2022/08/30/csharp/csharp-in-a-nutshell/%E7%AC%AC8%E7%AB%A0%20LINQ%E6%9F%A5%E8%AF%A2/" rel="bookmark" title="C# in a Nutshell - 第8章 LINQ查询">C# in a Nutshell - 第8章 LINQ查询</a></li><li><a href="/2022/09/01/csharp/csharp-in-a-nutshell/%E7%AC%AC12%E7%AB%A0%20%E5%AF%B9%E8%B1%A1%E9%94%80%E6%AF%81%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" rel="bookmark" title="C# in a Nutshell - 第12章 对象销毁与垃圾回收">C# in a Nutshell - 第12章 对象销毁与垃圾回收</a></li><li class="active"><a href="/2022/09/04/csharp/csharp-in-a-nutshell/%E7%AC%AC14%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%BC%82%E6%AD%A5/" rel="bookmark" title="C# in a Nutshell - 第14章 并发与异步">C# in a Nutshell - 第14章 并发与异步</a></li></ul></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sakupinera" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Sakupinera</p><div class="description" itemprop="description">保持你的决心！</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">86</span> <span class="name">posts</span></a></div><div class="item categories"><a href="/categories/"><span class="count">13</span> <span class="name">categories</span></a></div><div class="item tags"><a href="/tags/"><span class="count">6</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nha3VwaW5lcmE=" title="https:&#x2F;&#x2F;github.com&#x2F;sakupinera"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9zYWt1cGluZXJh" title="https:&#x2F;&#x2F;twitter.com&#x2F;sakupinera"><i class="ic i-twitter"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQwNzIyOTA3MQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;407229071"><i class="ic i-cloud-music"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMjIzMDczOTg/c3BtX2lkX2Zyb209MzMzLjEwMDcuMC4w" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;22307398?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li><li class="item"><a href="/games/" rel="section"><i class="ic i-flag"></i>Games</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-person"></i>About</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/09/04/linux/learn-linux/Shell%E7%BC%96%E7%A8%8B/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/09/05/linux/learn-linux/Linux%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/09/05/linux/learn-linux/%E5%90%AF%E5%8A%A8%E7%AE%A1%E7%90%86/" title="LearnLinux - 启动管理">LearnLinux - 启动管理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/09/18/computer-graphics/games101/%E5%8F%98%E6%8D%A2/" title="GAMES101 - Transformation（变换）">GAMES101 - Transformation（变换）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/22/csharp/clr-via-csharp/Chapter%2018%20Custom%20Attributes/" title="CLR via C# - Chapter 18 Custom Attributes">CLR via C# - Chapter 18 Custom Attributes</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2023/01/02/cpp/cpp-primer/Chapter%2010%20Generic%20Algorithms/" title="C++ Primer - Chapter 10 Generic Algorithms">C++ Primer - Chapter 10 Generic Algorithms</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/08/28/hello-world/" title="Hello World">Hello World</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/23/csharp/clr-via-csharp/Chapter%2019%20Nullable%20Value%20Types/" title="CLR via C# - Chapter 19 Nullable Value Types">CLR via C# - Chapter 19 Nullable Value Types</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/08/28/linux/learn-linux/Linux%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/" title="LearnLinux - Linux系统简介">LearnLinux - Linux系统简介</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/08/28/linux/learn-linux/%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/" title="LearnLinux - 软件包管理">LearnLinux - 软件包管理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2023/02/10/csharp/clr-via-csharp/Chapter%2030%20Hybrid%20Thread%20Synchronization%20Constructs/" title="CLR via C# - Chapter 30 Hybrid Thread Synchronization">CLR via C# - Chapter 30 Hybrid Thread Synchronization</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/" title="GAMES101 - Cameras, Lenses and Light Fields（相机，透镜和光场）">GAMES101 - Cameras, Lenses and Light Fields（相机，透镜和光场）</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Sakupinera @ Hanamai Sora</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="Symbols count total">2.2m words</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="Reading time total">33:30</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/09/04/csharp/csharp-in-a-nutshell/第14章 并发与异步/",favicon:{show:"（●´3｀●）Goooood",hide:"(´Д｀)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/shifuku.model.json"},display:{position:"left",width:250,height:500},mobile:{show:!1},react:{opacity:.9},log:!1})</script></body></html>