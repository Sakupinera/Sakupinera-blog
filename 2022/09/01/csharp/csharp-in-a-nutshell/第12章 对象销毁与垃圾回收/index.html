<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sakupinera" href="http://sakupinera.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sakupinera" href="http://sakupinera.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sakupinera" href="http://sakupinera.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="读书笔记,C#"><link rel="canonical" href="http://sakupinera.github.io/2022/09/01/csharp/csharp-in-a-nutshell/%E7%AC%AC12%E7%AB%A0%20%E5%AF%B9%E8%B1%A1%E9%94%80%E6%AF%81%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"><title>C# in a Nutshell - 第 12 章 对象销毁与垃圾回收 - CSharp-in-a-Nutshell - CSharp | Hanamai Sora = Sakupinera</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">C# in a Nutshell - 第 12 章 对象销毁与垃圾回收</h1><div class="meta"><span class="item" title="Created: 2022-09-01 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2022-09-01T00:00:00+08:00">2022-09-01</time> </span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">Symbols count in article</span> <span>8k</span> <span class="text">words</span> </span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">Reading time</span> <span>7 mins.</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hanamai Sora</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s2.loli.net/2023/03/08/udCBOQsY6PwAW1g.png"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/R9PEJQ54o7HMAis.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/GkbQv5EIRZBXgDn.png"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/Jxa8Trdmc4uFsqW.png"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/J4XewNCOu8fzIy9.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/5Ydecyt7rf8FhwR.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/" itemprop="item" rel="index" title="In CSharp"><span itemprop="name">CSharp</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/CSharp-in-a-Nutshell/" itemprop="item" rel="index" title="In CSharp-in-a-Nutshell"><span itemprop="name">CSharp-in-a-Nutshell</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://sakupinera.github.io/2022/09/01/csharp/csharp-in-a-nutshell/%E7%AC%AC12%E7%AB%A0%20%E5%AF%B9%E8%B1%A1%E9%94%80%E6%AF%81%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Sakupinera"><meta itemprop="description" content=", 保持你的决心！"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakupinera"></span><div class="body md" itemprop="articleBody"><h1 id="对象销毁与垃圾回收"><a class="anchor" href="#对象销毁与垃圾回收">#</a> 对象销毁与垃圾回收</h1><p>有些对象需要依靠显式销毁代码来释放资源，例如打开的文件、锁、操作系统句柄和非托管对象。它们在.NET 的属于中称为销毁（disposal），相应的功能则由 IDisposable 接口提供。此外，那些占用了托管内存但不再使用的对象必须在某个时间回收。这个功能称为垃圾回收，它由 CLR 执行。</p><p>销毁不同于垃圾回收，它通常是显式调用，而垃圾回收则是完全自动执行的。</p><h2 id="idisposable接口-disposable方法和close方法"><a class="anchor" href="#idisposable接口-disposable方法和close方法">#</a> IDisposable 接口、Disposable 方法和 Close 方法</h2><p>.NET Core 为需要进行销毁操作的类型提供了一个特殊的接口：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IDisposable</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>C# 的 using 语句从语法上提供了调用实现 IDisposable 接口对象的 Dispose 方法的捷径。它会将相应的语句包裹在 try/finally 语句块中。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token class-name">FileStream</span> fs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">FileStream</span> <span class="token punctuation">(</span><span class="token string">"myFile.txt"</span><span class="token punctuation">,</span> FileMode<span class="token punctuation">.</span>Open<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// ... Write to the file ...</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>编译器会将其转换为：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">FileStream</span> fs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">FileStream</span> <span class="token punctuation">(</span><span class="token string">"myFile.txt"</span><span class="token punctuation">,</span> FileMode<span class="token punctuation">.</span>Open<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">try</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// ... Write to the file ...</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">finally</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>fs <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>IDisposable<span class="token punctuation">)</span>fs<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>同样，下面的语法也能够确保在 fs 脱离作用域时将其销毁：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token class-name">FileStream</span> fs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">FileStream</span> <span class="token punctuation">(</span><span class="token string">"myFile.txt"</span><span class="token punctuation">,</span> FileMode<span class="token punctuation">.</span>Open<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// ... Write to the file ...</span></pre></td></tr></table></figure><p>在比较简单的情况下，编写自定义的可销毁类型只需要实现 IDisposable 接口并编写 Dispose 方法即可：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IDisposable</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// Perform cleanup / tear-down.</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="标准销毁语义"><a class="anchor" href="#标准销毁语义">#</a> 标准销毁语义</h3><p>.NET Core 在其销毁逻辑中遵循一系列事实的规则。<span class="exturl" data-url="aHR0cDovL3huLS1rbHF5OGY5dWZ5M2lra2xidHludmF0NzJiNW14MjJuLk5FVA==">这些规则并未硬编码在.NET</span> Core 或内置在 C# 语言中。它的目的是为消费者提供一个一致的协议。其中包括：</p><ol><li>对象一旦销毁就无法再恢复，也不能够重新激活。在销毁后继续调用其方法（除 Dispose 外）或访问其属性都将抛出 ObjectDisposedException。</li><li>可以重复调用对象的 Dispose 方法，且不会发生任何错误。</li><li>若可销毁对象 x “拥有” 可销毁对象 y，则 x 的 Dispose 方法会自动调用 y 的 Dispose 方法，接到其他指令的情况除外。</li></ol><p>尽管这些规则并不是强制的，但它对于编写自定义的类也是非常有帮助的。</p><p><strong>Close 方法和 Stop 方法</strong></p><p>除了 Dispose 方法，一些类型还定义了 Close 方法。框架并未对 Close 方法赋予一致的语义，但几乎所有情况都满足以下两者中的一个：</p><ul><li>在功能上等价于 Dispose 方法</li><li>在功能上是 Dispose 方法的子集</li></ul><p>第二种情形的一个示例是 IDbConnection 接口：关闭的连接可以重新打开；销毁的连接则不能。另一个例子是由 ShowDialog 激活的 Windows 窗体：Close 方法会隐藏它，但 Dispose 方法则释放它的资源。</p><p>一些类定义了 Stop 方法（例如 Timer 和 HttpListener）。Stop 方法可能会释放非托管资源，但和 Dispose 不同的是它允许调用 Start 方法重新开始。</p><p>在 Windows Runtime Library（WinRT）中，Close 方法和 Dispose 方法是等价的。事实上，运行时会将 Close 方法的调用映射到 Dispose 方法上，使相应的类型同样可以在 using 语句中使用。</p><h3 id="销毁对象的时机"><a class="anchor" href="#销毁对象的时机">#</a> 销毁对象的时机</h3><p>在几乎所有的情况下都需要遵循的安全规则是 “能销毁就销毁”。</p><p>然而，也有三种不适合销毁对象的情况：</p><ul><li>当你并不持有该对象；例如，当通过静态字段或者属性获得共享对象时</li><li>当对象的 Dispose 方法执行了一些并不需要的操作时</li><li>当对象的 Dispose 方法在设计上并非必需，而且释放该对象会增加程序的复杂性时</li></ul><p>第二种情况最常见。System.IO 和 System.Data 命名空间种就有一些很好的示例：</p><p><img data-src="Figure12_1.JPG" alt="image"></p><h3 id="在销毁时清理字段"><a class="anchor" href="#在销毁时清理字段">#</a> 在销毁时清理字段</h3><p>一般来说，我们并不需要在 Dispose 方法种清除对象的字段。然而，在销毁时取消在对象生命周期内对相关事件的订阅确实一个好的实践。取消这种订阅可以避免接收不需要的事件通知，同时能够避免垃圾回收器（GC）认为对象仍然处于存活状态。</p><p>Dispose 方法本身并没有释放（托管）内存，只有垃圾回收时才会释放内存。</p><h2 id="自动垃圾回收"><a class="anchor" href="#自动垃圾回收">#</a> 自动垃圾回收</h2><p>无论对象是否需通过 Dispose 方法来执行自定义清理逻辑，在某些时刻，堆上的内存都必须被释放。CLR 通过自动化的垃圾回收器来处理这些工作，而我们完全无法手动释放托管内存。</p><p>垃圾回收并非在对象不被引用后立即执行，而是周期进行的。这很像街道上的垃圾清洁工作，不同的是垃圾回收器的调度安排并不是确定的。CLR 会基于一些因素来决定何时开始回收。这些因素包括可用内存、已经分配的内存数目、最后一次内存回收的间隔（GC 会根据应用程序的内存访问模式自动进行优化）。这意味着在对象不被引用和内存释放之间有着不确定的延时。理论上说，这种间隔可能从几纳秒到几天。</p><p>垃圾回收器并不会在每一次回收中清理所有的垃圾。内存管理器会将内存划分为若干代。GC 会更频繁地回收最新的代（最近分配的对象），而旧的代（长时间存活的对象）则不会这样频繁地进行回收。</p><h3 id="根"><a class="anchor" href="#根">#</a> 根</h3><p>根可以使对象保持存活。如果对象没有直接或者间接地被根引用，那么它就可以被垃圾回收器回收了。</p><p>根由以下几种：</p><ul><li>当前正在执行的方法（或在其调用栈的任何一个方法中）的局部变量或者参数</li><li>静态变量</li><li>终结队列中的对象</li></ul><p>我们无法执行一个被删除对象中的代码，因此只要对象还有一个实例方法在执行，它就一定会被上述方式中的一种引用。</p><p>需要注意的是，相互循环引用的对象组在没有根引用的情况下可以回收。换言之，对象若无法按照箭头（引用）顺序从根对象进行访问，就是不可达的，这种对象将会被回收。</p><p><img data-src="Figure12_2.JPG" alt="image"></p><h3 id="垃圾回收和winrt"><a class="anchor" href="#垃圾回收和winrt">#</a> 垃圾回收和 WinRT</h3><p>WinRT 依赖引用计数机制而不是自动化的垃圾回收器，来释放内存。即便如此，从 C# 实例化的 WinRT 对象的生命周期也是靠 CLR 的垃圾回收器管理的。因为 CLR 会在背后创建一个名为运行时可调用包装器的对象，而它将通过这个中间对象访问 COM 对象。</p><h2 id="终结器"><a class="anchor" href="#终结器">#</a> 终结器</h2><p>若对象拥有终结器，则在对象从内存中释放前，会执行终结器。</p><p>终结器之所以可以执行是因为垃圾回收是分不同的阶段进行的。首先，垃圾回收器会确定未使用的可以删除的对象，而那些没有终结器的对象会被直接删除；有（挂起或未执行的）终结器的对象在当时会保持存活，并被放到一个特殊的队列中。</p><p>此时，垃圾回收就已经完成了，应用程序将继续执行。此时，终结器线程开始与应用程序并行执行，取出特殊队列中的对象并执行其终结方法。在每一个对象的终结器执行前，对象仍然是存活的，此时这个特殊队列扮演着根对象的角色。一旦对象离开了队列，并且终结器执行完毕，对象就变成了未引用的对象，并将在下一次（属于该对象那一代的）垃圾回收时删除。</p><p>终结器非常有用，但是它也有一些附加的代价：</p><ul><li>终结器会降低内存分配和回收的速度（GC 需要对终结器的执行进行追踪）。</li><li>终结器延长了对象和该对象所引用的对象的生命周期（它们必须等到下一次垃圾回收时才会被真正删除）。</li><li>无法预测多个对象的终结器调用的顺序。</li><li>开发者对于终结器调用的实际只有非常有限的控制。</li><li>如果一个终结器的代码阻塞，则其他对象也无法终结。</li><li>如果应用程序没有完全被卸载，则对象的终结器也可能无法得以执行。</li></ul><p>总之，终结器和律师有相似之处，虽然它的存在非常必要，但是除非绝对必要，通常都不会希望使用它。如果使用它的话，则需要 100% 理解它所做的一切。</p><p>要实现终结器，需要遵守以下的准则：</p><ul><li>保证终结器可以很快执行完毕</li><li>永远不要阻塞终结器的执行</li><li>不要引用其他可终结对象</li><li>不要在终结器中抛出异常</li></ul><p>CLR 甚至可以在对象构造器抛出异常时调用对象的终结器。因此需要注意，在编写终结器时，对象的字段有可能并没有初始化完毕。</p><h3 id="在终结器中调用dispose"><a class="anchor" href="#在终结器中调用dispose">#</a> 在终结器中调用 Dispose</h3><p>需要注意，在这种模式下，内存的回收和资源的回收两件事情耦合在了一起，而实际上它们的关注点是不同的（除非资源本身就是内存）。此外，这种模式会增加终结线程的负担。</p><p>该模式通常在消费者忘记调用 Dispose 方法时作为补救措施。但是，也可以相应地记录日志以便将来修复这个问题。</p><p>以下就是实现这种用途的标准模式：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IDisposable</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// NOT virtual</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> Dispose <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> GC<span class="token punctuation">.</span>SuppressFinalize <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Prevent finalizer from running.</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">protected</span> <span class="token keyword">virtual</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> Dispose <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">bool</span></span> disposing<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>disposing<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// Call Dispose() on other objects owned by this instance.</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token comment">// You can reference other finalizable objects here.</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token comment">// ...</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token comment">// Release unmanaged resources owned by (just) this object.</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token comment">// ...</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token operator">~</span><span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> Dispose <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>需要注意的一个地方时我们在无参数的 Dispose 方法中调用了 GC.SuppressFinalize 方法。这可以防止垃圾回收器在之后回收这个对象时执行终结器。</p><h3 id="对象的复活"><a class="anchor" href="#对象的复活">#</a> 对象的复活</h3><p>如果终结器将即将销毁的对象引用到了一个存活的对象上，那么当下一次（属于哪个对象代的）垃圾回收发生时，CLR 会发现先前需要销毁的对象不再需要销毁了，因此该对象就不会被回收。这是一个高级处理方式，称为 “复活”（resurrection）。</p><p><strong>GC.ReRegisterForFinalize 方法</strong></p><p>复活对象的终结器将不会重新执行。如果希望其重新执行，必须调用 GC.ReRegisterForFinalize 方法。</p><h2 id="垃圾回收器的工作方式"><a class="anchor" href="#垃圾回收器的工作方式">#</a> 垃圾回收器的工作方式</h2><p>标准 CLR 使用分代式标记 - 压缩 GC 对托管堆上的对象进行自动内存管理。这种垃圾回收器式追踪型垃圾回收器，它不会干涉每一次的对象访问，而是会直接激活并追踪存储在托管堆上的对象引用图来决定哪些对象应当作为垃圾进行回收。</p><p>当内存分配量超过了特定的阈值，或者需要降低应用程序内存使用量时，垃圾回收器就会在进行内存分配时（通过 new 关键字）触发一次垃圾回收。这个过程还可以通过调用 System.GC.Collect 方法手动触发。在垃圾会后过程中，所有的线程都可能冻结。</p><p>GC 会从根对象开始按照对象引用遍历对象图，将所有遍历到的对象标记为可达对象。当这个过程完成后，所有没有标记的对象（即未被使用的对象）将会被作为垃圾进行回收。</p><p>未被使用的对象若没有终结器，则会被立即回收。而有终结器的对象将会被放到终结队列中，并在 GC 完成后有终结器线程处理。这些对象将在下一次对这代对象的垃圾回收中回收（除非该对象复活）。</p><p>剩余的存活对象将移动到堆的起始位置（压缩），释放出更多的对象空间来容纳更多的对象。这种压缩的目的有两个：它可以防止内存碎片化，并且 GC 可以用很简单的策略来分配新的对象，将新的对象分配在堆的尾部即可；同时，它还避免了耗时的内存碎片列表的维护开销。</p><p>如果垃圾回收后仍然没有足够的内存来分配新的对象，且操作系统也无法分配更多的内存，则会抛出 OutOfMemoryException。</p><h3 id="优化技术"><a class="anchor" href="#优化技术">#</a> 优化技术</h3><p>垃圾回收器使用了多种优化技术来减少垃圾回收的时间。</p><p><strong>分代回收</strong></p><p>最重要的优化措施是分代垃圾回收。这是因为尽管许多对象的分配和释放非常频繁，但是某些对象会长时间存活，并不需要在每次回收时都追踪它。</p><p>垃圾回收器将堆上的内存分为了三代。刚刚分配的对象位于第 0 代；在第一轮回收中存活的对象在第 1 代，其他所有对象对象在第 2 代。第 0 代和第 1 代对象就是所谓的短生存期的代。</p><p>CLR 将第 0 代控制在一个相对较小的空间内（其典型大小在几百 KB 至几 MB）。当第 0 代填满时，GC 就会触发第 0 代垃圾回收。第 0 代垃圾回收会频繁发生。GC 对第 1 代内存应用了相似空间限制（作为第 2 代的缓冲区），且第 1 代内存的回收也相对快速而频繁。一次完整的内存回收会包含第 2 代内存，但是这种回收时间较长，因此并不是那么频繁。</p><p><img data-src="Figure12_3.JPG" alt="image"></p><p>与第 0 代和第 1 代内存不同，第二代内存是没有大小限制的。</p><p><strong>大对象堆</strong></p><p>垃圾回收器会将大于某一阈值的对象（目前是 85000 字节）存放在一个独立的堆中，称为大对象堆（Large Object Heap，LOH）。它可以避免大型对象的开销，并避免过量的第 0 代回收。如果没有 LOH，分配一系列的 16MB 对象时几乎每次分配就会触发一次第 0 代的回收。</p><p>默认情况下，大对象堆时不会被压缩的，因为在垃圾回收时移动大块内存的开销较大。这意味着：</p><ul><li>分配将变得更加缓慢，需要维护空闲内存块的链表</li><li>大对象堆可能会碎片化</li></ul><p>如果碎片化会造成问题，也可以控制 GC 在下一次回收时压缩大对象堆：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>GCSettings<span class="token punctuation">.</span>LargeObjectHeapCompactionMode <span class="token operator">=</span></pre></td></tr><tr><td data-num="2"></td><td><pre> GCLargeObjectHeapCompactionMode<span class="token punctuation">.</span>CompactOnce<span class="token punctuation">;</span></pre></td></tr></table></figure><p>如果应用程序频繁分配大型数组，<span class="exturl" data-url="aHR0cDovL3huLS00Z3F2ZDc5YmIyZTQxY280c25uZWQ4cW00YW83bTcxNmIuTkVU">则另一个应对方案是使用.NET</span> Core 的数组池 API。</p><p>大对象堆并不是分代的，其上所有的对象都会按第 2 代来处理。</p><p><strong>工作站回收与服务器回收</strong></p><p>.NET Core 提供了两种垃圾回收模式：工作站模式和服务器模式。工作站模式是默认模式。</p><p>当启用服务器回收模式时，CLR 会未每一个内核分配独立的堆并安排独立的 GC。虽然这样可以加速回收，但这会消耗更多的内存和 CPU 资源（因为每一个内核都需要相应的线程）。若计算机启用服务器 GC 并同时执行多个其他线程时就可能导致 CPU 过载。这在工作站下现象尤其明显，因为这将使操作系统的响应能力下降。</p><p><strong>后台回收</strong></p><p>不论是工作站还是服务器模式，CLR 都会默认启用后台回收。</p><p>在回收过程中，GC 必须冻结（阻塞）执行线程。而后台回收则可以缩小这种延迟，使得应用程序具有更好的响应性。当然，这也会相对地多消耗一些 CPU 和内存资源。</p><p>后台回收令应用程序代码和第 2 代会后得以并行执行（第 0 代和第 1 代的回收速度足够快，因此对其并行并行会后并没有太多的优势）。</p><p>后台回收是之前并发回收的改进版本。在先前的版本中，如果第 0 代内存已经占满且第 2 代正在进行内存回收则无法维持并发；而后台回收则没有这种限制。因此，使用后台回收，应用程序就可以持续地分配内存，并获得更好的响应性。</p><p><strong>垃圾回收通知</strong></p><h3 id="强制垃圾回收"><a class="anchor" href="#强制垃圾回收">#</a> 强制垃圾回收</h3><p>我们可以在任意时刻嗲用 GC.Collect 方法来强制进行垃圾回收。</p><h3 id="垃圾回收过程的调整"><a class="anchor" href="#垃圾回收过程的调整">#</a> 垃圾回收过程的调整</h3><p>GCSettings.LatencyMode 静态属性可以决定如何在延迟和整体效率上进行权衡。</p><h3 id="内存压力"><a class="anchor" href="#内存压力">#</a> 内存压力</h3><h3 id="数组池"><a class="anchor" href="#数组池">#</a> 数组池</h3><p>若应用程序频繁初始化数组对象，则可以使用数组池（array pooling）避免大部分垃圾回收的开销。</p><h2 id="托管内存泄漏"><a class="anchor" href="#托管内存泄漏">#</a> 托管内存泄漏</h2><p>托管内存泄露是由哪些虽然不再使用，但其引用已经被遗忘而一致存活的对象造成的。常见的一种情况是事件处理器造成的，它保存着堆目标对象的引用（除非目标是一个静态方法）。例如，考虑以下的类：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Host</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">event</span> <span class="token class-name">EventHandler</span> Click<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Client</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token class-name">Host</span> _host<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> Client <span class="token punctuation">(</span><span class="token class-name">Host</span> host<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> _host <span class="token operator">=</span> host<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> _host<span class="token punctuation">.</span>Click <span class="token operator">+=</span> HostClicked<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token return-type class-name"><span class="token keyword">void</span></span> HostClicked <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span></span> sender<span class="token punctuation">,</span> <span class="token class-name">EventArgs</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>The following test <span class="token keyword">class</span> <span class="token class-name">contains</span> a method that instantiates <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">000</span> clients<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Test</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token keyword">static</span> <span class="token class-name">Host</span> _host <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Host</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">CreateClients</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token class-name">Client<span class="token punctuation">[</span><span class="token punctuation">]</span></span> clients <span class="token operator">=</span> Enumerable<span class="token punctuation">.</span>Range <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token punctuation">.</span>Select <span class="token punctuation">(</span>i <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Client</span> <span class="token punctuation">(</span>_host<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token punctuation">.</span><span class="token function">ToArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token comment">// Do something with clients ...</span></pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>以上问题的解决方案之一是令 Client 实现 IDisposable 接口，并在 Disposse 方法中注销事件处理器：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> _host<span class="token punctuation">.</span>Click <span class="token operator">-=</span> HostClicked<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>而 Client 的消费者应当在使用完毕后销毁这些实例：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>Array<span class="token punctuation">.</span>ForEach <span class="token punctuation">(</span>clients<span class="token punctuation">,</span> c <span class="token operator">=></span> c<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="定时器"><a class="anchor" href="#定时器">#</a> 定时器</h3><p>忽略定时器也会造成内存泄漏。根据定时器的类型可分为两种不同的情况。首先我们来关注一下 System.Timers 命名空间中的定时器。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Timers</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Foo</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">Timer</span> _timer<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> _timer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">System<span class="token punctuation">.</span>Timers<span class="token punctuation">.</span>Timer</span> <span class="token punctuation">&#123;</span> Interval <span class="token operator">=</span> <span class="token number">1000</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> _timer<span class="token punctuation">.</span>Elapsed <span class="token operator">+=</span> tmr_Elapsed<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> _timer<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token return-type class-name"><span class="token keyword">void</span></span> tmr_Elapsed <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span></span> sender<span class="token punctuation">,</span> <span class="token class-name">ElapsedEventArgs</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在这种情况下，Foo 实例将永远不会被回收！<span class="exturl" data-url="aHR0cDovL3huLS02a3E5MnNvMThjN2hjLk5FVA==">问题在于.NET</span> Core 自身会保留已经激活的定时器的引用，以便触发 Elapsed 事件。因此：</p><ul><li>.NET Core 会确保_timer 的存活</li><li>_timer 通过 tmr_Elapsed 事件处理器使 Foo 实例保持存活</li></ul><p>当你意识到 Timer 实现了 IDisposable 接口时，其解决方法就很明显了。<span class="exturl" data-url="aHR0cDovL3huLS0ycnF1aXFubDBiMnluMjhoYm5hMjFhdDRub3h2bjdubTZhNTE4NmEuTkVU">销毁定时器将使其停止并保存.NET</span> Core 不会再引用定时器对象：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IDisposable</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> _timer<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>如果类中的任何字段所赋的对象实现了 IDisposable 接口，那么该类也应当实现 IDisposable 接口。这是一个实现 IDisposable 的良好准则。</p><p>然而，System.Threading 命名空间下的定时器是比较特殊的。.NET Core 并不会保存激活定时器的引用，而是直接引用回调委托。这意味着如果忘记销毁线程定时器，那么终结器也会触发，定时器将自动停止并销毁：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> tmr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">System<span class="token punctuation">.</span>Threading<span class="token punctuation">.</span>Timer</span> <span class="token punctuation">(</span>TimerTick<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> GC<span class="token punctuation">.</span><span class="token function">Collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> System<span class="token punctuation">.</span>Threading<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span>Sleep <span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Wait 10 seconds</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> TimerTick <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span></span> notUsed<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token string">"tick"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>上述代码必须在 “release” 模式下编译（禁用 debug 模式并开启代码优化）。</p><h3 id="诊断内存泄漏"><a class="anchor" href="#诊断内存泄漏">#</a> 诊断内存泄漏</h3><p>最简单避免托管内存泄漏的方式就是再编写应用程序时主动监视内存的使用状况。</p><h2 id="弱引用"><a class="anchor" href="#弱引用">#</a> 弱引用</h2><h3 id="弱引用和缓存"><a class="anchor" href="#弱引用和缓存">#</a> 弱引用和缓存</h3><h3 id="弱引用和事件"><a class="anchor" href="#弱引用和事件">#</a> 弱引用和事件</h3><div class="tags"><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 读书笔记</a> <a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C#</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2023-11-22 08:08:12" itemprop="dateModified" datetime="2023-11-22T08:08:12+08:00">2023-11-22</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Sakupinera WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Sakupinera Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Sakupinera PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Sakupinera <i class="ic i-at"><em>@</em></i>Sakupinera</li><li class="link"><strong>Post link: </strong><a href="http://sakupinera.github.io/2022/09/01/csharp/csharp-in-a-nutshell/%E7%AC%AC12%E7%AB%A0%20%E5%AF%B9%E8%B1%A1%E9%94%80%E6%AF%81%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" title="C# in a Nutshell - 第 12 章 对象销毁与垃圾回收">http://sakupinera.github.io/2022/09/01/csharp/csharp-in-a-nutshell/第12章 对象销毁与垃圾回收/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/08/30/csharp/csharp-in-a-nutshell/%E7%AC%AC8%E7%AB%A0%20LINQ%E6%9F%A5%E8%AF%A2/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;03&#x2F;08&#x2F;rkHPIpA3EmFKe7i.png" title="C# in a Nutshell - 第8章 LINQ查询"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i> CSharp-in-a-Nutshell</span><h3>C# in a Nutshell - 第8章 LINQ查询</h3></a></div><div class="item right"><a href="/2022/09/02/linux/learn-linux/Shell%E5%9F%BA%E7%A1%80/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;03&#x2F;08&#x2F;nishJ3GEKoDLIbw.jpg" title="LearnLinux - Shell基础"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i> Learn-Linux</span><h3>LearnLinux - Shell基础</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E9%94%80%E6%AF%81%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.</span> <span class="toc-text">对象销毁与垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#idisposable%E6%8E%A5%E5%8F%A3-disposable%E6%96%B9%E6%B3%95%E5%92%8Cclose%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">IDisposable 接口、Disposable 方法和 Close 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E9%94%80%E6%AF%81%E8%AF%AD%E4%B9%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">标准销毁语义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-number">1.1.2.</span> <span class="toc-text">销毁对象的时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E9%94%80%E6%AF%81%E6%97%B6%E6%B8%85%E7%90%86%E5%AD%97%E6%AE%B5"><span class="toc-number">1.1.3.</span> <span class="toc-text">在销毁时清理字段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.2.</span> <span class="toc-text">自动垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9"><span class="toc-number">1.2.1.</span> <span class="toc-text">根</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%92%8Cwinrt"><span class="toc-number">1.2.2.</span> <span class="toc-text">垃圾回收和 WinRT</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%88%E7%BB%93%E5%99%A8"><span class="toc-number">1.3.</span> <span class="toc-text">终结器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%BB%88%E7%BB%93%E5%99%A8%E4%B8%AD%E8%B0%83%E7%94%A8dispose"><span class="toc-number">1.3.1.</span> <span class="toc-text">在终结器中调用 Dispose</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E6%B4%BB"><span class="toc-number">1.3.2.</span> <span class="toc-text">对象的复活</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">垃圾回收器的工作方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="toc-number">1.4.1.</span> <span class="toc-text">优化技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.4.2.</span> <span class="toc-text">强制垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%E7%9A%84%E8%B0%83%E6%95%B4"><span class="toc-number">1.4.3.</span> <span class="toc-text">垃圾回收过程的调整</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%8E%8B%E5%8A%9B"><span class="toc-number">1.4.4.</span> <span class="toc-text">内存压力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%B1%A0"><span class="toc-number">1.4.5.</span> <span class="toc-text">数组池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%98%E7%AE%A1%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">1.5.</span> <span class="toc-text">托管内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">1.5.1.</span> <span class="toc-text">定时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%8A%E6%96%AD%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">1.5.2.</span> <span class="toc-text">诊断内存泄漏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-number">1.6.</span> <span class="toc-text">弱引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8%E5%92%8C%E7%BC%93%E5%AD%98"><span class="toc-number">1.6.1.</span> <span class="toc-text">弱引用和缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8%E5%92%8C%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.6.2.</span> <span class="toc-text">弱引用和事件</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"><ul><li><a href="/2022/08/29/csharp/csharp-in-a-nutshell/%E7%AC%AC2%E7%AB%A0%20%E5%9C%A8CSharp%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%9E%8B/" rel="bookmark" title="C# in a Nutshell - 第2章 C#语言基础">C# in a Nutshell - 第2章 C#语言基础</a></li><li><a href="/2022/08/29/csharp/csharp-in-a-nutshell/%E7%AC%AC3%E7%AB%A0%20%E5%9C%A8CSharp%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%9E%8B/" rel="bookmark" title="C# in a Nutshell - 第3章 在C#中创建类型">C# in a Nutshell - 第3章 在C#中创建类型</a></li><li><a href="/2022/08/29/csharp/csharp-in-a-nutshell/%E7%AC%AC4%E7%AB%A0%20CSharp%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/" rel="bookmark" title="C# in a Nutshell - 第4章 C#的高级特性">C# in a Nutshell - 第4章 C#的高级特性</a></li><li><a href="/2022/08/30/csharp/csharp-in-a-nutshell/%E7%AC%AC8%E7%AB%A0%20LINQ%E6%9F%A5%E8%AF%A2/" rel="bookmark" title="C# in a Nutshell - 第8章 LINQ查询">C# in a Nutshell - 第8章 LINQ查询</a></li><li class="active"><a href="/2022/09/01/csharp/csharp-in-a-nutshell/%E7%AC%AC12%E7%AB%A0%20%E5%AF%B9%E8%B1%A1%E9%94%80%E6%AF%81%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" rel="bookmark" title="C# in a Nutshell - 第12章 对象销毁与垃圾回收">C# in a Nutshell - 第12章 对象销毁与垃圾回收</a></li><li><a href="/2022/09/04/csharp/csharp-in-a-nutshell/%E7%AC%AC14%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%BC%82%E6%AD%A5/" rel="bookmark" title="C# in a Nutshell - 第14章 并发与异步">C# in a Nutshell - 第14章 并发与异步</a></li></ul></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sakupinera" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Sakupinera</p><div class="description" itemprop="description">保持你的决心！</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">86</span> <span class="name">posts</span></a></div><div class="item categories"><a href="/categories/"><span class="count">13</span> <span class="name">categories</span></a></div><div class="item tags"><a href="/tags/"><span class="count">6</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nha3VwaW5lcmE=" title="https:&#x2F;&#x2F;github.com&#x2F;sakupinera"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9zYWt1cGluZXJh" title="https:&#x2F;&#x2F;twitter.com&#x2F;sakupinera"><i class="ic i-twitter"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQwNzIyOTA3MQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;407229071"><i class="ic i-cloud-music"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMjIzMDczOTg/c3BtX2lkX2Zyb209MzMzLjEwMDcuMC4w" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;22307398?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li><li class="item"><a href="/games/" rel="section"><i class="ic i-flag"></i>Games</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-person"></i>About</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/08/30/csharp/csharp-in-a-nutshell/%E7%AC%AC8%E7%AB%A0%20LINQ%E6%9F%A5%E8%AF%A2/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/09/02/linux/learn-linux/Shell%E5%9F%BA%E7%A1%80/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/UnityShader/" title="In UnityShader">UnityShader</a></div><span><a href="/2022/09/19/computer-graphics/unityshader/%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/" title="UnityShader - 渲染流水线">UnityShader - 渲染流水线</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2023/01/06/cpp/cpp-primer/Chapter%2014%20Overloaded%20Operations%20and%20Conversions/" title="C++ Primer - Chapter 14 Overloaded Operations and Conversions">C++ Primer - Chapter 14 Overloaded Operations and Conversions</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/10/21/computer-graphics/games101/%E6%B8%B2%E6%9F%93%E4%B8%AD%E7%9A%84%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/" title="GAMES101 - Advanced Topics in Rendering（渲染中的高级主题）">GAMES101 - Advanced Topics in Rendering（渲染中的高级主题）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2023/01/03/cpp/cpp-primer/Chapter%2011%20Associative%20Containers/" title="C++ Primer - Chapter 11 Associative Containers">C++ Primer - Chapter 11 Associative Containers</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/09/05/linux/learn-linux/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/" title="LearnLinux - Linux系统管理">LearnLinux - Linux系统管理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/09/02/linux/learn-linux/Shell%E5%9F%BA%E7%A1%80/" title="LearnLinux - Shell基础">LearnLinux - Shell基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2023/01/10/cpp/cpp-primer/Chapter%2018%20Tools%20for%20Large%20Programs/" title="C++ Primer - Chapter 18 Tools for Large Programs">C++ Primer - Chapter 18 Tools for Large Programs</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/09/22/computer-graphics/games101/%E5%85%89%E6%A0%85%E5%8C%96/" title="GAMES101 - Rasterization（光栅化）">GAMES101 - Rasterization（光栅化）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" title="CLR via C# - Chapter 8 Methods">CLR via C# - Chapter 8 Methods</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/29/csharp/clr-via-csharp/Chapter%2023%20Assembly%20Loading%20and%20Reflection/" title="CLR via C# - Chapter 23 Assembly Loading and Reflection">CLR via C# - Chapter 23 Assembly Loading and Reflection</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Sakupinera @ Hanamai Sora</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="Symbols count total">2.2m words</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="Reading time total">33:30</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/09/01/csharp/csharp-in-a-nutshell/第12章 对象销毁与垃圾回收/",favicon:{show:"（●´3｀●）Goooood",hide:"(´Д｀)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/shifuku.model.json"},display:{position:"left",width:250,height:500},mobile:{show:!1},react:{opacity:.9},log:!1})</script></body></html>