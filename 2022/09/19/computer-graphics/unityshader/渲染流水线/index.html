<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sakupinera" href="http://sakupinera.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sakupinera" href="http://sakupinera.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sakupinera" href="http://sakupinera.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="学习笔记,CG"><link rel="canonical" href="http://sakupinera.github.io/2022/09/19/computer-graphics/unityshader/%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/"><title>UnityShader - 渲染流水线 - UnityShader - Computer-Graphics | Hanamai Sora = Sakupinera</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">UnityShader - 渲染流水线</h1><div class="meta"><span class="item" title="Created: 2022-09-19 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2022-09-19T00:00:00+08:00">2022-09-19</time> </span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">Symbols count in article</span> <span>11k</span> <span class="text">words</span> </span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">Reading time</span> <span>10 mins.</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hanamai Sora</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s2.loli.net/2023/03/08/r1VBTR45h8jQWZA.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/hub7DjxPVYvzoB4.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/KFwBz5WDl3HNyXq.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/NpgC85HtK6LwbuP.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/ex9IWsqg18bZua2.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/jV3gF2wSUYTdtsp.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Computer-Graphics/" itemprop="item" rel="index" title="In Computer-Graphics"><span itemprop="name">Computer-Graphics</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Computer-Graphics/UnityShader/" itemprop="item" rel="index" title="In UnityShader"><span itemprop="name">UnityShader</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://sakupinera.github.io/2022/09/19/computer-graphics/unityshader/%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Sakupinera"><meta itemprop="description" content=", 保持你的决心！"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakupinera"></span><div class="body md" itemprop="articleBody"><h1 id="渲染流水线"><a class="anchor" href="#渲染流水线">#</a> 渲染流水线</h1><p>渲染流水线的最终目的在于生成或者说是渲染一张二维纹理，即我们在电脑屏幕上看到的所有效果。</p><h2 id="综述"><a class="anchor" href="#综述">#</a> 综述</h2><p>实际上，Shader 仅仅是渲染流水线中的一个环节，想要让我们的 Shader 发挥出它的作用，我们就需要知道它在渲染流水线中扮演了怎样的角色。</p><p>渲染流水线的工作任务在于由一个三维场景出发、生成（或者说渲染）一张二维图像。换句话说，计算机需要从一系列的顶点数据、纹理等信息出发，把这些信息最终转换成一张人眼可以看到的图像。而这个工作通常是由 CPU 和 GPU 共同完成的。</p><p>《Real-Time Rendering，Third Edition》一书中将一个渲染流程分成 3 个阶段：应用阶段（Application Stage）、几何阶段（Geometry Stage）、光栅化阶段（Rasterizer Stage）。</p><p><img data-src="image-20220918172401637.png" alt="image-20220918172401637"></p><p><mark>注意：这里仅仅是概念性阶段，每个阶段本身通常也是一个流水线系统，即包含了子流水线阶段。要将这里的 3 个流水线阶段和后面要讲到的 GPU 流水线阶段区分开来。</mark></p><ul><li>应用阶段：这个阶段是应用主导的，通常由 CPU 负责实现。开发者有 3 个主要任务：⭐️首先，我们需要准备好场景数据，例如场景数据，例如摄像机的位置、视锥体、场景中包含了哪些模型、使用了哪些光源等等；⭐️其次，为了提高渲染性能，我们往往需要做一个粗粒度剔除（culling）工作，以把那些不可见的物体剔除出去，这样就不需要再移交给几何阶段进行处理；⭐️最后，我们需要设置好每个模型的渲染状态。这些渲染状态包括但不限于它使用的材质（漫反射颜色、高光反射颜色）、使用的纹理、使用的 Shader 等。这一阶段最重要的输出渲染所需的集合信息，即渲染图元（rendering primitives）。通俗来讲，渲染图元可以是点、线、三角面等。</li><li>几何阶段：几何阶段用于处理所有和我们要绘制的几何相关的事情。这一阶段通常在 GPU 上进行。几何阶段负责和每个渲染图元打交道，进行逐顶点、逐多边形的操作。⭐️几何阶段的一个重要任务就是把顶点坐标变换到屏幕空间中，再交给光栅器处理。通过对输入的渲染图元进行多步处理后，这一阶段将会输出屏幕空间的二维顶点坐标、每个顶点对应的深度值、着色等相关信息，并传递给下一个阶段。</li><li>光栅化阶段：这一阶段会使用上个阶段传递的数据来产生屏幕上的像素，并渲染除最终的图像。这一阶段也是在 GPU 上运行。⭐️光栅化的任务主要是决定每个渲染图元中的哪些像素应该被绘制在屏幕上。它需要对上一个阶段得到的逐顶点数据（例如纹理坐标、顶点颜色等）进行插值，然后再进行逐像素处理。</li></ul><h2 id="cpu和gpu之间的通信"><a class="anchor" href="#cpu和gpu之间的通信">#</a> CPU 和 GPU 之间的通信</h2><p>渲染流水线的起点是 CPU，即应用阶段。应用阶段大致可分为下面 3 个阶段：</p><ol><li>把数据加载到显存中。</li><li>设置渲染状态。</li><li>调用 Draw Call。</li></ol><h3 id="把数据加载到显存中"><a class="anchor" href="#把数据加载到显存中">#</a> 把数据加载到显存中</h3><p>所有渲染所需的数据都需要从硬盘（Hard Disk Drive， HDD）中加载到系统内存（Random Access Memory，ARM）中。然后，网格和纹理等数据又被加载到显卡上的存储空间 -- 显存（Video Random Access Memory， VRAM）中。这是因为，显卡对于显存的访问速度更快，而且大多数显卡对于 RAM 没有直接的访问权利。</p><p><img data-src="image-20220918172423464.png" alt="image-20220918172423464"></p><p>需要注意的是，真实渲染中需要加载到显存中的数据往往比图 2.3 所示复杂许多。例如，顶点的位置信息、法线信息、顶点颜色、纹理坐标等。</p><p>当把数据加载到显存中后，RAM 中的数据就可以移除了。但对于一些数据来说，CPU 仍然需要访问它们（例如，我们希望 CPU 可以访问网格数据来进行碰撞检测），那么我们可能就不希望这些数据被移除，因为从硬盘加载到 RAM 的过程是十分耗时的。</p><p>在这之后，开发者还需要通过 CPU 来设置渲染状态，从而 “指导 “GPU 如何进行渲染工作。</p><h3 id="设置渲染状态"><a class="anchor" href="#设置渲染状态">#</a> 设置渲染状态</h3><p>渲染状态定义了场景中的网格是怎样被渲染的。例如，使用哪个顶点着色器（Vertex Shader）/ 片元着色器（Fragment Shader）、光源属性、材质等。如果我们没有更改渲染状态，那么所有的网格都将使用同一种渲染状态。</p><p><img data-src="image-20220918190054061.png" alt="image-20220918190054061"></p><p>在准备好上述所有工作后，CPU 就需要调用一个渲染命令告诉 GPU，而这个渲染命令就是 Draw Call。</p><h3 id="调用draw-call"><a class="anchor" href="#调用draw-call">#</a> 调用 Draw Call</h3><p>实际上，Draw Call 就是一个命令，它的发起方是 CPU，接收方是 GPU。这个命令仅仅会指向一个需要被渲染的图元（primitives）列表，而不会再包含任何材质信息 -- 这是因为我们已经再上一个阶段中完成了！</p><p>当给定了一个 Draw Call 时，GPU 就会根据渲染状态（例如材质、纹理、着色器等）和所有输入的顶点数据来进行计算，最终输出成屏幕上显示的那些漂亮的像素。而这个计算过程，就是下一节要讲的 GPU 流水线。</p><p><img data-src="image-20220918190538723.png" alt="image-20220918190538723"></p><h2 id="gpu流水线"><a class="anchor" href="#gpu流水线">#</a> GPU 流水线</h2><p>当 GPU 从 CPU 那里得到渲染命令后，就会进行一系列流水线操作，最终把图元渲染到屏幕上。</p><h3 id="概述"><a class="anchor" href="#概述">#</a> 概述</h3><p>对于概念阶段的后两个阶段，即几何阶段和光栅化阶段，开发者无法拥有绝对的控制权，其实现载体是 GPU。GPU 通过实现流水线化，大大加快了渲染速度。虽然我们无法完全控制这两个阶段的实现细节，但 GPU 向开发者开放了很多控制权。</p><p>几何阶段和光栅化阶段可以分成若干更小的流水线阶段，这些流水线阶段由 GPU 来实现，每个阶段 GPU 提供了不同的可配置性或可编程性。</p><p><img data-src="image-20220918193801564.png" alt="image-20220918193801564"></p><p>从图中可以看出，GPU 的渲染流水线接受顶点数据作为输入。这些顶点数据是由应用阶段加载到显存中，再由 Draw Call 指定的。这些数据随后被传递给顶点着色器。</p><p>** 顶点着色器（Vertex Shader）** 是完全可编程的，它通常用于实现顶点的空间变换、顶点着色等功能。<strong>曲面细分着色器（Tessellation Shader）<strong>是一个可选的着色器，它用于细分图元。<strong>几何着色器（Geometry Shader）<strong>同样是一个可选的着色器，它可以被用于执行逐图元（Per-Primitive）的着色操作，或者被用于产生更多的图元。下一个流水线阶段是</strong>裁剪（Clipping）</strong>，这一阶段的目的是将那些不在摄像机视野内的顶点裁剪掉，并剔除某些三角图元的片面。这个阶段是可配置的。例如，我们可以使用自定义的裁剪平面来配置裁剪区域，也可以通过指令控制裁剪三角图元的正面还是背面。几何概念阶段的最后一个流水线阶段是</strong>屏幕映射（Screen Mapping）</strong>。这一阶段是不可配置和编程的，它负责把每个图元的坐标转换到屏幕坐标系中。</p><p>光栅化概念阶段中的<strong>三角形设置（Triangle Setup）<strong>和</strong>三角形遍历（Triangle Traversal）<strong>阶段也都是固定函数（Fixed-Function）的阶段。接下来的</strong>片元着色器（Fragment Shader）</strong>，则是完全可编程的，它用于实现逐片元（Per-Fragment）的着色操作。最后，** 逐片元操作（Per-Fragment）** 阶段负责执行很多重要的操作，例如修改颜色、深度缓冲、进行混合等，它不是可编程的，但具有很高的可配置性。</p><h3 id="顶点着色器"><a class="anchor" href="#顶点着色器">#</a> 顶点着色器</h3><p>** 顶点着色器（Vertex Shader）** 是流水线的第一个阶段，它的输入来自于 CPU。顶点着色器的处理单位是顶点，也就是说，输入进来的每个顶点都会调用一次顶点着色器。顶点着色器本身不可以创建或者销毁任何顶点，而且无法得到顶点于顶点之间的关系。例如，我们无法得知两个顶点是否属于同一个三角网络。但正是因为这样的相互独立性，GPU 可以利用本身的特性并行化处理每一个顶点，这意味着这一阶段的处理速度会很快。</p><p>顶点着色器需要完成的工作主要有：坐标变换和逐顶点光照。当然，除了这两个主要任务外，顶点着色器还可以输出后续阶段所需的数据。</p><p><img data-src="image-20220918201859656.png" alt="image-20220918201859656"></p><ul><li><p>坐标变换。顾名思义，就是对顶点的坐标（即位置）进行某种变换。顶点着色器可以在这一步中改变顶点的位置，这在顶点动画中是非常有用的。例如，我们可以通过改变顶点位置来模拟水面、布料等。但需要注意的是，无论我们在顶点着色器中怎样改变顶点的位置，一个最基本的顶点着色器必须完成的一个工作是，<strong>把顶点坐标从模型空间转换到其次裁剪空间</strong>。</p><figure class="highlight clike"><figcaption data-lang="C-like"></figcaption><table><tr><td data-num="1"></td><td><pre>o<span class="token punctuation">.</span>pos <span class="token operator">=</span> <span class="token function">mul</span><span class="token punctuation">(</span>UNITY_MVP<span class="token punctuation">,</span> v<span class="token punctuation">.</span>position<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li></ul><p>类似上面这句代码的功能，就是把顶点坐标转换到其次裁剪坐标系下，接着通常再由硬件做透视除法后，最终得到归一化的设备坐标（Normalized Device Coordinates，NDC）。</p><p><img data-src="image-20220918203104251.png" alt="image-20220918203104251"></p><p>需要注意的是，图 2.8 给出的坐标范围是 OpenGL 同时也是 Unity 使用的 NDC，它的 z 分量范围在 [-1,1] 之间，而在 DirectX 中，NDC 的 z 分量范围是 [0,1]。顶点着色器可以有不同的输出方式。最常见的输出路径是经光栅化后交给片元着色器进行处理。而在现代的 Shader Model 中，它还可以把数据发送给曲面细分着色器或几何着色器。</p><h3 id="裁剪"><a class="anchor" href="#裁剪">#</a> 裁剪</h3><p>由于我们的场景可能会很大，而摄像机的视野范围很有可能不会覆盖所有的场景物体，那些不在摄像机视野范围的物体不需要被处理。而 ** 裁剪（Clipping）** 就是为了完成这个目的而被提出来的。</p><p>一个图元和摄像机视野的关系有 3 种：完全在视野内、部分在视野内、完全在视野内。完全在视野内的图元就继续传递给下一个流水线阶段，完全在视野外的图元不会继续向下传递，因为它们不需要被渲染。<mark>而那些部分在视野内的图元需要进行一个处理，这就是裁剪。</mark></p><p>由于我们已知在 NDC 下的顶点位置，即顶点位置在一个立方体内，因此裁剪就变得很简单：只需要将图元裁剪到单位立方体内。</p><p><img data-src="image-20220918204820455.png" alt="image-20220918204820455"></p><p>和顶点着色器不同，这一步是不可编程的，即我们无法通过编程来控制裁剪的过程，而是硬件上的固定操作，但我们可以自定义一个裁剪操作来对这一步进行配置。</p><h3 id="屏幕映射"><a class="anchor" href="#屏幕映射">#</a> 屏幕映射</h3><p>这一步输入的坐标仍然是三维坐标系下的坐标（范围在单位立方体内）。** 屏幕映射（Screen Mapping）<strong>的任务是把每个图元的 x 和 y 坐标转换到</strong>屏幕坐标系（Screen Coordinates）** 下。屏幕坐标系是一个二维坐标系，它和我们用于显示画面的分辨率有很大关系。</p><p>由于我们输入的坐标范围在 - 1 到 1，因此可以想象到，这个过程实际上是一个缩放的过程。屏幕映射不会对输入的 z 坐标做任何处理。实际上，屏幕坐标系和 z 坐标一起构成了一个坐标系，叫做<strong>窗口坐标系（Window Coordinates）</strong>。这些值会一起被传递到光栅化阶段。</p><p><img data-src="image-20220918205949150.png" alt="image-20220918205949150"></p><p>屏幕映射得到的屏幕坐标决定了这个顶点对应屏幕上哪个像素以及距离这个像素有多远。</p><p>有一个需要引起注意的地方是，屏幕坐标系在 OpenGL 和 DirectX 之间的差异问题。OpenGL 把屏幕的左下角当成最小的窗口坐标值，而 DirectX 则定义了屏幕的左上角为最小的窗口坐标值。</p><p><img data-src="image-20220918210014220.png" alt="image-20220918210014220"></p><p>产生这种差异的原因是，微软的窗口都使用了这样的坐标系统，因为这和我们的阅读方式是一致的：从左到右、从上到下，并且很多图像文件也是按照这样的格式进行存储的。</p><h3 id="三角形设置"><a class="anchor" href="#三角形设置">#</a> 三角形设置</h3><p>由这一步开始就进入了光栅化阶段。从上一个阶段输出的信息是屏幕坐标系下的顶点位置以及和它们相关的额外信息，如深度值（z 坐标）、法线方向、视角方向等。<mark>光栅化阶段有两个最重要的目标：计算每个图元覆盖了哪些像素，以及为这些像素计算它们的颜色。</mark></p><p>光栅化的第一个流水线阶段是<strong>三角形设置（Triangle Setup）</strong>。这个阶段会计算光栅化一个三角网格所需的信息。具体的说，上一个阶段输出的都是三角网格的顶点，即我们得到的是三角网格每条边的两个端点。但如果要得到整个三角网络对像素的覆盖情况，我们就必须计算每条边上的像素坐标。为了能够计算边界像素的坐标信息，我们就需要得到三角形边界的表示方式。这样一个计算三角网络表示数据的过程就叫做三角形设置。它的输出是为了给下一个阶段做准备。</p><h3 id="三角形遍历"><a class="anchor" href="#三角形遍历">#</a> 三角形遍历</h3><p><strong>三角形遍历（Triangle Traversal）<strong>阶段将会检查每个像素是否被一个三角网格锁覆盖。如果被覆盖的话，就会生成一个</strong>片元（fragment）</strong>。而这样一个找到哪些像素被三角网格覆盖的过程就是三角形遍历，这个扫描也被称为<strong>扫描变换（Scan Conversion）</strong>。</p><p><mark>三角形遍历阶段会根据上一个阶段的计算结果来判断一个三角形网格覆盖了哪些像素，并使用三角网格 3 个顶点的顶点信息对整个覆盖区域的像素进行插值。</mark></p><p><img data-src="image-20220918211658920.png" alt="image-20220918211658920"></p><p>这一步的输出就是得到一个片元序列。需要注意的是，一个片元并不是真正意义上的像素，而是包含了很多状态的集合，这些状态用于计算每个像素的最终颜色。这些状态包括了（但不限于）它的屏幕坐标、深度信息，以及其他从集合阶段输出的顶点信息，例如法线，纹理坐标等。</p><h3 id="片元着色器"><a class="anchor" href="#片元着色器">#</a> 片元着色器</h3><p><strong>片元着色器（Fragment Shader）<strong>是另一个非常重要的可编程着色器阶段。在 DirectX 中，片元着色器被称为</strong>像素着色器（Pixel Shader）</strong>，但片元着色器是一个更合适的名字，因为此时的片元并不是一个真正意义上的像素。</p><p>前面的光栅化阶段实际上并不会影响屏幕上每个像素的颜色值，而是会产生一系列的数据信息，用来表述一个三角网络是怎样覆盖每个像素的。而每个片元就负责存储这样一系列数据。真正会对像素产生影响的阶段是下一个流水线阶段 --<strong> 逐片元操作（Per-Fragment Operations）</strong>。</p><p>片元着色器的输入是上一个阶段对顶点信息插值得到的结果，更具体来说，是根据那些从顶点着色器中输出的数据插值得到的。而它的输出是一个或者多个颜色值。</p><p><img data-src="image-20220918213448999.png" alt="image-20220918213448999"></p><p>这一阶段可以完成很多重要的渲染技术，其中最重要的技术之一就是纹理采样。为了在片元着色器中进行纹理采样，我们通常会在顶点着色器阶段输出每个顶点对应的纹理坐标，然后经过光栅化阶段对三角网络的 3 个顶点对应的纹理坐标进行插值后，就可以得到其覆盖的片元的纹理坐标了。</p><p>虽然片元着色器可以完成很多重要效果，但它的局限在于，它仅可以影响单个片元。也就是说，当执行片元着色器时，它不可以将自己的任何结果直接发送给它的邻居们。有一个情况例外，就是片元着色器可以访问到导数信息（gradient，或者说是 derivation）。</p><h3 id="逐片元操作"><a class="anchor" href="#逐片元操作">#</a> 逐片元操作</h3><p>终于到了渲染流水线的最后一步。<strong>逐片元操作（Per-Fragment Operations）<strong>是 OpenGL 中的说法，在 DirectX 中，这一阶段被称为</strong>输出合并阶段（Output-Merger）</strong>。</p><p>这一阶段有几个主要任务。</p><ol><li>决定每个片元的可见性。这涉及了很多测试工作，例如深度测试、模板测试等。</li><li>如果一个皮纳元通过了所有的测试，就需要把这个片元的颜色值和已经存储在颜色缓冲区中的颜色进行合并，或者说是混合。</li></ol><p>需要指明的是，逐片元操作阶段是高度可配置性的，即我们可以设置每一步的操作细节。</p><p>这个阶段首先需要解决每个片元的可见性问题。这需要进行一系列测试。如果它没有通过其中的某一个测试，那么对不起，之前为了产生这个片元所做的所有工作都是白费的，因为这个片元会被舍弃掉。</p><p><img data-src="image-20220918225019612.png" alt="image-20220918225019612"></p><p>测试的过程实际上是个比较复杂的过程，而且不同的图形接口（例如 OpenGL 和 DirectX）的实现细节也不尽相同。这里给出两个最基本的测试 -- 深度测试和模板测试的实现过程。是否理解这些测试过程将关乎是否可以理解后后面提到的渲染队列，尤其是处理透明效果时出现的问题。</p><p><img data-src="image-20220918225312507.png" alt="image-20220918225312507"></p><p>先来看看<strong>模板测试（Stencil Test）</strong>。与之相关的是模板缓冲（Stencil Buffer）。实际上，模板缓冲和我们经常听到的颜色缓冲、深度缓冲几乎是一类东西。如果开启了模板测试，GPU 会首先读取（使用读取掩码）模板缓冲区中该片元位置的模板值，然后将该值和读取（使用读取掩码）到的参考值（reference value）进行比较，这个比较函数可以是由开发者指定的，例如小于时舍弃该片元，或者大于等于时舍弃该片元。如果这个片元没有通过这个测试，该片元就会被舍弃。不管一个片元有没有通过模板测试，我们都可以根据模板测试和下面的深度测试结果来修改模板缓冲区，这个修改操作也是由开发者指定的。开发者可以设置不同结果下的修改结果，例如，在失败时模板缓冲区保持不变，通过时将模板缓冲区中对应位置的值加 1 等。模板测试通常用于限制渲染的区域。另外，模板测试还有一些更高级的用法，如渲染阴影、轮廓渲染等。</p><p>如果一个片元幸运地通过了模板测试，那么它会进行下一个测试 --<strong> 深度测试（Depth Test）</strong>。这个测试同样是可以高度配置的。如果开启了深度测试，GPU 会把该片换的深度值和已经存在于深度缓冲区中的深度值进行比较。这个比较函数也是可由开发者设置的，例如小于时舍弃该片元，或者大于等于时舍弃该片元。通常这个比较函数是小于等于的关系，即如果这个片元的深度值大于等于当前深度缓冲区中的值，那么就会舍弃它。这是因为，我们总想只显示出离摄像机最近的物理，而那些被其他物体遮挡的就不要出现在屏幕上。如果这个片元没有通过这个测试，该片元就会被舍弃。<mark>和模板测试有些不同的是，如果一个片元没有通过深度测试，它就没有权力更改深度缓冲区中的值。而如果它通过了测试，开发者还可以指定是否要用这个片元的深度值覆盖掉原有的深度值，这是通过开启 / 关闭深度写入来做到的。</mark></p><p>如果一个幸运的片元通过了上面所有测试，它就可以自豪地来到<strong>合并</strong>功能的面前。</p><p>这里所讨论的渲染过程是一个物体接着一个物体画到屏幕上的。而每个像素的颜色信息被存储在一个名为颜色缓冲的地方。因此，当我们执行这次渲染时，颜色缓冲中往往已经有了上次渲染之后的颜色结果，那么，我们是使用上一次渲染之后的颜色结果，还是进行其他处理？这就是合并需要解决的问题。</p><p>对于不透明物体，开发者可以关闭 ** 混合（Blend）** 操作。这样片元着色器计算得到的颜色值就会直接覆盖掉颜色缓冲区中的像素值。但对于半透明物体，我们就需要使用混合操作来让这个物体看起来是透明的。</p><p><img data-src="image-20220918231548839.png" alt="image-20220918231548839"></p><p>混合操作也是可以高度配置的：开发者可以选择开启 / 关闭混合功能。如果没有开启混合功能，就会直接使用片元的颜色覆盖掉颜色缓冲区中的颜色。如果开启了混合，GPU 会取出源颜色和目标颜色，将两种颜色进行混合。源颜色指的是片元着色器得到的颜色值，而目标颜色则是已经存在于颜色缓冲区中的颜色。之后，就会使用一个混合函数来进行混合操作。这个混合函数通常和透明统到息息相关，例如根据透明通道的值进行相加、相减、相乘等。</p><p>上面给出的测试顺序并不是唯一的，而且虽然从逻辑上来说这些测试是在片元着色器之后进行的，但对于大多数 GPU 来说，它们会尽可能在执行片元着色器之前就进行这些测试。</p><p>作为一个想充分提高性能的 GPU，它会希望尽可能早地指导哪些片元是会被舍弃的，对于这些片元就不需要再使用片元着色器来计算它们的颜色。再 Unity 给出的渲染流水线中，我们也可以发现它给出的深度测试是在片元着色器之前。深度测试提前执行的技术通常也被称为 Early-Z 技术。</p><p>但是，如果将这些测试提前的话，其检测结果可能会与片元着色器中的一些操作冲突。例如，如果我们再片元着色器进行了透明度测试，而这个片元没有通过透明度测试，我们会在着色器中调用 API（例如 clip 函数）来手动将其舍弃掉。这就导致 GPU 无法提前执行各种测试。因此，现代的 GPU 会判断片元着色器的操作是否和提前测试发生冲突，如果有冲突，就会禁用提前测试。但是，这样也会造成性能上的下降，因为有更多片元需要被处理了。这也是透明度测试会导致性能下降的原因。</p><p>当模型的图元经过了上面层层计算和测试后，就会显示到我们的屏幕上。我们的屏幕显示的就是颜色缓冲区中的颜色值。但是，为了避免我们看到那些正在进行光栅化的图元，GPU 会使用 ** 双重缓冲（Double Buffering）<strong>的策略。这意味着，对场景的渲染是在幕后发生的，即在</strong>后置缓冲（Back Buffer）<strong>中。一旦场景已经被渲染到了后置缓冲中，GPU 就会交换后置缓冲区和</strong>前置缓冲（Front Buffer）** 中的内容，而前置缓冲区是之前显示在屏幕上的图像。因此，保证了我们看到的图像总是连续的。</p><h3 id="总结"><a class="anchor" href="#总结">#</a> 总结</h3><p>虽然渲染流水线比较复杂，但 Unity 为我们封装了很多功能。更多的时候，我们只需要在一个 Unity Shader 设置一些输入、编写顶点着色器和片元着色器、设置一下屏幕状态就可以达到大部分常见的屏幕效果。但这样的缺点在于，封装性会导致编程自由度下降，容易迷失方向，无法掌握其背后的原理，并在出现问题时，往往无法找到错误原因，这是在学习 Unity Shader 时普遍的遭遇。建议：多看教程，一个教程看不懂就换个教程，别指望能靠一个教程就把所有的东西都学会。</p><h2 id="一些容易困惑的地方"><a class="anchor" href="#一些容易困惑的地方">#</a> 一些容易困惑的地方</h2><h3 id="什么是opengldirectx"><a class="anchor" href="#什么是opengldirectx">#</a> 什么是 OpenGL/DirectX</h3><p>OpenGL 和 DirectX 是图像应用编程接口，这些接口用于渲染二维或三维图形。可以说这些接口架起了上层应用程序和底层 GPU 的沟通桥梁。一个应用程序向这些接口发送渲染命令，而这些接口会一次向显卡驱动（Graphics Driver）发送渲染命令，这些显卡驱动是真正指导如何和 GPU 通信的角色，正是它们把 OpenGL 或者 DirectX 的函数调用翻译成了 GPU 所能够听懂的语言，同时它们也负责把纹理等数据转换成 GPU 所支持的格式。<mark>一个比喻是，显卡驱动就是显卡的操作系统。</mark></p><p>概括来说，我们的应用程序运行在 CPU 上。应用程序可以通过调用 OpenGL 或 DirectX 的图形接口将渲染所需的数据，如顶点数据、纹理数据、材质参数等数据存储在显存中的特定区域。随后，开发者可以通过图像编程接口发出渲染命令，这些渲染命令也被称为 Draw Call，它们将会被显卡驱动翻译成 GPU 能够理解的代码，进行真正的绘制。</p><p>因为显卡驱动的存在，几乎所有的 GPU 都既可以和 OpenGL 合作，也可以和 DirectX 一起工作。显卡制作商只需要提供支持 OpenGL 和 DirectX 接口的显卡驱动即可。</p><p><img data-src="image-20220919095347993.png" alt="image-20220919095347993"></p><h3 id="什么是hlsl-glsl-cg"><a class="anchor" href="#什么是hlsl-glsl-cg">#</a> 什么是 HLSL、GLSL、Cg</h3><p>在可编程管线出现之前，为了编写着色器代码，开发者们学习汇编语言。为了给开发者们打开更方便的大门，就出现了更高级的着色语言（Shading Language）。着色语言是专门用于编写着色器的，常见的着色语言有 DirectX 的 HLSL（High Level Shading Language）、OpenGL 的 GLSL（OpenGL Shading Language）以及 NVIDIA 的 Cg（C for Graphic）。HLSL、GLSL、Cg 都是 “高级（High-Level）” 语言，但这种高级是相对于汇编语言来说的，而不是像 C# 相对于 C 的高级那样。这些语言会被编译成与机器无关的汇编语言，也被称为中间语言（Intermediate Language，IL）。这些中间语言再交给显卡驱动来翻译成真正的机器语言，即 GPU 可以理解的语言。</p><p>GLSL 的优点在于它的跨平台性，它可以在 Windows、Linux、Mac 甚至移动平台等多种平台上工作，但这种跨平台性是由于 OpenGL 没有提供着色器编译器，而是由显卡驱动来完成着色器的编译工作。也就是说，只要显卡驱动支持对 GLSL 的编译它就可以运行。这种做法的好处在于，由于供应商完全了解自己的硬件构造，它们知道怎样做可以发挥出最大的作用。<mark>换句话说，GLSL 是以来硬件，而非操作系统层级的。</mark></p><p>而对于 HLSL，是由未然控制着色器的编译，就算使用了不同的硬件，同一个着色器的编译结果也是一样的（前提是版本相同）。但也因此支持 HLSL 的平台相对比较有限，几乎完全是微软自己的产品，如 Windows、Xbox 360 等。这是因为在其他平台上没有可以编译 HLSL 的编译器。</p><p>Cg 则是真正意义上的跨平台。他会根据平台的不同，编译成相应的中间语言。Cg 语言的跨平台性很大原因取决于与微软的合作，这也导致 Cg 语言的语法和 HLSL 非常像，Cg 可以无缝移植成 HLSL 代码。但缺点是可以无法完全发挥出 HLSL 的最新特性。</p><p>对于 Unity 平台，我们同样可以选择使用哪种语言。在 Unity Shader 中，我们可以选择使用 “Cg/HLSL” 或者 “GLSL”。带引号是因为 Unity 里的这些着色语言并不是真正意义上的对应着色语言，尽管它们的语法几乎一样。</p><h3 id="什么是draw-call"><a class="anchor" href="#什么是draw-call">#</a> 什么是 Draw Call</h3><p><strong>问题一：CPU 和 GPU 是如何实现并行工作的？</strong></p><p>如何让 CPU 和 GPU 可以并行工作，使用到了一个叫做 ** 命令缓冲区（Command Buffer）** 的东西。</p><p>命令缓冲区包含了一个命令队列，由 CPU 向其中添加命令，而由 GPU 从中读取命令，添加和读取的过程是互相独立的。命令缓冲区使得 CPU 和 GPU 可以相互独立工作。当 CPU 需要渲染一些对象时，它可以向命令缓冲区中添加命令，当 GPU 完成了上一次的渲染任务后，它就可以从命令队列中再取出一个命令并执行它。</p><p>命令缓冲区中的命令有很多种类，而 Draw Call 是其中一种，其他命令还有改变渲染状态等（例如改变使用的着色器，使用不同的纹理等）。</p><p><img data-src="image-20220919104944362.png" alt="image-20220919104944362"></p><p><strong>问题二：为什么 Draw Call 多了会影响帧率？</strong></p><p>在每次调用 Draw Call 之前，CPU 需要向 GPU 发送很多内容，包括数据、状态和命令等。在这一阶段，CPU 需要完成很多工作，例如查看渲染状态等。而一旦 CPU 完成了这些准备工作，GPU 就可以开始本次的渲染。GPU 的渲染能力很强，渲染 200 个还是 2000 个三角网格通常没有什么区别，因此渲染速度往往快于 CPU 提交命令的速度。如果 Draw Call 的数量太多，CPU 就会把大量时间花费在提交 Draw Call 上，造成 CPU 的过载。</p><p><img data-src="image-20220919105638177.png" alt="image-20220919105638177"></p><p><strong>问题三：如何减少 Draw Call？</strong></p><p>减少 Draw 的方法有很多，这里我们仅讨论使用 ** 批处理（Batching）** 的方法。</p><p>提交大量很小的 Draw Call 会造成 CPU 的性能瓶颈，即 CPU 把时间都花费在准备 Draw Call 的工作上了。那么，一个很显然的优化想法就是把很多小的 DrawCall 合并成一个大的 DrawCall，这就是批处理的思想。</p><p>需要注意的是，由于我们需要在 CPU 的内存中合并网格，而合并的过程是需要消耗时间的。因此，批处理技术更加适合那些静态的物体，例如不会移动的大地、石头等，对于这些静态物体我们只需要合并一次即可。当然，我们也可以对动态物体进行批处理。但是，由于这些物体是不断运动的，因此每一帧都需要重新进行合并然后再发给 GPU，这对空间和时间都会造成一定的影响。</p><p><img data-src="image-20220919135911865.png" alt="image-20220919135911865"></p><p>在游戏开发过程中，为了减少 Draw Call 的开销，有两点需要注意。</p><ol><li>避免使用大量很小的网络。当不可避免地需要使用很小的网络结果时，考虑是否可以合并它们。</li><li>避免使用过多的材质。尽量在不同的网格之间共用同一个材质。</li></ol><h3 id="什么是固定渲染管线"><a class="anchor" href="#什么是固定渲染管线">#</a> 什么是固定渲染管线</h3><p><strong>固定函数的流水线（Fixed-Function Pipeline）</strong>，也称为固定管线，通常是指在较旧的 GPU 上实现的渲染流水线。这种流水线只给开发者提供一些配置操作，但开发者没有对流水线阶段的完全控制权。</p><p>随着 GPU 的发展，固定管线已经逐渐退出历史舞台。</p><div class="tags"><a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 学习笔记</a> <a href="/tags/CG/" rel="tag"><i class="ic i-tag"></i> CG</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2023-11-22 08:10:45" itemprop="dateModified" datetime="2023-11-22T08:10:45+08:00">2023-11-22</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Sakupinera WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Sakupinera Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Sakupinera PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Sakupinera <i class="ic i-at"><em>@</em></i>Sakupinera</li><li class="link"><strong>Post link: </strong><a href="http://sakupinera.github.io/2022/09/19/computer-graphics/unityshader/%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/" title="UnityShader - 渲染流水线">http://sakupinera.github.io/2022/09/19/computer-graphics/unityshader/渲染流水线/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/09/18/computer-graphics/games101/%E5%8F%98%E6%8D%A2/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;03&#x2F;08&#x2F;wi84uPUELq2rcnD.jpg" title="GAMES101 - Transformation（变换）"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i> GAMES101</span><h3>GAMES101 - Transformation（变换）</h3></a></div><div class="item right"><a href="/2022/09/22/computer-graphics/games101/%E5%85%89%E6%A0%85%E5%8C%96/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;03&#x2F;08&#x2F;rkHPIpA3EmFKe7i.png" title="GAMES101 - Rasterization（光栅化）"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i> GAMES101</span><h3>GAMES101 - Rasterization（光栅化）</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">1.</span> <span class="toc-text">渲染流水线</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%BC%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">综述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cpu%E5%92%8Cgpu%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">1.2.</span> <span class="toc-text">CPU 和 GPU 之间的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E5%88%B0%E6%98%BE%E5%AD%98%E4%B8%AD"><span class="toc-number">1.2.1.</span> <span class="toc-text">把数据加载到显存中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%B8%B2%E6%9F%93%E7%8A%B6%E6%80%81"><span class="toc-number">1.2.2.</span> <span class="toc-text">设置渲染状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8draw-call"><span class="toc-number">1.2.3.</span> <span class="toc-text">调用 Draw Call</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gpu%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">1.3.</span> <span class="toc-text">GPU 流水线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">顶点着色器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%81%E5%89%AA"><span class="toc-number">1.3.3.</span> <span class="toc-text">裁剪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%8F%E5%B9%95%E6%98%A0%E5%B0%84"><span class="toc-number">1.3.4.</span> <span class="toc-text">屏幕映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E5%BD%A2%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.3.5.</span> <span class="toc-text">三角形设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E5%BD%A2%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.6.</span> <span class="toc-text">三角形遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%87%E5%85%83%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">1.3.7.</span> <span class="toc-text">片元着色器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%90%E7%89%87%E5%85%83%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.8.</span> <span class="toc-text">逐片元操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.9.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%AE%B9%E6%98%93%E5%9B%B0%E6%83%91%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="toc-number">1.4.</span> <span class="toc-text">一些容易困惑的地方</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFopengldirectx"><span class="toc-number">1.4.1.</span> <span class="toc-text">什么是 OpenGL&#x2F;DirectX</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFhlsl-glsl-cg"><span class="toc-number">1.4.2.</span> <span class="toc-text">什么是 HLSL、GLSL、Cg</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFdraw-call"><span class="toc-number">1.4.3.</span> <span class="toc-text">什么是 Draw Call</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%BA%E5%AE%9A%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF"><span class="toc-number">1.4.4.</span> <span class="toc-text">什么是固定渲染管线</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"><ul><li class="active"><a href="/2022/09/19/computer-graphics/unityshader/%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/" rel="bookmark" title="UnityShader - 渲染流水线">UnityShader - 渲染流水线</a></li></ul></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sakupinera" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Sakupinera</p><div class="description" itemprop="description">保持你的决心！</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">86</span> <span class="name">posts</span></a></div><div class="item categories"><a href="/categories/"><span class="count">13</span> <span class="name">categories</span></a></div><div class="item tags"><a href="/tags/"><span class="count">6</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nha3VwaW5lcmE=" title="https:&#x2F;&#x2F;github.com&#x2F;sakupinera"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9zYWt1cGluZXJh" title="https:&#x2F;&#x2F;twitter.com&#x2F;sakupinera"><i class="ic i-twitter"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQwNzIyOTA3MQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;407229071"><i class="ic i-cloud-music"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMjIzMDczOTg/c3BtX2lkX2Zyb209MzMzLjEwMDcuMC4w" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;22307398?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li><li class="item"><a href="/games/" rel="section"><i class="ic i-flag"></i>Games</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-person"></i>About</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/09/18/computer-graphics/games101/%E5%8F%98%E6%8D%A2/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/09/22/computer-graphics/games101/%E5%85%89%E6%A0%85%E5%8C%96/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/23/csharp/clr-via-csharp/Chapter%2019%20Nullable%20Value%20Types/" title="CLR via C# - Chapter 19 Nullable Value Types">CLR via C# - Chapter 19 Nullable Value Types</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/" title="CLR via C# - Chapter 20 Exceptions and State Management">CLR via C# - Chapter 20 Exceptions and State Management</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/09/05/linux/learn-linux/%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/" title="LearnLinux - 备份与恢复">LearnLinux - 备份与恢复</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2022/12/11/cpp/cpp-primer/Chapter%203%20Strings,%20Vectors,%20and%20Arrays/" title="C++ Primer - Chapter 3 Strings, Vectors, and Arrays">C++ Primer - Chapter 3 Strings, Vectors, and Arrays</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/08/28/linux/learn-linux/Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/" title="LearnLinux - Linux系统安装">LearnLinux - Linux系统安装</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/" title="CLR via C# - Chapter 14 Chars, Strings, and Working with Text">CLR via C# - Chapter 14 Chars, Strings, and Working with Text</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/09/18/computer-graphics/games101/%E5%8F%98%E6%8D%A2/" title="GAMES101 - Transformation（变换）">GAMES101 - Transformation（变换）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/" title="CLR via C# - Chapter 22 CLR Hosting and AppDomains">CLR via C# - Chapter 22 CLR Hosting and AppDomains</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/08/28/linux/learn-linux/Linux%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/" title="LearnLinux - Linux系统简介">LearnLinux - Linux系统简介</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/10/21/computer-graphics/games101/%E6%B8%B2%E6%9F%93%E4%B8%AD%E7%9A%84%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/" title="GAMES101 - Advanced Topics in Rendering（渲染中的高级主题）">GAMES101 - Advanced Topics in Rendering（渲染中的高级主题）</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Sakupinera @ Hanamai Sora</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="Symbols count total">2.2m words</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="Reading time total">33:30</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/09/19/computer-graphics/unityshader/渲染流水线/",favicon:{show:"（●´3｀●）Goooood",hide:"(´Д｀)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/shifuku.model.json"},display:{position:"left",width:250,height:500},mobile:{show:!1},react:{opacity:.9},log:!1})</script></body></html>