<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sakupinera" href="http://sakupinera.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sakupinera" href="http://sakupinera.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sakupinera" href="http://sakupinera.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="读书笔记,C#"><link rel="canonical" href="http://sakupinera.github.io/2022/12/06/csharp/clr-via-csharp/Chapter%2025%20Interoperating%20with%20WinRT%20%20Components/"><title>CLR via C# - Chapter 25 Interoperating with WinRT Components - CLR-via-CSharp - CSharp | Hanamai Sora = Sakupinera</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">CLR via C# - Chapter 25 Interoperating with WinRT Components</h1><div class="meta"><span class="item" title="Created: 2022-12-06 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2022-12-06T00:00:00+08:00">2022-12-06</time> </span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">Symbols count in article</span> <span>51k</span> <span class="text">words</span> </span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">Reading time</span> <span>46 mins.</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hanamai Sora</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s2.loli.net/2023/03/08/jV3gF2wSUYTdtsp.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/EXaiHD39BF7QWok.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/AK1D84aqsYghTOC.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/DFUCvo21fTb5mwG.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/Z2usRnE64TXN1Lp.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/J4XewNCOu8fzIy9.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/" itemprop="item" rel="index" title="In CSharp"><span itemprop="name">CSharp</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/CLR-via-CSharp/" itemprop="item" rel="index" title="In CLR-via-CSharp"><span itemprop="name">CLR-via-CSharp</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://sakupinera.github.io/2022/12/06/csharp/clr-via-csharp/Chapter%2025%20Interoperating%20with%20WinRT%20%20Components/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Sakupinera"><meta itemprop="description" content=", 保持你的决心！"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakupinera"></span><div class="body md" itemprop="articleBody"><h1 id="chapter-25-interoperating-with-winrt-components"><a class="anchor" href="#chapter-25-interoperating-with-winrt-components">#</a> Chapter 25 Interoperating with WinRT Components</h1><blockquote><p>Windows 8 comes with a new class library allowing applications to access operating system functionality. The formal name for this class library is the Windows Runtime (WinRT) and its components are accessible using the WinRT type system. WinRT has many of the same goals that the Common Language Runtime (CLR) had when it was first introduced, such as simplifying application development and allowing code implemented in different programming languages to easily interoperate with one another. Specifically, Microsoft supports consuming WinRT components from native C/C++, JavaScript (when using Microsoft’s “Chakra” JavaScript virtual machine), as well as C# and Visual Basic via the CLR.</p></blockquote><blockquote><p>Figure 25-1 shows the kinds of features exposed by Windows’s WinRT components and the various languages that Microsoft supports to access them. For applications implemented with native C/C++, the developer must compile his or her code for each CPU architecture (x86, x64, and ARM). But Microsoft .NET Framework developers need to compile their code just once into Intermediate Language (IL) and then the CLR compiles that into the native code specific to the host CPU. JavaScript developers actually ship the source code to their application and the “Chakra” virtual machine parses the source code and compiles it into native code specific to the host machine’s CPU. Other companies can produce languages and environments that support interoperating with WinRT components too.</p></blockquote><blockquote><p>Windows Store Apps and desktop applications can leverage operating system functionality by using these WinRT components. Today, the number of WinRT components that ship as part of Windows is relatively tiny when compared to the size of the .NET Framework’s class library. However, this is by design, because the components are focused on exposing what an operating system does best: abstracting hardware and cross-application facilities to application developers. So, most of the WinRT components expose features, such as storage, networking, graphics, media, security, threading, and so on. Other core language services (like string manipulation) and more complex frameworks (like language integrated query) are not offered by the operating system and are instead provided by the language being used to access the operating system’s WinRT components.</p></blockquote><p><img data-src="/2022/12/06/csharp/clr-via-csharp/Chapter%2025%20Interoperating%20with%20WinRT%20%20Components/image-20221205200521173.png" alt="image-20221205200521173"></p><blockquote><p>WinRT components are internally implemented as Component Object Model (COM) components, which is a technology that Microsoft introduced in 1993. At the time, COM was considered a complicated model with a lot of arcane rules and a very tedious programming model. However, there are a lot of good ideas in COM, and over the years, Microsoft has tweaked it in an effort to greatly simplify it. For WinRT components, Microsoft made a very significant tweak: instead of using type libraries to describe a COM component’s API, they now use metadata. That’s right, WinRT components describe their API using the same .NET metadata format (ECMA-335) as was standardized by the ECMA committee. This is the same metadata format I’ve been discussing throughout this whole book.</p></blockquote><blockquote><p>Metadata is much richer than type libraries and the CLR already has a complete understanding of metadata. In addition, the CLR has supported interoperating with COM components via Runtime Callable Wrappers (RCWs) and COM Callable Wrappers (CCWs) because its inception. For the most part, this allows languages (like C#) running on top of the CLR to seamlessly interoperate with WinRT types and components.</p></blockquote><blockquote><p>In C#, when you have a reference to a WinRT object, you really have a reference to an RCW that internally refers to the WinRT object. Similarly, if you pass a CLR object to a WinRT API, you are really passing a reference to a CCW to the WinRT API and the CCW holds a reference to your CLR object.</p></blockquote><blockquote><p>WinRT components have their metadata embedded in files with a .winmd file extension. The WinRT components that ship with Windows have their metadata in the various Windows.*.winmd files, which can be found in the %WinDir%\System32\WinMetadata directory. When building an app, you would reference the one Windows.winmd file that the Windows SDK installs here.</p></blockquote><pre><code class="language-cmd">%ProgramFiles(x86)%\Windows Kits\8.0\References\CommonConfiguration\Neutral\Windows.winmd
</code></pre><blockquote><p>A major design goal of the Windows Runtime type system is to enable developers to be successful in writing apps by using the technologies, tools, practices, and conventions that are already familiar and well-known to them. In order to achieve this, some WinRT features are projected to the respective development technologies. For .NET Framework developers, there are two kinds of projections:</p><ul><li><p>CLR projections CLR projections are mappings performed implicitly by the CLR, usually related to reinterpreting metadata. The next section focuses on the WinRT Component Type System Rules and how the CLR projects these rules to the .NET Framework developer.</p></li><li><p>Framework projections Framework projections are mappings performed explicitly in your code by leveraging new APIs introduced into the Framework Class Library. Framework projections are required when the impedance mismatch between the WinRT type system and the CLR’s type system is too great for the CLR to do it implicitly. Framework projections are discussed later in this chapter.</p></li></ul></blockquote><p>💡小结：Windows 8/8.1 带来了一个新类库，应用程序可通过它访问操作系统功能。类库正式名称是 Windows 运行时 (Windows Runtime， WinRT)，其组件通过 WinRT 类型系统访问。对于原生 C/C++ 实现的应用程序，开发人员必须为每种 CPU 架构 (x86，x64 和 ARM) 单独编译代码。相比之下，.NET 开发人员只需编译一次 (编译成 IL，CLR 自行将其编译成与主机 CPU 对应的本机代码)。JavaScript 应用程序则自带了源代码，“Chakra” 虚拟机解析这些源代码，把它编译成与主机 CPU 对应的本机代码。Windows 配套提供的 WinRT 组件数量比 .NET Framework 类库小多了。但设计就是这样的，组件的目的是公开操作系统最擅长的事情，也就是对硬件和跨应用程序的功能进行抽象。所以，大多数 WinRT 组件都只是公开了功能，比如存储、联网、图形、媒体、安全性、线程处理等。而其他核心语言服务 (比如字符串操作) 和较复杂的框架 (比如 LINQ) 不是由操作系统提供，而是由访问 WinRT 组件的语言提供。WinRT 组件内部作为 “组件对象模型”(Component Object Model，COM) 组件来实现，后者是 Microsoft 1993 年推出的技术。COM 当年被认为过于复杂，规则过于难解，是一个很让人头疼的编程模型。但 COM 实际是有许多亮点的。多年来，Microsoft 对其进行了大量修订，显著地进行了简化。Microsoft 对 WinRT 组件进行了一个很大的调整，不是使用类库来描述 COM 组件的 API，而是使用元数据。你没有看错，WinRT 组件使用由 ECMA 协会标准化的 .NET 元数据格式 (ECMA-335) 来描述其 API。这个元数据格式正是本书一直在讨论的。元数据比类库更有表现力，而且 CLR 已经对元数据有了全面理解。此外，CLR 一开始就通过运行时可调用包装器 (Runtime Callable Wrapper，RCW) 和 COM 可调用包装器 (COM Callable Wrapper，CCW) 实现了与 COM 组件的互操作。这使在 CLR 顶部运行的语言 (如 C#) 能无缝地与 WinRT 类型和组件进行互操作。在 C# 中引用 WinRT 对象，实际获得的是对一个 RCW 的引用，RCW 内部引用了 WinRT 组件。类似地，将一个 CLR 对象传给 WinRT API，实际传递的是一个 CCW 引用，CCW 内部容纳了对 CLR 对象的引用。WinRT 组件将元数据嵌入扩展名为 .winmd 的文件中 (winmd 代表 Windows MetaData)。Windows 搭载的 WinRT 组件将元数据存储到各种 Windows.*.winmd 文件中，这些文件可在 % WinDir%\System32\WinMetadata 目录中找到。Windows Runtime 类型系统的一个主要设计目标是使开发人员能使用他们擅长的技术、工具、实践以及约定写应用。为此，有的 WinRT 功能被投射 &lt; sup&gt;②&lt;/sup &gt; 成对应的开发技术。<span class="exturl" data-url="aHR0cDovL3huLS1jZXQxOTJrLk5FVA==">针对.NET</span> Framework 开发人员主要有两种投射：CLR 投射和 Framework 投射。CLR 投射由 CLR 隐式执行，通常和元数据的重写解释有关。Framework 投射由你的代码显式执行，这是通过 FCL 新引入的 API 来执行的。如果 WinRT 类型系统和 CLR 类型系统差异太大，造成 CLR 不能隐式地投射，就需要用到 Framework 投射。</p><h2 id="clr-projections-and-winrt-component-type-system-rules"><a class="anchor" href="#clr-projections-and-winrt-component-type-system-rules">#</a> CLR Projections and WinRT Component Type System Rules</h2><blockquote><p>WinRT components conform to a type system similar to how the CLR enforces a type system. When the CLR sees a WinRT type, it usually allows that type to be used via the CLRs normal COM interop technologies. But, in some cases, the CLR hides the WinRT type (by dynamically setting it to private) and then the CLR exposes the type via a different type. Internally, the CLR is looking for certain types (via metadata) and then mapping these types to types in the Framework Class Library. For the complete list of WinRT types that the CLR implicitly projects to Framework Class Library types, see http:// <span class="exturl" data-url="aHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L3dpbmRvd3MvYXBwcy9oaDk5NTA1MC5hc3B4">msdn.microsoft.com/en-us/library/windows/apps/hh995050.aspx</span>.</p></blockquote><h3 id="winrt-type-system-core-concepts"><a class="anchor" href="#winrt-type-system-core-concepts">#</a> WinRT Type System Core Concepts</h3><blockquote><p>The WinRT type system is not as feature rich as the CLR’s type system. This bulleted list describes the WinRT type system’s core concepts and how the CLR projects them:</p><ul><li><p>File names and namespaces The name of the .winmd file itself must match the name of the namespace containing the WinRT components. For example, a file named Wintellect. WindowsStore.winmd must have WinRT components defined in a Wintellect.WindowsStore namespace or in a sub-namespace of Wintellect.WindowsStore. Because the Windows file system is case insensitive, namespaces that differ by case only are not allowed. Also, a WinRT component cannot have the same name as a namespace.</p></li><li><p>Common base type WinRT components do not share a common base class. When the CLR projects a WinRT type, it appears as if the WinRT type is derived from System.Object and therefore all WinRT types inherit public methods like ToString, GetHashCode, Equals, and GetType. So, when using a WinRT object via C#, the object will look like it is derived from System.Object, and you can pass WinRT objects throughout your code. You can also call the “inherited” methods such as ToString.</p></li><li><p>Core data types The WinRT type system supports the core data types such as Boolean, unsigned byte, 16-bit, 32-bit, and 64-bit signed and unsigned integer numbers, single-precision and double-precision floating-point numbers, 16-bit character, strings, and void.1 Like in the CLR, all other data types are composed from these core data types.</p></li><li><p>Classes WinRT is an object-oriented type system, meaning that WinRT components support data abstraction, inheritance, and polymorphism.2 However, some languages (like JavaScript) do not support type inheritance and in order to cater to these languages, almost no WinRT components take advantage of inheritance. This means they also do not take advantage of polymorphism. In fact, only WinRT components consumable from non-JavaScript languages leverage inheritance and polymorphism. For the WinRT components that ship with Windows, only the XAML components (for building user interfaces) take advantage of inheritance and polymorphism. Applications written in JavaScript use HTML and CSS to produce their user interface instead.</p></li><li><p>Structures WinRT supports structures (value types), and instances of these are marshaled by value across the COM interoperability boundary. Unlike CLR value types, WinRT structures can only have public fields of the core data types or of another WinRT structure.3 In addition, WinRT structures cannot have any constructors or helper methods. For convenience, the CLR projects some operating system WinRT structures as some native CLR types, which do offer constructors and helper methods. These projected types feel more natural to the CLR developer. Examples include the Point, Rect, Size, and TimeSpan structures all defined in the Windows.Foundation namespace.</p></li><li><p>Nullable Structures WinRT APIs can expose nullable structures (value types). The CLR projects the WinRT’s Windows.Foundation.IReference interface as the CLR’s System.Nullable type.</p></li><li><p>Enumerations An enumeration value is simply passed as a signed or unsigned 32-bit integer. If you define an enumeration type in C#, the underlying type must be either int or uint. Also, signed 32-bit integer enums are considered to be discreet values, whereas unsigned 32-bit enums are considered to be flags capable of being OR’d together.</p></li><li><p>Interfaces A WinRT interface’s members must specify only WinRT-compatible types for parameters and return types.</p></li><li><p>Methods WinRT has limited support for method overloading. Specifically, because JavaScript has dynamic typing, it can’t distinguish between methods that differ only by the types of their parameters. For example, JavaScript will happily pass a number to a method expecting a string. However, JavaScript can distinguish between a method that takes one parameter and a method that takes two parameters. In addition, WinRT does not support operator overload methods and default argument values. Furthermore, arguments can only be marshaled in or out; never in and out. This means you can’t apply ref to a method argument but out is OK. For more information about this, see the “Arrays” bullet point in the next list.</p></li><li><p>Properties WinRT properties must specify only WinRT-compatible types for their data type. WinRT does not support parameterful properties or write-only properties.</p></li><li><p>Delegates WinRT delegate types must specify only WinRT components for parameter types and return types. When passing a delegate to a WinRT component, the delegate object is wrapped with a CCW and will not get garbage collected until the CCW is released by the WinRT component consuming it. WinRT delegates do not have BeginInvoke and EndInvoke methods.</p></li><li><p>Events WinRT components can expose events by using a WinRT delegate type. Because most WinRT components are sealed (no inheritance), WinRT defines a TypedEventHandler delegate where the sender parameter is a generic type (as opposed to System.Object).</p></li></ul></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">delegate</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">TypedEventHandler</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>TSender<span class="token punctuation">,</span> TResult<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">TSender</span> sender<span class="token punctuation">,</span> <span class="token class-name">TResult</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>There is also a Windows.Foundation.EventHandler WinRT delegate type that the CLR projects as the .NET Framework’s familiar System.EventHandler delegate type.</p><ul><li><p>Exceptions Under the covers, WinRT components, like COM components, indicate their status via HRESULT values (a 32-bit integer with special semantics). The CLR projects WinRT values of type Windows.Foundation.HResult as exception objects. When a WinRT API returns a well-known failure HRESULT value, the CLR throws an instance of a corresponding Exceptionderived class. For instance, the HRESULT 0x8007000e (E_OUTOFMEMORY) is mapped to a System.OutOfMemoryException. Other HRESULT values cause the CLR to throw a System. Exception object whose HResult property contains the HRESULT value. A WinRT component implemented in C# can just throw an exception of a desired type and the CLR will convert it to an appropriate HRESULT value. To have complete control over the HRESULT value, construct an exception object, assign a specific HRESULT value in the object’s HResult property, and then throw the object.</p></li><li><p>Strings Of course, you can pass immutable strings between the WinRT and CLR type systems. However, the WinRT type system doesn’t allow a string to have a value of null. If you pass null to a string parameter of a WinRT API, the CLR detects this and throws an ArgumentNullException; instead, use String.Empty to pass an empty string into a WinRT API. Strings are passed by reference to a WinRT API; they are pinned on the way in and unpinned upon return. Strings are always copied when returned from a WinRT API back to the CLR. When passing a CLR string array (String[]) to or from a WinRT API, a copy of the array is made with all its string elements and the copy is passed or returned to the other side.</p></li><li><p>Dates and Times The WinRT Windows.Foundation.DateTime structure represents a UTC date/time. The CLR projects the WinRT DateTime structure as the .NET Framework’s System.DateTimeOffset structure, because DateTimeOffset is preferred over the .NET Framework’s System.DateTime structure. The CLR converts the UTC date/time being returned from a WinRT to local time in the resulting DateTimeOffset instance. The CLR passes a DateTimeOffet to a WinRT API as a UTC time.</p></li><li><p>URIs The CLR projects the WinRT Windows.Foundation.Uri type as the .NET Framework’s System.Uri type. When passing a .NET Framework Uri to a WinRT API, the CLR throws an ArgumentException if the URI is a relative URI; WinRT supports absolute URIs only. URIs are always copied across the interop boundary.</p></li><li><p>IClosable/IDisposable The CLR projects the WinRT Windows.Foundation.IClosable interface (which has only a Close method) as the .NET Framework’s System.IDisposable interface (with its Dispose method). One thing to really take note of here is that all WinRT APIs that perform I/O operations are implemented asynchronously. Because IClosable interface’s method is called Close and is not called CloseAsync, the Close method must not perform any I/O operations. This is semantically different from how Dispose usually works in the .NET Framework. For .NET Framework-implemented types, calling Dispose can do I/O and, in fact, it frequently causes buffered data to be written before actually closing a device. When C# code calls Dispose on a WinRT type however, I/O (like writing buffered data) will not be performed and a loss of data is possible. You must be aware of this and, for WinRT components that wrap output streams, you will have to explicitly call methods to prevent data loss. For example, when using a DataWriter, you should always call its StoreAsync method.</p></li><li><p>Arrays WinRT APIs support single-dimension, zero-based arrays. WinRT can marshal an array’s elements in or out of a method; never in and out. Because of this, you cannot pass an array into a WinRT API, have the API modify the array’s elements and then access the modified elements after the API returns.4 I have just described the contract that should be adhered to. However, this contract is not actively enforced, so it is possible that some projections might marshal array contents both in and out. This usually happens naturally due to improving performance. For example, if the array contains structures, the CLR will simply pin the array, pass it to the WinRT API, and then unpin it upon return. In effect, the array’s contents are passed in, the WinRT API can modify the contents and, in effect, the modified contents are returned. However, in this example, the WinRT API is violating the contract and this behavior is not guaranteed to work. And, in fact, it will not work if the API is invoked on a WinRT component that is running out-of-process.</p></li><li><p>Collections When passing a collection to a WinRT API, the CLR wraps the collection object with a CCW and passes a reference to the CCW to the WinRT API. When WinRT code invokes a member on the CCW, the calling thread crosses the interop boundary, thereby incurring a performance hit. Unlike arrays, this means that passing a collection to a WinRT API allows the API to manipulate the collection in place, and copies of the collection’s elements are not being created. Table 25-1 shows the WinRT collection interfaces and how the CLR projects them to .NET application code.</p></li></ul></blockquote><p><img data-src="/2022/12/06/csharp/clr-via-csharp/Chapter%2025%20Interoperating%20with%20WinRT%20%20Components/image-20221205201049228.png" alt="image-20221205201049228"></p><blockquote><p>As you can see from the previous list, the CLR team has done a lot of work to make interoperating between the WinRT type system and the CLR’s type system as seamless as possible so that it is easy for managed code developers to leverage WinRT components in their code.</p></blockquote><p>💡小结：就像 CLR 强制遵循一个类型系统，WinRT 组件也遵循自己的类型系统。CLR 看到一个 WinRT 类型时，通常允许通过 CLR 的一般化 COM 互操作技术来使用该类型。但有时 CLR 会隐藏 WinRT 类型 (将其动态设为私有)。然后，CLR 通过一个不同的类型来公开该类型。在内部，CLR 会查找特定的类型 (通过元数据)，然后将这些类型映射成 FCL 的类型。</p><h2 id="framework-projections"><a class="anchor" href="#framework-projections">#</a> Framework Projections</h2><blockquote><p>When the CLR can’t implicitly project a WinRT type to the .NET Framework developer, the developer must resort to explicitly using framework projections. There are three main technologies where framework projections are required: asynchronous programming, interoperating between WinRT streams and .NET Framework streams, and when passing blocks of data between the CLR and WinRT APIs. These three framework projections are discussed in the following three sections of this chapter. Because many applications require the use of these technologies, it is important that you understand them well and use them effectively.</p></blockquote><h3 id="calling-asynchronous-winrt-apis-from-net-code"><a class="anchor" href="#calling-asynchronous-winrt-apis-from-net-code">#</a> Calling Asynchronous WinRT APIs from .NET Code</h3><blockquote><p>When a thread performs an I/O operation synchronously, the thread can block for an indefinite amount of time. When a GUI thread waits for a synchronous I/O operation to complete, the application’s user interface stops responding to user input, such as touch, mouse, and stylus events, causing the user to get frustrated with the application. To prevent non-responsive applications, WinRT components that perform I/O operations expose the functionality via asynchronous APIs. In fact, WinRT components that perform compute operations also expose this functionality via asynchronous APIs if the CPU operation could take greater than 50 milliseconds. For more information about building responsive applications, see Part V, “Threading” of this book.</p></blockquote><blockquote><p>Because so many WinRT APIs are asynchronous, being productive with them requires that you understand how to interoperate with them from C#. To understand it, examine the following code.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">WinRTAsyncIntro</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">IAsyncOperation<span class="token punctuation">&lt;</span>StorageFile<span class="token punctuation">></span></span> asyncOp <span class="token operator">=</span> KnownFolders<span class="token punctuation">.</span>MusicLibrary<span class="token punctuation">.</span><span class="token function">GetFileAsync</span><span class="token punctuation">(</span><span class="token string">"Song.mp3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> asyncOp<span class="token punctuation">.</span>Completed <span class="token operator">=</span> OpCompleted<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// Optional: call asyncOp.Cancel() sometime later</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// NOTE: Callback method executes via GUI or thread pool thread:</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">OpCompleted</span><span class="token punctuation">(</span><span class="token class-name">IAsyncOperation<span class="token punctuation">&lt;</span>StorageFile<span class="token punctuation">></span></span> asyncOp<span class="token punctuation">,</span> <span class="token class-name">AsyncStatus</span> status<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">switch</span> <span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">case</span> AsyncStatus<span class="token punctuation">.</span>Completed<span class="token punctuation">:</span> <span class="token comment">// Process result</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token class-name">StorageFile</span> file <span class="token operator">=</span> asyncOp<span class="token punctuation">.</span><span class="token function">GetResults</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Completed... */</span> <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">case</span> AsyncStatus<span class="token punctuation">.</span>Canceled<span class="token punctuation">:</span> <span class="token comment">// Process cancellation </span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">/* Canceled... */</span> <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">case</span> AsyncStatus<span class="token punctuation">.</span>Error<span class="token punctuation">:</span> <span class="token comment">// Process exception</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token class-name">Exception</span> exception <span class="token operator">=</span> asyncOp<span class="token punctuation">.</span>ErrorCode<span class="token punctuation">;</span> <span class="token comment">/* Error... */</span> <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre> asyncOp<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The WinRTAsyncIntro method invokes the WinRT GetFileAsync method to find a file in the user’s music library. All WinRT APIs that perform asynchronous operations are named with the Async suffix and they all return an object whose type implements a WinRT IAsyncXxx interface; in this example, an IAsyncOperation interface where TResult is the WinRT StorageFile type. This object, whose reference I put in an asyncOp variable, represents the pending asynchronous operation. Your code must somehow receive notification when the pending operation completes. To do this, you must implement a callback method (OpCompleted in my example), create a delegate to it, and assign the delegate to the asyncOp’s Completed property. Now, when the operation completes, the callback method is invoked via some thread (not necessarily the GUI thread). If the operation completed before assigning the delegate to the OnCompleted property, then the system will invoke the callback as soon as possible. In other words, there is a race condition here, but the object implementing the IAsyncXxx interface resolves the race for you, ensuring that your code works correctly.</p></blockquote><blockquote><p>As noted at the end of the WinRTAsyncIntro method, you can optionally call a Cancel method offered by all IAsyncXxx interfaces if you want to cancel the pending operation. All asynchronous operations complete for one of three possible reasons: the operation runs to completion successfully, the operation is explicitly canceled, or the operation results in a failure. When the operation completes due to any of these reasons, the system invokes the callback method, passes it a reference to the same object that the original XxxAsync method returned, and an AsyncStatus. In my OnCompleted method, I examine the status parameter and either process the result due to the successful completion, handle the explicit cancellation, or handle the failure.6 Also, note that after processing the operation’s completion, the IAsyncXxx interface object should be cleaned up by calling its Close method.</p></blockquote><blockquote><p>Figure 25-2 shows the various WinRT IAsyncXxx interfaces. The four main interfaces all derive from the IAsyncInfo interface. The two IAsyncAction interfaces give you a way to know when the operation has completed, but their operations complete with no return value (their GetResults methods have a void return type). The two IAsyncOperation interfaces also give you a way to know when the operation has completed and allow you to get their return value (their GetResults methods have a generic TResult return type).</p></blockquote><blockquote><p>The two IAsyncXxxWithProgress interfaces allow your code to receive periodic progress updates as the asynchronous operation is progressing through its work. Most asynchronous operations do not offer progress updates but some (like background downloading and uploading) do. To receive periodic progress updates, you would define another callback method in your code, create a delegate that refers to it, and assign the delegate to the IAsyncXxxWithProgress object’s Progress property. When your callback method is invoked, it is passed an argument whose type matches the generic TProgress type.</p></blockquote><p><img data-src="/2022/12/06/csharp/clr-via-csharp/Chapter%2025%20Interoperating%20with%20WinRT%20%20Components/image-20221205201500265.png" alt="image-20221205201500265"></p><blockquote><p>In the .NET Framework, we use the types in the System.Threading.Tasks namespace to simplify performing asynchronous operations. I explain these types and how to use them to perform compute operations in Chapter 27, “Compute-Bound Asynchronous Operations,” and how to use them to perform I/O operations in Chapter 28, “I/O-Bound Asynchronous Operations.” In addition, C# offers the async and await keywords, which allow you to perform asynchronous operations by using a sequential programming model, thereby simplifying your code substantially.</p></blockquote><blockquote><p>The following code is a rewrite of the WinRTAsyncIntro method previously mentioned. However, this version is leveraging some extension methods supplied with the .NET Framework, which turn the WinRT asynchronous programming model into the more convenient C# programming model.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> <span class="token comment">// Required for extension methods in WindowsRuntimeSystemExtensions</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">async</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">WinRTAsyncIntro</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token class-name">StorageFile</span> file <span class="token operator">=</span> <span class="token keyword">await</span> KnownFolders<span class="token punctuation">.</span>MusicLibrary<span class="token punctuation">.</span><span class="token function">GetFileAsync</span><span class="token punctuation">(</span><span class="token string">"Song.mp3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">/* Completed... */</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">OperationCanceledException</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* Canceled... */</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SomeOtherException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* Error... */</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>What’s happening here is that the use of C#’s await operator causes the compiler to look for a GetAwaiter method on the IAsyncOperation interface returned from the GetFileAsync method. This interface doesn’t provide a GetAwaiter method, and so, the compiler looks for an extension method. Fortunately, the .NET Framework team has provided in System.Runtime.WindowsRuntime.dll a bunch of extension methods callable when you have one of WinRT’s IAsyncXxx interfaces.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">namespace</span> <span class="token namespace">System</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">WindowsRuntimeSystemExtensions</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">TaskAwaiter</span> <span class="token function">GetAwaiter</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">IAsyncAction</span> source<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">TaskAwaiter</span> <span class="token generic-method"><span class="token function">GetAwaiter</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>TProgress<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">IAsyncActionWithProgress<span class="token punctuation">&lt;</span>TProgress<span class="token punctuation">></span></span> </pre></td></tr><tr><td data-num="5"></td><td><pre>source<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">TaskAwaiter<span class="token punctuation">&lt;</span>TResult<span class="token punctuation">></span></span> <span class="token generic-method"><span class="token function">GetAwaiter</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>TResult<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">IAsyncOperation<span class="token punctuation">&lt;</span>TResult<span class="token punctuation">></span></span> </pre></td></tr><tr><td data-num="7"></td><td><pre>source<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">TaskAwaiter<span class="token punctuation">&lt;</span>TResult<span class="token punctuation">></span></span> <span class="token generic-method"><span class="token function">GetAwaiter</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>TResult<span class="token punctuation">,</span> TProgress<span class="token punctuation">></span></span></span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">this</span> <span class="token class-name">IAsyncOperationWithProgress<span class="token punctuation">&lt;</span>TResult<span class="token punctuation">,</span> TProgress<span class="token punctuation">></span></span> source<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Internally, all these methods construct a TaskCompletionSource and tell the IAsyncXxx object to invoke a callback that sets the TaskCompletionSource’s final state when the asynchronous operation completes. The TaskAwaiter object returned from these extension methods is ultimately what C# awaits. When the asynchronous operation completes, the TaskAwaiter object ensures that the code continues executing via the SynchronizationContext (discussed in Chapter 28) that is associated with the original thread. Then, the thread executes the C# compiler generated code, which queries the TaskCompletionSource’s Task’s Result property, which returns the result (a StorageFile in my example), throws an OperationCanceledException in case of cancellation, or throws some other exception if a failure occurred. For an example of how these methods work internally, see the code at the end of this section.</p></blockquote><blockquote><p>What I have just shown is the common scenario of calling an asynchronous WinRT API and discovering its outcome. But, in the previous code, I showed how to find out if cancellation occurred, but I didn’t show how to actually cancel the operation. In addition, I didn’t show how to deal with progress updates. To properly handle cancellation and progress updates, instead of having the compiler automatically call one of the GetAwaiter extension methods shown earlier, you would explicitly call one of the AsTask extension methods that the WindowsRuntimeSystemExtensions class also defines.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">namespace</span> <span class="token namespace">System</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">WindowsRuntimeSystemExtensions</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Task</span> <span class="token generic-method"><span class="token function">AsTask</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>TProgress<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">IAsyncActionWithProgress<span class="token punctuation">&lt;</span>TProgress<span class="token punctuation">></span></span> source<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">CancellationToken</span> cancellationToken<span class="token punctuation">,</span> <span class="token class-name">IProgress<span class="token punctuation">&lt;</span>TProgress<span class="token punctuation">></span></span> progress<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Task<span class="token punctuation">&lt;</span>TResult<span class="token punctuation">></span></span> <span class="token generic-method"><span class="token function">AsTask</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>TResult<span class="token punctuation">,</span> TProgress<span class="token punctuation">></span></span></span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">this</span> <span class="token class-name">IAsyncOperationWithProgress<span class="token punctuation">&lt;</span>TResult<span class="token punctuation">,</span> TProgress<span class="token punctuation">></span></span> source<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token class-name">CancellationToken</span> cancellationToken<span class="token punctuation">,</span> <span class="token class-name">IProgress<span class="token punctuation">&lt;</span>TProgress<span class="token punctuation">></span></span> progress<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Simpler overloads not shown here</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>So now, let me show you the complete picture. Here is how to call an asynchronous WinRT API and fully leverage cancellation and progress for those times when you need these enhancements.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> <span class="token comment">// For WindowsRuntimeSystemExtensions’s AsTask</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Threading</span><span class="token punctuation">;</span> <span class="token comment">// For CancellationTokenSource</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">CancellationTokenSource</span> m_cts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">CancellationTokenSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// NOTE: If invoked by GUI thread, all code executes via GUI thread:</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">async</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">MappingWinRTAsyncToDotNet</span><span class="token punctuation">(</span><span class="token class-name">WinRTType</span> someWinRTObj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Assume XxxAsync returns IAsyncOperationWithProgress&lt;IBuffer, UInt32> </span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token class-name">IBuffer</span> result <span class="token operator">=</span> <span class="token keyword">await</span> someWinRTObj<span class="token punctuation">.</span><span class="token function">XxxAsync</span><span class="token punctuation">(</span><span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">.</span><span class="token function">AsTask</span><span class="token punctuation">(</span>m_cts<span class="token punctuation">.</span>Token<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Progress<span class="token punctuation">&lt;</span>UInt32<span class="token punctuation">></span></span><span class="token punctuation">(</span>ProgressReport<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">/* Completed... */</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">OperationCanceledException</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* Canceled... */</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SomeOtherException</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* Error... */</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ProgressReport</span><span class="token punctuation">(</span><span class="token class-name">UInt32</span> progress<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* Update progress... */</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> m_cts<span class="token punctuation">.</span><span class="token function">Cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// Called sometime later</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>I know that some readers would like to understand how these AsTask methods internally convert a WinRT IAsyncXxx into a .NET Framework Task that can ultimately be awaited. The following code shows how the most complicated AsTask method is effectively implemented internally. The simpler overloads are, of course, simpler than this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Task<span class="token punctuation">&lt;</span>TResult<span class="token punctuation">></span></span> <span class="token generic-method"><span class="token function">AsTask</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>TResult<span class="token punctuation">,</span> TProgress<span class="token punctuation">></span></span></span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">this</span> <span class="token class-name">IAsyncOperationWithProgress<span class="token punctuation">&lt;</span>TResult<span class="token punctuation">,</span> TProgress<span class="token punctuation">></span></span> asyncOp<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">CancellationToken</span> ct <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">(</span><span class="token type-expression class-name">CancellationToken</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">IProgress<span class="token punctuation">&lt;</span>TProgress<span class="token punctuation">></span></span> progress <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// When CancellationTokenSource is canceled, cancel the async operation</span></pre></td></tr><tr><td data-num="6"></td><td><pre> ct<span class="token punctuation">.</span><span class="token function">Register</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> asyncOp<span class="token punctuation">.</span><span class="token function">Cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// When the async operation reports progress, report it to the progress callback </span></pre></td></tr><tr><td data-num="8"></td><td><pre> asyncOp<span class="token punctuation">.</span>Progress <span class="token operator">=</span> <span class="token punctuation">(</span>asyncInfo<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token operator">=></span> progress<span class="token punctuation">.</span><span class="token function">Report</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// This TaskCompletionSource monitors the async operation's completion</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> tcs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">TaskCompletionSource<span class="token punctuation">&lt;</span>TResult<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// When the async operation completes, notify the TaskCompletionSource</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// Code awaiting the TaskCompletionSource regains control when this happens</span></pre></td></tr><tr><td data-num="13"></td><td><pre> asyncOp<span class="token punctuation">.</span>Completed <span class="token operator">=</span> <span class="token punctuation">(</span>asyncOp2<span class="token punctuation">,</span> asyncStatus<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">switch</span> <span class="token punctuation">(</span>asyncStatus<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token keyword">case</span> AsyncStatus<span class="token punctuation">.</span>Completed<span class="token punctuation">:</span> tcs<span class="token punctuation">.</span><span class="token function">SetResult</span><span class="token punctuation">(</span>asyncOp2<span class="token punctuation">.</span><span class="token function">GetResults</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token keyword">case</span> AsyncStatus<span class="token punctuation">.</span>Canceled<span class="token punctuation">:</span> tcs<span class="token punctuation">.</span><span class="token function">SetCanceled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token keyword">case</span> AsyncStatus<span class="token punctuation">.</span>Error<span class="token punctuation">:</span> tcs<span class="token punctuation">.</span><span class="token function">SetException</span><span class="token punctuation">(</span>asyncOp2<span class="token punctuation">.</span>ErrorCode<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token comment">// When calling code awaits this returned Task, it calls GetAwaiter, which </span></pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token comment">// wraps a SynchronizationContext around the Task ensuring that completion </span></pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token comment">// occurs on the SynchronizationContext object's context</span></pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token keyword">return</span> tcs<span class="token punctuation">.</span>Task<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="interoperating-between-winrt-streams-and-net-streams"><a class="anchor" href="#interoperating-between-winrt-streams-and-net-streams">#</a> Interoperating Between WinRT Streams and .NET Streams</h3><blockquote><p>There are many .NET Framework classes that operate on System.IO.Stream-derived types, such as serialization and LINQ to XML. To use a WinRT object that implements WinRT’s IStorageFile or IStorageFolder interfaces with a .NET Framework class that requires a Stream-derived type, we leverage extension methods defined in the System.IO.WindowsRuntimeStorageExtensions class.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">namespace</span> <span class="token namespace">System<span class="token punctuation">.</span>IO</span> <span class="token punctuation">&#123;</span> <span class="token comment">// Defined in System.Runtime.WindowsRuntime.dll</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">WindowsRuntimeStorageExtensions</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Task<span class="token punctuation">&lt;</span>Stream<span class="token punctuation">></span></span> <span class="token function">OpenStreamForReadAsync</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">IStorageFile</span> file<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Task<span class="token punctuation">&lt;</span>Stream<span class="token punctuation">></span></span> <span class="token function">OpenStreamForWriteAsync</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">IStorageFile</span> file<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Task<span class="token punctuation">&lt;</span>Stream<span class="token punctuation">></span></span> <span class="token function">OpenStreamForReadAsync</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">IStorageFolder</span> rootDirectory<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token class-name">String</span> relativePath<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Task<span class="token punctuation">&lt;</span>Stream<span class="token punctuation">></span></span> <span class="token function">OpenStreamForWriteAsync</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">IStorageFolder</span> rootDirectory<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token class-name">String</span> relativePath<span class="token punctuation">,</span> <span class="token class-name">CreationCollisionOption</span> creationCollisionOption<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Here is an example that uses one of the extension methods to open a WinRT StorageFile and read its contents into a .NET Framework XElement object.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">async</span> <span class="token return-type class-name">Task<span class="token punctuation">&lt;</span>XElement<span class="token punctuation">></span></span> <span class="token function">FromStorageFileToXElement</span><span class="token punctuation">(</span><span class="token class-name">StorageFile</span> file<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token class-name">Stream</span> stream <span class="token operator">=</span> <span class="token keyword">await</span> file<span class="token punctuation">.</span><span class="token function">OpenStreamForReadAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">return</span> XElement<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Finally, the System.IO.WindowsRuntimeStreamExtensions class offers extension methods that “cast” WinRT stream interfaces (such as IRandomAccessStream, IInputStream or IOutputStream) to the .NET Framework's Stream type and vice versa.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">namespace</span> <span class="token namespace">System<span class="token punctuation">.</span>IO</span> <span class="token punctuation">&#123;</span> <span class="token comment">// Defined in System.Runtime.WindowsRuntime.dll</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">WindowsRuntimeStreamExtensions</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Stream</span> <span class="token function">AsStream</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">IRandomAccessStream</span> winRTStream<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Stream</span> <span class="token function">AsStream</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">IRandomAccessStream</span> winRTStream<span class="token punctuation">,</span> <span class="token class-name">Int32</span> bufferSize<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Stream</span> <span class="token function">AsStreamForRead</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">IInputStream</span> winRTStream<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Stream</span> <span class="token function">AsStreamForRead</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">IInputStream</span> winRTStream<span class="token punctuation">,</span> <span class="token class-name">Int32</span> bufferSize<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Stream</span> <span class="token function">AsStreamForWrite</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">IOutputStream</span> winRTStream<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Stream</span> <span class="token function">AsStreamForWrite</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">IOutputStream</span> winRTStream<span class="token punctuation">,</span> <span class="token class-name">Int32</span> bufferSize<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">IInputStream</span> AsInputStream <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">Stream</span> clrStream<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">IOutputStream</span> <span class="token function">AsOutputStream</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">Stream</span> clrStream<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Here is an example that uses one of the extension methods to “cast” a WinRT IInputStream to a .NET Framework Stream object.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token return-type class-name">XElement</span> <span class="token function">FromWinRTStreamToXElement</span><span class="token punctuation">(</span><span class="token class-name">IInputStream</span> winRTStream<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Stream</span> netStream <span class="token operator">=</span> winRTStream<span class="token punctuation">.</span><span class="token function">AsStreamForRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">return</span> XElement<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span>netStream<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Note that the &quot;casting&quot; extension methods provided by the .NET Framework do a little more than just casting under the covers. Specifically, the methods that adapt a WinRT stream to a .NET Framework stream implicitly create a buffer for the WinRT stream in the managed heap. As a result, most operations write to this buffer and do not need to cross the interop boundary, thereby improving performance. This is especially significant in scenarios that involve many small I/O operations, such as parsing an XML document.</p></blockquote><blockquote><p>One of the benefits of using the .NET Framework’s stream projections is that if you use an AsStreamXxx method more than once on the same WinRT stream instance, you do not need to worry that different, disconnected buffers will be created, and data written to one buffer will not be visible in the other. The .NET Framework APIs ensure that every stream object has a unique adapter instance and all users share the same buffer.</p></blockquote><blockquote><p>Although in most cases the default buffering offers a good compromise between performance and memory usage, there are some cases where you may want to tweak the size of your buffer to be different from the 16-KB default. The AsStreamXxx methods offer overloads for that. For instance, if you know that you will be working with a very large file for an extended period of time, and that not many other buffered streams will be used at the same time, you can gain some additional performance by requesting a very large buffer for your stream. Conversely, in some network scenarios with low-latency requirements, you may want to ensure that no more bytes are read from the network than were explicitly requested by your application. In such cases, you can disable buffering altogether. If you specify a buffer size of zero bytes to the AsStreamXxx methods, no buffer object will be created.</p></blockquote><h3 id="passing-blocks-of-data-between-the-clr-and-winrt"><a class="anchor" href="#passing-blocks-of-data-between-the-clr-and-winrt">#</a> Passing Blocks of Data Between the CLR and WinRT</h3><blockquote><p>When possible, you should use the stream framework projections as discussed in the previous section, because they have pretty good performance characteristics. However, there may be times when you need to pass raw blocks of data between the CLR and WinRT components. For example, WinRT’s file and socket stream components require you to write and read raw blocks of data. Also, WinRT’s cryptography components encrypt and decrypt blocks of data, and bitmap pixels are maintained in raw blocks of data too.</p></blockquote><blockquote><p>In the .NET Framework, the usual way to obtain a block of data is either with a byte array (Byte[]) or with a stream (such as when using the MemoryStream class). Of course, byte array and MemoryStream objects can’t be passed to WinRT components directly. So, WinRT defines an IBuffer interface and objects that implement this interface represent raw blocks of data that can be passed to WinRT APIs. The WinRT IBuffer interface is defined as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">namespace</span> <span class="token namespace">Windows<span class="token punctuation">.</span>Storage<span class="token punctuation">.</span>Streams</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IBuffer</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token return-type class-name">UInt32</span> Capacity <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// Maximum size of the buffer (in bytes)</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token return-type class-name">UInt32</span> Length <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// Number of bytes currently in use by the buffer</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>As you can see, an IBuffer object has a maximum size and length; oddly enough, this interface gives you no way to actually read from or write to the data in the buffer. The main reason for this is because WinRT types cannot express pointers in their metadata, because pointers do not map well to some languages (like JavaScript or safe C# code). So, an IBuffer object is really just a way to pass a memory address between the CLR and WinRT APIs. To access the bytes at the memory address, an internal COM interface, known as IBufferByteAccess, is used. Note that this interface is a COM interface (because it returns a pointer) and it is not a WinRT interface. The .NET Framework team has defined an internal RCW for this COM interface, which looks like the following.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">namespace</span> <span class="token namespace">System<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>InteropServices<span class="token punctuation">.</span>WindowsRuntime</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Guid</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token string">"905a0fef-bc53-11df-8c49-001e4fc686da"</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">InterfaceType</span><span class="token attribute-arguments"><span class="token punctuation">(</span>ComInterfaceType<span class="token punctuation">.</span>InterfaceIsIUnknown<span class="token punctuation">)</span></span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">ComImport</span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">internal</span> <span class="token keyword">interface</span> <span class="token class-name">IBufferByteAccess</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">unsafe</span> Byte<span class="token operator">*</span> Buffer <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Internally, the CLR can take an IBuffer object, query for its IBufferByteAccess interface, and then query the Buffer property to get an unsafe pointer to the bytes contained within the buffer. With the pointer, the bytes can be accessed directly.</p></blockquote><blockquote><p>To avoid having developers write unsafe code that manipulates pointers, the Framework Class Library includes a WindowsRuntimeBufferExtensions class that defines a bunch of extension methods, which .NET Framework developers explicitly invoke to help pass blocks of data between CLR byte arrays and streams to WinRT IBuffer objects. To call these extension methods, make sure you add a using System.Runtime.InteropServices.WindowsRuntime; directive to your source code.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">namespace</span> <span class="token namespace">System<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>InteropServices<span class="token punctuation">.</span>WindowsRuntime</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">WindowsRuntimeBufferExtensions</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">IBuffer</span> <span class="token function">AsBuffer</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">Byte<span class="token punctuation">[</span><span class="token punctuation">]</span></span> source<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">IBuffer</span> <span class="token function">AsBuffer</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">Byte<span class="token punctuation">[</span><span class="token punctuation">]</span></span> source<span class="token punctuation">,</span> <span class="token class-name">Int32</span> offset<span class="token punctuation">,</span> <span class="token class-name">Int32</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">IBuffer</span> <span class="token function">AsBuffer</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">Byte<span class="token punctuation">[</span><span class="token punctuation">]</span></span> source<span class="token punctuation">,</span> <span class="token class-name">Int32</span> offset<span class="token punctuation">,</span> <span class="token class-name">Int32</span> length<span class="token punctuation">,</span> <span class="token class-name">Int32</span> </pre></td></tr><tr><td data-num="6"></td><td><pre>capacity<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">IBuffer</span> <span class="token function">GetWindowsRuntimeBuffer</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">MemoryStream</span> stream<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">IBuffer</span> <span class="token function">GetWindowsRuntimeBuffer</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">MemoryStream</span> stream<span class="token punctuation">,</span> <span class="token class-name">Int32</span> position<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token class-name">Int32</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>So, if you have a Byte[] and you want to pass it to a WinRT API requiring an IBuffer, you simply call AsBuffer on the Byte[] array. This effectively wraps the reference to the Byte[] inside an object that implements the IBuffer interface; the contents of the Byte[] array is not copied, so this is very efficient. Similarly, if you have a MemoryStream object wrapping a publicly visible Byte[] array buffer in it, you simply call GetWindowsRuntimeBuffer on it to wrap the reference to the MemoryStream’s buffer inside an object that implements the IBuffer interface. Again, the buffer’s content is not copied, so this is very efficient. The following method demonstrates both scenarios.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">ByteArrayAndStreamToIBuffer</span><span class="token punctuation">(</span><span class="token class-name">IRandomAccessStream</span> winRTStream<span class="token punctuation">,</span> <span class="token class-name">Int32</span> count<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Byte<span class="token punctuation">[</span><span class="token punctuation">]</span></span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Byte</span><span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">await</span> winRTStream<span class="token punctuation">.</span><span class="token function">ReadAsync</span><span class="token punctuation">(</span>bytes<span class="token punctuation">.</span><span class="token function">AsBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>UInt32<span class="token punctuation">)</span>bytes<span class="token punctuation">.</span>Length<span class="token punctuation">,</span> InputStreamOptions<span class="token punctuation">.</span>None<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">Int32</span> sum <span class="token operator">=</span> bytes<span class="token punctuation">.</span><span class="token function">Sum</span><span class="token punctuation">(</span>b <span class="token operator">=></span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Access the bytes read via the Byte[]</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> ms <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">MemoryStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> sw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">StreamWriter</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> sw<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token string">"This string represents data in a stream"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> sw<span class="token punctuation">.</span><span class="token function">Flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token class-name">UInt32</span> bytesWritten <span class="token operator">=</span> <span class="token keyword">await</span> winRTStream<span class="token punctuation">.</span><span class="token function">WriteAsync</span><span class="token punctuation">(</span>ms<span class="token punctuation">.</span><span class="token function">GetWindowsRuntimeBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>WinRT’s IRandomAccessStream interface implements WinRT’s IInputStream interface defined as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">namespace</span> <span class="token namespace">Windows<span class="token punctuation">.</span>Storage<span class="token punctuation">.</span>Streams</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IOutputStream</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IDisposable</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token return-type class-name">IAsyncOperationWithProgress<span class="token punctuation">&lt;</span>UInt32<span class="token punctuation">,</span> UInt32<span class="token punctuation">></span></span> <span class="token function">WriteAsync</span><span class="token punctuation">(</span><span class="token class-name">IBuffer</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When you call the AsBuffer or GetWindowsRuntimeBuffer extension methods in your code, these methods wrap the source object inside an object whose class implements the IBuffer interface. The CLR then creates a CCW for this object and passes it to the WinRT API. When the WinRT API queries the IBufferByteAccess interface’s Buffer property to obtain a pointer to the underlying byte array, the byte array is pinned, and the address is returned to the WinRT API so it can access the data. The underlying byte array is unpinned when the WinRT API internally calls COM’s Release method on the IBufferByteAccess interface.</p></blockquote><blockquote><p>If you call a WinRT API that returns an IBuffer back to you, then the data itself is probably in native memory, and you’ll need a way to access this data from managed code. For this, we’ll turn to some other extension methods defined by the WindowsRuntimeBufferExtensions class.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">namespace</span> <span class="token namespace">System<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>InteropServices<span class="token punctuation">.</span>WindowsRuntime</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">WindowsRuntimeBufferExtensions</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Stream</span> <span class="token function">AsStream</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">IBuffer</span> source<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Byte<span class="token punctuation">[</span><span class="token punctuation">]</span></span> <span class="token function">ToArray</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">IBuffer</span> source<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Byte<span class="token punctuation">[</span><span class="token punctuation">]</span></span> <span class="token function">ToArray</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">IBuffer</span> source<span class="token punctuation">,</span> <span class="token class-name">UInt32</span> sourceIndex<span class="token punctuation">,</span> <span class="token class-name">Int32</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Not shown: CopyTo method to transfer bytes between an IBuffer and a Byte[]</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// Not shown: GetByte, IsSameData methods</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The AsStream method creates a Stream-derived object that wraps the source IBuffer. With this Stream object, you can access the data in the IBuffer by calling Stream’s Read, Write, and similar methods. The ToArray method internally allocates a Byte[] and then copies all the bytes from the source IBuffer into the Byte[]; be aware that this extension method is potentially expensive in terms of memory consumption and CPU time.</p></blockquote><blockquote><p>The WindowsRuntimeBufferExtensions class also has several overloads of a CopyTo method that can copy bytes between an IBuffer and a Byte[]. It also has a GetByte method that retrieves a single byte at a time from an IBuffer and an IsSameData method that compares the contents of two IBuffer objects to see if their contents are identical. For most applications, it is unlikely that you will have a need to call any of these methods.</p></blockquote><blockquote><p>’d also like to point out that the .NET Framework defines a System.Runtime.InteropServices. WindowsRuntimeBuffer class that allows you to create an IBuffer object whose bytes are in the managed heap. Similarly, there is a WinRT component called Windows.Storage.Streams.Buffer that allows you to create an IBuffer object whose bytes are in the native heap. For most .NET Framework developers, there should be no need to use either of these classes explicitly in your code.</p></blockquote><p>💡小结：在 CLR 不能将一个 WinRT 类型隐式投射给 .NET Framework 开发人员的时候，开发人员就必须显式使用框架投射。主要有三种需要进行框架投射的技术：异步编程、WinRT 流和 .NET Framework 流之间的互操作以及需要在 CLR 和 WinRT API 之间传输数据块的时候。后续的小节将分别讨论这三种框架投射。由于许多应用程序都要使用这些技术，所以有必要很好地理解和高效地使用它们。</p><h2 id="defining-winrt-components-in-c"><a class="anchor" href="#defining-winrt-components-in-c">#</a> Defining WinRT Components in C#</h2><blockquote><p>So far in this chapter, I’ve been focusing on how to consume WinRT components from C#. However, you can also define WinRT components in C# and then these components can be used by native C/C++, C#/Visual Basic, JavaScript, and potentially other languages too. Although this is possible to do, we need to think about the scenarios where this actually makes sense. For example, it makes no sense at all to define a WinRT component in C# if the only consumers of the component are other managed languages that run on top of the CLR. This is because the WinRT type system has far fewer features, which make it much more restrictive than the CLR’s type system.</p></blockquote><blockquote><p>I also don’t think it makes a lot of sense to implement a WinRT component with C# that could be consumed by native C/C++ code. Developers using native C/C++ to implement their application are probably doing so because they are very concerned about performance and/or memory consumption. They are unlikely to want to take advantage of a WinRT component implemented with managed code, because this forces the CLR to load into their process and thus increases their memory requirements and performance due to the garbage collections and just-in-time compiling of code. For this reason, most WinRT components (like those that ship with Windows itself) are implemented in native code. Of course, there may be some parts of a native C++ app where performance is not so sensitive and, at these times, it may make sense to leverage .NET Framework functionality in order to improve productivity. For example, Bing Maps uses native C++ to draw its UI by using DirectX, but it also uses C# for its business logic.</p></blockquote><blockquote><p>So, it seems to me that the sweet spot for C#-implemented WinRT components is for Windows Store app developers who want to build their user interface with HTML and CSS and then use JavaScript as the glue code to tie the UI with business logic code that is implemented in a C# WinRT component. Another scenario would be to leverage existing Framework Class Library functionality (like Windows Communication Foundation) from an HTML/JavaScript app. Developers working with HTML and JavaScript are already willing to accept the kind of performance and memory consumption that comes with a browser engine and may be willing to even further accept the additional performance and memory consumption that comes along with also using the CLR.</p></blockquote><blockquote><p>To build a WinRT component with C#, you must first create a Microsoft Visual Studio “Windows Runtime Component” project. What this really does is create a normal class library project; however, the C# compiler will be spawned with the /t:winmdobj command line switch in order to produce a file with a .winmdobj file extension. With this switch specified, the compiler emits some IL code differently than it normally would. For example, WinRT components add and remove delegates to events differently than how the CLR does it, so the compiler emits different code for an event’s add and remove methods when this compiler switch is specified. I’ll show how to explicitly implement an event’s add and remove methods later in this section.</p></blockquote><blockquote><p>After the compiler produces the .winmdobj file, the WinMD export utility (WinMDExp.exe) is spawned passing to it the .winmdobj, .pdb, and .xml (doc) files produced by the compiler. The WinMDExp.exe utility examines your file’s metadata, ensuring that your types adhere to the various WinRT type system rules, as discussed at the beginning of this chapter. The utility also modifies the metadata contained in the .winmdobj file; it does not alter the IL code at all. Specifically, the utility maps any CLR types to the equivalent WinRT types. For example, references to the .NET Framework’s IList type are changed to WinRT’s IVector type. The output of the WinMDExp.exe utility is a .winmd file that other programming languages can consume.</p></blockquote><blockquote><p>You can use the .NET Framework’s Intermediate Disassembler utility (ILDasm.exe) to inspect the contents of a .winmd file. By default, ILDasm.exe shows you the raw contents of the file. However, ILDasm.exe supports a /project command-line switch that shows you what the metadata would look like after the CLR projected the WinRT types into their .NET Framework equivalents.</p></blockquote><blockquote><p>The following code demonstrates how to implement various WinRT components in C#. The components leverage many of the features discussed throughout this chapter, and there are a lot of comments throughout the code to explain what is going on. If you need to implement a WinRT component in C#, I’d suggest using the code I show here as a model.</p></blockquote><p>💡重要提示：托管代码使用同样托管代码携程的 WinRT 组件时，CLR 将其视为普通的托管组件。也就是说，CLR 不会创建 CCW 和 RCW，不通过这些包装器来调用 WinRT API。这显著曾倩了性能。但在测试组件时，API 的调用方式有别于从其他语言 (如原生 C/C++ 或 JavaScript) 调用时的方式。所以，除了性能和内存消耗不能反映实际情况，托管代码还能向要求一个 <code>String</code> 的 WinRT API 传递 <code>null</code> 而不引发 <code>ArgumentNullException</code> 。另外，用托管代码实现的 WinRT API 可操作传入的数组，调用者能在 API 返回时看到更改过的数组内容。而一般情况下，WinRT 类型系统禁止修改传给 API 的数组。还有其他未列出的差异，所以务必小心。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/******************************************************************************</span></pre></td></tr><tr><td data-num="2"></td><td><pre>Module: WinRTComponents.cs</pre></td></tr><tr><td data-num="3"></td><td><pre>Notices: Copyright (c) 2012 by Jeffrey Richter</pre></td></tr><tr><td data-num="4"></td><td><pre>******************************************************************************/</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>Generic</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Linq</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>InteropServices<span class="token punctuation">.</span>WindowsRuntime</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Threading</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Threading<span class="token punctuation">.</span>Tasks</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">Windows<span class="token punctuation">.</span>Foundation</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">Windows<span class="token punctuation">.</span>Foundation<span class="token punctuation">.</span>Metadata</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment">// The namespace MUST match the assembly name and cannot be "Windows"</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">namespace</span> <span class="token namespace">Wintellect<span class="token punctuation">.</span>WinRTComponents</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// [Flags] // Must not be present if enum is int; required if enum is uint</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">WinRTEnum</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token keyword">int</span></span> <span class="token punctuation">&#123;</span> <span class="token comment">// Enums must be backed by int or uint</span></pre></td></tr><tr><td data-num="17"></td><td><pre> None<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="18"></td><td><pre> NotNone</pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token comment">// Structures can only contain core data types, String, &amp; other structures </span></pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token comment">// No constructors or methods are allowed</span></pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">struct</span> <span class="token class-name">WinRTStruct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name">Int32</span> ANumber<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name">String</span> AString<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name">WinRTEnum</span> AEnum<span class="token punctuation">;</span> <span class="token comment">// Really just a 32-bit integer</span></pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre> <span class="token comment">// Delegates must have WinRT-compatible types in the signature (no BeginInvoke/EndInvoke)</span></pre></td></tr><tr><td data-num="28"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">delegate</span> <span class="token return-type class-name">String</span> <span class="token function">WinRTDelegate</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre> <span class="token comment">// Interfaces can have methods, properties, &amp; events but cannot be generic.</span></pre></td></tr><tr><td data-num="30"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IWinRTInterface</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="31"></td><td><pre> <span class="token comment">// Nullable&lt;T> marshals as IReference&lt;T></span></pre></td></tr><tr><td data-num="32"></td><td><pre> <span class="token return-type class-name">Int32<span class="token punctuation">?</span></span> InterfaceProperty <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre> <span class="token comment">// Members without a [Version(#)] attribute default to the class's </span></pre></td></tr><tr><td data-num="35"></td><td><pre> <span class="token comment">// version (1) and are part of the same underlying COM interface</span></pre></td></tr><tr><td data-num="36"></td><td><pre> <span class="token comment">// produced by WinMDExp.exe.</span></pre></td></tr><tr><td data-num="37"></td><td><pre> <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Version</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="38"></td><td><pre> <span class="token comment">// Class must be derived from Object, sealed, not generic, </span></pre></td></tr><tr><td data-num="39"></td><td><pre> <span class="token comment">// implement only WinRT interfaces, &amp; public members must be WinRT types</span></pre></td></tr><tr><td data-num="40"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">WinRTClass</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IWinRTInterface</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="41"></td><td><pre> <span class="token comment">// Public fields are not allowed </span></pre></td></tr><tr><td data-num="42"></td><td><pre> <span class="token preprocessor property">#<span class="token directive keyword">region</span> Class can expose static methods, properties, and events</span></pre></td></tr><tr><td data-num="43"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">String</span> <span class="token function">StaticMethod</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token string">"Returning "</span> <span class="token operator">+</span> s<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="44"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">WinRTStruct</span> StaticProperty <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="45"></td><td><pre> <span class="token comment">// In JavaScript 'out' parameters are returned as objects with each </span></pre></td></tr><tr><td data-num="46"></td><td><pre> <span class="token comment">// parameter becoming a property along with the return value</span></pre></td></tr><tr><td data-num="47"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">String</span> <span class="token function">OutParameters</span><span class="token punctuation">(</span><span class="token keyword">out</span> <span class="token class-name">WinRTStruct</span> x<span class="token punctuation">,</span> <span class="token keyword">out</span> <span class="token class-name">Int32</span> year<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="48"></td><td><pre> x <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">WinRTStruct</span> <span class="token punctuation">&#123;</span> AEnum <span class="token operator">=</span> WinRTEnum<span class="token punctuation">.</span>NotNone<span class="token punctuation">,</span> ANumber <span class="token operator">=</span> <span class="token number">333</span><span class="token punctuation">,</span> AString <span class="token operator">=</span> <span class="token string">"Jeff"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="49"></td><td><pre> year <span class="token operator">=</span> DateTimeOffset<span class="token punctuation">.</span>Now<span class="token punctuation">.</span>Year<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="50"></td><td><pre> <span class="token keyword">return</span> <span class="token string">"Grant"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="51"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="52"></td><td><pre> <span class="token preprocessor property">#<span class="token directive keyword">endregion</span></span></pre></td></tr><tr><td data-num="53"></td><td><pre> <span class="token comment">// Constructor can take arguments but not out/ref arguments</span></pre></td></tr><tr><td data-num="54"></td><td><pre> <span class="token keyword">public</span> <span class="token function">WinRTClass</span><span class="token punctuation">(</span><span class="token class-name">Int32<span class="token punctuation">?</span></span> number<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> InterfaceProperty <span class="token operator">=</span> number<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="55"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32<span class="token punctuation">?</span></span> InterfaceProperty <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="56"></td><td><pre> <span class="token comment">// Only ToString is allowed to be overridden</span></pre></td></tr><tr><td data-num="57"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name">String</span> <span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="58"></td><td><pre> <span class="token keyword">return</span> String<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"InterfaceProperty=&#123;0&#125;"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="59"></td><td><pre> <span class="token return-type class-name">InterfaceProperty<span class="token punctuation">.</span>HasValue <span class="token punctuation">?</span></span> InterfaceProperty<span class="token punctuation">.</span>Value<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token string">"(not set)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="60"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="61"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ThrowingMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="62"></td><td><pre> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">InvalidOperationException</span><span class="token punctuation">(</span><span class="token string">"My exception message"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="63"></td><td><pre> <span class="token comment">// To throw a specific HRESULT, use COMException instead</span></pre></td></tr><tr><td data-num="64"></td><td><pre> <span class="token comment">//const Int32 COR_E_INVALIDOPERATION = unchecked((Int32)0x80131509);</span></pre></td></tr><tr><td data-num="65"></td><td><pre> <span class="token comment">//throw new COMException("Invalid Operation", COR_E_INVALIDOPERATION);</span></pre></td></tr><tr><td data-num="66"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="67"></td><td><pre> <span class="token preprocessor property">#<span class="token directive keyword">region</span> Arrays are passed, returned OR filled; never a combination</span></pre></td></tr><tr><td data-num="68"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token function">PassArray</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">ReadOnlyArray</span></span><span class="token punctuation">]</span> <span class="token comment">/* [In] implied */</span> <span class="token class-name">Int32<span class="token punctuation">[</span><span class="token punctuation">]</span></span> data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="69"></td><td><pre> <span class="token comment">// NOTE: Modified array contents MAY not be marshaled out; do not modify the array</span></pre></td></tr><tr><td data-num="70"></td><td><pre> <span class="token keyword">return</span> data<span class="token punctuation">.</span><span class="token function">Sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="71"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="72"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token function">FillArray</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">WriteOnlyArray</span></span><span class="token punctuation">]</span> <span class="token comment">/* [Out] implied */</span> <span class="token class-name">Int32<span class="token punctuation">[</span><span class="token punctuation">]</span></span> data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="73"></td><td><pre> <span class="token comment">// NOTE: Original array contents MAY not be marshaled in; </span></pre></td></tr><tr><td data-num="74"></td><td><pre> <span class="token comment">// write to the array before reading from it</span></pre></td></tr><tr><td data-num="75"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> data<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">)</span> data<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="76"></td><td><pre> <span class="token keyword">return</span> data<span class="token punctuation">.</span>Length<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="77"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="78"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32<span class="token punctuation">[</span><span class="token punctuation">]</span></span> <span class="token function">ReturnArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="79"></td><td><pre> <span class="token comment">// Array is marshaled out upon return</span></pre></td></tr><tr><td data-num="80"></td><td><pre> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Int32<span class="token punctuation">[</span><span class="token punctuation">]</span></span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="81"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="82"></td><td><pre> <span class="token preprocessor property">#<span class="token directive keyword">endregion</span></span></pre></td></tr><tr><td data-num="83"></td><td><pre> <span class="token comment">// Collections are passed by reference</span></pre></td></tr><tr><td data-num="84"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">PassAndModifyCollection</span><span class="token punctuation">(</span><span class="token class-name">IDictionary<span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token punctuation">></span></span> collection<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="85"></td><td><pre> collection<span class="token punctuation">[</span><span class="token string">"Key2"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Value2"</span><span class="token punctuation">;</span> <span class="token comment">// Modifies collection in place via interop</span></pre></td></tr><tr><td data-num="86"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="87"></td><td><pre> <span class="token preprocessor property">#<span class="token directive keyword">region</span> Method overloading</span></pre></td></tr><tr><td data-num="88"></td><td><pre> <span class="token comment">// Overloads with same # of parameters are considered identical to JavaScript</span></pre></td></tr><tr><td data-num="89"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SomeMethod</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="90"></td><td><pre> <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Windows<span class="token punctuation">.</span>Foundation<span class="token punctuation">.</span>Metadata<span class="token punctuation">.</span>DefaultOverload</span></span><span class="token punctuation">]</span> <span class="token comment">// Makes this method the default overload</span></pre></td></tr><tr><td data-num="91"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SomeMethod</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="92"></td><td><pre> <span class="token preprocessor property">#<span class="token directive keyword">endregion</span></span></pre></td></tr><tr><td data-num="93"></td><td><pre> <span class="token preprocessor property">#<span class="token directive keyword">region</span> Automatically implemented event</span></pre></td></tr><tr><td data-num="94"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">event</span> <span class="token class-name">WinRTDelegate</span> AutoEvent<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="95"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">String</span> <span class="token function">RaiseAutoEvent</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> number<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="96"></td><td><pre> <span class="token class-name">WinRTDelegate</span> d <span class="token operator">=</span> AutoEvent<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="97"></td><td><pre> <span class="token keyword">return</span> <span class="token punctuation">(</span>d <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">?</span> <span class="token string">"No callbacks registered"</span> <span class="token punctuation">:</span> <span class="token function">d</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="98"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="99"></td><td><pre> <span class="token preprocessor property">#<span class="token directive keyword">endregion</span></span></pre></td></tr><tr><td data-num="100"></td><td><pre> <span class="token preprocessor property">#<span class="token directive keyword">region</span> Manually implemented event</span></pre></td></tr><tr><td data-num="101"></td><td><pre> <span class="token comment">// Private field that keeps track of the event's registered delegates</span></pre></td></tr><tr><td data-num="102"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">EventRegistrationTokenTable<span class="token punctuation">&lt;</span>WinRTDelegate<span class="token punctuation">></span></span> m_manualEvent <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="103"></td><td><pre> <span class="token comment">// Manual implementation of the event's add and remove methods</span></pre></td></tr><tr><td data-num="104"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">event</span> <span class="token return-type class-name">WinRTDelegate</span> ManualEvent <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="105"></td><td><pre> <span class="token keyword">add</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="106"></td><td><pre> <span class="token comment">// Gets the existing table, or creates a new one if the table is not yet initialized</span></pre></td></tr><tr><td data-num="107"></td><td><pre> <span class="token keyword">return</span> EventRegistrationTokenTable<span class="token operator">&lt;</span>WinRTDelegate<span class="token operator">></span></pre></td></tr><tr><td data-num="108"></td><td><pre> <span class="token punctuation">.</span><span class="token function">GetOrCreateEventRegistrationTokenTable</span><span class="token punctuation">(</span><span class="token keyword">ref</span> m_manualEvent<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="109"></td><td><pre> <span class="token punctuation">.</span><span class="token function">AddEventHandler</span><span class="token punctuation">(</span><span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="110"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="111"></td><td><pre> <span class="token keyword">remove</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="112"></td><td><pre> EventRegistrationTokenTable<span class="token operator">&lt;</span>WinRTDelegate<span class="token operator">></span></pre></td></tr><tr><td data-num="113"></td><td><pre> <span class="token punctuation">.</span><span class="token function">GetOrCreateEventRegistrationTokenTable</span><span class="token punctuation">(</span><span class="token keyword">ref</span> m_manualEvent<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="114"></td><td><pre> <span class="token punctuation">.</span><span class="token function">RemoveEventHandler</span><span class="token punctuation">(</span><span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="115"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="116"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="117"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">String</span> <span class="token function">RaiseManualEvent</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> number<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="118"></td><td><pre> <span class="token class-name">WinRTDelegate</span> d <span class="token operator">=</span> EventRegistrationTokenTable<span class="token operator">&lt;</span>WinRTDelegate<span class="token operator">></span></pre></td></tr><tr><td data-num="119"></td><td><pre> <span class="token punctuation">.</span><span class="token function">GetOrCreateEventRegistrationTokenTable</span><span class="token punctuation">(</span><span class="token keyword">ref</span> m_manualEvent<span class="token punctuation">)</span><span class="token punctuation">.</span>InvocationList<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="120"></td><td><pre> <span class="token keyword">return</span> <span class="token punctuation">(</span>d <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">?</span> <span class="token string">"No callbacks registered"</span> <span class="token punctuation">:</span> <span class="token function">d</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="121"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="122"></td><td><pre> <span class="token preprocessor property">#<span class="token directive keyword">endregion</span></span></pre></td></tr><tr><td data-num="123"></td><td><pre> <span class="token preprocessor property">#<span class="token directive keyword">region</span> Asynchronous methods</span></pre></td></tr><tr><td data-num="124"></td><td><pre> <span class="token comment">// Async methods MUST return IAsync[Action|Operation](WithProgress)</span></pre></td></tr><tr><td data-num="125"></td><td><pre> <span class="token comment">// NOTE: Other languages see the DataTimeOffset as Windows.Foundation.DateTime</span></pre></td></tr><tr><td data-num="126"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">IAsyncOperationWithProgress<span class="token punctuation">&lt;</span>DateTimeOffset<span class="token punctuation">,</span> Int32<span class="token punctuation">></span></span> <span class="token function">DoSomethingAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="127"></td><td><pre> <span class="token comment">// Use the System.Runtime.InteropServices.WindowsRuntime.AsyncInfo's Run methods to </span></pre></td></tr><tr><td data-num="128"></td><td><pre> <span class="token comment">// invoke a private method written entirely in managed code</span></pre></td></tr><tr><td data-num="129"></td><td><pre> <span class="token keyword">return</span> AsyncInfo<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Run</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>DateTimeOffset<span class="token punctuation">,</span> Int32<span class="token punctuation">></span></span></span><span class="token punctuation">(</span>DoSomethingAsyncInternal<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="130"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="131"></td><td><pre> <span class="token comment">// Implement the async operation via a private method using normal .NET technologies</span></pre></td></tr><tr><td data-num="132"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task<span class="token punctuation">&lt;</span>DateTimeOffset<span class="token punctuation">></span></span> <span class="token function">DoSomethingAsyncInternal</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="133"></td><td><pre> <span class="token class-name">CancellationToken</span> ct<span class="token punctuation">,</span> <span class="token class-name">IProgress<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">></span></span> progress<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="134"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="135"></td><td><pre> <span class="token comment">// This code supports cancellation and progress reporting</span></pre></td></tr><tr><td data-num="136"></td><td><pre> ct<span class="token punctuation">.</span><span class="token function">ThrowIfCancellationRequested</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="137"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>progress <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> progress<span class="token punctuation">.</span><span class="token function">Report</span><span class="token punctuation">(</span>x <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="138"></td><td><pre> <span class="token keyword">await</span> Task<span class="token punctuation">.</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Simulate doing something asynchronously</span></pre></td></tr><tr><td data-num="139"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="140"></td><td><pre> <span class="token keyword">return</span> DateTimeOffset<span class="token punctuation">.</span>Now<span class="token punctuation">;</span> <span class="token comment">// Ultimate return value</span></pre></td></tr><tr><td data-num="141"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="142"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">IAsyncOperation<span class="token punctuation">&lt;</span>DateTimeOffset<span class="token punctuation">></span></span> <span class="token function">DoSomethingAsync2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="143"></td><td><pre> <span class="token comment">// If you don’t need cancellation &amp; progress, use </span></pre></td></tr><tr><td data-num="144"></td><td><pre> <span class="token comment">// System.WindowsRuntimeSystemExtensions’ AsAsync[Action|Operation] Task </span></pre></td></tr><tr><td data-num="145"></td><td><pre> <span class="token comment">// extension methods (these call AsyncInfo.Run internally)</span></pre></td></tr><tr><td data-num="146"></td><td><pre> <span class="token keyword">return</span> <span class="token function">DoSomethingAsyncInternal</span><span class="token punctuation">(</span><span class="token keyword">default</span><span class="token punctuation">(</span><span class="token type-expression class-name">CancellationToken</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">AsAsyncOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="147"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="148"></td><td><pre> <span class="token preprocessor property">#<span class="token directive keyword">endregion</span></span></pre></td></tr><tr><td data-num="149"></td><td><pre> <span class="token comment">// After you ship a version, mark new members with a [Version(#)] attribute</span></pre></td></tr><tr><td data-num="150"></td><td><pre> <span class="token comment">// so that WinMDExp.exe puts the new members in a different underlying COM </span></pre></td></tr><tr><td data-num="151"></td><td><pre> <span class="token comment">// interface. This is required since COM interfaces are supposed to be immutable.</span></pre></td></tr><tr><td data-num="152"></td><td><pre> <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Version</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="153"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">NewMethodAddedInV2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="154"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="155"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The following JavaScript code demonstrates how to access all of the previous WinRT components and features.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>function <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Make accessing the namespace more convenient in the code</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> WinRTComps <span class="token operator">=</span> Wintellect<span class="token punctuation">.</span>WinRTComponents<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// NOTE: The JavaScript VM projects WinRT APIs via camel casing</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// Access WinRT type's static method &amp; property </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> s <span class="token operator">=</span> WinRTComps<span class="token punctuation">.</span>WinRTClass<span class="token punctuation">.</span><span class="token function">staticMethod</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// NOTE: JavaScript pass "null" here!</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">var</span> <span class="token keyword">struct</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> anumber<span class="token punctuation">:</span> <span class="token number">123</span><span class="token punctuation">,</span> <span class="token named-parameter punctuation">astring</span><span class="token punctuation">:</span> <span class="token string">"Jeff"</span><span class="token punctuation">,</span> <span class="token named-parameter punctuation">aenum</span><span class="token punctuation">:</span> WinRTComps<span class="token punctuation">.</span>WinRTEnum<span class="token punctuation">.</span>notNone <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> WinRTComps<span class="token punctuation">.</span>WinRTClass<span class="token punctuation">.</span>staticProperty <span class="token operator">=</span> <span class="token keyword">struct</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> s <span class="token operator">=</span> WinRTComps<span class="token punctuation">.</span>WinRTClass<span class="token punctuation">.</span>staticProperty<span class="token punctuation">;</span> <span class="token comment">// Read it back</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// If the method has out parameters, they and the return value </span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// are returned as an object’s properties </span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> s <span class="token operator">=</span> WinRTComps<span class="token punctuation">.</span>WinRTClass<span class="token punctuation">.</span><span class="token function">outParameters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> name <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token keyword">value</span><span class="token punctuation">;</span> <span class="token comment">// Return value</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">var</span> <span class="token keyword">struct</span> <span class="token operator">=</span> s<span class="token punctuation">.</span>x<span class="token punctuation">;</span> <span class="token comment">// an 'out' parameter</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> year <span class="token operator">=</span> s<span class="token punctuation">.</span>year<span class="token punctuation">;</span> <span class="token comment">// another 'out' parameter</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token comment">// Construct an instance of the WinRT component</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> winRTClass <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">WinRTComps<span class="token punctuation">.</span>WinRTClass</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre> s <span class="token operator">=</span> winRTClass<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Call ToString()</span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token comment">// Demonstrate throw and catch</span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span> winRTClass<span class="token punctuation">.</span><span class="token function">throwingMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">err</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token comment">// Array passing</span></pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> sum <span class="token operator">=</span> winRTClass<span class="token punctuation">.</span><span class="token function">passArray</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token comment">// Array filling</span></pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> arrayOut <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// NOTE: fillArray sees all zeros!</span></pre></td></tr><tr><td data-num="27"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> length <span class="token operator">=</span> winRTClass<span class="token punctuation">.</span><span class="token function">fillArray</span><span class="token punctuation">(</span>arrayOut<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// On return, arrayOut = [0, 1, 2]</span></pre></td></tr><tr><td data-num="28"></td><td><pre> <span class="token comment">// Array returning</span></pre></td></tr><tr><td data-num="29"></td><td><pre> a <span class="token operator">=</span> winRTClass<span class="token punctuation">.</span><span class="token function">returnArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// a = [ 1, 2, 3]</span></pre></td></tr><tr><td data-num="30"></td><td><pre> <span class="token comment">// Pass a collection and have its elements modified</span></pre></td></tr><tr><td data-num="31"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> localSettings <span class="token operator">=</span> Windows<span class="token punctuation">.</span>Storage<span class="token punctuation">.</span>ApplicationData<span class="token punctuation">.</span>current<span class="token punctuation">.</span>localSettings<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre> localSettings<span class="token punctuation">.</span>values<span class="token punctuation">[</span><span class="token string">"Key1"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Value1"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre> winRTClass<span class="token punctuation">.</span><span class="token function">passAndModifyCollection</span><span class="token punctuation">(</span>localSettings<span class="token punctuation">.</span>values<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre> <span class="token comment">// On return, localSettings.values has 2 key/value pairs in it</span></pre></td></tr><tr><td data-num="35"></td><td><pre> <span class="token comment">// Call overloaded method</span></pre></td></tr><tr><td data-num="36"></td><td><pre> winRTClass<span class="token punctuation">.</span><span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Actually calls SomeMethod(String) passing "5"</span></pre></td></tr><tr><td data-num="37"></td><td><pre> <span class="token comment">// Consume the automatically implemented event</span></pre></td></tr><tr><td data-num="38"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> f <span class="token operator">=</span> function <span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> v<span class="token punctuation">.</span>target<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre> winRTClass<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"autoevent"</span><span class="token punctuation">,</span> f<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre> s <span class="token operator">=</span> winRTClass<span class="token punctuation">.</span><span class="token function">raiseAutoEvent</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre> <span class="token comment">// Consume the manually implemented event</span></pre></td></tr><tr><td data-num="42"></td><td><pre> winRTClass<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"manualevent"</span><span class="token punctuation">,</span> f<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre> s <span class="token operator">=</span> winRTClass<span class="token punctuation">.</span><span class="token function">raiseManualEvent</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre> <span class="token comment">// Invoke asynchronous method supporting progress, cancelation, &amp; error handling</span></pre></td></tr><tr><td data-num="45"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> promise <span class="token operator">=</span> winRTClass<span class="token punctuation">.</span><span class="token function">doSomethingAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre> promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="47"></td><td><pre> function <span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Async op complete: "</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="48"></td><td><pre> function <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Async op error: "</span> <span class="token operator">+</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="49"></td><td><pre> function <span class="token punctuation">(</span>progress<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="50"></td><td><pre> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Async op progress: "</span> <span class="token operator">+</span> progress<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="51"></td><td><pre> <span class="token comment">//if (progress == 30) promise.cancel(); // To test cancelation</span></pre></td></tr><tr><td data-num="52"></td><td><pre> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="53"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>💡小结：如果唯一的使用者就是在 CLR 顶部运行的其他托管语言，那么用 C# 定义的 WinRT 组件就没有什么意义。这是由于 WinRT 类型系统功能少得多，相比 CLR 的类型系统限制太大。用 C# 定义能由原生 C/C++ 代码使用的 WinRT 组件也没有多大意义。一般情况下，应用程序关心性能和内存消耗时才会用原生 C/C++ 来实现。这时不太可能使用由托管代码实现的 WinRT 组件，否则就要被迫在进程中加载 CLR，增大内存消耗和降低性能 (因为要进行垃圾回收和 JIT 编译)。所以，大多数 WinRT 组件 (比如随同 Windows 提供的那些) 都是用原生代码实现的。当然，如果原生 C++ 应用的某些部分对性能不敏感，就可考虑利用 .NET Framework 的功能来提高开发效率。例如，必应地图 Bing Maps 用原生 C++ 和 DirectX 绘制 UI，但业务逻辑用 C# 实现。用 C# 实现的 WinRT 组件最佳应用场合就是：Windows Store 应用的开发人员用 HTML 和 CSS 构建 UI。然后，使用 JavaScript 代码将 UI 和用 C# WinRT 组件实现的业务逻辑 “粘合” 起来。还有一个应用场合是在 HTML/JavaScript 应用中使用现有的 FCL 功能 (比如 WCF)。HTML/JavaScript 开发人员已习惯了浏览器引擎造成的性能损失和内存消耗，所以基本上能接受使用 CLR 造成的额外性能损失和内存消耗。用 C# 定义 WinRT 组件首先要在 Microsoft Visual Studio 中创建 “Windows 运行时组件” 项目。创建的其实是一个普通的类库项目，但 C# 编译器会自动添加 <code>t/:winmdobj</code> 命令行开关来生成 .winmdobj 文件。文件中会插入一些和平时不同的 IL 代码。例如，WinRT 组件采用和 CLR 不同的方式为事件添加和删除委托。所以，如果指定了这个编译器开关，编译器就会为事件的添加和删除方法生成不同的代码。编译器生成 .winmdobj 文件后将启动 WinMD 实用程序 (WinMDExp.exe)&lt;sup&gt;①&lt;/sup&gt;，向它传递由编译器生成的 .winmdobj，.pdb 和 .xml (doc) 文件。WinMDExp.exe 实用程序检查文件的元数据，确保你的类型符合本章开头讨论的 WinRT 类型系统的各种规则。实用程序还会修改 .winmdobj 文件中的元数据；它一点儿都不会碰 IL 代码。具体地说，实用程序只能将 CLR 类型映射到等价的 WinRT 类型。例如，对 .NET Framework <code>IList&lt;String&gt;</code> 类型的引用被更改为 WinRT 的 <code>IVector&lt;String&gt;</code> 类型。WinMDExp.exe 输出的是可供其他语言使用的 .winmd 文件。可用 .NET Framework 的 IL 反汇编器工具 (ILDasm.exe) 检查.winmd 文件的内容。ILDasm.exe 默认显示文件的原始内容。但它支持用 <code>/project</code> 命令行开关显示将 WinRT 类型投射成 .NET Framework 等价类型之后的元数据。</p><div class="tags"><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 读书笔记</a> <a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C#</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2022-12-06 11:20:14" itemprop="dateModified" datetime="2022-12-06T11:20:14+08:00">2022-12-06</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Sakupinera WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Sakupinera Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Sakupinera PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Sakupinera <i class="ic i-at"><em>@</em></i>Sakupinera</li><li class="link"><strong>Post link: </strong><a href="http://sakupinera.github.io/2022/12/06/csharp/clr-via-csharp/Chapter%2025%20Interoperating%20with%20WinRT%20%20Components/" title="CLR via C# - Chapter 25 Interoperating with WinRT Components">http://sakupinera.github.io/2022/12/06/csharp/clr-via-csharp/Chapter 25 Interoperating with WinRT Components/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;03&#x2F;08&#x2F;hub7DjxPVYvzoB4.jpg" title="CLR via C# - Chapter 24 Runtime Serialization"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 24 Runtime Serialization</h3></a></div><div class="item right"><a href="/2022/12/09/cpp/cpp-primer/Chapter%201%20Getting%20Started/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;03&#x2F;08&#x2F;AK1D84aqsYghTOC.jpg" title="C++ Primer - Chapter 1 Getting Started"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i> Cpp-Primer</span><h3>C++ Primer - Chapter 1 Getting Started</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-25-interoperating-with-winrt-components"><span class="toc-number">1.</span> <span class="toc-text">Chapter 25 Interoperating with WinRT Components</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#clr-projections-and-winrt-component-type-system-rules"><span class="toc-number">1.1.</span> <span class="toc-text">CLR Projections and WinRT Component Type System Rules</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#winrt-type-system-core-concepts"><span class="toc-number">1.1.1.</span> <span class="toc-text">WinRT Type System Core Concepts</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#framework-projections"><span class="toc-number">1.2.</span> <span class="toc-text">Framework Projections</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#calling-asynchronous-winrt-apis-from-net-code"><span class="toc-number">1.2.1.</span> <span class="toc-text">Calling Asynchronous WinRT APIs from .NET Code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#interoperating-between-winrt-streams-and-net-streams"><span class="toc-number">1.2.2.</span> <span class="toc-text">Interoperating Between WinRT Streams and .NET Streams</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#passing-blocks-of-data-between-the-clr-and-winrt"><span class="toc-number">1.2.3.</span> <span class="toc-text">Passing Blocks of Data Between the CLR and WinRT</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#defining-winrt-components-in-c"><span class="toc-number">1.3.</span> <span class="toc-text">Defining WinRT Components in C#</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"><ul><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/" rel="bookmark" title="CLR via C# - Chapter 1 The CLR’s Execution Model">CLR via C# - Chapter 1 The CLR’s Execution Model</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/" rel="bookmark" title="CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types">CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%203%20Shared%20Assemblies%20and%20Strongly%20Named%20Assemblies/" rel="bookmark" title="CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies">CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies</a></li><li><a href="/2022/09/27/csharp/clr-via-csharp/Chapter%204%20Type%20Fundamentals/" rel="bookmark" title="CLR via C# - Chapter 4 Type Fundamentals">CLR via C# - Chapter 4 Type Fundamentals</a></li><li><a href="/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/" rel="bookmark" title="CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals">CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals</a></li><li><a href="/2022/10/21/csharp/clr-via-csharp/Chapter%206%20Type%20and%20Member%20Basics/" rel="bookmark" title="CLR via C# - Chapter 6 Type and Member Basics">CLR via C# - Chapter 6 Type and Member Basics</a></li><li><a href="/2022/10/24/csharp/clr-via-csharp/Chapter%207%20Constants%20and%20Fields/" rel="bookmark" title="CLR via C# - Chapter 7 Constants and Fields">CLR via C# - Chapter 7 Constants and Fields</a></li><li><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" rel="bookmark" title="CLR via C# - Chapter 8 Methods">CLR via C# - Chapter 8 Methods</a></li><li><a href="/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/" rel="bookmark" title="CLR via C# - Chapter 9 Parameters">CLR via C# - Chapter 9 Parameters</a></li><li><a href="/2022/10/28/csharp/clr-via-csharp/Chapter%2010%20Properties/" rel="bookmark" title="CLR via C# - Chapter 10 Properties">CLR via C# - Chapter 10 Properties</a></li><li><a href="/2022/10/29/csharp/clr-via-csharp/Chapter%2011%20Events/" rel="bookmark" title="CLR via C# - Chapter 11 Events">CLR via C# - Chapter 11 Events</a></li><li><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" rel="bookmark" title="CLR via C# - Chapter 12 Generics">CLR via C# - Chapter 12 Generics</a></li><li><a href="/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/" rel="bookmark" title="CLR via C# - Chapter 13 Interfaces">CLR via C# - Chapter 13 Interfaces</a></li><li><a href="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/" rel="bookmark" title="CLR via C# - Chapter 14 Chars, Strings, and Working with Text">CLR via C# - Chapter 14 Chars, Strings, and Working with Text</a></li><li><a href="/2022/11/17/csharp/clr-via-csharp/Chapter%2015%20Enumerated%20Types%20and%20Bit%20Flags/" rel="bookmark" title="CLR via C# - Chapter 15 Enumerated Types and Bit Flags">CLR via C# - Chapter 15 Enumerated Types and Bit Flags</a></li><li><a href="/2022/11/19/csharp/clr-via-csharp/Chapter%2016%20Arrays/" rel="bookmark" title="CLR via C# - Chapter 16 Arrays">CLR via C# - Chapter 16 Arrays</a></li><li><a href="/2022/11/21/csharp/clr-via-csharp/Chapter%2017%20Delegates/" rel="bookmark" title="CLR via C# - Chapter 17 Delegates">CLR via C# - Chapter 17 Delegates</a></li><li><a href="/2022/11/22/csharp/clr-via-csharp/Chapter%2018%20Custom%20Attributes/" rel="bookmark" title="CLR via C# - Chapter 18 Custom Attributes">CLR via C# - Chapter 18 Custom Attributes</a></li><li><a href="/2022/11/23/csharp/clr-via-csharp/Chapter%2019%20Nullable%20Value%20Types/" rel="bookmark" title="CLR via C# - Chapter 19 Nullable Value Types">CLR via C# - Chapter 19 Nullable Value Types</a></li><li><a href="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/" rel="bookmark" title="CLR via C# - Chapter 20 Exceptions and State Management">CLR via C# - Chapter 20 Exceptions and State Management</a></li><li><a href="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/" rel="bookmark" title="CLR via C# - Chapter 21 The Managed Heap and Garbage  Collection">CLR via C# - Chapter 21 The Managed Heap and Garbage Collection</a></li><li><a href="/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/" rel="bookmark" title="CLR via C# - Chapter 22 CLR Hosting and AppDomains">CLR via C# - Chapter 22 CLR Hosting and AppDomains</a></li><li><a href="/2022/11/29/csharp/clr-via-csharp/Chapter%2023%20Assembly%20Loading%20and%20Reflection/" rel="bookmark" title="CLR via C# - Chapter 23 Assembly Loading and Reflection">CLR via C# - Chapter 23 Assembly Loading and Reflection</a></li><li><a href="/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/" rel="bookmark" title="CLR via C# - Chapter 24 Runtime Serialization">CLR via C# - Chapter 24 Runtime Serialization</a></li><li class="active"><a href="/2022/12/06/csharp/clr-via-csharp/Chapter%2025%20Interoperating%20with%20WinRT%20%20Components/" rel="bookmark" title="CLR via C# - Chapter 25 Interoperating with WinRT Components">CLR via C# - Chapter 25 Interoperating with WinRT Components</a></li><li><a href="/2023/02/06/csharp/clr-via-csharp/Chapter%2026%20Thread%20Basics/" rel="bookmark" title="CLR via C# - Chapter 26 Thread Basics">CLR via C# - Chapter 26 Thread Basics</a></li><li><a href="/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations">CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations</a></li><li><a href="/2023/02/08/csharp/clr-via-csharp/Chapter%2028%20IO-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 28 IO-Bound Asynchronous Operations">CLR via C# - Chapter 28 IO-Bound Asynchronous Operations</a></li><li><a href="/2023/02/09/csharp/clr-via-csharp/Chapter%2029%20Primitive%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 29 Primitive Thread Synchronization">CLR via C# - Chapter 29 Primitive Thread Synchronization</a></li><li><a href="/2023/02/10/csharp/clr-via-csharp/Chapter%2030%20Hybrid%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 30 Hybrid Thread Synchronization">CLR via C# - Chapter 30 Hybrid Thread Synchronization</a></li></ul></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sakupinera" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Sakupinera</p><div class="description" itemprop="description">保持你的决心！</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">86</span> <span class="name">posts</span></a></div><div class="item categories"><a href="/categories/"><span class="count">13</span> <span class="name">categories</span></a></div><div class="item tags"><a href="/tags/"><span class="count">6</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nha3VwaW5lcmE=" title="https:&#x2F;&#x2F;github.com&#x2F;sakupinera"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9zYWt1cGluZXJh" title="https:&#x2F;&#x2F;twitter.com&#x2F;sakupinera"><i class="ic i-twitter"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQwNzIyOTA3MQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;407229071"><i class="ic i-cloud-music"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMjIzMDczOTg/c3BtX2lkX2Zyb209MzMzLjEwMDcuMC4w" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;22307398?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li><li class="item"><a href="/games/" rel="section"><i class="ic i-flag"></i>Games</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-person"></i>About</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/12/09/cpp/cpp-primer/Chapter%201%20Getting%20Started/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/" title="CLR via C# - Chapter 14 Chars, Strings, and Working with Text">CLR via C# - Chapter 14 Chars, Strings, and Working with Text</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/23/csharp/clr-via-csharp/Chapter%2019%20Nullable%20Value%20Types/" title="CLR via C# - Chapter 19 Nullable Value Types">CLR via C# - Chapter 19 Nullable Value Types</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2023/02/10/csharp/clr-via-csharp/Chapter%2030%20Hybrid%20Thread%20Synchronization%20Constructs/" title="CLR via C# - Chapter 30 Hybrid Thread Synchronization">CLR via C# - Chapter 30 Hybrid Thread Synchronization</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/08/28/linux/learn-linux/Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/" title="LearnLinux - Linux系统安装">LearnLinux - Linux系统安装</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CSharp-in-a-Nutshell/" title="In CSharp-in-a-Nutshell">CSharp-in-a-Nutshell</a></div><span><a href="/2022/08/29/csharp/csharp-in-a-nutshell/%E7%AC%AC2%E7%AB%A0%20%E5%9C%A8CSharp%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%9E%8B/" title="C# in a Nutshell - 第2章 C#语言基础">C# in a Nutshell - 第2章 C#语言基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/08/28/linux/learn-linux/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/" title="LearnLinux - 权限管理">LearnLinux - 权限管理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2023/01/11/cpp/cpp-primer/Chapter%2019%20Specialized%20Tools%20and%20Techniques/" title="C++ Primer - Chapter 19 Specialized Tools and Techniques">C++ Primer - Chapter 19 Specialized Tools and Techniques</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/22/csharp/clr-via-csharp/Chapter%2018%20Custom%20Attributes/" title="CLR via C# - Chapter 18 Custom Attributes">CLR via C# - Chapter 18 Custom Attributes</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/" title="CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types">CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/09/05/linux/learn-linux/%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/" title="LearnLinux - 备份与恢复">LearnLinux - 备份与恢复</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Sakupinera @ Hanamai Sora</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="Symbols count total">2.2m words</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="Reading time total">33:30</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/12/06/csharp/clr-via-csharp/Chapter 25 Interoperating with WinRT  Components/",favicon:{show:"（●´3｀●）Goooood",hide:"(´Д｀)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/shifuku.model.json"},display:{position:"left",width:250,height:500},mobile:{show:!1},react:{opacity:.9},log:!1})</script></body></html>