<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sakupinera" href="http://sakupinera.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sakupinera" href="http://sakupinera.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sakupinera" href="http://sakupinera.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="学习笔记,CG"><link rel="canonical" href="http://sakupinera.github.io/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/"><title>GAMES101 - Cameras, Lenses and Light Fields（相机，透镜和光场） - GAMES101 - Computer-Graphics | Hanamai Sora = Sakupinera</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">GAMES101 - Cameras, Lenses and Light Fields（相机，透镜和光场）</h1><div class="meta"><span class="item" title="Created: 2022-10-31 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2022-10-31T00:00:00+08:00">2022-10-31</time> </span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">Symbols count in article</span> <span>11k</span> <span class="text">words</span> </span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">Reading time</span> <span>10 mins.</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hanamai Sora</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipexoj0moj20zk0m8kgu.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giciszlczyj20zk0m816d.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipetfk5zwj20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gicit31ffoj20zk0m8naf.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipeudstjqj20zk0m8k3r.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gicm0n457cj20zk0m8e81.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Computer-Graphics/" itemprop="item" rel="index" title="In Computer-Graphics"><span itemprop="name">Computer-Graphics</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Computer-Graphics/GAMES101/" itemprop="item" rel="index" title="In GAMES101"><span itemprop="name">GAMES101</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://sakupinera.github.io/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Sakupinera"><meta itemprop="description" content=", 保持你的决心！"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakupinera"></span><div class="body md" itemprop="articleBody"><h1 id="cameras-lenses-and-light-fields相机透镜和光场"><a class="anchor" href="#cameras-lenses-and-light-fields相机透镜和光场">#</a> Cameras, Lenses and Light Fields（相机，透镜和光场）</h1><h2 id="imaging-synthesis-capture"><a class="anchor" href="#imaging-synthesis-capture">#</a> Imaging = Synthesis + Capture</h2><p>我们之前说过计算机图形学里面有两种成像方法，一种是光栅化成像，一种是光线追踪成像，这两种方法都是属于合成（Synthesis）方法，也就是说这些场景本身在自然界中实际不存在。但是我们不止能通过合成方法来成像，还能通过捕捉方法来成像。捕捉（Capture）方法指的是把真实世界存在的场景变成照片，而最简单的捕捉方法就是用相机来捕捉。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221021144843720.png" alt="image-20221021144843720"></p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221021144905073.png" alt="image-20221021144905073"></p><p>最早的时候大家研究相机是从小孔成像的现象开始的，光线由于直线传播在穿过小孔后会形成一个倒立的像，右边如果再放上一个传感器将其记录在胶片上就能得到一张相片，这种相机也叫做针孔相机。我们平常见的更多的还是上图下面那种带透镜的相机。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221021144944200.png" alt="image-20221021144944200"></p><p>上图是一个去掉了镜头的相机，我们看到的这个部分就是控制光是否能够进入机身的一个部件，也就是快门（Shutter）。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221021145007269.png" alt="image-20221021145007269"></p><p>当光进入相机之后，还需要一个部件把光捕捉并且记录下来，这个部件叫作传感器（Sensor）。传感器上的任意一个点记录的是 Irradiance 的信息。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221021145042310.png" alt="image-20221021145042310"></p><p>如果一个相机没有镜头，那么它要想拍照是不可能的，这是因为如果直接把传感器放在人的面前，那么传感器的任何一个点都可能会收集到来不同方向的光，也就是说它收集的是 Irradiance 的信息而不是 Radiance 的信息，这样拍出来的东西都是糊的。</p><h2 id="pinhole-image-formation"><a class="anchor" href="#pinhole-image-formation">#</a> Pinhole Image Formation</h2><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221021145121665.png" alt="image-20221021145121665"></p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221021145141678.png" alt="image-20221021145141678"></p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221021145200200.png" alt="image-20221021145200200"></p><p>针孔相机拍出来的东西是没有深度可言的，也就是说它的任意一个部分都不会是虚的，都一定是清楚锐利的，不会有虚化的现象。我们做光线追踪时用的就是针孔摄像机的模型，因此我们也得不出不同的地方有不同的模糊，所谓景深的效果。</p><h2 id="field-of-view-fov"><a class="anchor" href="#field-of-view-fov">#</a> Field of View (FOV)</h2><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221021145229836.png" alt="image-20221021145229836"></p><p>视场（FOV）指的是我们能看到多大的范围，对于广角镜头来说能看到的 FOV 更大，而对于普通的手机来说它们的 FOV 就更窄。我们这里关心的是什么因素能够决定这个视场。从小孔成像的针孔摄像机来理解，我们认为传感器能感受到所有的光线，传感器的宽度为 h，距离小孔的距离叫作焦距<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span></span></span></span>，那么 FOV 对应的角度就能通过 arctan 算出来。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221021145247884.png" alt="image-20221021145247884"></p><p>不同的视场一定会导致不同的拍照结果，因此我们需要一个严格的定义。由于视场和传感器大小和焦距都有关系，因此人们在定义视场的时候通常以 35mm 的胶片为基准。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221021145302818.png" alt="image-20221021145302818"></p><p>不同 FOV 的镜头自然就会拍出各种各样不同的效果，当视场越窄时，我们能看到的地方就越远。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221021145325005.png" alt="image-20221021145325005"></p><p>如果我们真的能够改变传感器的大小，那么在相同的焦距情况下，小一点的传感器自然就会对应小一点的视场。这里我们实际混淆的使用了两个概念，一个是传感器，一个是胶片。正常情况下，我们不区分这两个概念没什么关系，但对于渲染来说，传感器负责记录每个像素收到的 Irradiance 有多大，最后用胶片来把它存成相应的格式，因此这两个概念可以不一样，但对于我们目前来说把它们混淆使用也无所谓。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221021145345886.png" alt="image-20221021145345886"></p><p>传感器当然可以有不同的大小，对于一个大的相机它就有更大的传感器，也就意味着它有更大的分辨率，因此不同的相机它们的价格各不相同。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221021145413050.png" alt="image-20221021145413050"></p><p>如果我们想要让较小传感器的手机拥有和相机相同的 FOV，那么我们就让手机的焦距也给变小，以此就可以达到相同的 FOV。</p><h2 id="exposure"><a class="anchor" href="#exposure">#</a> Exposure</h2><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024160123461.png" alt="image-20221024160123461"></p><p>曝光被定义成 Irradiance 和时间的乘积。如果对着一个明亮的场景拍一张照，那么得到的结果看上去就亮一些；如果对着一个相对比较暗的场景拍一张照，但是快门按下的时间很长，也就是说曝光的时间很长，那么也能得到一个比较亮的照片。也就是说，一个是单位时间进来多少光，一个是进来多长的时间，把这两个乘积起来就能得到曝光度。Irradiance 的大小由很多因素决定，其中一个因素就是光圈的大小，光圈的大小会影响到镜头到底能接受到多少光，也就是说，相机上有很多可以控制的部分来影响最后的曝光度是多少。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024160156258.png" alt="image-20221024160156258"></p><p>那么在相机里面到底有哪些因素在影响最后的照片拍出来亮不亮呢？第一，光圈的大小。由于相机是一个精密仪器，它是可以控制光圈的大小的，这通过 f-stop 来控制。光圈实际上是一个仿生学的设计，对于光圈来说它是在仿照人的瞳孔，人的瞳孔是可以动态调节大小的，如果在相对暗的环境下，瞳孔会自动放大，这样单位时间下就能接受更多的光，能看清更多的东西。如果在相对亮的环境下，瞳孔会自动缩小，以此来防止更多的光进来灼伤视网膜。第二，快门的速度。Shutter speed 越快就意味着快门开放的时间越短，就意味着只能有更少的光才能进来，反之亦然。第三，ISO 增益（感光度）。简单的理解，ISO 是一种后期的处理，当最后感光元件已经感知到了某个层级的光，在后期再给它乘上某一个数来对结果进行修正。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024160213877.png" alt="image-20221024160213877"></p><p>上面这幅图就说明了相机上用各种不同的配置所能得到的结果。例如改变光圈的大小，这里用到了 f-stop 来表示光圈的大小，对应白色的部分，F 数越大光圈越小。Shutter speed 用一个分数表示，意味着快门开放多长的时间，1/1000 意味着开放 1ms。ISO 也能做出调整，不同的 ISO 可以理解为根据大小线性的相乘。另外，我们会发现，当光圈越大的时候，在照片的一定区域就会显得很虚；当快门开放时间越长的时候，会看到动态模糊的效果；ISO 增益越大的时候，由于存在噪声，在放大信号的同时也放大了噪声，因此当在很暗的一个房间里面用很小的光圈，但很短的快门时间，并且用一个相当大 ISO 试图把照片变得更亮，但是结果也会变得更加的 noisy。也就是说对于 ISO 来说，正常情况下不会通过调整它来得到更亮的图，在一定的小范围没有什么问题，在调整非常大的情况下，一定会出现噪声问题。这正是因为简单放大信号会同时放大噪声的原因。为什么会有噪声？这个问题实际上很深刻，这里最简单的一个理解就是把光认为是光子，如果快门时间不够，那么进入到感光元件的光子数就少，光子数那么最后看到的结果自然就很 noisy。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024160233828.png" alt="image-20221024160233828"></p><p>ISO 又叫增益，我们之前也说过，它是在结果上做简单的线性相乘。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024160251108.png" alt="image-20221024160251108"></p><p>我们控制其他的变量，让一张图得到的结果一张比一张暗，然后再通过 ISO 把它们调回来，使它们的亮度相同。我们就会看到，ISO 12800 的图明显比 ISO 100 的噪声明显，也就是说，ISO 确实能够提升曝光度，但是同样会造成噪声的放大问题。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024160312700.png" alt="image-20221024160312700"></p><p>用来描述光圈的大小是有一个数的，我们之前说过叫作 F 数（F-Number，也叫 F-Stop）。F 数有两种写法，一种是 FN，一种是 F/N（N 表示数字大小）。对 F 数的非正规理解是，F 数是光圈直径的逆，也就是 N 越大代表光圈的直径越小。由于光圈影响了在一个时间段内进入到相机内的能量大小，那么调整光圈自然就能得到各种不同的曝光度。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024160332656.png" alt="image-20221024160332656"></p><p>快门一开始是关闭的，之后会突然一下打开，然后再把它关上。这里快门从完全关闭状态到完全打开是有一个过程的，由于有这个过程存在所以会对图片造成一些影响，我们后面再说。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024160355477.png" alt="image-20221024160355477"></p><p>快门的曝光时间当然可以起到调整曝光度的作用，但是除了这个作用，我们还能看到运动模糊的现象。对于高速运动物体就很容易出现运动模糊，这是由于在快门打开的这段时间内，这个物体已经发生了一些运动，由于物体的起止位置不同，但是中间运动的过程也被记录了下来，并且传感器又起到了平均的作用，所以我们就能看到运动模糊的现象。如果把快门的曝光时间延长，那么进来的光就会更多，如果物体以相同的速率运动，那么移动的距离就会更大，那么运动模糊的现象就会更严重。这就反映了为什么用更长的曝光时间会造成更严重的运动模糊，反过来想，如果我们用等长的快门时间，那么物体运动更快就越容易出现运动模糊。我们这里说的快门都是机械式的快门，一些其他方式控制的快门我们这里不做介绍。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024160421761.png" alt="image-20221024160421761"></p><p>运动模糊并不一定是坏事，人们长久以来在感知这个世界的过程中，自然而然产生了有运动模糊的物体运动速度一定是快的这种认知。如果我们不想要运动模糊，那又意味着什么？我们在不同的帧去记录物体运动时不同的位置，由于实际上物体运动是连续的，也就相当于我们在不同的时间对物体所在的位置进行了采样，这就和我们之前说过的反走样非常像了，只不过这里的采样是在时间上的采样，运动模糊就相当于反走样的效果。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024160435632.png" alt="image-20221024160435632"></p><p>对于机械的快门来说，由于快门打开有一个过程。这如果物体的运动的运动比快门还快或者说速度差不多，那么这种情况下就一定会出问题，这个问题叫作 Rolling shutter 问题。例如上图的螺旋桨，我们就会看到明显的扭曲现象，之所以会扭曲是因为图像上的不同位置有可能记录的是不同时间进来的光。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024160455827.png" alt="image-20221024160455827"></p><p>我们把光圈和快门速度两个一起来考虑。快门时间短，那么照片就会暗，那么我们就要提高光圈的大小，也就是用更小的 F 数。上图的表格由于上下的一些对应，让每一列基本都可以达到相同的曝光度。例如 F-Stop 由 4.0 变为 8.0，也就是直径减小了一半，那么对应光圈的面积就变为了原本的 1/4，那么就应该用 4 倍的曝光时间去补偿照片的亮度。但是这并不意味着这两种方式得到照片的结果是一模一样的，我们之前也提到过大光圈会引起前景深的问题，我们之后还会分析，曝光度还会影响运动模糊。因此这两个参数正常情况下都是需要权衡的。</p><h2 id="fast-and-slow-photography"><a class="anchor" href="#fast-and-slow-photography">#</a> Fast and Slow Photography</h2><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024160521635.png" alt="image-20221024160521635"></p><p>如果平时经常摄影，我们可以拍出一些非常有意思的照片。高速摄影是每秒钟拍更多的帧数，然后再按照正常的速度来播放。而每一秒要拍出更多的照片，就意味着每一张照片留给它的快门时间就非常的短，但是我们又想让图片有正常的曝光度，那么就需要用更大的光圈或者更大的 ISO。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024160545748.png" alt="image-20221024160545748"></p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024160616051.png" alt="image-20221024160616051"></p><p>与高速摄影相反，低速摄影就是给照片特别特别长的曝光时间，并且用非常小的光圈去拍摄，这样拍出来的东西就是延时摄影。上图就是一个飞机着陆时的飞行轨迹。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024160643695.png" alt="image-20221024160643695"></p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024160701983.png" alt="image-20221024160701983"></p><h2 id="thin-lens-approximation"><a class="anchor" href="#thin-lens-approximation">#</a> Thin Lens Approximation</h2><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024160725760.png" alt="image-20221024160725760"></p><p>我们之前一直都在说相机各种不同地方的部件，还有一个最重要的部件我们还没有讲，那就是镜头。对于真正的摄影设备来说，它们的镜头都非常复杂，因为它们都会用透镜组来完成成像。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024160739914.png" alt="image-20221024160739914"></p><p>有一些透镜还不像我们通常假设的那种，它一面是凸的，一面是平的。像这种透镜它就不可能把光聚集到一块儿去，从而出现了 Aberration 这种性质。也就是说，实际的透镜可能很复杂，我们这里做了简化处理，也就是理想化的薄透镜，即透镜的厚度不作考虑。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024160758373.png" alt="image-20221024160758373"></p><p>理想化的情况，对于一束穿过透镜的平行光，它们都会被集中到一个点上，这个点叫作焦点，那么焦距就是焦点到棱镜中心的距离。由于光路有可逆性，也就意味着如果光线穿过了焦点被透镜折射之后就会变成平行光。我们这里还会假设这个薄透镜可以任意地改变它的焦距。虽然对于一个设计出来的透镜来说，它的焦距一定是固定的，我们之所以认为它能改是因为相机的透镜组通过不同的组合使得就好像是一个薄透镜能够任意的改变它的焦距一样。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024160824132.png" alt="image-20221024160824132"></p><p>透镜会满足一些基本的物理规律。除了我们之前说的平行光过透镜会被聚焦到焦点，以及过焦点的光会变成平行光出去之外，我们还会认为穿过透镜中心的光线它的方向不会发生改变。上图我们定义了物距<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mi>o</mi></msub></mrow><annotation encoding="application/x-tex">z_o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.04398em">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.04398em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>、像距<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">z_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.04398em">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.04398em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>，以及透镜的焦距<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span></span></span></span>。那么它们之间会满足上面的一个式子。这个式子说明对于一个固定焦距的透镜来说，如果改变它的物距，那么它的像距也一定会跟着改变。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024160841331.png" alt="image-20221024160841331"></p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024160858805.png" alt="image-20221024160858805"></p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024160915057.png" alt="image-20221024160915057"></p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024160931782.png" alt="image-20221024160931782"></p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024160950460.png" alt="image-20221024160950460"></p><h2 id="defocus-blur"><a class="anchor" href="#defocus-blur">#</a> Defocus Blur</h2><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024161010436.png" alt="image-20221024161010436"></p><p>通过薄透镜我们就能就是很多很多的问题，我们先来看看 Defocus Blur（散焦模糊），这也是涉及到景深的一个问题。为了解释模糊，我们需要引入一个概念，叫作 Circle of Confusion（CoC）。原本我们知道远处有一个平面（Focal Plane），这个平面上所有的光经过透镜之后都会被聚焦到右边成像的平面上（Sensor Plane），如果说有物体不在 Focal Plane 上，那么这个物体看上去就会比较模糊，这是由于根据之前得到的焦距、物距以及像距之间的关系，我们知道了 Object 会成像在 Image 这个平面，但是我们的成像平面（Sensor Plane）并不在这个地方，因此光线没有发生碰撞会继续传播，这就意味者左边一个点经过透镜被感光元件接收到的时候，它就不再是一个点了，而成了一个圆，这个圆就叫做 CoC。通过相似三角形我们可以写出上面的式子。假如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∣</mi><msub><mi>z</mi><mi>s</mi></msub><mo>−</mo><msub><mi>z</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi></mrow><msub><mi>z</mi><mi>i</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">|z_s-z_i|\over{z_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4550999999999998em;vertical-align:-.44509999999999994em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em"><span style="top:-2.655em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.04398em">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3280857142857143em"><span style="top:-2.357em;margin-left:-.04398em;margin-right:.07142857142857144em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.143em"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.485em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.04398em">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.16454285714285719em"><span style="top:-2.357em;margin-left:-.04398em;margin-right:.07142857142857144em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.143em"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.04398em">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3280857142857143em"><span style="top:-2.357em;margin-left:-.04398em;margin-right:.07142857142857144em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.143em"><span></span></span></span></span></span></span><span class="mord mtight">∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.44509999999999994em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 为定值，那么相机拍摄某个物体的模糊程度是和 aperture 的大小成正比的。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024161028069.png" alt="image-20221024161028069"></p><p>CoC 告诉了我们看到的东西模糊不模糊取决于光圈的大小。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024161103006.png" alt="image-20221024161103006"></p><p>既然说 CoC 和光圈的大小成正比，我们现在来给光圈一个正式的定义。之前我们简单的把 F 数定义为光圈直径大小的逆，这实际上是不对的，F 数实际的定义是焦距除以光圈的直径。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024161122161.png" alt="image-20221024161122161"></p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024161151111.png" alt="image-20221024161151111"></p><p>知道了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mi>f</mi><mi mathvariant="normal">/</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">A=f/N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span> 之后，我们又可以看出来 CoC 和 N 是有反比关系的，也就是说平时我们为了拍出更清楚的照片，那么就要用小光圈。</p><h2 id="ray-tracing-ideal-thin-lenses"><a class="anchor" href="#ray-tracing-ideal-thin-lenses">#</a> Ray Tracing Ideal Thin Lenses</h2><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024161218814.png" alt="image-20221024161218814"></p><p>我们现在已经知道光线会怎么穿过薄透镜，那么自然而然我们就可以使用薄透镜来渲染。之前做 Path Tracing 的时候，我们都是从相机往任何一个像素中的采样点去连线，其实就默认了这是小孔成像的模型，即针孔摄像机的模型。但是我们完全可以模拟出一个薄透镜的渲染过程。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024161235340.png" alt="image-20221024161235340"></p><p>在上面的场景中，我们确定了传感器的大小、透镜的焦距和光圈的大小。并且把透镜到我们想要拍摄的平面（Subject Plane）之间的距离记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">z_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.04398em">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.04398em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>。现在，透镜的属性设置好了，传感器也设置好了，并且它们都被放到场景中指定的位置上了，那么根据薄透镜公式，我们就可以求出传感器和透镜的距离<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">z_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.04398em">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.04398em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024161250514.png" alt="image-20221024161250514"></p><p>接下来就可以开始实际做 Ray Tracing。我们现在就是想找一些光线让它们穿过透镜打到场景里面去，那么就在 Sensor 上面找任意找一个点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">x&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.751892em;vertical-align:0"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.751892em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>，并且在透镜上选另外一个点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup></mrow><annotation encoding="application/x-tex">x&#x27;&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.751892em;vertical-align:0"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.751892em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>，然后把这两个点连一条线，之后我们就能立刻知道这条线经过透镜折射之后打在 Subject Plane 的一点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup></mrow><annotation encoding="application/x-tex">x&#x27;&#x27;&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.751892em;vertical-align:0"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.751892em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span><span class="mord mtight">′</span><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 上。之后我们就能把<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><msup><mi>x</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup></mrow><annotation encoding="application/x-tex">x&#x27;&#x27;x&#x27;&#x27;&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.751892em;vertical-align:0"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.751892em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.751892em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span><span class="mord mtight">′</span><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 这条线上的 Radiance 记录到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">x&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.751892em;vertical-align:0"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.751892em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 这一点上。</p><h2 id="depth-of-field"><a class="anchor" href="#depth-of-field">#</a> Depth of Field</h2><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024161310404.png" alt="image-20221024161310404"></p><p>接着，我们就可以用 Defocus Blur 来正式的定义景深的概念。上面两张照片就是用不同的光圈大小拍出来的。我们之前说过，大的光圈对应大的 CoC，成像的一个点到传感器上形成了一个大的圆，所以就会更模糊。但是，总归有些地方它是不模糊的，也就是 Focal Plane，在这个平面上都是不模糊的。也就是说，不同的光圈大小会影响到模糊的范围。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024161326304.png" alt="image-20221024161326304"></p><p>现在有一束光经过透镜它会打到某一个成像平面，在这个成像平面的附近一段区域内我们都认为这个 CoC 是足够小的。而景深就是指，在实际的场景中有一段深度，这段深度经过透镜之后会在成像平面的附近形成一段区域，这段区域内我们认为 CoC 都是足够小的。那么我们想要算景深，其实就是想算在 CoC 很小的一段范围内，我们基本认为对应看到的场景那一段它是清晰的。之所以可以这么理解，是因为成像平面由像素构成，每个像素都是有大小的，当 CoC 的大小跟像素相比差不多或者比像素小时，我们都可以认为最后得到的结果是锐利的，这就是为什么我们不止说这个成像平面自己，在成像平面附近一个微小的范围都是可以认为这段成像出来结果都是锐利的。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024161347880.png" alt="image-20221024161347880"></p><p>我们可以考虑这个景深的最远处和最近处，并且能得到它们穿过透镜后所形成的一段成像范围，并且我们希望把<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>F</mi></msub></mrow><annotation encoding="application/x-tex">D_F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.02778em">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.02778em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.13889em">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">D_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.02778em">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.02778em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.05764em">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">D_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.02778em">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.02778em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.10903em">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>F</mi></msub></mrow><annotation encoding="application/x-tex">d_F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.84444em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.13889em">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">d_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.84444em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.05764em">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">d_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.84444em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.10903em">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span></span></span></span> 联系起来（通过相似三角形和透镜公式）。于是，我们就能把 DOF（景深）给解出来。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221024161403084.png" alt="image-20221024161403084"></p><h2 id="light-field-lumigraph光场"><a class="anchor" href="#light-field-lumigraph光场">#</a> Light Field / Lumigraph（光场）</h2><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221101173502501.png" alt="image-20221101173502501"></p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221101173614432.png" alt="image-20221101173614432"></p><p>在解释光场之前，我们先从我们看到的世界说起。我们设定一个简单的场景，小人坐在一个凳子上看整个屋子，并且透过窗户可以看到一棵树。如果我们把他看到的东西画下来，那么就是一张图。如果我们在房间的中间加上一层幕布，这个幕布能够严格意义上模拟小人之前看到光线从某一个点打到另外一个点的强度是多少。这个幕布我们就让它显示我们之前所能看到的这张图，那么小人坐在那里看那张幕布是绝对体会不到这块幕布和真实世界有区别的，这也是虚拟现实的原理。也就是说，只要我们把所有的信息都记录在这样一个平面上，然后考虑这个平面上的任意一个点往任意一个方向发出来的光，如果把这些信息都完整地记录起来然后被人看到，那么是严格意义上和人看到的真实场景是一模一样的。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221101173644107.png" alt="image-20221101173644107"></p><p>我们能够描述人到底能够看到什么东西，可以用全光函数来表达。全光函数描述了我们能看到的所有东西。我们从最简单的全光函数开始说起，然后一步一步把它说明白。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221101173703879.png" alt="image-20221101173703879"></p><p>假设我们站在一个场景里面位置固定，并且我们可以往四面八方去看，于是我们可以定义任意一个方向（用极坐标表示，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.02778em">θ</span></span></span></span> 和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">ϕ</span></span></span></span>）。那么我们就可以定义<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>θ</mi><mo separator="true">,</mo><mi>ϕ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(\theta,\phi)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.02778em">θ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">ϕ</span><span class="mclose">)</span></span></span></span> 表示从任意一个方向看能得到什么样的一个值。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221101173728546.png" alt="image-20221101173728546"></p><p>我们可以把这个函数再改进一点，我们会引入一个波长的概念。既然是波长，也就说明我们引入了各种各样不同的颜色。如果我们把向任意一个方向上看到的对应波长的光给记录下来，那么就相当于我们看到了一个彩色的世界。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221101173744408.png" alt="image-20221101173744408"></p><p>我们再对上面的函数扩展一个时间 t，那么我们就能看到电影。因为我们能往各个不同的方向看并且这个信息是彩色的，然后在不同的时间看到的东西还不一样。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221101173805675.png" alt="image-20221101173805675"></p><p>再进一步扩展，我们可以让人的位置或者摄像机的位置在三维空间中任意的移动。三维空间中的任意一个位置我们知道（X、Y、Z）。既然连各个位置看到的东西都定义了，那么我们看到的就是全息电影。也就是我们不仅能够看到整个世界，还能改变自己的位置从另外一个角度来看这个世界。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221101173820487.png" alt="image-20221101173820487"></p><p>我们还可以最后再改进一步。也就是我们不把这个函数当作电影来看，而是理解成在任何位置往任何方向看，并且在任何时间我们看到的不同的颜色，那么这就是我们所看到的所有的事情。整个一个视觉的世界其实就是一个七个维度的世界。到此为止，我们就能把这个七维的函数叫做全光函数，并且所有的整个世界都可以拿这个函数来表示了。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221101173835456.png" alt="image-20221101173835456"></p><p>光场的概念就是从上面讲到的全光函数开始的。我们先从全光函数本身的定义上来看，也就是上面紫色的点可以在任意一个位置上，并且从任意一个方向我们都能知道过来的光是多少，并且这些信息都是连续的。也就是说，我们可以从全光函数中提取一部分信息出来，用它们来表示一些更复杂的光，光场实际上就是全光函数的一个小部分。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221101173851666.png" alt="image-20221101173851666"></p><p>定义光场之前，我们先来定义光线，三维中的任意一条光线可以用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>θ</mi><mo separator="true">,</mo><mi>ϕ</mi><mo separator="true">,</mo><msub><mi>V</mi><mi>X</mi></msub><mo separator="true">,</mo><msub><mi>V</mi><mi>Y</mi></msub><mo separator="true">,</mo><msub><mi>V</mi><mi>Z</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(\theta,\phi,V_X,V_Y,V_Z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.02778em">θ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">ϕ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.22222em">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.22222em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.07847em">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.22222em">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.22222em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.22222em">Y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.22222em">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.22222em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.07153em">Z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 来表示。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221101173909464.png" alt="image-20221101173909464"></p><p>我们会发现上面那个对光线的定义需要一个起点和一个方向，但也不一定说这种方式的定义就是最好的，还有其他各种各样的方式来定义这样一条光线。例如，我们只要知道了光线上的两个点就能定义出一条光线（方向可以通过正负来定义）。这样的话，我们要向定义一条光线就只需要二维的位置和二维的方向。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221101173928641.png" alt="image-20221101173928641"></p><p>如果我们想定义对于任意一个物体它的表面（这个物体可以被放在某一个包围盒中），那么我们看向这个物体，无非就是从任何位置、任何方向去看向这个物体。反过来，通过光路的可逆性，我们也可以认为要想描述物体所能被看到的所有情况，就描述这个物体在它的包围盒上任意一个位置往任意一个方向上过去的光线，只要把这个过程描述清楚，我们就可以得到从任意一个位置看向这个物体它应该长什么样了。因为我们从任何位置看向这个物体，就相当于包围盒上有一个点并且和观测的位置两点确定了一条光线，并且我们知道它的方向，那么我们就能够查询之前记录的函数。这个函数记录了在物体表面不同位置的点往各个不同的方向的发光情况，如果我们把这个信息记录下来，这就是我们要的光场。总结一下，光场就是在任何一个位置往任何一个方向去的光的强度，这样一来我们就在光场和全光函数之间建立起了联系。光场是全光函数的一小部分，只是二维的位置和二维的方向。现在我们回过头来再来理解二维的位置和二维的方向，3D 世界中，三维物体的表面实际上是在一个二维的空间中的，空间中的方向我们也可以用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.02778em">θ</span></span></span></span> 和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">ϕ</span></span></span></span> 来表示。也就是两个数来表示方向，两个数来表示位置，这就是光场。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221101173944188.png" alt="image-20221101173944188"></p><p>如果我们有了一个物体的光场，物体上的任何一个位置往任何一个方向都可以发光。我们之前说的是，在任何一个位置向物体看过去，只要有光场我们就能知道能看到什么（由于之前记录光场的时候，任何位置往任何方向都记录过光线所带的能量）。有了光场之后我们得出一个结论，我们可以得到各种物体不同的观测。这也是光场的好处，它是一个四维的函数，能给我们任意的一个观测方向所能看到的结果。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221101174004438.png" alt="image-20221101174004438"></p><p>我们之前提到过光场是定义在物体表面的，但是前一个例子我们又说把物体放在一个包围盒里，并且我们不需要知道盒子里的物体是什么，我们只需要把盒子上的任意一个点它往任意一个方向的光给记录下来就可以。也就是说，我们不需要知道光场表示的是个什么东西，而只用把它看成一个黑盒，在盒子的表面的任何一个位置都能知道任何一个方向的光线，这样我们就能记录光场（前提是观测点在包围盒的外面，在里面我们没有记录信息）。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221101174018372.png" alt="image-20221101174018372"></p><p>更进一步，这种方式我们还可以理解为取一个平面，这个平面的右边假设有一些发光的物体，这些发光的物体会发出各种各样的光会穿过这个平面。我们前面说平面右边的东西可以忽略，而只关心平面左边的信息就可以。也就是说，对这个平面上的任意一个点，我们能知道它任意的一个方向就可以了。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221101174032609.png" alt="image-20221101174032609"></p><p>那么我们也可以用两个相互平行的平面来定义任何一个光场，只需要在两个平面上各自任取一个点即可。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221101174042923.png" alt="image-20221101174042923"></p><p>因此，在光场里面平时大家会用到 uv 和 st 的概念，也就是对光场参数化的过程，因为光场本质上就是一个四维的函数，就取决于我们怎么描述这个四维函数而已。那么对于两个平面来说，假设我们知道发光的物体在右边（确定了光照的方向），那么平面上任意的两个点的连线就能找到一条光线，之后确定这条光线的值并记录下来。重复上面的步骤，我们只要找到所有的 uv，所有的 st 它们的组合就可以了。到此为止，我们基本上就把光场的概念说清楚了。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221101174055421.png" alt="image-20221101174055421"></p><p>我们再来看看对两个平面这种参数化方式的两种不同的理解方式。我们可以在 st 上取一个点，然后看所有的 uv 长什么样。我们通过下面这张图来理解这句话。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221101174113421.png" alt="image-20221101174113421"></p><p>我们记录的光场，就相当于是在 st 上取一个点，然后 uv 上取一个点，再把它们连起来。如果我们在 uv 上面取一个固定的点，然后再去看向所有的 st 平面上的点，这就好像是没有光场一样。因为我们在 uv 上取一个点，然后看向这个世界，这个世界右边都是我们不关心的东西，也就好像一个针孔相机所能看到的东西，因此每一个点我们都能看到一个完整的图，只不过是以不同的角度看向这个世界。相对难以理解的是，我们固定 st 上的一个点，然后再往 uv 平面上去看，整个世界还是在 st 平面的右边，我们反过来想，也就是在 uv 上的每一个点都看向 st 上的同一个点，这样的话我们看的是同一个点只不过是从不同的角度去看，那么我们就能看到各个角度不同高光的效果。或者我们也可以理解成，当摄像机拍了一张图之后，一个像素上存的是 Irradiance 的信息，那么通过这种方式就能把像素上的 Irradiance 给展开成为 Radiance，我们能看到打到任何一个像素上不同方向的光到底是什么。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221101174131759.png" alt="image-20221101174131759"></p><p>斯坦福大学做出来摄像机矩阵就对应了我们上面讲的第一种理解。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221101174146766.png" alt="image-20221101174146766"></p><p>我们其实更关心的是另外一种。在自然界中，有一些昆虫例如苍蝇，它们的眼睛称之为复眼。苍蝇眼睛的成像原理其实就是在成像一个光场。还是从刚才的角度来说，我们盯着原本正常拍出来的照片来看，照片上的任何一个像素它记录的是 Irradiance，Irradiance 不区分来自各个方向的光，然后把它们都平均在一块儿。对于光场的另外一种理解方式，我们把上图中的 lenslet 当作某一个像素，那么对于最左边的像素来说，它接受到的光有来自于左边的蓝色、来自于正上方的绿色、来自于右边的红色。如果是普通的相机，我们就把这个像素给记录下来了，这个记录的结果就是蓝色、绿色和红色的平均。如果我们有办法能把它们都分开，也就是光线打到像素上之后不立刻记录它，而是把这个像素变成某个小透镜，这个小透镜的作用就是把来自各个方向的光给分到不同的位置上去，实际的感光元件放在底下，经过分光这一步操作之后，我们就能把原本打在像素上的各个方向的光分别记录在不同的位置。这就相当于，我们记录的不再是一个像素的 Irradiance 了，而是记录往各个方向看过去的 Radiance，这也正是光场摄像机的基本原理。我们看着一个像素，其实相当于看着穿过这个像素的不同方向的光。</p><h2 id="light-field-camera"><a class="anchor" href="#light-field-camera">#</a> Light Field Camera</h2><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221101174212154.png" alt="image-20221101174212154"></p><p>光场的原理我们已经清楚了，利用这个原理就能做出光场摄像机。光场相机中用到了微透镜，也就是把一个像素替换成一个透镜，然后让这个透镜可以把来自于不同方向的光分开并记录下来。光场相机最重要的功能就是支持后期的重新聚焦。使用光场相机我们可以先拍张照片，然后在考虑聚焦或者别的一些问题，例如调整光圈大小等等。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221101174229914.png" alt="image-20221101174229914"></p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221101174247133.png" alt="image-20221101174247133"></p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221101174300347.png" alt="image-20221101174300347"></p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221101174318053.png" alt="image-20221101174318053"></p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221101174328164.png" alt="image-20221101174328164"></p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221101174340149.png" alt="image-20221101174340149"></p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221101174403352.png" alt="image-20221101174403352"></p><p>光场相机的原理就是光场的原理。原本我们的成像平面是在上图的透镜处，在普通的相机里，这就是我们的像素。任何一个像素它会接收到来自各个方向上不同的光，然后把它们平均起来，也就是 Irradiance。光场相机的原理就相当于把原本的这些像素换成了微透镜，这些微透镜就会把来自个方向上的光给分散到不同的方向上去，我们在后面把这些光线给记录下来，也就是说把感光元件往后面拿一点点，让不同方向上的光经过透镜之后正好分散在一片区域上。光场相机和普通相机的区别就在于，原本我们只需要记录一个像素，现在我们要记录一块像素。光场相机照出来的最原始的图中，原本一个像素变成一个圆，任何一个圆内部如果平均起来就是传统相机的结果，如果考虑在这个圆的内部各个像素在干些什么，那么它们实际上记录的就是光线各个不同的方向。光场相机做到了把来自各个方向上不同的光都记录下来。我们观察上图中透镜的位置，不同的透镜对应不同的位置，不同的透镜又能接受到不同方向上来的光并且把它们存起来，从这些透镜往左边看可不就是一个光场吗？</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221101174422776.png" alt="image-20221101174422776"></p><p>我们有了一张光场相机拍出来的最原始的图，但是我们最后想要一个普通的相片该怎么办？一个很简单的办法，原本用光场相机之前，这些微透镜都是像素。如果我们把每个微透镜后面的都选一条同一个方向的光线，然后我们把每个得到的结果记录在对应像素上，也就是说现在的透镜就只对应一个值了，那么我们就能得到一张原始的照片。这张照片拍出来的效果就好像是我们把相机放在某一个位置然后往这个特定的方向去看。也就是说，有了光场之后，我们就能虚拟地移动摄像机的朝向让它向着指定的方向去看。这里我们没有具体的说动态的重新聚焦怎么做，但是重新聚焦也是伊一样的道理，因为我们拥有整个光场，那么要想把一个焦平面移动的非常远或者非常近，在移动的过程中就对应着这些光线应该如何变化，那么我们就在光场中去查询更新后的光线，也就是按需在光场里面去取就可以了。这和我们移动相机的位置理论上是一模一样的，也就是中间我们要进行一些计算，算出来我们应该取哪些方向。</p><p><img data-src="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/image-20221101174438848.png" alt="image-20221101174438848"></p><p>总结起来，为什么这些功能得以实现，正是因为光场相机记录了整个光场的信息，整个光场就是所有进入到相机里的所有的信息，包括位置和方向。但是光场相机本身也存在一些问题，例如光场相机通常都有分辨率不足的问题，这是因为我们改变了成像平面之后，我们现在可能要用 100 个像素去记录原先一个像素的信息，因为我们把不同的方向分开了。现在胶片的分辨率就变成了空间上的分辨率，即原本照片的分辨率乘以方向上的分辨率。现在方向上记录的信息多，那么在照片本身记录的分辨率就会低，所以这种方式对胶片分辨率的要求非常高，自然而然这种方式就会造成高成本。高成本不仅体现在为了让光场相机达到和以前一样的照片分辨率，那么就得用超级高分辨率的胶片。其次就是微透镜是一种超级精密的仪器，实现起来会非常困难。这就造成了光场相机的高成本。这里我们再次体会到整个计算机图形学都存在对各种方面的权衡，如果提升了其中的一块，那么另外一块可能就会受到影响。</p><div class="tags"><a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 学习笔记</a> <a href="/tags/CG/" rel="tag"><i class="ic i-tag"></i> CG</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2022-11-04 23:38:25" itemprop="dateModified" datetime="2022-11-04T23:38:25+08:00">2022-11-04</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Sakupinera WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Sakupinera Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Sakupinera PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Sakupinera <i class="ic i-at"><em>@</em></i>Sakupinera</li><li class="link"><strong>Post link: </strong><a href="http://sakupinera.github.io/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/" title="GAMES101 - Cameras, Lenses and Light Fields（相机，透镜和光场）">http://sakupinera.github.io/2022/10/31/computer-graphics/games101/相机，透镜和光场/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/10/29/csharp/clr-via-csharp/Chapter%2011%20Events/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipexoj0moj20zk0m8kgu.jpg" title="CLR via C# - Chapter 11 Events"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 11 Events</h3></a></div><div class="item right"><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipevuctzzj20zk0m84qp.jpg" title="CLR via C# - Chapter 12 Generics"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 12 Generics</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#cameras-lenses-and-light-fields%E7%9B%B8%E6%9C%BA%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA"><span class="toc-number">1.</span> <span class="toc-text">Cameras, Lenses and Light Fields（相机，透镜和光场）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#imaging-synthesis-capture"><span class="toc-number">1.1.</span> <span class="toc-text">Imaging &#x3D; Synthesis + Capture</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pinhole-image-formation"><span class="toc-number">1.2.</span> <span class="toc-text">Pinhole Image Formation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#field-of-view-fov"><span class="toc-number">1.3.</span> <span class="toc-text">Field of View (FOV)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exposure"><span class="toc-number">1.4.</span> <span class="toc-text">Exposure</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fast-and-slow-photography"><span class="toc-number">1.5.</span> <span class="toc-text">Fast and Slow Photography</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#thin-lens-approximation"><span class="toc-number">1.6.</span> <span class="toc-text">Thin Lens Approximation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#defocus-blur"><span class="toc-number">1.7.</span> <span class="toc-text">Defocus Blur</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ray-tracing-ideal-thin-lenses"><span class="toc-number">1.8.</span> <span class="toc-text">Ray Tracing Ideal Thin Lenses</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#depth-of-field"><span class="toc-number">1.9.</span> <span class="toc-text">Depth of Field</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#light-field-lumigraph%E5%85%89%E5%9C%BA"><span class="toc-number">1.10.</span> <span class="toc-text">Light Field &#x2F; Lumigraph（光场）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#light-field-camera"><span class="toc-number">1.11.</span> <span class="toc-text">Light Field Camera</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"><ul><li><a href="/2022/09/06/computer-graphics/games101/%E5%90%91%E9%87%8F%E5%92%8C%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" rel="bookmark" title="GAMES101 - 向量和线性代数">GAMES101 - 向量和线性代数</a></li><li><a href="/2022/09/06/computer-graphics/games101/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%A6%82%E8%BF%B0/" rel="bookmark" title="GAMES101 - 计算机图形学概述">GAMES101 - 计算机图形学概述</a></li><li><a href="/2022/09/18/computer-graphics/games101/%E5%8F%98%E6%8D%A2/" rel="bookmark" title="GAMES101 - Transformation（变换）">GAMES101 - Transformation（变换）</a></li><li><a href="/2022/09/22/computer-graphics/games101/%E5%85%89%E6%A0%85%E5%8C%96/" rel="bookmark" title="GAMES101 - Rasterization（光栅化）">GAMES101 - Rasterization（光栅化）</a></li><li><a href="/2022/09/30/computer-graphics/games101/%E7%9D%80%E8%89%B2/" rel="bookmark" title="GAMES101 - Shading（着色）">GAMES101 - Shading（着色）</a></li><li><a href="/2022/10/03/computer-graphics/games101/%E5%87%A0%E4%BD%95/" rel="bookmark" title="GAMES101 - Geometry（几何）">GAMES101 - Geometry（几何）</a></li><li><a href="/2022/10/09/computer-graphics/games101/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/" rel="bookmark" title="GAMES101 - Ray Tracing（光线追踪）">GAMES101 - Ray Tracing（光线追踪）</a></li><li><a href="/2022/10/14/computer-graphics/games101/%E6%9D%90%E8%B4%A8%E4%B8%8E%E5%A4%96%E8%A7%82/" rel="bookmark" title="GAMES101 - Materials and Appearances（材质与外观）">GAMES101 - Materials and Appearances（材质与外观）</a></li><li><a href="/2022/10/21/computer-graphics/games101/%E6%B8%B2%E6%9F%93%E4%B8%AD%E7%9A%84%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/" rel="bookmark" title="GAMES101 - Advanced Topics in Rendering（渲染中的高级主题）">GAMES101 - Advanced Topics in Rendering（渲染中的高级主题）</a></li><li class="active"><a href="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/" rel="bookmark" title="GAMES101 - Cameras, Lenses and Light Fields（相机，透镜和光场）">GAMES101 - Cameras, Lenses and Light Fields（相机，透镜和光场）</a></li><li><a href="/2023/08/20/computer-graphics/games101/%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/" rel="bookmark" title="GAMES101 - Color and Perception（颜色与感知）">GAMES101 - Color and Perception（颜色与感知）</a></li><li><a href="/2023/09/18/computer-graphics/games101/%E5%8A%A8%E7%94%BB/" rel="bookmark" title="GAMES101 -  Animation（动画）">GAMES101 - Animation（动画）</a></li></ul></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sakupinera" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Sakupinera</p><div class="description" itemprop="description">保持你的决心！</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">89</span> <span class="name">posts</span></a></div><div class="item categories"><a href="/categories/"><span class="count">17</span> <span class="name">categories</span></a></div><div class="item tags"><a href="/tags/"><span class="count">8</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nha3VwaW5lcmE=" title="https:&#x2F;&#x2F;github.com&#x2F;sakupinera"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9zYWt1cGluZXJh" title="https:&#x2F;&#x2F;twitter.com&#x2F;sakupinera"><i class="ic i-twitter"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQwNzIyOTA3MQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;407229071"><i class="ic i-cloud-music"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMjIzMDczOTg/c3BtX2lkX2Zyb209MzMzLjEwMDcuMC4w" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;22307398?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li><li class="item"><a href="/games/" rel="section"><i class="ic i-flag"></i>games</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-person"></i>About</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/10/29/csharp/clr-via-csharp/Chapter%2011%20Events/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/09/04/linux/learn-linux/Shell%E7%BC%96%E7%A8%8B/" title="LearnLinux - Shell编程">LearnLinux - Shell编程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/" title="CLR via C# - Chapter 1 The CLR’s Execution Model">CLR via C# - Chapter 1 The CLR’s Execution Model</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" title="CLR via C# - Chapter 8 Methods">CLR via C# - Chapter 8 Methods</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2023/09/18/computer-graphics/games101/%E5%8A%A8%E7%94%BB/" title="GAMES101 -  Animation（动画）">GAMES101 - Animation（动画）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CSharp-in-a-Nutshell/" title="In CSharp-in-a-Nutshell">CSharp-in-a-Nutshell</a></div><span><a href="/2022/09/01/csharp/csharp-in-a-nutshell/%E7%AC%AC12%E7%AB%A0%20%E5%AF%B9%E8%B1%A1%E9%94%80%E6%AF%81%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" title="C# in a Nutshell - 第12章 对象销毁与垃圾回收">C# in a Nutshell - 第12章 对象销毁与垃圾回收</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/08/28/linux/learn-linux/%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/" title="LearnLinux - 软件包管理">LearnLinux - 软件包管理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Network/" title="In Network">Network</a></div><span><a href="/2023/03/21/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">计算机网络</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/08/28/linux/learn-linux/Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/" title="LearnLinux - Linux系统安装">LearnLinux - Linux系统安装</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/09/06/computer-graphics/games101/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%A6%82%E8%BF%B0/" title="GAMES101 - 计算机图形学概述">GAMES101 - 计算机图形学概述</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/17/csharp/clr-via-csharp/Chapter%2015%20Enumerated%20Types%20and%20Bit%20Flags/" title="CLR via C# - Chapter 15 Enumerated Types and Bit Flags">CLR via C# - Chapter 15 Enumerated Types and Bit Flags</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Sakupinera @ Hanamai Sora</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="Symbols count total">2.2m words</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="Reading time total">34:05</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/10/31/computer-graphics/games101/相机，透镜和光场/",favicon:{show:"（●´3｀●）Goooood",hide:"(´Д｀)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/shifuku.model.json"},display:{position:"left",width:250,height:500},mobile:{show:!1},react:{opacity:.9},log:!1})</script></body></html>