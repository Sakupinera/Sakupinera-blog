<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sakupinera" href="http://sakupinera.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sakupinera" href="http://sakupinera.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sakupinera" href="http://sakupinera.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="读书笔记,C#"><link rel="canonical" href="http://sakupinera.github.io/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/"><title>CLR via C# - Chapter 9 Parameters - CLR-via-CSharp - CSharp | Hanamai Sora = Sakupinera</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">CLR via C# - Chapter 9 Parameters</h1><div class="meta"><span class="item" title="Created: 2022-10-27 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2022-10-27T00:00:00+08:00">2022-10-27</time> </span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">Symbols count in article</span> <span>33k</span> <span class="text">words</span> </span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">Reading time</span> <span>30 mins.</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hanamai Sora</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclxp31goj20zk0m8qv5.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclhfehz7j20zk0m8u0x.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giph4baakhj20zk0m8h5q.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gicmnywqgpj20zk0m8dwx.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipet4bz0yj20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gicis081o9j20zk0m8dmr.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/" itemprop="item" rel="index" title="In CSharp"><span itemprop="name">CSharp</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/CLR-via-CSharp/" itemprop="item" rel="index" title="In CLR-via-CSharp"><span itemprop="name">CLR-via-CSharp</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://sakupinera.github.io/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Sakupinera"><meta itemprop="description" content=", 保持你的决心！"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakupinera"></span><div class="body md" itemprop="articleBody"><h1 id="chapter-9-parameters"><a class="anchor" href="#chapter-9-parameters">#</a> Chapter 9 Parameters</h1><h2 id="optional-and-named-parameters"><a class="anchor" href="#optional-and-named-parameters">#</a> Optional and Named Parameters</h2><blockquote><p>When designing a method’s parameters, you can assign default values to some of or all the parameters. Then, code that calls these methods can optionally not specify some of the arguments, thereby accepting the default values. In addition, when you call a method, you can specify arguments by using the name of their parameters. Here is some code that demonstrates using both optional and named parameters.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Int32</span> s_n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">M</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"A"</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">DateTime</span> dt <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">(</span><span class="token type-expression class-name">DateTime</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Guid</span> guid <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Guid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"x=&#123;0&#125;, s=&#123;1&#125;, dt=&#123;2&#125;, guid=&#123;3&#125;"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> s<span class="token punctuation">,</span> dt<span class="token punctuation">,</span> guid<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// 1. Same as: M(9, "A", default(DateTime), new Guid());</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token function">M</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// 2. Same as: M(8, "X", default(DateTime), new Guid());</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token function">M</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">"X"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// 3. Same as: M(5, "A", DateTime.Now, Guid.NewGuid());</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token function">M</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token named-parameter punctuation">guid</span><span class="token punctuation">:</span> Guid<span class="token punctuation">.</span><span class="token function">NewGuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token named-parameter punctuation">dt</span><span class="token punctuation">:</span> DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token comment">// 4. Same as: M(0, "1", default(DateTime), new Guid());</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token function">M</span><span class="token punctuation">(</span>s_n<span class="token operator">++</span><span class="token punctuation">,</span> s_n<span class="token operator">++</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token comment">// 5. Same as: String t1 = "2"; Int32 t2 = 3; </span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token comment">// M(t2, t1, default(DateTime), new Guid());</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token function">M</span><span class="token punctuation">(</span><span class="token named-parameter punctuation">s</span><span class="token punctuation">:</span> <span class="token punctuation">(</span>s_n<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token named-parameter punctuation">x</span><span class="token punctuation">:</span> s_n<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When I run this program, I get the following output.</p></blockquote><pre><code>x=9, s=A, dt=1/1/0001 12:00:00 AM, guid=00000000-0000-0000-0000-000000000000
x=8, s=X, dt=1/1/0001 12:00:00 AM, guid=00000000-0000-0000-0000-000000000000
x=5, s=A, dt=8/16/2012 10:14:25 PM, guid=d24a59da-6009-4aae-9295-839155811309
x=0, s=1, dt=1/1/0001 12:00:00 AM, guid=00000000-0000-0000-0000-000000000000
x=3, s=2, dt=1/1/0001 12:00:00 AM, guid=00000000-0000-0000-0000-000000000000
</code></pre><blockquote><p>As you can see, whenever arguments are left out at the call site, the C# compiler embeds the parameter’s default value. The third and fifth calls to M use C#’s named parameter feature. In the two calls, I’m explicitly passing a value for x and I’m indicating that I want to pass an argument for the parameters named guid and dt.</p></blockquote><blockquote><p>When you pass arguments to a method, the compiler evaluates the arguments from left to right. In the fourth call to M, the value in s_n (0) is passed for x, then s_n is incremented, and s_n (1) is passed as a string for s and then s_n is incremented again to 2. When you pass arguments by using named parameters, the compiler still evaluates the arguments from left to right. In the fifth call to M, the value in s_n (2) is converted to a string and saved in a temporary variable (t1) that the compiler creates. Next, s_n is incremented to 3 and this value is saved in another temporary variable (t2) created by the compiler, and then s_n is incremented again to 4. Ultimately, M is invoked, passing it t2, t1, a default DateTime, and a new Guid.</p></blockquote><h3 id="rules-and-guidelines"><a class="anchor" href="#rules-and-guidelines">#</a> Rules and Guidelines</h3><blockquote><p>There are some additional rules and guidelines that you should know about when defining a method that specifies default values for some of its parameters:</p></blockquote><ul><li><p>You can specify default values for the parameters of methods, constructor methods, and parameterful properties (C# indexers). You can also specify default values for parameters that are part of a delegate definition. Then, when invoking a variable of this delegate type, you can omit the arguments and accept the default values.</p></li><li><p>Parameters with default values must come after any parameters that do not have default values. That is, after you define a parameter as having a default value, then all parameters to the right of it must also have default values. For example, in the definition of my M method, I would get a compiler error if I removed the default value (&quot;A&quot;) for s. There is one exception to this rule: a params array parameter (discussed later in this chapter) must come after all parameters (including those that have default values), and the array cannot have a default value itself.</p></li><li><p>Default values must be constant values known at compile time. This means that you can set default values for parameters of types that C# considers to be primitive types, as shown in Table 5-1 in Chapter 5, “Primitive, Reference, and Value Types.” This also includes enumerated types, and any reference type can be set to null. For a parameter of an arbitrary value type, you can set the default value to be an instance of the value type, with all its fields containing zeroes. You can use the default keyword or the new keyword to express this; both syntaxes produce identical Intermediate Language (IL) code. Examples of both syntaxes are used by my M method for setting the default value for the dt parameter and guid parameter, respectively.</p></li><li><p>Be careful not to rename parameter variables because any callers who are passing arguments by parameter name will have to modify their code. For example, in the declaration of my M method, if I rename the dt variable to dateTime, then my third call to M in the earlier code will cause the compiler to produce the following message: error CS1739: The best overload for 'M' does not have a parameter named 'dt'.</p></li><li><p>Be aware that changing a parameter’s default value is potentially dangerous if the method is called from outside the module. A call site embeds the default value into its call. If you later change the parameter’s default value and do not recompile the code containing the call site, then it will call your method passing the old default value. You might want to consider using a default value of 0/null as a sentinel to indicate default behavior; this allows you to change your default without having to recompile all the code with call sites. Here is an example.</p></li></ul><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Don’t do this:</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name">String</span> <span class="token function">MakePath</span><span class="token punctuation">(</span><span class="token class-name">String</span> filename <span class="token operator">=</span> <span class="token string">"Untitled"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">return</span> String<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">@"C:\&#123;0&#125;.txt"</span><span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// Do this instead:</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name">String</span> <span class="token function">MakePath</span><span class="token punctuation">(</span><span class="token class-name">String</span> filename <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// I am using the null-coalescing operator (??) here; see Chapter 19</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">return</span> String<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">@"C:\&#123;0&#125;.txt"</span><span class="token punctuation">,</span> filename <span class="token operator">??</span> <span class="token string">"Untitled"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>You cannot set default values for parameters marked with either the ref or out keywords because there is no way to pass a meaningful default value for these parameters.</li></ul><blockquote><p>There are some additional rules and guidelines that you should know about when calling a method by using optional or named parameters:</p></blockquote><ul><li><p>Arguments can be passed in any order; however, named arguments must always appear at the end of the argument list.</p></li><li><p>You can pass arguments by name to parameters that do not have default values, but all required arguments must be passed (by position or by name) for the compiler to compile the code.</p></li><li><p>C# doesn’t allow you to omit arguments between commas, as in M(1, ,DateTime.Now), because this could lead to unreadable comma-counting code. Pass arguments by way of their parameter name if you want to omit some arguments for parameters with default values.</p></li><li><p>To pass an argument by parameter name that requires ref/out, use syntax like the following.</p></li></ul><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Method declaration:</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">M</span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token class-name">Int32</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// Method invocation:</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token class-name">Int32</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">M</span><span class="token punctuation">(</span><span class="token named-parameter punctuation">x</span><span class="token punctuation">:</span> <span class="token keyword">ref</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>💡注意：写 C# 代码和 Microsoft Office 的 COM 对象模型进行互操作性时，C# 的可选参数和命名参数功能非常好用。另外，调用 COM 组件时，如果是以传引用的方式传递实参，C# 还允许省略 <code>ref/out</code> ，进一步简化编码。但如果调用的不是 COM 组件，C# 就要求必须向实参应用 <code>ref/out</code> 关键字。</p><h3 id="the-defaultparametervalue-and-optional-attributes"><a class="anchor" href="#the-defaultparametervalue-and-optional-attributes">#</a> The DefaultParameterValue and Optional Attributes</h3><blockquote><p>It would be best if this concept of default and optional arguments was not C#-specific. Specifically, we want programmers to define a method indicating which parameters are optional and what their default value should be in a programming language and then give programmers working in other programming languages the ability to call them. For this to work, the compiler of choice must allow the caller to omit some arguments and have a way of determining what those arguments’ default values should be.</p></blockquote><blockquote><p>In C#, when you give a parameter a default value, the compiler internally applies the System. <code>Runtime.InteropServices.OptionalAttribute</code> custom attribute to the parameter, and this attribute is persisted in the resulting file’s metadata. In addition, the compiler applies <code>System.Runtime.InteropServices.DefaultParameterValueAttribute</code> to the parameter and persists this attribute in the resulting file’s metadata. Then, <code>DefaultParameterValueAttribute</code> ’s constructor is passed the constant value that you specified in your source code.</p></blockquote><blockquote><p>Now, when a compiler sees that you have code calling a method that is missing some arguments, the compiler can ensure that you’ve omitted optional arguments, grab their default values out of metadata, and embed the values in the call for you automatically.</p></blockquote><p>💡小结：设计方法的参数时，可以给部分或全部参数分配默认值。然后，调用这些方法的代码可以选择不提供部分实参，使用其默认值。此外，调用方法时可通过指定参数名称来传递实参。使用命名参数传递实参时，编译器仍然按从左到右的顺序对实参进行求值。在方法中为部分参数指定默认值需要注意一些规则和原则。可为方法、构造器方法和有参属性（C# 索引器）的参数指定默认值。还可为属于委托定义一部分的参数指定默认值。有默认值的参数必须放在没有默认值的所有参数之后。但这个规则有一个例外：“参数数组” 这种参数必须放在所有参数（包括有默认值的这些）之后，而且数组本身不能有一个默认值。默认值必须是编译时能确定的常量值。这些参数的类型可以是 C# 认定的基元类型、枚举类型，以及能设为 null 的任何引用类型。值类型的参数可将默认值设为值类型的实例，并让它的所有字段都包含零值。可以用 default 关键字或者 new 关键字来表达这个意思，两种语法将生成完全一致的 IL 代码。不要重命名参数变量，否则任何调用者以传参数名的方式传递实参，它们的代码也必须修改。可考虑将默认值 0/null 作为哨兵值使用，从而指出默认行为。这样一来，即使更改了默认值，也不必重新编译包含了 call site（发出调用的地方，可理解成调用了一个目标方法的表达式或代码行，call site 在它的调用中嵌入默认值）的全部代码。如果参数用 ref 或 out 关键字进行了标识，就不能设置默认值。因为没有办法为这些参数传递有意义的默认值。对于可选或命名参数调用来说，实参可按任意顺序传递，但命名实参只能出现在实参列表的尾部。在 C# 中，一旦为参数分配了默认值，编译器就会在内部向该参数应用定制特性 <code>System.Runtime.InteropServices.OptionalAttribute</code> 。该特性会在最终生成的文件的元数据中持久性地储存下来。然后，会向 <code>DefaultParameterValueAttribute</code> 的构造器传递你在源代码中指定的常量值。之后，一旦编译器发现某个方法调用确实了部分实参，就可以确定省略的是可选的实参，并从元数据中提取默认值，将值自动嵌入调用中。</p><h2 id="implicitly-typed-local-variables"><a class="anchor" href="#implicitly-typed-local-variables">#</a> Implicitly Typed Local Variables</h2><blockquote><p>C# supports the ability to infer the type of a method’s local variable from the type of expression that is used to initialize it. The following shows some sample code demonstrating the use of this feature.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ImplicitlyTypedLocalVariables</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> name <span class="token operator">=</span> <span class="token string">"Jeff"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token function">ShowVariableType</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays: System.String</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// var n = null; // Error: Cannot assign &lt;null> to an implicitly-typed local </span></pre></td></tr><tr><td data-num="5"></td><td><pre>variable</pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> x <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span><span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// OK, but not much value</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token function">ShowVariableType</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays: System.String</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> numbers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Int32<span class="token punctuation">[</span><span class="token punctuation">]</span></span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token function">ShowVariableType</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays: System.Int32[]</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// Less typing for complex types</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> collection <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Dictionary<span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> Single<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#123;</span> <span class="token string">"Grant"</span><span class="token punctuation">,</span> <span class="token number">4.0f</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// Displays: System.Collections.Generic.Dictionary`2[System.String,System.Single]</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token function">ShowVariableType</span><span class="token punctuation">(</span>collection<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> item <span class="token keyword">in</span> collection<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// Displays: System.Collections.Generic.KeyValuePair`2[System.String,System.Single]</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token function">ShowVariableType</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">ShowVariableType</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">T</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The first line of code inside the ImplicitlyTypedLocalVariables method is introducing a new local variable by using the C# var token. To determine the type of the name variable, the compiler looks at the type of the expression on the right side of the assignment operator (=). Because &quot;Jeff&quot; is a string, the compiler infers that name’s type must be String. To prove that the compiler is inferring the type correctly, I wrote the ShowVariableType method. This generic method infers the type of its argument, and then it shows the type that it inferred on the console. I added what ShowVariableType displayed as comments inside the ImplicitlyTypedLocalVariables method for easy reading.</p></blockquote><blockquote><p>The second assignment (commented out) inside the ImplicitlyTypedLocalVariables method would produce a compiler error (error CS0815: Cannot assign to an implicitlytyped local variable) because null is implicitly castable to any reference type or nullable value type; therefore, the compiler cannot infer a distinct type for it. However, on the third assignment, I show that it is possible to initialize an implicitly typed local variable with null if you explicitly specify a type (String, in my example). Although this is possible, it is not that useful because you could also write String x = null; to get the same result.</p></blockquote><blockquote><p>In the fourth assignment, you see some real value of using C#’s implicitly typed local variable feature. Without this feature, you’d have to specify Dictionary on both sides of the assignment operator. Not only is this a lot of typing, but if you ever decide to change the collection type or any of the generic parameter types, then you would have to modify your code on both sides of the assignment operator, too.</p></blockquote><blockquote><p>In the foreach loop, I also use var to have the compiler automatically infer the type of the elements inside the collection. This demonstrates that it is possible and quite useful to use var with foreach, using, and for statements. It can also be useful when experimenting with code. For example, you initialize an implicitly typed local variable from the return type of a method, and as you develop your method, you might decide to change its return type. If you do this, the compiler will automatically figure out that the return type has changed and automatically change the type of the variable! This is great, but of course, other code in the method that uses that variable may no longer compile if the code accesses members by using the variable assuming that it was the old type.</p></blockquote><blockquote><p>In Microsoft Visual Studio, you can hold the mouse cursor over var in your source code and the editor will display a tooltip showing you the type that the compiler infers from the expression. C#’s implicitly typed local variable feature must be used when working with anonymous types within a method; see Chapter 10, “Properties,” for more details.</p></blockquote><blockquote><p>You cannot declare a method’s parameter type by using var. The reason for this should be obvious to you because the compiler would have to infer the parameter’s type from the argument being passed at a callsite and there could be no call sites or many call sites. In addition, you cannot declare a type’s field by using var. There are many reasons why C# has this restriction. One reason is that fields can be accessed by several methods and the C# team feels that this contract (the type of the variable) should be stated explicitly. Another reason is that allowing this would permit an anonymous type (discussed in Chapter 10) to leak outside of a single method.</p></blockquote><p>💡重要提示：不要混淆 <code>dynamic</code> 和 <code>var</code> 。用 <code>var</code> 声明局部变量只有一种简化语法，它要求编译器根据表达式推断具体数据类型。 <code>var</code> 关键字只能声明方法内部的局部变量，而 <code>dynamic</code> 关键字适用于局部变量、字段和参数。表达式不能转型为 <code>var</code> ，但能转型为 <code>dynamic</code> 。必须显式初始化用 <code>var</code> 声明的变量，但无需初始化用 <code>dynamic</code> 声明的变量。欲知 C# <code>dynamic</code> 类型的详情，请参见 5.5 节 “ <code>dynamic</code> 基元类型 &quot;。</p><p>💡小结：C# 不能将 null 赋给隐式类型（var 类型）的局部变量。这是由于 null 能隐式转型为任何引用类型或可空值类型。因此，编译器不能推断它的确切类型，除非将 null 强转为具体类型，不过这样做也意义不大。在 VS 中，鼠标放到 var 上将显示一条 “工具提示”，指出编译器根据表达式推断出来的类型。在方法中使用匿名类型时必须用到 C# 的隐式类型局部变量，这会在 “属性” 章节讲解。不能用 var 声明方法的参数类型。原因显而易见，因为编译器必须根据在 call site 传递的实参来推断参数类型，但 call site 可能一个都没有，也可能有好多个。（要么一个类型都推断不出来，要么多个推断发生冲突。）除此之外，不能用 var 声明类型中的字段。</p><h2 id="passing-parameters-by-reference-to-a-method"><a class="anchor" href="#passing-parameters-by-reference-to-a-method">#</a> Passing Parameters by Reference to a Method</h2><blockquote><p>By default, the common language runtime (CLR) assumes that all method parameters are passed by value. When reference type objects are passed, the reference (or pointer) to the object is passed (by value) to the method. This means that the method can modify the object and the caller will see the change. For value type instances, a copy of the instance is passed to the method. This means that the method gets its own private copy of the value type and the instance in the caller isn’t affected.</p></blockquote><p>💡重要提示：在方法中，必须知道传递的每个参数是引用类型还是值类型，处理参数的代码显著有别。</p><blockquote><p>The CLR allows you to pass parameters by reference instead of by value. In C#, you do this by using the out and ref keywords. Both keywords tell the C# compiler to emit metadata indicating that this designated parameter is passed by reference, and the compiler uses this to generate code to pass the address of the parameter rather than the parameter itself.</p></blockquote><blockquote><p>From the CLR’s perspective, out and ref are identical—that is, the same IL is produced regardless of which keyword you use, and the metadata is also identical except for 1 bit, which is used to record whether you specified out or ref when declaring the method. However, the C# compiler treats the two keywords differently, and the difference has to do with which method is responsible for initializing the object being referred to. If a method’s parameter is marked with out, the caller isn’t expected to have initialized the object prior to calling the method. The called method can’t read from the value, and the called method must write to the value before returning. If a method’s parameter is marked with ref, the caller must initialize the parameter’s value prior to calling the method. The called method can read from the value and/or write to the value.</p></blockquote><blockquote><p>Reference and value types behave very differently with out and ref. Let’s look at using out and ref with value types first.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Int32</span> x<span class="token punctuation">;</span> <span class="token comment">// x is uninitialized. </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token function">GetVal</span><span class="token punctuation">(</span><span class="token keyword">out</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// x doesn’t have to be initialized. </span></pre></td></tr><tr><td data-num="5"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "10" </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">GetVal</span><span class="token punctuation">(</span><span class="token keyword">out</span> <span class="token class-name">Int32</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> v <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// This method must initialize v. </span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In this code, x is declared in Main’s stack frame. The address of x is then passed to GetVal. GetVal’s v is a pointer to the Int32 value in Main’s stack frame. Inside GetVal, the Int32 that v points to is changed to 10. When GetVal returns, Main’s x has a value of 10, and 10 is displayed on the console. Using out with large value types is efficient because it prevents instances of the value type’s fields from being copied when making method calls.</p></blockquote><blockquote><p>Now let’s look at an example that uses ref instead of out.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// x is initialized. </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token function">AddVal</span><span class="token punctuation">(</span><span class="token keyword">ref</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// x must be initialized. </span></pre></td></tr><tr><td data-num="5"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "15" </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">AddVal</span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token class-name">Int32</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> v <span class="token operator">+=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// This method can use the initialized value in v. </span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In this code, x is also declared in Main’s stack frame and is initialized to 5. The address of x is then passed to AddVal. AddVal’s v is a pointer to the Int32 value in Main’s stack frame. Inside AddVal, the Int32 that v points to is required to have a value already. So, AddVal can use the initial value in any expression it desires. AddVal can also change the value, and the new value will be “returned” to the caller. In this example, AddVal adds 10 to the initial value. When AddVal returns, Main’s x will contain 15, which is what gets displayed in the console.</p></blockquote><blockquote><p>To summarize, from an IL or a CLR perspective, out and ref do exactly the same thing: they both cause a pointer to the instance to be passed. The difference is that the compiler helps ensure that your code is correct. The following code that attempts to pass an uninitialized value to a method expecting a ref parameter produces the following message: error CS0165: Use of unassigned local variable 'x'.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Int32</span> x<span class="token punctuation">;</span> <span class="token comment">// x is not initialized. </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// The following line fails to compile, producing </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// error CS0165: Use of unassigned local variable 'x'. </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token function">AddVal</span><span class="token punctuation">(</span><span class="token keyword">ref</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">AddVal</span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token class-name">Int32</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> v <span class="token operator">+=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// This method can use the initialized value in v. </span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>💡重要提示：经常有人问我，为什么 C# 要求必须在调用方法时指定 <code>out</code> 或 <code>ref</code> ？毕竟，编译器知道被调用的方法需要的是 <code>out</code> 还是 <code>ref</code> ，所以应该能正确编译代码。事实上，C# 编译器确实能自动采用正确的操作。但 C# 语言的设计者认为调用者的方法是否需要对传递的变量值进行更改。</p><p>另外，CLR 允许根据使用的是 <code>out</code> 还是 <code>ref</code> 参数对方法进行重载。例如，在 C# 中，以下代码是合法的，可以通过编译：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token class-name">Point</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token class-name">Point</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>两个重载方法只有 <code>out</code> 还是 <code>ref</code> 的区别则不合法，因为两个签名的元数据形式完全相同。所以，不能在上述 <code>Point</code> 类型中再定义以下方法：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">out</span> <span class="token class-name">Point</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>试图在 <code>Point</code> 类型中添加这个 <code>Add</code> 方法，C# 编译器会显示以下消息： <code>CS0663:&quot;Add&quot; 不能定义仅在ref和out上有差别的重载方法</code> 。</p><blockquote><p>Using out and ref with value types gives you the same behavior that you already get when passing reference types by value. With value types, out and ref allow a method to manipulate a single value type instance. The caller must allocate the memory for the instance, and the callee manipulates that memory. With reference types, the caller allocates memory for a pointer to a reference object, and the callee manipulates this pointer. Because of this behavior, using out and ref with reference types is useful only when the method is going to “return” a reference to an object that it knows about. The following code demonstrates.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>IO</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token class-name">FileStream</span> fs<span class="token punctuation">;</span> <span class="token comment">// fs is uninitialized </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Open the first file to be processed. </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token function">StartProcessingFiles</span><span class="token punctuation">(</span><span class="token keyword">out</span> fs<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Continue while there are more files to process. </span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> fs <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token function">ContinueProcessingFiles</span><span class="token punctuation">(</span><span class="token keyword">ref</span> fs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// Process a file. </span></pre></td></tr><tr><td data-num="11"></td><td><pre> fs<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span><span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">StartProcessingFiles</span><span class="token punctuation">(</span><span class="token keyword">out</span> <span class="token class-name">FileStream</span> fs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> fs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">FileStream</span><span class="token punctuation">(</span><span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// fs must be initialized in this method </span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ContinueProcessingFiles</span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token class-name">FileStream</span> fs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="18"></td><td><pre> fs<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Close the last file worked on. </span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token comment">// Open the next file, or if no more files, "return" null. </span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>noMoreFilesToProcess<span class="token punctuation">)</span> fs <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token keyword">else</span> fs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">FileStream</span> <span class="token punctuation">(</span><span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>As you can see, the big difference with this code is that the methods that have out or ref reference type parameters are constructing an object, and the pointer to the new object is returned to the caller. You’ll also notice that the ContinueProcessingFiles method can manipulate the object being passed into it before returning a new object. This is possible because the parameter is marked with the ref keyword. You can simplify the preceding code a bit, as shown here.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>IO</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token class-name">FileStream</span> fs <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// Initialized to null (required) </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Open the first file to be processed. </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token function">ProcessFiles</span><span class="token punctuation">(</span><span class="token keyword">ref</span> fs<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Continue while there are more files to process. </span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> fs <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token function">ProcessFiles</span><span class="token punctuation">(</span><span class="token keyword">ref</span> fs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// Process a file. </span></pre></td></tr><tr><td data-num="11"></td><td><pre> fs<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span><span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ProcessFiles</span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token class-name">FileStream</span> fs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// Close the previous file if one was open. </span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>fs <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> fs<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Close the last file worked on. </span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token comment">// Open the next file, or if no more files, "return" null. </span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>noMoreFilesToProcess<span class="token punctuation">)</span> fs <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token keyword">else</span> fs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">FileStream</span> <span class="token punctuation">(</span><span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Here’s another example that demonstrates how to use the ref keyword to implement a method<br>that swaps two reference types.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token class-name">Object</span> a<span class="token punctuation">,</span> <span class="token keyword">ref</span> <span class="token class-name">Object</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Object</span> t <span class="token operator">=</span> b<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> b <span class="token operator">=</span> a<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> a <span class="token operator">=</span> t<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>To swap references to two String objects, you’d probably think that you could write code like the following.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SomeMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token string">"Jeffrey"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token string">"Richter"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">ref</span> s1<span class="token punctuation">,</span> <span class="token keyword">ref</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "Richter" </span></pre></td></tr><tr><td data-num="7"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "Jeffrey" </span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>However, this code won’t compile. The problem is that variables passed by reference to a method must be of the same type as declared in the method signature. In other words, Swap expects two Object references, not two String references. To swap the two String references, you must do the following.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SomeMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token string">"Jeffrey"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token string">"Richter"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// Variables that are passed by reference </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// must match what the method expects. </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token class-name">Object</span> o1 <span class="token operator">=</span> s1<span class="token punctuation">,</span> o2 <span class="token operator">=</span> s2<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">ref</span> o1<span class="token punctuation">,</span> <span class="token keyword">ref</span> o2<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// Now cast the objects back to strings. </span></pre></td></tr><tr><td data-num="10"></td><td><pre> s1 <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> o1<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> s2 <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> o2<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> </pre></td></tr><tr><td data-num="13"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "Richter" </span></pre></td></tr><tr><td data-num="14"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "Jeffrey" </span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>This version of SomeMethod does compile and execute as expected. The reason why the parameters passed must match the parameters expected by the method is to ensure that type safety is preserved. The following code, which thankfully won’t compile, shows how type safety could be compromised.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name">Int32</span> m_val<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token class-name">SomeType</span> st<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// The following line generates error CS1503: Argument '1': </span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// cannot convert from 'ref SomeType' to 'ref object'. </span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token function">GetAnObject</span><span class="token punctuation">(</span><span class="token keyword">out</span> st<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span>m_val<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">GetAnObject</span><span class="token punctuation">(</span><span class="token keyword">out</span> <span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">String</span><span class="token punctuation">(</span><span class="token char">'X'</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In this code, Main clearly expects GetAnObject to return a SomeType object. However, because GetAnObject’s signature indicates a reference to an Object, GetAnObject is free to initialize o to an object of any type. In this example, when GetAnObject returned to Main, st would refer to a String, which is clearly not a SomeType object, and the call to Console.WriteLine would certainly fail. Fortunately, the C# compiler won’t compile the preceding code because st is a reference to SomeType, but GetAnObject requires a reference to an Object.</p></blockquote><blockquote><p>You can use generics to fix these methods so that they work as you’d expect. Here is how to fix the Swap method shown earlier.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">Swap</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token class-name">T</span> a<span class="token punctuation">,</span> <span class="token keyword">ref</span> <span class="token class-name">T</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">T</span> t <span class="token operator">=</span> b<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> b <span class="token operator">=</span> a<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> a <span class="token operator">=</span> t<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>And now, with Swap rewritten as above, the following code (identical to that shown before) will compile and run perfectly.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SomeMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token string">"Jeffrey"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token string">"Richter"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">ref</span> s1<span class="token punctuation">,</span> <span class="token keyword">ref</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "Richter" </span></pre></td></tr><tr><td data-num="6"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "Jeffrey" </span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>For some other examples that use generics to solve this problem, see System.Threading’s Interlocked class with its CompareExchange and Exchange methods.</p></blockquote><p>💡小结：CLR 默认所有方法参数都传值。传递引用类型的对象时，对象引用（或者说指向对象的指针）被传给方法。注意引用（或指针）本身是传值的，意味着方法能修改对象，而调用者能看到这些修改。对于值类型的实例，传给方法的是实例的一个副本，意味着方法将获得它专用的一个值类型实例副本，调用者中的实例不受影响。CLR 允许以传引用而非传值的方式传递参数。C# 用关键字 out 或 ref 支持这个功能。两个关键字都告诉 C# 编译器生成元数据来指明改参数是传引用的。CLR 不区分 out 和 ref，意味着无论用哪个关键字，都会生成相同的 IL 代码。另外，元数据也几乎完全一致，只有一个 bit 除外，它用于记录声明方法时指定的是 out 还是 ref。但是 C# 编译器是区别这两个关键字的。如果方法的参数用 out 标记，表示不指望调用者在调用方法之前初始化好了对象。被调用的方法不能读取参数的值，而且在返回前必须向这个值写入。相反，如果方法的参数用 ref 来标记，调用者就必须在调用该方法前初始化参数的值，被调用的方法可以读取值以及 / 或者向值写入。对于以传引用的方式传给方法的变量，它的类型必须与方法签名中声明的类型相同，这是由于我们无法预测方法内部是否会进行不恰当的转型引起编译错误。</p><h2 id="passing-a-variable-number-of-arguments-to-a-method"><a class="anchor" href="#passing-a-variable-number-of-arguments-to-a-method">#</a> Passing a Variable Number of Arguments to a Method</h2><blockquote><p>It’s sometimes convenient for the developer to define a method that can accept a variable number of arguments. For example, the System.String type offers methods allowing an arbitrary number of strings to be concatenated together and methods allowing the caller to specify a set of strings that are to be formatted together.</p></blockquote><blockquote><p>To declare a method that accepts a variable number of arguments, you declare the method as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">params</span> <span class="token class-name">Int32<span class="token punctuation">[</span><span class="token punctuation">]</span></span> values<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// NOTE: it is possible to pass the 'values' </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// array to other methods if you want to. </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">Int32</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>values <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> values<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> sum <span class="token operator">+=</span> values<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">return</span> sum<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Everything in this method should look very familiar to you except for the params keyword that is applied to the last parameter of the method signature. Ignoring the params keyword for the moment, it’s obvious that this method accepts an array of Int32 values and iterates over the array, adding up all of the values. The resulting sum is returned to the caller.</p></blockquote><blockquote><p>Obviously, code can call this method as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Displays "15" </span></pre></td></tr><tr><td data-num="3"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">Int32<span class="token punctuation">[</span><span class="token punctuation">]</span></span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>It’s clear that the array can easily be initialized with an arbitrary number of elements and then passed off to Add for processing. Although the preceding code would compile and work correctly, it is a little ugly. As developers, we would certainly prefer to have written the call to Add as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Displays "15" </span></pre></td></tr><tr><td data-num="3"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>You’ll be happy to know that we can do this because of the params keyword. The params keyword tells the compiler to apply an instance of the System.ParamArrayAttribute custom attribute to the parameter.</p></blockquote><blockquote><p>When the C# compiler detects a call to a method, the compiler checks all of the methods with the specified name, where no parameter has the ParamArray attribute applied. If a method exists that can accept the call, the compiler generates the code necessary to call the method. However, if the compiler can’t find a match, it looks for methods that have a ParamArray attribute to see whether the call can be satisfied. If the compiler finds a match, it emits code that constructs an array and populates its elements before emitting the code that calls the selected method.</p></blockquote><blockquote><p>In the previous example, no Add method is defined that takes five Int32-compatible arguments; however, the compiler sees that the source code has a call to Add that is being passed a list of Int32 values and that there is an Add method whose array-of-Int32 parameter is marked with the ParamArray attribute. So the compiler considers this a match and generates code that coerces the parameters into an Int32 array and then calls the Add method. The end result is that you can write the code, easily passing a bunch of parameters to Add, but the compiler generates code as though you’d written the first version that explicitly constructs and initializes the array.</p></blockquote><blockquote><p>Only the last parameter to a method can be marked with the params keyword (ParamArrayAttribute). This parameter must also identify a single-dimension array of any type. It’s legal to pass null or a reference to an array of 0 entries as the last parameter to the method. The following call to Add compiles fine, runs fine, and produces a resulting sum of 0 (as expected).</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Both of these lines display "0" </span></pre></td></tr><tr><td data-num="3"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// passes new Int32[0] to Add</span></pre></td></tr><tr><td data-num="4"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// passes null to Add: more efficient (no array allocated)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>So far, all of the examples have shown how to write a method that takes an arbitrary number of Int32 parameters. How would you write a method that takes an arbitrary number of parameters where the parameters could be any type? The answer is very simple: just modify the method’s prototype so that it takes an Object[] instead of an Int32[]. Here’s a method that displays the Type of every object passed to it.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token function">DisplayTypes</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Jeff"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">DisplayTypes</span><span class="token punctuation">(</span><span class="token keyword">params</span> <span class="token class-name">Object<span class="token punctuation">[</span><span class="token punctuation">]</span></span> objects<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>objects <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name">Object</span> o <span class="token keyword">in</span> objects<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Running this code yields the following output.</p></blockquote><pre><code>System.Object
System.Random
System.String
System.Int32
</code></pre><p>💡重要提示：注意，调用参数数量可变的方法对性能有所影响 (除非显式传递 <code>null</code> )。毕竟，数组对象必须在堆上分配，数组元素必须初始化，而且数组的内存最终需要垃圾回收。要减少对性能的影响，可考虑定义几个没有使用 <code>params</code> 关键字的重载版本。关于这方面的范例，请参考 <code>System.String</code> 类的 <code>Concat</code> 方法，该方法定义了以下重载版本：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">String</span> <span class="token punctuation">:</span> Object<span class="token punctuation">,</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> <span class="token function">Concat</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span></span> arg0<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> <span class="token function">Concat</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span></span> arg0<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">object</span></span> arg1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> <span class="token function">Concat</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span></span> arg0<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">object</span></span> arg1<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">object</span></span> arg2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> <span class="token function">Concat</span><span class="token punctuation">(</span><span class="token keyword">params</span> <span class="token class-name"><span class="token keyword">object</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> <span class="token function">Concat</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> str0<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span></span> str1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> <span class="token function">Concat</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> str0<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span></span> str1<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span></span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> <span class="token function">Concat</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> str0<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span></span> str1<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span></span> str2<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span></span> str3<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> <span class="token function">Concat</span><span class="token punctuation">(</span><span class="token keyword">params</span> <span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> values<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>如你所见， <code>Concat</code> 方法定义了几个没有使用 <code>params</code> 关键字的重载版本。这是为了改善常规情形下的性能。使用了 <code>params</code> 关键字的重载则用于不太常见的情形；在这些情形下，性能有一定的损失。但幸运的是，这些情形本来就不常见。</p><p>💡小结：方法有时需要获取可变数量的参数。为了接受可变数量的参数，要在原先的参数定义前面加上 <code>params</code> 关键字， <code>params</code> 只能应用于方法签名中的最后一个参数。 <code>params</code> 关键字告诉编译器向参数应用定制特性 <code>System.ParamArrayAttribute</code> 的一个实例。C# 编译器检测到方法调用时，会先检查所有具有指定名称、同时参数没有应用 <code>ParamArray</code> 特性的方法。找到匹配的方法，就生成调用它所需的代码。没有找到，就接着检查应用了 <code>ParamArray</code> 特性的方法。找到匹配的方法，编译器先生成代码来构造一个数组，填充它的元素，再生成代码来调用所选的方法。只有方法的最后一个参数才可以用 <code>params</code> 关键字（ <code>ParamArrayAttribute</code> ）标记。另外，这个参数只能标记一维数组（任意类型）。可为这个参数传递 null 值，或传递对包含零个元素的一个数组的引用。</p><h2 id="parameter-and-return-type-guidelines"><a class="anchor" href="#parameter-and-return-type-guidelines">#</a> Parameter and Return Type Guidelines</h2><blockquote><p>When declaring a method’s parameter types, you should specify the weakest type possible, preferring interfaces over base classes. For example, if you are writing a method that manipulates a collection of items, it would be best to declare the method’s parameter by using an interface such as <code>IEnumerable</code> rather than using a strong data type such as List or even a stronger interface type such as <code>ICollection</code> or <code>IList</code> .</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Desired: This method uses a weak parameter type </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">ManipulateItems</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> collection<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// Undesired: This method uses a strong parameter type </span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">ManipulateItems</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">List<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> collection<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The reason, of course, is that someone can call the first method passing in an array object, a List object, a String object, and so on—any object whose type implements <code>IEnumerable</code> . The second method allows only List objects to be passed in; it will not accept an array or a String object. Obviously, the first method is better because it is much more flexible and can be used in a much wider range of scenarios.</p></blockquote><blockquote><p>Naturally, if you are writing a method that requires a list (not just any enumerable object), then you should declare the parameter type as an <code>IList</code> . You should still avoid declaring the parameter type as List. Using <code>IList</code> allows the caller to pass arrays and any other objects whose type implements <code>IList</code> .</p></blockquote><blockquote><p>Note that my examples talked about collections, which are designed using an interface architecture. If we were talking about classes designed using a base class architecture, the concept still applies. So, for example, if I were implementing a method that processed bytes from a stream, we’d have the following.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Desired: This method uses a weak parameter type </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ProcessBytes</span><span class="token punctuation">(</span><span class="token class-name">Stream</span> someStream<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// Undesired: This method uses a strong parameter type </span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ProcessBytes</span><span class="token punctuation">(</span><span class="token class-name">FileStream</span> fileStream<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The first method can process bytes from any kind of stream: a <code>FileStream</code> , a <code>NetworkStream</code> , a <code>MemoryStream</code> , and so on. The second method can operate only on a <code>FileStream</code> , making it far more limited.</p></blockquote><blockquote><p>On the flip side, it is usually best to declare a method’s return type by using the strongest type possible (trying not to commit yourself to a specific type). For example, it is better to declare a method that returns a <code>FileStream</code> object as opposed to returning a Stream object.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Desired: This method uses a strong return type </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name">FileStream</span> <span class="token function">OpenFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// Undesired: This method uses a weak return type </span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name">Stream</span> <span class="token function">OpenFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Here, the first method is preferred because it allows the method’s caller the option of treating the returned object as either a FileStream object or as a Stream object. Meanwhile, the second method requires that the caller treat the returned object as a Stream object. Basically, it is best to let the caller have as much flexibility as possible when calling a method, allowing the method to be used in the widest range of scenarios.</p></blockquote><blockquote><p>Sometimes you want to retain the ability to change the internal implementation of a method without affecting the callers. In the example just shown, the <code>OpenFile</code> method is unlikely to ever change its internal implementation to return anything other than a <code>FileStream</code> object (or an object whose type is derived from <code>FileStream</code> ). However, if you have a method that returns a List object, you might very well want to change the internal implementation of this method in the future so that it would instead return a String[]. In the cases in which you want to leave yourself some flexibility to change what your method returns, choose a weaker return type. The following is an example.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Flexible: This method uses a weaker return type </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name">IList<span class="token punctuation">&lt;</span>String<span class="token punctuation">></span></span> <span class="token function">GetStringCollection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// Inflexible: This method uses a stronger return type </span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name">List<span class="token punctuation">&lt;</span>String<span class="token punctuation">></span></span> <span class="token function">GetStringCollection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In this example, even though the <code>GetStringCollection</code> method uses a List object internally and returns it, it is better to prototype the method as returning an <code>IList</code> instead. In the future, the <code>GetStringCollection</code> method could change its internal collection to use a String[], and callers of the method won’t be required to change any of their source code. In fact, they won’t even have to recompile their code. Notice in this example that I’m using the strongest of the weakest types. For instance, I’m not using an <code>IEnumerable</code> or even <code>ICollection</code> .</p></blockquote><p>💡小结：声明方法的参数类型时，应尽量指定最弱的类型，宁愿要接口也不要基类。原因是这样能使方法更灵活，适合更广泛的情形。除非方法需要的类型有特定的要求。不仅是接口体系结构实用上面的概念，对于基类体系结构设计的类时，概念同样适用。相反，一般最好是将方法的返回类型声明为最强的类型（防止受限于特定类型）。如果想保持一定的灵活性，在将来更改方法返回的东西，那么就选择一个较弱的（注意是相较于最强的较弱）返回返回类型。</p><h2 id="const-ness"><a class="anchor" href="#const-ness">#</a> Const-ness</h2><blockquote><p>n some languages, such as unmanaged C++, it is possible to declare methods or parameters as a constant that forbids the code in an instance method from changing any of the object’s fields or prevents the code from modifying any of the objects passed into the method. The CLR does not provide for this, and many programmers have been lamenting this missing feature. Because the CLR doesn’t offer this feature, no language (including C#) can offer this feature.</p></blockquote><blockquote><p>First, you should note that in unmanaged C++, marking an instance method or parameter as const ensured only that the programmer could not write normal code that would modify the object or parameter. Inside the method, it was always possible to write code that could mutate the object/ parameter by either casting away the const-ness or by getting the address of the object/argument and then writing to the address. In a sense, unmanaged C++ lied to programmers, making them believe that their constant objects/arguments couldn’t be written to even though they could.</p></blockquote><blockquote><p>When designing a type’s implementation, the developer can just avoid writing code that manipulates the object/arguments. For example, strings are immutable because the String class doesn’t offer any methods that can change a string object.</p></blockquote><blockquote><p>Also, it would be very difficult for Microsoft to endow the CLR with the ability to verify that a constant object/argument isn’t being mutated. The CLR would have to verify at each write that the write was not occurring to a constant object, and this would hurt performance significantly. Of course, a detected violation would result in the CLR throwing an exception. Furthermore, constant support adds a lot of complexity for developers. For example, if a type is immutable, all derived types would have to respect this. In addition, an immutable type would probably have to consist of fields that are also of immutable types.</p></blockquote><blockquote><p>These are just some of the reasons why the CLR does not support constant objects/arguments.</p></blockquote><p>💡小结：有的语言（比如非托管 C++）允许将方法或参数声明为常量，从而禁止实例方法中的代码更改对象的任何字段，或者更改传给方法的任何对象。CLR 没有提供这个功能，既然 CLR 都不提供，那么面向它的任何编程语言（包括 C#）自然也无法提供。不过非托管 C++ 将实例方法或参数声明为 <code>const</code> 只能防止程序员用一般的代码来更改对象或参数。方法内部总是可以更改对象或实参的。例如用强制类型转换去掉 “常量性”，或者通过获取对象 / 实参的地址，在向那个地址写入。实现类型时，开发人员可以避免写操纵对象或实参的代码。例如，String 类就没有提供任何能更改 String 对象的方法，所以字符串是不可变（immutable）的。此外，Microsoft 很难为 CLR 赋予验证常量对象 / 实参未被更改的能力。CLR 将不得不对每个写入操作进行验证，确定该写入针对的不是常量对象。这对性能影响很大。当然，如果检测到有违反常量性的地方，会造成 CLR 抛出异常。此外，如果支持常量性，还会给开发人员带来大量复杂性。例如，如果类型是不可变的，它的所有派生类型都不得不遵守这个约定。除此之外，在不可变的类型中，字段也必须不可变。考虑到种种原因，CLR 没有提供对常量对象 / 实参的支持。</p><div class="tags"><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 读书笔记</a> <a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C#</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2022-11-01 14:23:08" itemprop="dateModified" datetime="2022-11-01T14:23:08+08:00">2022-11-01</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Sakupinera WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Sakupinera Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Sakupinera PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Sakupinera <i class="ic i-at"><em>@</em></i>Sakupinera</li><li class="link"><strong>Post link: </strong><a href="http://sakupinera.github.io/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/" title="CLR via C# - Chapter 9 Parameters">http://sakupinera.github.io/2022/10/27/csharp/clr-via-csharp/Chapter 9 Parameters/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipet4bz0yj20zk0m8e81.jpg" title="CLR via C# - Chapter 8 Methods"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 8 Methods</h3></a></div><div class="item right"><a href="/2022/10/28/csharp/clr-via-csharp/Chapter%2010%20Properties/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipesng5oej20zk0m87d4.jpg" title="CLR via C# - Chapter 10 Properties"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 10 Properties</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-9-parameters"><span class="toc-number">1.</span> <span class="toc-text">Chapter 9 Parameters</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#optional-and-named-parameters"><span class="toc-number">1.1.</span> <span class="toc-text">Optional and Named Parameters</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rules-and-guidelines"><span class="toc-number">1.1.1.</span> <span class="toc-text">Rules and Guidelines</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#the-defaultparametervalue-and-optional-attributes"><span class="toc-number">1.1.2.</span> <span class="toc-text">The DefaultParameterValue and Optional Attributes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#implicitly-typed-local-variables"><span class="toc-number">1.2.</span> <span class="toc-text">Implicitly Typed Local Variables</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#passing-parameters-by-reference-to-a-method"><span class="toc-number">1.3.</span> <span class="toc-text">Passing Parameters by Reference to a Method</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#passing-a-variable-number-of-arguments-to-a-method"><span class="toc-number">1.4.</span> <span class="toc-text">Passing a Variable Number of Arguments to a Method</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#parameter-and-return-type-guidelines"><span class="toc-number">1.5.</span> <span class="toc-text">Parameter and Return Type Guidelines</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const-ness"><span class="toc-number">1.6.</span> <span class="toc-text">Const-ness</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"><ul><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/" rel="bookmark" title="CLR via C# - Chapter 1 The CLR’s Execution Model">CLR via C# - Chapter 1 The CLR’s Execution Model</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/" rel="bookmark" title="CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types">CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%203%20Shared%20Assemblies%20and%20Strongly%20Named%20Assemblies/" rel="bookmark" title="CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies">CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies</a></li><li><a href="/2022/09/27/csharp/clr-via-csharp/Chapter%204%20Type%20Fundamentals/" rel="bookmark" title="CLR via C# - Chapter 4 Type Fundamentals">CLR via C# - Chapter 4 Type Fundamentals</a></li><li><a href="/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/" rel="bookmark" title="CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals">CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals</a></li><li><a href="/2022/10/21/csharp/clr-via-csharp/Chapter%206%20Type%20and%20Member%20Basics/" rel="bookmark" title="CLR via C# - Chapter 6 Type and Member Basics">CLR via C# - Chapter 6 Type and Member Basics</a></li><li><a href="/2022/10/24/csharp/clr-via-csharp/Chapter%207%20Constants%20and%20Fields/" rel="bookmark" title="CLR via C# - Chapter 7 Constants and Fields">CLR via C# - Chapter 7 Constants and Fields</a></li><li><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" rel="bookmark" title="CLR via C# - Chapter 8 Methods">CLR via C# - Chapter 8 Methods</a></li><li class="active"><a href="/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/" rel="bookmark" title="CLR via C# - Chapter 9 Parameters">CLR via C# - Chapter 9 Parameters</a></li><li><a href="/2022/10/28/csharp/clr-via-csharp/Chapter%2010%20Properties/" rel="bookmark" title="CLR via C# - Chapter 10 Properties">CLR via C# - Chapter 10 Properties</a></li><li><a href="/2022/10/29/csharp/clr-via-csharp/Chapter%2011%20Events/" rel="bookmark" title="CLR via C# - Chapter 11 Events">CLR via C# - Chapter 11 Events</a></li><li><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" rel="bookmark" title="CLR via C# - Chapter 12 Generics">CLR via C# - Chapter 12 Generics</a></li><li><a href="/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/" rel="bookmark" title="CLR via C# - Chapter 13 Interfaces">CLR via C# - Chapter 13 Interfaces</a></li><li><a href="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/" rel="bookmark" title="CLR via C# - Chapter 14 Chars, Strings, and Working with Text">CLR via C# - Chapter 14 Chars, Strings, and Working with Text</a></li><li><a href="/2022/11/17/csharp/clr-via-csharp/Chapter%2015%20Enumerated%20Types%20and%20Bit%20Flags/" rel="bookmark" title="CLR via C# - Chapter 15 Enumerated Types and Bit Flags">CLR via C# - Chapter 15 Enumerated Types and Bit Flags</a></li><li><a href="/2022/11/19/csharp/clr-via-csharp/Chapter%2016%20Arrays/" rel="bookmark" title="CLR via C# - Chapter 16 Arrays">CLR via C# - Chapter 16 Arrays</a></li><li><a href="/2022/11/21/csharp/clr-via-csharp/Chapter%2017%20Delegates/" rel="bookmark" title="CLR via C# - Chapter 17 Delegates">CLR via C# - Chapter 17 Delegates</a></li><li><a href="/2022/11/22/csharp/clr-via-csharp/Chapter%2018%20Custom%20Attributes/" rel="bookmark" title="CLR via C# - Chapter 18 Custom Attributes">CLR via C# - Chapter 18 Custom Attributes</a></li><li><a href="/2022/11/23/csharp/clr-via-csharp/Chapter%2019%20Nullable%20Value%20Types/" rel="bookmark" title="CLR via C# - Chapter 19 Nullable Value Types">CLR via C# - Chapter 19 Nullable Value Types</a></li><li><a href="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/" rel="bookmark" title="CLR via C# - Chapter 20 Exceptions and State Management">CLR via C# - Chapter 20 Exceptions and State Management</a></li><li><a href="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/" rel="bookmark" title="CLR via C# - Chapter 21 The Managed Heap and Garbage  Collection">CLR via C# - Chapter 21 The Managed Heap and Garbage Collection</a></li><li><a href="/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/" rel="bookmark" title="CLR via C# - Chapter 22 CLR Hosting and AppDomains">CLR via C# - Chapter 22 CLR Hosting and AppDomains</a></li><li><a href="/2022/11/29/csharp/clr-via-csharp/Chapter%2023%20Assembly%20Loading%20and%20Reflection/" rel="bookmark" title="CLR via C# - Chapter 23 Assembly Loading and Reflection">CLR via C# - Chapter 23 Assembly Loading and Reflection</a></li><li><a href="/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/" rel="bookmark" title="CLR via C# - Chapter 24 Runtime Serialization">CLR via C# - Chapter 24 Runtime Serialization</a></li><li><a href="/2022/12/06/csharp/clr-via-csharp/Chapter%2025%20Interoperating%20with%20WinRT%20%20Components/" rel="bookmark" title="CLR via C# - Chapter 25 Interoperating with WinRT Components">CLR via C# - Chapter 25 Interoperating with WinRT Components</a></li><li><a href="/2023/02/06/csharp/clr-via-csharp/Chapter%2026%20Thread%20Basics/" rel="bookmark" title="CLR via C# - Chapter 26 Thread Basics">CLR via C# - Chapter 26 Thread Basics</a></li><li><a href="/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations">CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations</a></li><li><a href="/2023/02/08/csharp/clr-via-csharp/Chapter%2028%20IO-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 28 IO-Bound Asynchronous Operations">CLR via C# - Chapter 28 IO-Bound Asynchronous Operations</a></li><li><a href="/2023/02/09/csharp/clr-via-csharp/Chapter%2029%20Primitive%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 29 Primitive Thread Synchronization">CLR via C# - Chapter 29 Primitive Thread Synchronization</a></li><li><a href="/2023/02/10/csharp/clr-via-csharp/Chapter%2030%20Hybrid%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 30 Hybrid Thread Synchronization">CLR via C# - Chapter 30 Hybrid Thread Synchronization</a></li></ul></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sakupinera" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Sakupinera</p><div class="description" itemprop="description">保持你的决心！</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">89</span> <span class="name">posts</span></a></div><div class="item categories"><a href="/categories/"><span class="count">17</span> <span class="name">categories</span></a></div><div class="item tags"><a href="/tags/"><span class="count">8</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nha3VwaW5lcmE=" title="https:&#x2F;&#x2F;github.com&#x2F;sakupinera"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9zYWt1cGluZXJh" title="https:&#x2F;&#x2F;twitter.com&#x2F;sakupinera"><i class="ic i-twitter"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQwNzIyOTA3MQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;407229071"><i class="ic i-cloud-music"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMjIzMDczOTg/c3BtX2lkX2Zyb209MzMzLjEwMDcuMC4w" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;22307398?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li><li class="item"><a href="/games/" rel="section"><i class="ic i-flag"></i>games</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-person"></i>About</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/10/28/csharp/clr-via-csharp/Chapter%2010%20Properties/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/09/30/computer-graphics/games101/%E7%9D%80%E8%89%B2/" title="GAMES101 - Shading（着色）">GAMES101 - Shading（着色）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2023/02/10/csharp/clr-via-csharp/Chapter%2030%20Hybrid%20Thread%20Synchronization%20Constructs/" title="CLR via C# - Chapter 30 Hybrid Thread Synchronization">CLR via C# - Chapter 30 Hybrid Thread Synchronization</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2022/12/09/cpp/cpp-primer/Chapter%201%20Getting%20Started/" title="C++ Primer - Chapter 1 Getting Started">C++ Primer - Chapter 1 Getting Started</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Language/" title="In Language">Language</a> <i class="ic i-angle-right"></i> <a href="/categories/Language/Japanese/" title="In Japanese">Japanese</a></div><span><a href="/2024/10/23/language/japanese/%E6%97%A5%E6%9C%AC%E8%AA%9E%E3%81%AE%E5%8B%89%E5%BC%B7/" title="日本語の勉強">日本語の勉強</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" title="CLR via C# - Chapter 12 Generics">CLR via C# - Chapter 12 Generics</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/" title="GAMES101 - Cameras, Lenses and Light Fields（相机，透镜和光场）">GAMES101 - Cameras, Lenses and Light Fields（相机，透镜和光场）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2022/12/16/cpp/cpp-primer/Chapter%208%20The%20IO%20Library/" title="C++ Primer - Chapter 8 The IO Library">C++ Primer - Chapter 8 The IO Library</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/10/03/computer-graphics/games101/%E5%87%A0%E4%BD%95/" title="GAMES101 - Geometry（几何）">GAMES101 - Geometry（几何）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2023/02/09/csharp/clr-via-csharp/Chapter%2029%20Primitive%20Thread%20Synchronization%20Constructs/" title="CLR via C# - Chapter 29 Primitive Thread Synchronization">CLR via C# - Chapter 29 Primitive Thread Synchronization</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/12/06/csharp/clr-via-csharp/Chapter%2025%20Interoperating%20with%20WinRT%20%20Components/" title="CLR via C# - Chapter 25 Interoperating with WinRT Components">CLR via C# - Chapter 25 Interoperating with WinRT Components</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Sakupinera @ Hanamai Sora</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="Symbols count total">2.2m words</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="Reading time total">34:05</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/10/27/csharp/clr-via-csharp/Chapter 9 Parameters/",favicon:{show:"（●´3｀●）Goooood",hide:"(´Д｀)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/shifuku.model.json"},display:{position:"left",width:250,height:500},mobile:{show:!1},react:{opacity:.9},log:!1})</script></body></html>