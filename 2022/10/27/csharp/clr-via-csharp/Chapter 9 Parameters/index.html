<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sakupinera" href="http://sakupinera.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sakupinera" href="http://sakupinera.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sakupinera" href="http://sakupinera.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="è¯»ä¹¦ç¬”è®°,C#"><link rel="canonical" href="http://sakupinera.github.io/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/"><title>CLR via C# - Chapter 9 Parameters - CLR-via-CSharp - CSharp | Hanamai Sora = Sakupinera</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">CLR via C# - Chapter 9 Parameters</h1><div class="meta"><span class="item" title="Created: 2022-10-27 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2022-10-27T00:00:00+08:00">2022-10-27</time> </span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">Symbols count in article</span> <span>33k</span> <span class="text">words</span> </span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">Reading time</span> <span>30 mins.</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hanamai Sora</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclxp31goj20zk0m8qv5.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclhfehz7j20zk0m8u0x.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giph4baakhj20zk0m8h5q.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gicmnywqgpj20zk0m8dwx.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipet4bz0yj20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gicis081o9j20zk0m8dmr.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/" itemprop="item" rel="index" title="In CSharp"><span itemprop="name">CSharp</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/CLR-via-CSharp/" itemprop="item" rel="index" title="In CLR-via-CSharp"><span itemprop="name">CLR-via-CSharp</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://sakupinera.github.io/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Sakupinera"><meta itemprop="description" content=", ä¿æŒä½ çš„å†³å¿ƒï¼"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakupinera"></span><div class="body md" itemprop="articleBody"><h1 id="chapter-9-parameters"><a class="anchor" href="#chapter-9-parameters">#</a> Chapter 9 Parameters</h1><h2 id="optional-and-named-parameters"><a class="anchor" href="#optional-and-named-parameters">#</a> Optional and Named Parameters</h2><blockquote><p>When designing a methodâ€™s parameters, you can assign default values to some of or all the parameters. Then, code that calls these methods can optionally not specify some of the arguments, thereby accepting the default values. In addition, when you call a method, you can specify arguments by using the name of their parameters. Here is some code that demonstrates using both optional and named parameters.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Int32</span> s_n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">M</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"A"</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">DateTime</span> dt <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">(</span><span class="token type-expression class-name">DateTime</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Guid</span> guid <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Guid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"x=&#123;0&#125;, s=&#123;1&#125;, dt=&#123;2&#125;, guid=&#123;3&#125;"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> s<span class="token punctuation">,</span> dt<span class="token punctuation">,</span> guid<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// 1. Same as: M(9, "A", default(DateTime), new Guid());</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token function">M</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// 2. Same as: M(8, "X", default(DateTime), new Guid());</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token function">M</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">"X"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// 3. Same as: M(5, "A", DateTime.Now, Guid.NewGuid());</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token function">M</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token named-parameter punctuation">guid</span><span class="token punctuation">:</span> Guid<span class="token punctuation">.</span><span class="token function">NewGuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token named-parameter punctuation">dt</span><span class="token punctuation">:</span> DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token comment">// 4. Same as: M(0, "1", default(DateTime), new Guid());</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token function">M</span><span class="token punctuation">(</span>s_n<span class="token operator">++</span><span class="token punctuation">,</span> s_n<span class="token operator">++</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token comment">// 5. Same as: String t1 = "2"; Int32 t2 = 3; </span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token comment">// M(t2, t1, default(DateTime), new Guid());</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token function">M</span><span class="token punctuation">(</span><span class="token named-parameter punctuation">s</span><span class="token punctuation">:</span> <span class="token punctuation">(</span>s_n<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token named-parameter punctuation">x</span><span class="token punctuation">:</span> s_n<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When I run this program, I get the following output.</p></blockquote><pre><code>x=9, s=A, dt=1/1/0001 12:00:00 AM, guid=00000000-0000-0000-0000-000000000000
x=8, s=X, dt=1/1/0001 12:00:00 AM, guid=00000000-0000-0000-0000-000000000000
x=5, s=A, dt=8/16/2012 10:14:25 PM, guid=d24a59da-6009-4aae-9295-839155811309
x=0, s=1, dt=1/1/0001 12:00:00 AM, guid=00000000-0000-0000-0000-000000000000
x=3, s=2, dt=1/1/0001 12:00:00 AM, guid=00000000-0000-0000-0000-000000000000
</code></pre><blockquote><p>As you can see, whenever arguments are left out at the call site, the C# compiler embeds the parameterâ€™s default value. The third and fifth calls to M use C#â€™s named parameter feature. In the two calls, Iâ€™m explicitly passing a value for x and Iâ€™m indicating that I want to pass an argument for the parameters named guid and dt.</p></blockquote><blockquote><p>When you pass arguments to a method, the compiler evaluates the arguments from left to right. In the fourth call to M, the value in s_n (0) is passed for x, then s_n is incremented, and s_n (1) is passed as a string for s and then s_n is incremented again to 2. When you pass arguments by using named parameters, the compiler still evaluates the arguments from left to right. In the fifth call to M, the value in s_n (2) is converted to a string and saved in a temporary variable (t1) that the compiler creates. Next, s_n is incremented to 3 and this value is saved in another temporary variable (t2) created by the compiler, and then s_n is incremented again to 4. Ultimately, M is invoked, passing it t2, t1, a default DateTime, and a new Guid.</p></blockquote><h3 id="rules-and-guidelines"><a class="anchor" href="#rules-and-guidelines">#</a> Rules and Guidelines</h3><blockquote><p>There are some additional rules and guidelines that you should know about when defining a method that specifies default values for some of its parameters:</p></blockquote><ul><li><p>You can specify default values for the parameters of methods, constructor methods, and parameterful properties (C# indexers). You can also specify default values for parameters that are part of a delegate definition. Then, when invoking a variable of this delegate type, you can omit the arguments and accept the default values.</p></li><li><p>Parameters with default values must come after any parameters that do not have default values. That is, after you define a parameter as having a default value, then all parameters to the right of it must also have default values. For example, in the definition of my M method, I would get a compiler error if I removed the default value (&quot;A&quot;) for s. There is one exception to this rule: a params array parameter (discussed later in this chapter) must come after all parameters (including those that have default values), and the array cannot have a default value itself.</p></li><li><p>Default values must be constant values known at compile time. This means that you can set default values for parameters of types that C# considers to be primitive types, as shown in Table 5-1 in Chapter 5, â€œPrimitive, Reference, and Value Types.â€ This also includes enumerated types, and any reference type can be set to null. For a parameter of an arbitrary value type, you can set the default value to be an instance of the value type, with all its fields containing zeroes. You can use the default keyword or the new keyword to express this; both syntaxes produce identical Intermediate Language (IL) code. Examples of both syntaxes are used by my M method for setting the default value for the dt parameter and guid parameter, respectively.</p></li><li><p>Be careful not to rename parameter variables because any callers who are passing arguments by parameter name will have to modify their code. For example, in the declaration of my M method, if I rename the dt variable to dateTime, then my third call to M in the earlier code will cause the compiler to produce the following message: error CS1739: The best overload for 'M' does not have a parameter named 'dt'.</p></li><li><p>Be aware that changing a parameterâ€™s default value is potentially dangerous if the method is called from outside the module. A call site embeds the default value into its call. If you later change the parameterâ€™s default value and do not recompile the code containing the call site, then it will call your method passing the old default value. You might want to consider using a default value of 0/null as a sentinel to indicate default behavior; this allows you to change your default without having to recompile all the code with call sites. Here is an example.</p></li></ul><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Donâ€™t do this:</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name">String</span> <span class="token function">MakePath</span><span class="token punctuation">(</span><span class="token class-name">String</span> filename <span class="token operator">=</span> <span class="token string">"Untitled"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">return</span> String<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">@"C:\&#123;0&#125;.txt"</span><span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// Do this instead:</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name">String</span> <span class="token function">MakePath</span><span class="token punctuation">(</span><span class="token class-name">String</span> filename <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// I am using the null-coalescing operator (??) here; see Chapter 19</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">return</span> String<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">@"C:\&#123;0&#125;.txt"</span><span class="token punctuation">,</span> filename <span class="token operator">??</span> <span class="token string">"Untitled"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>You cannot set default values for parameters marked with either the ref or out keywords because there is no way to pass a meaningful default value for these parameters.</li></ul><blockquote><p>There are some additional rules and guidelines that you should know about when calling a method by using optional or named parameters:</p></blockquote><ul><li><p>Arguments can be passed in any order; however, named arguments must always appear at the end of the argument list.</p></li><li><p>You can pass arguments by name to parameters that do not have default values, but all required arguments must be passed (by position or by name) for the compiler to compile the code.</p></li><li><p>C# doesnâ€™t allow you to omit arguments between commas, as in M(1, ,DateTime.Now), because this could lead to unreadable comma-counting code. Pass arguments by way of their parameter name if you want to omit some arguments for parameters with default values.</p></li><li><p>To pass an argument by parameter name that requires ref/out, use syntax like the following.</p></li></ul><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Method declaration:</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">M</span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token class-name">Int32</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// Method invocation:</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token class-name">Int32</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">M</span><span class="token punctuation">(</span><span class="token named-parameter punctuation">x</span><span class="token punctuation">:</span> <span class="token keyword">ref</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>ğŸ’¡æ³¨æ„ï¼šå†™ C# ä»£ç å’Œ Microsoft Office çš„ COM å¯¹è±¡æ¨¡å‹è¿›è¡Œäº’æ“ä½œæ€§æ—¶ï¼ŒC# çš„å¯é€‰å‚æ•°å’Œå‘½åå‚æ•°åŠŸèƒ½éå¸¸å¥½ç”¨ã€‚å¦å¤–ï¼Œè°ƒç”¨ COM ç»„ä»¶æ—¶ï¼Œå¦‚æœæ˜¯ä»¥ä¼ å¼•ç”¨çš„æ–¹å¼ä¼ é€’å®å‚ï¼ŒC# è¿˜å…è®¸çœç•¥ <code>ref/out</code> ï¼Œè¿›ä¸€æ­¥ç®€åŒ–ç¼–ç ã€‚ä½†å¦‚æœè°ƒç”¨çš„ä¸æ˜¯ COM ç»„ä»¶ï¼ŒC# å°±è¦æ±‚å¿…é¡»å‘å®å‚åº”ç”¨ <code>ref/out</code> å…³é”®å­—ã€‚</p><h3 id="the-defaultparametervalue-and-optional-attributes"><a class="anchor" href="#the-defaultparametervalue-and-optional-attributes">#</a> The DefaultParameterValue and Optional Attributes</h3><blockquote><p>It would be best if this concept of default and optional arguments was not C#-specific. Specifically, we want programmers to define a method indicating which parameters are optional and what their default value should be in a programming language and then give programmers working in other programming languages the ability to call them. For this to work, the compiler of choice must allow the caller to omit some arguments and have a way of determining what those argumentsâ€™ default values should be.</p></blockquote><blockquote><p>In C#, when you give a parameter a default value, the compiler internally applies the System. <code>Runtime.InteropServices.OptionalAttribute</code> custom attribute to the parameter, and this attribute is persisted in the resulting fileâ€™s metadata. In addition, the compiler applies <code>System.Runtime.InteropServices.DefaultParameterValueAttribute</code> to the parameter and persists this attribute in the resulting fileâ€™s metadata. Then, <code>DefaultParameterValueAttribute</code> â€™s constructor is passed the constant value that you specified in your source code.</p></blockquote><blockquote><p>Now, when a compiler sees that you have code calling a method that is missing some arguments, the compiler can ensure that youâ€™ve omitted optional arguments, grab their default values out of metadata, and embed the values in the call for you automatically.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šè®¾è®¡æ–¹æ³•çš„å‚æ•°æ—¶ï¼Œå¯ä»¥ç»™éƒ¨åˆ†æˆ–å…¨éƒ¨å‚æ•°åˆ†é…é»˜è®¤å€¼ã€‚ç„¶åï¼Œè°ƒç”¨è¿™äº›æ–¹æ³•çš„ä»£ç å¯ä»¥é€‰æ‹©ä¸æä¾›éƒ¨åˆ†å®å‚ï¼Œä½¿ç”¨å…¶é»˜è®¤å€¼ã€‚æ­¤å¤–ï¼Œè°ƒç”¨æ–¹æ³•æ—¶å¯é€šè¿‡æŒ‡å®šå‚æ•°åç§°æ¥ä¼ é€’å®å‚ã€‚ä½¿ç”¨å‘½åå‚æ•°ä¼ é€’å®å‚æ—¶ï¼Œç¼–è¯‘å™¨ä»ç„¶æŒ‰ä»å·¦åˆ°å³çš„é¡ºåºå¯¹å®å‚è¿›è¡Œæ±‚å€¼ã€‚åœ¨æ–¹æ³•ä¸­ä¸ºéƒ¨åˆ†å‚æ•°æŒ‡å®šé»˜è®¤å€¼éœ€è¦æ³¨æ„ä¸€äº›è§„åˆ™å’ŒåŸåˆ™ã€‚å¯ä¸ºæ–¹æ³•ã€æ„é€ å™¨æ–¹æ³•å’Œæœ‰å‚å±æ€§ï¼ˆC# ç´¢å¼•å™¨ï¼‰çš„å‚æ•°æŒ‡å®šé»˜è®¤å€¼ã€‚è¿˜å¯ä¸ºå±äºå§”æ‰˜å®šä¹‰ä¸€éƒ¨åˆ†çš„å‚æ•°æŒ‡å®šé»˜è®¤å€¼ã€‚æœ‰é»˜è®¤å€¼çš„å‚æ•°å¿…é¡»æ”¾åœ¨æ²¡æœ‰é»˜è®¤å€¼çš„æ‰€æœ‰å‚æ•°ä¹‹åã€‚ä½†è¿™ä¸ªè§„åˆ™æœ‰ä¸€ä¸ªä¾‹å¤–ï¼šâ€œå‚æ•°æ•°ç»„â€ è¿™ç§å‚æ•°å¿…é¡»æ”¾åœ¨æ‰€æœ‰å‚æ•°ï¼ˆåŒ…æ‹¬æœ‰é»˜è®¤å€¼çš„è¿™äº›ï¼‰ä¹‹åï¼Œè€Œä¸”æ•°ç»„æœ¬èº«ä¸èƒ½æœ‰ä¸€ä¸ªé»˜è®¤å€¼ã€‚é»˜è®¤å€¼å¿…é¡»æ˜¯ç¼–è¯‘æ—¶èƒ½ç¡®å®šçš„å¸¸é‡å€¼ã€‚è¿™äº›å‚æ•°çš„ç±»å‹å¯ä»¥æ˜¯ C# è®¤å®šçš„åŸºå…ƒç±»å‹ã€æšä¸¾ç±»å‹ï¼Œä»¥åŠèƒ½è®¾ä¸º null çš„ä»»ä½•å¼•ç”¨ç±»å‹ã€‚å€¼ç±»å‹çš„å‚æ•°å¯å°†é»˜è®¤å€¼è®¾ä¸ºå€¼ç±»å‹çš„å®ä¾‹ï¼Œå¹¶è®©å®ƒçš„æ‰€æœ‰å­—æ®µéƒ½åŒ…å«é›¶å€¼ã€‚å¯ä»¥ç”¨ default å…³é”®å­—æˆ–è€… new å…³é”®å­—æ¥è¡¨è¾¾è¿™ä¸ªæ„æ€ï¼Œä¸¤ç§è¯­æ³•å°†ç”Ÿæˆå®Œå…¨ä¸€è‡´çš„ IL ä»£ç ã€‚ä¸è¦é‡å‘½åå‚æ•°å˜é‡ï¼Œå¦åˆ™ä»»ä½•è°ƒç”¨è€…ä»¥ä¼ å‚æ•°åçš„æ–¹å¼ä¼ é€’å®å‚ï¼Œå®ƒä»¬çš„ä»£ç ä¹Ÿå¿…é¡»ä¿®æ”¹ã€‚å¯è€ƒè™‘å°†é»˜è®¤å€¼ 0/null ä½œä¸ºå“¨å…µå€¼ä½¿ç”¨ï¼Œä»è€ŒæŒ‡å‡ºé»˜è®¤è¡Œä¸ºã€‚è¿™æ ·ä¸€æ¥ï¼Œå³ä½¿æ›´æ”¹äº†é»˜è®¤å€¼ï¼Œä¹Ÿä¸å¿…é‡æ–°ç¼–è¯‘åŒ…å«äº† call siteï¼ˆå‘å‡ºè°ƒç”¨çš„åœ°æ–¹ï¼Œå¯ç†è§£æˆè°ƒç”¨äº†ä¸€ä¸ªç›®æ ‡æ–¹æ³•çš„è¡¨è¾¾å¼æˆ–ä»£ç è¡Œï¼Œcall site åœ¨å®ƒçš„è°ƒç”¨ä¸­åµŒå…¥é»˜è®¤å€¼ï¼‰çš„å…¨éƒ¨ä»£ç ã€‚å¦‚æœå‚æ•°ç”¨ ref æˆ– out å…³é”®å­—è¿›è¡Œäº†æ ‡è¯†ï¼Œå°±ä¸èƒ½è®¾ç½®é»˜è®¤å€¼ã€‚å› ä¸ºæ²¡æœ‰åŠæ³•ä¸ºè¿™äº›å‚æ•°ä¼ é€’æœ‰æ„ä¹‰çš„é»˜è®¤å€¼ã€‚å¯¹äºå¯é€‰æˆ–å‘½åå‚æ•°è°ƒç”¨æ¥è¯´ï¼Œå®å‚å¯æŒ‰ä»»æ„é¡ºåºä¼ é€’ï¼Œä½†å‘½åå®å‚åªèƒ½å‡ºç°åœ¨å®å‚åˆ—è¡¨çš„å°¾éƒ¨ã€‚åœ¨ C# ä¸­ï¼Œä¸€æ—¦ä¸ºå‚æ•°åˆ†é…äº†é»˜è®¤å€¼ï¼Œç¼–è¯‘å™¨å°±ä¼šåœ¨å†…éƒ¨å‘è¯¥å‚æ•°åº”ç”¨å®šåˆ¶ç‰¹æ€§ <code>System.Runtime.InteropServices.OptionalAttribute</code> ã€‚è¯¥ç‰¹æ€§ä¼šåœ¨æœ€ç»ˆç”Ÿæˆçš„æ–‡ä»¶çš„å…ƒæ•°æ®ä¸­æŒä¹…æ€§åœ°å‚¨å­˜ä¸‹æ¥ã€‚ç„¶åï¼Œä¼šå‘ <code>DefaultParameterValueAttribute</code> çš„æ„é€ å™¨ä¼ é€’ä½ åœ¨æºä»£ç ä¸­æŒ‡å®šçš„å¸¸é‡å€¼ã€‚ä¹‹åï¼Œä¸€æ—¦ç¼–è¯‘å™¨å‘ç°æŸä¸ªæ–¹æ³•è°ƒç”¨ç¡®å®äº†éƒ¨åˆ†å®å‚ï¼Œå°±å¯ä»¥ç¡®å®šçœç•¥çš„æ˜¯å¯é€‰çš„å®å‚ï¼Œå¹¶ä»å…ƒæ•°æ®ä¸­æå–é»˜è®¤å€¼ï¼Œå°†å€¼è‡ªåŠ¨åµŒå…¥è°ƒç”¨ä¸­ã€‚</p><h2 id="implicitly-typed-local-variables"><a class="anchor" href="#implicitly-typed-local-variables">#</a> Implicitly Typed Local Variables</h2><blockquote><p>C# supports the ability to infer the type of a methodâ€™s local variable from the type of expression that is used to initialize it. The following shows some sample code demonstrating the use of this feature.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ImplicitlyTypedLocalVariables</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> name <span class="token operator">=</span> <span class="token string">"Jeff"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token function">ShowVariableType</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays: System.String</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// var n = null; // Error: Cannot assign &lt;null> to an implicitly-typed local </span></pre></td></tr><tr><td data-num="5"></td><td><pre>variable</pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> x <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span><span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// OK, but not much value</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token function">ShowVariableType</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays: System.String</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> numbers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Int32<span class="token punctuation">[</span><span class="token punctuation">]</span></span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token function">ShowVariableType</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays: System.Int32[]</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// Less typing for complex types</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> collection <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Dictionary<span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> Single<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#123;</span> <span class="token string">"Grant"</span><span class="token punctuation">,</span> <span class="token number">4.0f</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// Displays: System.Collections.Generic.Dictionary`2[System.String,System.Single]</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token function">ShowVariableType</span><span class="token punctuation">(</span>collection<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> item <span class="token keyword">in</span> collection<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// Displays: System.Collections.Generic.KeyValuePair`2[System.String,System.Single]</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token function">ShowVariableType</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">ShowVariableType</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">T</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The first line of code inside the ImplicitlyTypedLocalVariables method is introducing a new local variable by using the C# var token. To determine the type of the name variable, the compiler looks at the type of the expression on the right side of the assignment operator (=). Because &quot;Jeff&quot; is a string, the compiler infers that nameâ€™s type must be String. To prove that the compiler is inferring the type correctly, I wrote the ShowVariableType method. This generic method infers the type of its argument, and then it shows the type that it inferred on the console. I added what ShowVariableType displayed as comments inside the ImplicitlyTypedLocalVariables method for easy reading.</p></blockquote><blockquote><p>The second assignment (commented out) inside the ImplicitlyTypedLocalVariables method would produce a compiler error (error CS0815: Cannot assign to an implicitlytyped local variable) because null is implicitly castable to any reference type or nullable value type; therefore, the compiler cannot infer a distinct type for it. However, on the third assignment, I show that it is possible to initialize an implicitly typed local variable with null if you explicitly specify a type (String, in my example). Although this is possible, it is not that useful because you could also write String x = null; to get the same result.</p></blockquote><blockquote><p>In the fourth assignment, you see some real value of using C#â€™s implicitly typed local variable feature. Without this feature, youâ€™d have to specify Dictionary on both sides of the assignment operator. Not only is this a lot of typing, but if you ever decide to change the collection type or any of the generic parameter types, then you would have to modify your code on both sides of the assignment operator, too.</p></blockquote><blockquote><p>In the foreach loop, I also use var to have the compiler automatically infer the type of the elements inside the collection. This demonstrates that it is possible and quite useful to use var with foreach, using, and for statements. It can also be useful when experimenting with code. For example, you initialize an implicitly typed local variable from the return type of a method, and as you develop your method, you might decide to change its return type. If you do this, the compiler will automatically figure out that the return type has changed and automatically change the type of the variable! This is great, but of course, other code in the method that uses that variable may no longer compile if the code accesses members by using the variable assuming that it was the old type.</p></blockquote><blockquote><p>In Microsoft Visual Studio, you can hold the mouse cursor over var in your source code and the editor will display a tooltip showing you the type that the compiler infers from the expression. C#â€™s implicitly typed local variable feature must be used when working with anonymous types within a method; see Chapter 10, â€œProperties,â€ for more details.</p></blockquote><blockquote><p>You cannot declare a methodâ€™s parameter type by using var. The reason for this should be obvious to you because the compiler would have to infer the parameterâ€™s type from the argument being passed at a callsite and there could be no call sites or many call sites. In addition, you cannot declare a typeâ€™s field by using var. There are many reasons why C# has this restriction. One reason is that fields can be accessed by several methods and the C# team feels that this contract (the type of the variable) should be stated explicitly. Another reason is that allowing this would permit an anonymous type (discussed in Chapter 10) to leak outside of a single method.</p></blockquote><p>ğŸ’¡é‡è¦æç¤ºï¼šä¸è¦æ··æ·† <code>dynamic</code> å’Œ <code>var</code> ã€‚ç”¨ <code>var</code> å£°æ˜å±€éƒ¨å˜é‡åªæœ‰ä¸€ç§ç®€åŒ–è¯­æ³•ï¼Œå®ƒè¦æ±‚ç¼–è¯‘å™¨æ ¹æ®è¡¨è¾¾å¼æ¨æ–­å…·ä½“æ•°æ®ç±»å‹ã€‚ <code>var</code> å…³é”®å­—åªèƒ½å£°æ˜æ–¹æ³•å†…éƒ¨çš„å±€éƒ¨å˜é‡ï¼Œè€Œ <code>dynamic</code> å…³é”®å­—é€‚ç”¨äºå±€éƒ¨å˜é‡ã€å­—æ®µå’Œå‚æ•°ã€‚è¡¨è¾¾å¼ä¸èƒ½è½¬å‹ä¸º <code>var</code> ï¼Œä½†èƒ½è½¬å‹ä¸º <code>dynamic</code> ã€‚å¿…é¡»æ˜¾å¼åˆå§‹åŒ–ç”¨ <code>var</code> å£°æ˜çš„å˜é‡ï¼Œä½†æ— éœ€åˆå§‹åŒ–ç”¨ <code>dynamic</code> å£°æ˜çš„å˜é‡ã€‚æ¬²çŸ¥ C# <code>dynamic</code> ç±»å‹çš„è¯¦æƒ…ï¼Œè¯·å‚è§ 5.5 èŠ‚ â€œ <code>dynamic</code> åŸºå…ƒç±»å‹ &quot;ã€‚</p><p>ğŸ’¡å°ç»“ï¼šC# ä¸èƒ½å°† null èµ‹ç»™éšå¼ç±»å‹ï¼ˆvar ç±»å‹ï¼‰çš„å±€éƒ¨å˜é‡ã€‚è¿™æ˜¯ç”±äº null èƒ½éšå¼è½¬å‹ä¸ºä»»ä½•å¼•ç”¨ç±»å‹æˆ–å¯ç©ºå€¼ç±»å‹ã€‚å› æ­¤ï¼Œç¼–è¯‘å™¨ä¸èƒ½æ¨æ–­å®ƒçš„ç¡®åˆ‡ç±»å‹ï¼Œé™¤éå°† null å¼ºè½¬ä¸ºå…·ä½“ç±»å‹ï¼Œä¸è¿‡è¿™æ ·åšä¹Ÿæ„ä¹‰ä¸å¤§ã€‚åœ¨ VS ä¸­ï¼Œé¼ æ ‡æ”¾åˆ° var ä¸Šå°†æ˜¾ç¤ºä¸€æ¡ â€œå·¥å…·æç¤ºâ€ï¼ŒæŒ‡å‡ºç¼–è¯‘å™¨æ ¹æ®è¡¨è¾¾å¼æ¨æ–­å‡ºæ¥çš„ç±»å‹ã€‚åœ¨æ–¹æ³•ä¸­ä½¿ç”¨åŒ¿åç±»å‹æ—¶å¿…é¡»ç”¨åˆ° C# çš„éšå¼ç±»å‹å±€éƒ¨å˜é‡ï¼Œè¿™ä¼šåœ¨ â€œå±æ€§â€ ç« èŠ‚è®²è§£ã€‚ä¸èƒ½ç”¨ var å£°æ˜æ–¹æ³•çš„å‚æ•°ç±»å‹ã€‚åŸå› æ˜¾è€Œæ˜“è§ï¼Œå› ä¸ºç¼–è¯‘å™¨å¿…é¡»æ ¹æ®åœ¨ call site ä¼ é€’çš„å®å‚æ¥æ¨æ–­å‚æ•°ç±»å‹ï¼Œä½† call site å¯èƒ½ä¸€ä¸ªéƒ½æ²¡æœ‰ï¼Œä¹Ÿå¯èƒ½æœ‰å¥½å¤šä¸ªã€‚ï¼ˆè¦ä¹ˆä¸€ä¸ªç±»å‹éƒ½æ¨æ–­ä¸å‡ºæ¥ï¼Œè¦ä¹ˆå¤šä¸ªæ¨æ–­å‘ç”Ÿå†²çªã€‚ï¼‰é™¤æ­¤ä¹‹å¤–ï¼Œä¸èƒ½ç”¨ var å£°æ˜ç±»å‹ä¸­çš„å­—æ®µã€‚</p><h2 id="passing-parameters-by-reference-to-a-method"><a class="anchor" href="#passing-parameters-by-reference-to-a-method">#</a> Passing Parameters by Reference to a Method</h2><blockquote><p>By default, the common language runtime (CLR) assumes that all method parameters are passed by value. When reference type objects are passed, the reference (or pointer) to the object is passed (by value) to the method. This means that the method can modify the object and the caller will see the change. For value type instances, a copy of the instance is passed to the method. This means that the method gets its own private copy of the value type and the instance in the caller isnâ€™t affected.</p></blockquote><p>ğŸ’¡é‡è¦æç¤ºï¼šåœ¨æ–¹æ³•ä¸­ï¼Œå¿…é¡»çŸ¥é“ä¼ é€’çš„æ¯ä¸ªå‚æ•°æ˜¯å¼•ç”¨ç±»å‹è¿˜æ˜¯å€¼ç±»å‹ï¼Œå¤„ç†å‚æ•°çš„ä»£ç æ˜¾è‘—æœ‰åˆ«ã€‚</p><blockquote><p>The CLR allows you to pass parameters by reference instead of by value. In C#, you do this by using the out and ref keywords. Both keywords tell the C# compiler to emit metadata indicating that this designated parameter is passed by reference, and the compiler uses this to generate code to pass the address of the parameter rather than the parameter itself.</p></blockquote><blockquote><p>From the CLRâ€™s perspective, out and ref are identicalâ€”that is, the same IL is produced regardless of which keyword you use, and the metadata is also identical except for 1 bit, which is used to record whether you specified out or ref when declaring the method. However, the C# compiler treats the two keywords differently, and the difference has to do with which method is responsible for initializing the object being referred to. If a methodâ€™s parameter is marked with out, the caller isnâ€™t expected to have initialized the object prior to calling the method. The called method canâ€™t read from the value, and the called method must write to the value before returning. If a methodâ€™s parameter is marked with ref, the caller must initialize the parameterâ€™s value prior to calling the method. The called method can read from the value and/or write to the value.</p></blockquote><blockquote><p>Reference and value types behave very differently with out and ref. Letâ€™s look at using out and ref with value types first.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Int32</span> x<span class="token punctuation">;</span> <span class="token comment">// x is uninitialized. </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token function">GetVal</span><span class="token punctuation">(</span><span class="token keyword">out</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// x doesnâ€™t have to be initialized. </span></pre></td></tr><tr><td data-num="5"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "10" </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">GetVal</span><span class="token punctuation">(</span><span class="token keyword">out</span> <span class="token class-name">Int32</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> v <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// This method must initialize v. </span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In this code, x is declared in Mainâ€™s stack frame. The address of x is then passed to GetVal. GetValâ€™s v is a pointer to the Int32 value in Mainâ€™s stack frame. Inside GetVal, the Int32 that v points to is changed to 10. When GetVal returns, Mainâ€™s x has a value of 10, and 10 is displayed on the console. Using out with large value types is efficient because it prevents instances of the value typeâ€™s fields from being copied when making method calls.</p></blockquote><blockquote><p>Now letâ€™s look at an example that uses ref instead of out.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// x is initialized. </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token function">AddVal</span><span class="token punctuation">(</span><span class="token keyword">ref</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// x must be initialized. </span></pre></td></tr><tr><td data-num="5"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "15" </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">AddVal</span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token class-name">Int32</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> v <span class="token operator">+=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// This method can use the initialized value in v. </span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In this code, x is also declared in Mainâ€™s stack frame and is initialized to 5. The address of x is then passed to AddVal. AddValâ€™s v is a pointer to the Int32 value in Mainâ€™s stack frame. Inside AddVal, the Int32 that v points to is required to have a value already. So, AddVal can use the initial value in any expression it desires. AddVal can also change the value, and the new value will be â€œreturnedâ€ to the caller. In this example, AddVal adds 10 to the initial value. When AddVal returns, Mainâ€™s x will contain 15, which is what gets displayed in the console.</p></blockquote><blockquote><p>To summarize, from an IL or a CLR perspective, out and ref do exactly the same thing: they both cause a pointer to the instance to be passed. The difference is that the compiler helps ensure that your code is correct. The following code that attempts to pass an uninitialized value to a method expecting a ref parameter produces the following message: error CS0165: Use of unassigned local variable 'x'.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Int32</span> x<span class="token punctuation">;</span> <span class="token comment">// x is not initialized. </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// The following line fails to compile, producing </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// error CS0165: Use of unassigned local variable 'x'. </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token function">AddVal</span><span class="token punctuation">(</span><span class="token keyword">ref</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">AddVal</span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token class-name">Int32</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> v <span class="token operator">+=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// This method can use the initialized value in v. </span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>ğŸ’¡é‡è¦æç¤ºï¼šç»å¸¸æœ‰äººé—®æˆ‘ï¼Œä¸ºä»€ä¹ˆ C# è¦æ±‚å¿…é¡»åœ¨è°ƒç”¨æ–¹æ³•æ—¶æŒ‡å®š <code>out</code> æˆ– <code>ref</code> ï¼Ÿæ¯•ç«Ÿï¼Œç¼–è¯‘å™¨çŸ¥é“è¢«è°ƒç”¨çš„æ–¹æ³•éœ€è¦çš„æ˜¯ <code>out</code> è¿˜æ˜¯ <code>ref</code> ï¼Œæ‰€ä»¥åº”è¯¥èƒ½æ­£ç¡®ç¼–è¯‘ä»£ç ã€‚äº‹å®ä¸Šï¼ŒC# ç¼–è¯‘å™¨ç¡®å®èƒ½è‡ªåŠ¨é‡‡ç”¨æ­£ç¡®çš„æ“ä½œã€‚ä½† C# è¯­è¨€çš„è®¾è®¡è€…è®¤ä¸ºè°ƒç”¨è€…çš„æ–¹æ³•æ˜¯å¦éœ€è¦å¯¹ä¼ é€’çš„å˜é‡å€¼è¿›è¡Œæ›´æ”¹ã€‚</p><p>å¦å¤–ï¼ŒCLR å…è®¸æ ¹æ®ä½¿ç”¨çš„æ˜¯ <code>out</code> è¿˜æ˜¯ <code>ref</code> å‚æ•°å¯¹æ–¹æ³•è¿›è¡Œé‡è½½ã€‚ä¾‹å¦‚ï¼Œåœ¨ C# ä¸­ï¼Œä»¥ä¸‹ä»£ç æ˜¯åˆæ³•çš„ï¼Œå¯ä»¥é€šè¿‡ç¼–è¯‘ï¼š</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token class-name">Point</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token class-name">Point</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>ä¸¤ä¸ªé‡è½½æ–¹æ³•åªæœ‰ <code>out</code> è¿˜æ˜¯ <code>ref</code> çš„åŒºåˆ«åˆ™ä¸åˆæ³•ï¼Œå› ä¸ºä¸¤ä¸ªç­¾åçš„å…ƒæ•°æ®å½¢å¼å®Œå…¨ç›¸åŒã€‚æ‰€ä»¥ï¼Œä¸èƒ½åœ¨ä¸Šè¿° <code>Point</code> ç±»å‹ä¸­å†å®šä¹‰ä»¥ä¸‹æ–¹æ³•ï¼š</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">out</span> <span class="token class-name">Point</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>è¯•å›¾åœ¨ <code>Point</code> ç±»å‹ä¸­æ·»åŠ è¿™ä¸ª <code>Add</code> æ–¹æ³•ï¼ŒC# ç¼–è¯‘å™¨ä¼šæ˜¾ç¤ºä»¥ä¸‹æ¶ˆæ¯ï¼š <code>CS0663:&quot;Add&quot; ä¸èƒ½å®šä¹‰ä»…åœ¨refå’Œoutä¸Šæœ‰å·®åˆ«çš„é‡è½½æ–¹æ³•</code> ã€‚</p><blockquote><p>Using out and ref with value types gives you the same behavior that you already get when passing reference types by value. With value types, out and ref allow a method to manipulate a single value type instance. The caller must allocate the memory for the instance, and the callee manipulates that memory. With reference types, the caller allocates memory for a pointer to a reference object, and the callee manipulates this pointer. Because of this behavior, using out and ref with reference types is useful only when the method is going to â€œreturnâ€ a reference to an object that it knows about. The following code demonstrates.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>IO</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token class-name">FileStream</span> fs<span class="token punctuation">;</span> <span class="token comment">// fs is uninitialized </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Open the first file to be processed. </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token function">StartProcessingFiles</span><span class="token punctuation">(</span><span class="token keyword">out</span> fs<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Continue while there are more files to process. </span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> fs <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token function">ContinueProcessingFiles</span><span class="token punctuation">(</span><span class="token keyword">ref</span> fs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// Process a file. </span></pre></td></tr><tr><td data-num="11"></td><td><pre> fs<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span><span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">StartProcessingFiles</span><span class="token punctuation">(</span><span class="token keyword">out</span> <span class="token class-name">FileStream</span> fs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> fs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">FileStream</span><span class="token punctuation">(</span><span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// fs must be initialized in this method </span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ContinueProcessingFiles</span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token class-name">FileStream</span> fs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="18"></td><td><pre> fs<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Close the last file worked on. </span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token comment">// Open the next file, or if no more files, "return" null. </span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>noMoreFilesToProcess<span class="token punctuation">)</span> fs <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token keyword">else</span> fs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">FileStream</span> <span class="token punctuation">(</span><span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>As you can see, the big difference with this code is that the methods that have out or ref reference type parameters are constructing an object, and the pointer to the new object is returned to the caller. Youâ€™ll also notice that the ContinueProcessingFiles method can manipulate the object being passed into it before returning a new object. This is possible because the parameter is marked with the ref keyword. You can simplify the preceding code a bit, as shown here.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>IO</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token class-name">FileStream</span> fs <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// Initialized to null (required) </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Open the first file to be processed. </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token function">ProcessFiles</span><span class="token punctuation">(</span><span class="token keyword">ref</span> fs<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Continue while there are more files to process. </span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> fs <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token function">ProcessFiles</span><span class="token punctuation">(</span><span class="token keyword">ref</span> fs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// Process a file. </span></pre></td></tr><tr><td data-num="11"></td><td><pre> fs<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span><span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ProcessFiles</span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token class-name">FileStream</span> fs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// Close the previous file if one was open. </span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>fs <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> fs<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Close the last file worked on. </span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token comment">// Open the next file, or if no more files, "return" null. </span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>noMoreFilesToProcess<span class="token punctuation">)</span> fs <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token keyword">else</span> fs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">FileStream</span> <span class="token punctuation">(</span><span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Hereâ€™s another example that demonstrates how to use the ref keyword to implement a method<br>that swaps two reference types.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token class-name">Object</span> a<span class="token punctuation">,</span> <span class="token keyword">ref</span> <span class="token class-name">Object</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Object</span> t <span class="token operator">=</span> b<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> b <span class="token operator">=</span> a<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> a <span class="token operator">=</span> t<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>To swap references to two String objects, youâ€™d probably think that you could write code like the following.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SomeMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token string">"Jeffrey"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token string">"Richter"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">ref</span> s1<span class="token punctuation">,</span> <span class="token keyword">ref</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "Richter" </span></pre></td></tr><tr><td data-num="7"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "Jeffrey" </span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>However, this code wonâ€™t compile. The problem is that variables passed by reference to a method must be of the same type as declared in the method signature. In other words, Swap expects two Object references, not two String references. To swap the two String references, you must do the following.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SomeMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token string">"Jeffrey"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token string">"Richter"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// Variables that are passed by reference </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// must match what the method expects. </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token class-name">Object</span> o1 <span class="token operator">=</span> s1<span class="token punctuation">,</span> o2 <span class="token operator">=</span> s2<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">ref</span> o1<span class="token punctuation">,</span> <span class="token keyword">ref</span> o2<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// Now cast the objects back to strings. </span></pre></td></tr><tr><td data-num="10"></td><td><pre> s1 <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> o1<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> s2 <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> o2<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> </pre></td></tr><tr><td data-num="13"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "Richter" </span></pre></td></tr><tr><td data-num="14"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "Jeffrey" </span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>This version of SomeMethod does compile and execute as expected. The reason why the parameters passed must match the parameters expected by the method is to ensure that type safety is preserved. The following code, which thankfully wonâ€™t compile, shows how type safety could be compromised.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name">Int32</span> m_val<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token class-name">SomeType</span> st<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// The following line generates error CS1503: Argument '1': </span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// cannot convert from 'ref SomeType' to 'ref object'. </span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token function">GetAnObject</span><span class="token punctuation">(</span><span class="token keyword">out</span> st<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span>m_val<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">GetAnObject</span><span class="token punctuation">(</span><span class="token keyword">out</span> <span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">String</span><span class="token punctuation">(</span><span class="token char">'X'</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In this code, Main clearly expects GetAnObject to return a SomeType object. However, because GetAnObjectâ€™s signature indicates a reference to an Object, GetAnObject is free to initialize o to an object of any type. In this example, when GetAnObject returned to Main, st would refer to a String, which is clearly not a SomeType object, and the call to Console.WriteLine would certainly fail. Fortunately, the C# compiler wonâ€™t compile the preceding code because st is a reference to SomeType, but GetAnObject requires a reference to an Object.</p></blockquote><blockquote><p>You can use generics to fix these methods so that they work as youâ€™d expect. Here is how to fix the Swap method shown earlier.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">Swap</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token class-name">T</span> a<span class="token punctuation">,</span> <span class="token keyword">ref</span> <span class="token class-name">T</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">T</span> t <span class="token operator">=</span> b<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> b <span class="token operator">=</span> a<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> a <span class="token operator">=</span> t<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>And now, with Swap rewritten as above, the following code (identical to that shown before) will compile and run perfectly.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SomeMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token string">"Jeffrey"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token string">"Richter"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">ref</span> s1<span class="token punctuation">,</span> <span class="token keyword">ref</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "Richter" </span></pre></td></tr><tr><td data-num="6"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "Jeffrey" </span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>For some other examples that use generics to solve this problem, see System.Threadingâ€™s Interlocked class with its CompareExchange and Exchange methods.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šCLR é»˜è®¤æ‰€æœ‰æ–¹æ³•å‚æ•°éƒ½ä¼ å€¼ã€‚ä¼ é€’å¼•ç”¨ç±»å‹çš„å¯¹è±¡æ—¶ï¼Œå¯¹è±¡å¼•ç”¨ï¼ˆæˆ–è€…è¯´æŒ‡å‘å¯¹è±¡çš„æŒ‡é’ˆï¼‰è¢«ä¼ ç»™æ–¹æ³•ã€‚æ³¨æ„å¼•ç”¨ï¼ˆæˆ–æŒ‡é’ˆï¼‰æœ¬èº«æ˜¯ä¼ å€¼çš„ï¼Œæ„å‘³ç€æ–¹æ³•èƒ½ä¿®æ”¹å¯¹è±¡ï¼Œè€Œè°ƒç”¨è€…èƒ½çœ‹åˆ°è¿™äº›ä¿®æ”¹ã€‚å¯¹äºå€¼ç±»å‹çš„å®ä¾‹ï¼Œä¼ ç»™æ–¹æ³•çš„æ˜¯å®ä¾‹çš„ä¸€ä¸ªå‰¯æœ¬ï¼Œæ„å‘³ç€æ–¹æ³•å°†è·å¾—å®ƒä¸“ç”¨çš„ä¸€ä¸ªå€¼ç±»å‹å®ä¾‹å‰¯æœ¬ï¼Œè°ƒç”¨è€…ä¸­çš„å®ä¾‹ä¸å—å½±å“ã€‚CLR å…è®¸ä»¥ä¼ å¼•ç”¨è€Œéä¼ å€¼çš„æ–¹å¼ä¼ é€’å‚æ•°ã€‚C# ç”¨å…³é”®å­— out æˆ– ref æ”¯æŒè¿™ä¸ªåŠŸèƒ½ã€‚ä¸¤ä¸ªå…³é”®å­—éƒ½å‘Šè¯‰ C# ç¼–è¯‘å™¨ç”Ÿæˆå…ƒæ•°æ®æ¥æŒ‡æ˜æ”¹å‚æ•°æ˜¯ä¼ å¼•ç”¨çš„ã€‚CLR ä¸åŒºåˆ† out å’Œ refï¼Œæ„å‘³ç€æ— è®ºç”¨å“ªä¸ªå…³é”®å­—ï¼Œéƒ½ä¼šç”Ÿæˆç›¸åŒçš„ IL ä»£ç ã€‚å¦å¤–ï¼Œå…ƒæ•°æ®ä¹Ÿå‡ ä¹å®Œå…¨ä¸€è‡´ï¼Œåªæœ‰ä¸€ä¸ª bit é™¤å¤–ï¼Œå®ƒç”¨äºè®°å½•å£°æ˜æ–¹æ³•æ—¶æŒ‡å®šçš„æ˜¯ out è¿˜æ˜¯ refã€‚ä½†æ˜¯ C# ç¼–è¯‘å™¨æ˜¯åŒºåˆ«è¿™ä¸¤ä¸ªå…³é”®å­—çš„ã€‚å¦‚æœæ–¹æ³•çš„å‚æ•°ç”¨ out æ ‡è®°ï¼Œè¡¨ç¤ºä¸æŒ‡æœ›è°ƒç”¨è€…åœ¨è°ƒç”¨æ–¹æ³•ä¹‹å‰åˆå§‹åŒ–å¥½äº†å¯¹è±¡ã€‚è¢«è°ƒç”¨çš„æ–¹æ³•ä¸èƒ½è¯»å–å‚æ•°çš„å€¼ï¼Œè€Œä¸”åœ¨è¿”å›å‰å¿…é¡»å‘è¿™ä¸ªå€¼å†™å…¥ã€‚ç›¸åï¼Œå¦‚æœæ–¹æ³•çš„å‚æ•°ç”¨ ref æ¥æ ‡è®°ï¼Œè°ƒç”¨è€…å°±å¿…é¡»åœ¨è°ƒç”¨è¯¥æ–¹æ³•å‰åˆå§‹åŒ–å‚æ•°çš„å€¼ï¼Œè¢«è°ƒç”¨çš„æ–¹æ³•å¯ä»¥è¯»å–å€¼ä»¥åŠ / æˆ–è€…å‘å€¼å†™å…¥ã€‚å¯¹äºä»¥ä¼ å¼•ç”¨çš„æ–¹å¼ä¼ ç»™æ–¹æ³•çš„å˜é‡ï¼Œå®ƒçš„ç±»å‹å¿…é¡»ä¸æ–¹æ³•ç­¾åä¸­å£°æ˜çš„ç±»å‹ç›¸åŒï¼Œè¿™æ˜¯ç”±äºæˆ‘ä»¬æ— æ³•é¢„æµ‹æ–¹æ³•å†…éƒ¨æ˜¯å¦ä¼šè¿›è¡Œä¸æ°å½“çš„è½¬å‹å¼•èµ·ç¼–è¯‘é”™è¯¯ã€‚</p><h2 id="passing-a-variable-number-of-arguments-to-a-method"><a class="anchor" href="#passing-a-variable-number-of-arguments-to-a-method">#</a> Passing a Variable Number of Arguments to a Method</h2><blockquote><p>Itâ€™s sometimes convenient for the developer to define a method that can accept a variable number of arguments. For example, the System.String type offers methods allowing an arbitrary number of strings to be concatenated together and methods allowing the caller to specify a set of strings that are to be formatted together.</p></blockquote><blockquote><p>To declare a method that accepts a variable number of arguments, you declare the method as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">params</span> <span class="token class-name">Int32<span class="token punctuation">[</span><span class="token punctuation">]</span></span> values<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// NOTE: it is possible to pass the 'values' </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// array to other methods if you want to. </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">Int32</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>values <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> values<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> sum <span class="token operator">+=</span> values<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">return</span> sum<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Everything in this method should look very familiar to you except for the params keyword that is applied to the last parameter of the method signature. Ignoring the params keyword for the moment, itâ€™s obvious that this method accepts an array of Int32 values and iterates over the array, adding up all of the values. The resulting sum is returned to the caller.</p></blockquote><blockquote><p>Obviously, code can call this method as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Displays "15" </span></pre></td></tr><tr><td data-num="3"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">Int32<span class="token punctuation">[</span><span class="token punctuation">]</span></span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Itâ€™s clear that the array can easily be initialized with an arbitrary number of elements and then passed off to Add for processing. Although the preceding code would compile and work correctly, it is a little ugly. As developers, we would certainly prefer to have written the call to Add as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Displays "15" </span></pre></td></tr><tr><td data-num="3"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Youâ€™ll be happy to know that we can do this because of the params keyword. The params keyword tells the compiler to apply an instance of the System.ParamArrayAttribute custom attribute to the parameter.</p></blockquote><blockquote><p>When the C# compiler detects a call to a method, the compiler checks all of the methods with the specified name, where no parameter has the ParamArray attribute applied. If a method exists that can accept the call, the compiler generates the code necessary to call the method. However, if the compiler canâ€™t find a match, it looks for methods that have a ParamArray attribute to see whether the call can be satisfied. If the compiler finds a match, it emits code that constructs an array and populates its elements before emitting the code that calls the selected method.</p></blockquote><blockquote><p>In the previous example, no Add method is defined that takes five Int32-compatible arguments; however, the compiler sees that the source code has a call to Add that is being passed a list of Int32 values and that there is an Add method whose array-of-Int32 parameter is marked with the ParamArray attribute. So the compiler considers this a match and generates code that coerces the parameters into an Int32 array and then calls the Add method. The end result is that you can write the code, easily passing a bunch of parameters to Add, but the compiler generates code as though youâ€™d written the first version that explicitly constructs and initializes the array.</p></blockquote><blockquote><p>Only the last parameter to a method can be marked with the params keyword (ParamArrayAttribute). This parameter must also identify a single-dimension array of any type. Itâ€™s legal to pass null or a reference to an array of 0 entries as the last parameter to the method. The following call to Add compiles fine, runs fine, and produces a resulting sum of 0 (as expected).</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Both of these lines display "0" </span></pre></td></tr><tr><td data-num="3"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// passes new Int32[0] to Add</span></pre></td></tr><tr><td data-num="4"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// passes null to Add: more efficient (no array allocated)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>So far, all of the examples have shown how to write a method that takes an arbitrary number of Int32 parameters. How would you write a method that takes an arbitrary number of parameters where the parameters could be any type? The answer is very simple: just modify the methodâ€™s prototype so that it takes an Object[] instead of an Int32[]. Hereâ€™s a method that displays the Type of every object passed to it.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token function">DisplayTypes</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Jeff"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">DisplayTypes</span><span class="token punctuation">(</span><span class="token keyword">params</span> <span class="token class-name">Object<span class="token punctuation">[</span><span class="token punctuation">]</span></span> objects<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>objects <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name">Object</span> o <span class="token keyword">in</span> objects<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Running this code yields the following output.</p></blockquote><pre><code>System.Object
System.Random
System.String
System.Int32
</code></pre><p>ğŸ’¡é‡è¦æç¤ºï¼šæ³¨æ„ï¼Œè°ƒç”¨å‚æ•°æ•°é‡å¯å˜çš„æ–¹æ³•å¯¹æ€§èƒ½æœ‰æ‰€å½±å“ (é™¤éæ˜¾å¼ä¼ é€’ <code>null</code> )ã€‚æ¯•ç«Ÿï¼Œæ•°ç»„å¯¹è±¡å¿…é¡»åœ¨å †ä¸Šåˆ†é…ï¼Œæ•°ç»„å…ƒç´ å¿…é¡»åˆå§‹åŒ–ï¼Œè€Œä¸”æ•°ç»„çš„å†…å­˜æœ€ç»ˆéœ€è¦åƒåœ¾å›æ”¶ã€‚è¦å‡å°‘å¯¹æ€§èƒ½çš„å½±å“ï¼Œå¯è€ƒè™‘å®šä¹‰å‡ ä¸ªæ²¡æœ‰ä½¿ç”¨ <code>params</code> å…³é”®å­—çš„é‡è½½ç‰ˆæœ¬ã€‚å…³äºè¿™æ–¹é¢çš„èŒƒä¾‹ï¼Œè¯·å‚è€ƒ <code>System.String</code> ç±»çš„ <code>Concat</code> æ–¹æ³•ï¼Œè¯¥æ–¹æ³•å®šä¹‰äº†ä»¥ä¸‹é‡è½½ç‰ˆæœ¬ï¼š</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">String</span> <span class="token punctuation">:</span> Object<span class="token punctuation">,</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> <span class="token function">Concat</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span></span> arg0<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> <span class="token function">Concat</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span></span> arg0<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">object</span></span> arg1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> <span class="token function">Concat</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span></span> arg0<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">object</span></span> arg1<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">object</span></span> arg2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> <span class="token function">Concat</span><span class="token punctuation">(</span><span class="token keyword">params</span> <span class="token class-name"><span class="token keyword">object</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> <span class="token function">Concat</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> str0<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span></span> str1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> <span class="token function">Concat</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> str0<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span></span> str1<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span></span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> <span class="token function">Concat</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> str0<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span></span> str1<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span></span> str2<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span></span> str3<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> <span class="token function">Concat</span><span class="token punctuation">(</span><span class="token keyword">params</span> <span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> values<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>å¦‚ä½ æ‰€è§ï¼Œ <code>Concat</code> æ–¹æ³•å®šä¹‰äº†å‡ ä¸ªæ²¡æœ‰ä½¿ç”¨ <code>params</code> å…³é”®å­—çš„é‡è½½ç‰ˆæœ¬ã€‚è¿™æ˜¯ä¸ºäº†æ”¹å–„å¸¸è§„æƒ…å½¢ä¸‹çš„æ€§èƒ½ã€‚ä½¿ç”¨äº† <code>params</code> å…³é”®å­—çš„é‡è½½åˆ™ç”¨äºä¸å¤ªå¸¸è§çš„æƒ…å½¢ï¼›åœ¨è¿™äº›æƒ…å½¢ä¸‹ï¼Œæ€§èƒ½æœ‰ä¸€å®šçš„æŸå¤±ã€‚ä½†å¹¸è¿çš„æ˜¯ï¼Œè¿™äº›æƒ…å½¢æœ¬æ¥å°±ä¸å¸¸è§ã€‚</p><p>ğŸ’¡å°ç»“ï¼šæ–¹æ³•æœ‰æ—¶éœ€è¦è·å–å¯å˜æ•°é‡çš„å‚æ•°ã€‚ä¸ºäº†æ¥å—å¯å˜æ•°é‡çš„å‚æ•°ï¼Œè¦åœ¨åŸå…ˆçš„å‚æ•°å®šä¹‰å‰é¢åŠ ä¸Š <code>params</code> å…³é”®å­—ï¼Œ <code>params</code> åªèƒ½åº”ç”¨äºæ–¹æ³•ç­¾åä¸­çš„æœ€åä¸€ä¸ªå‚æ•°ã€‚ <code>params</code> å…³é”®å­—å‘Šè¯‰ç¼–è¯‘å™¨å‘å‚æ•°åº”ç”¨å®šåˆ¶ç‰¹æ€§ <code>System.ParamArrayAttribute</code> çš„ä¸€ä¸ªå®ä¾‹ã€‚C# ç¼–è¯‘å™¨æ£€æµ‹åˆ°æ–¹æ³•è°ƒç”¨æ—¶ï¼Œä¼šå…ˆæ£€æŸ¥æ‰€æœ‰å…·æœ‰æŒ‡å®šåç§°ã€åŒæ—¶å‚æ•°æ²¡æœ‰åº”ç”¨ <code>ParamArray</code> ç‰¹æ€§çš„æ–¹æ³•ã€‚æ‰¾åˆ°åŒ¹é…çš„æ–¹æ³•ï¼Œå°±ç”Ÿæˆè°ƒç”¨å®ƒæ‰€éœ€çš„ä»£ç ã€‚æ²¡æœ‰æ‰¾åˆ°ï¼Œå°±æ¥ç€æ£€æŸ¥åº”ç”¨äº† <code>ParamArray</code> ç‰¹æ€§çš„æ–¹æ³•ã€‚æ‰¾åˆ°åŒ¹é…çš„æ–¹æ³•ï¼Œç¼–è¯‘å™¨å…ˆç”Ÿæˆä»£ç æ¥æ„é€ ä¸€ä¸ªæ•°ç»„ï¼Œå¡«å……å®ƒçš„å…ƒç´ ï¼Œå†ç”Ÿæˆä»£ç æ¥è°ƒç”¨æ‰€é€‰çš„æ–¹æ³•ã€‚åªæœ‰æ–¹æ³•çš„æœ€åä¸€ä¸ªå‚æ•°æ‰å¯ä»¥ç”¨ <code>params</code> å…³é”®å­—ï¼ˆ <code>ParamArrayAttribute</code> ï¼‰æ ‡è®°ã€‚å¦å¤–ï¼Œè¿™ä¸ªå‚æ•°åªèƒ½æ ‡è®°ä¸€ç»´æ•°ç»„ï¼ˆä»»æ„ç±»å‹ï¼‰ã€‚å¯ä¸ºè¿™ä¸ªå‚æ•°ä¼ é€’ null å€¼ï¼Œæˆ–ä¼ é€’å¯¹åŒ…å«é›¶ä¸ªå…ƒç´ çš„ä¸€ä¸ªæ•°ç»„çš„å¼•ç”¨ã€‚</p><h2 id="parameter-and-return-type-guidelines"><a class="anchor" href="#parameter-and-return-type-guidelines">#</a> Parameter and Return Type Guidelines</h2><blockquote><p>When declaring a methodâ€™s parameter types, you should specify the weakest type possible, preferring interfaces over base classes. For example, if you are writing a method that manipulates a collection of items, it would be best to declare the methodâ€™s parameter by using an interface such as <code>IEnumerable</code> rather than using a strong data type such as List or even a stronger interface type such as <code>ICollection</code> or <code>IList</code> .</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Desired: This method uses a weak parameter type </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">ManipulateItems</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> collection<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// Undesired: This method uses a strong parameter type </span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">ManipulateItems</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">List<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> collection<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The reason, of course, is that someone can call the first method passing in an array object, a List object, a String object, and so onâ€”any object whose type implements <code>IEnumerable</code> . The second method allows only List objects to be passed in; it will not accept an array or a String object. Obviously, the first method is better because it is much more flexible and can be used in a much wider range of scenarios.</p></blockquote><blockquote><p>Naturally, if you are writing a method that requires a list (not just any enumerable object), then you should declare the parameter type as an <code>IList</code> . You should still avoid declaring the parameter type as List. Using <code>IList</code> allows the caller to pass arrays and any other objects whose type implements <code>IList</code> .</p></blockquote><blockquote><p>Note that my examples talked about collections, which are designed using an interface architecture. If we were talking about classes designed using a base class architecture, the concept still applies. So, for example, if I were implementing a method that processed bytes from a stream, weâ€™d have the following.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Desired: This method uses a weak parameter type </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ProcessBytes</span><span class="token punctuation">(</span><span class="token class-name">Stream</span> someStream<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// Undesired: This method uses a strong parameter type </span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ProcessBytes</span><span class="token punctuation">(</span><span class="token class-name">FileStream</span> fileStream<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The first method can process bytes from any kind of stream: a <code>FileStream</code> , a <code>NetworkStream</code> , a <code>MemoryStream</code> , and so on. The second method can operate only on a <code>FileStream</code> , making it far more limited.</p></blockquote><blockquote><p>On the flip side, it is usually best to declare a methodâ€™s return type by using the strongest type possible (trying not to commit yourself to a specific type). For example, it is better to declare a method that returns a <code>FileStream</code> object as opposed to returning a Stream object.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Desired: This method uses a strong return type </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name">FileStream</span> <span class="token function">OpenFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// Undesired: This method uses a weak return type </span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name">Stream</span> <span class="token function">OpenFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Here, the first method is preferred because it allows the methodâ€™s caller the option of treating the returned object as either a FileStream object or as a Stream object. Meanwhile, the second method requires that the caller treat the returned object as a Stream object. Basically, it is best to let the caller have as much flexibility as possible when calling a method, allowing the method to be used in the widest range of scenarios.</p></blockquote><blockquote><p>Sometimes you want to retain the ability to change the internal implementation of a method without affecting the callers. In the example just shown, the <code>OpenFile</code> method is unlikely to ever change its internal implementation to return anything other than a <code>FileStream</code> object (or an object whose type is derived from <code>FileStream</code> ). However, if you have a method that returns a List object, you might very well want to change the internal implementation of this method in the future so that it would instead return a String[]. In the cases in which you want to leave yourself some flexibility to change what your method returns, choose a weaker return type. The following is an example.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Flexible: This method uses a weaker return type </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name">IList<span class="token punctuation">&lt;</span>String<span class="token punctuation">></span></span> <span class="token function">GetStringCollection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// Inflexible: This method uses a stronger return type </span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name">List<span class="token punctuation">&lt;</span>String<span class="token punctuation">></span></span> <span class="token function">GetStringCollection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In this example, even though the <code>GetStringCollection</code> method uses a List object internally and returns it, it is better to prototype the method as returning an <code>IList</code> instead. In the future, the <code>GetStringCollection</code> method could change its internal collection to use a String[], and callers of the method wonâ€™t be required to change any of their source code. In fact, they wonâ€™t even have to recompile their code. Notice in this example that Iâ€™m using the strongest of the weakest types. For instance, Iâ€™m not using an <code>IEnumerable</code> or even <code>ICollection</code> .</p></blockquote><p>ğŸ’¡å°ç»“ï¼šå£°æ˜æ–¹æ³•çš„å‚æ•°ç±»å‹æ—¶ï¼Œåº”å°½é‡æŒ‡å®šæœ€å¼±çš„ç±»å‹ï¼Œå®æ„¿è¦æ¥å£ä¹Ÿä¸è¦åŸºç±»ã€‚åŸå› æ˜¯è¿™æ ·èƒ½ä½¿æ–¹æ³•æ›´çµæ´»ï¼Œé€‚åˆæ›´å¹¿æ³›çš„æƒ…å½¢ã€‚é™¤éæ–¹æ³•éœ€è¦çš„ç±»å‹æœ‰ç‰¹å®šçš„è¦æ±‚ã€‚ä¸ä»…æ˜¯æ¥å£ä½“ç³»ç»“æ„å®ç”¨ä¸Šé¢çš„æ¦‚å¿µï¼Œå¯¹äºåŸºç±»ä½“ç³»ç»“æ„è®¾è®¡çš„ç±»æ—¶ï¼Œæ¦‚å¿µåŒæ ·é€‚ç”¨ã€‚ç›¸åï¼Œä¸€èˆ¬æœ€å¥½æ˜¯å°†æ–¹æ³•çš„è¿”å›ç±»å‹å£°æ˜ä¸ºæœ€å¼ºçš„ç±»å‹ï¼ˆé˜²æ­¢å—é™äºç‰¹å®šç±»å‹ï¼‰ã€‚å¦‚æœæƒ³ä¿æŒä¸€å®šçš„çµæ´»æ€§ï¼Œåœ¨å°†æ¥æ›´æ”¹æ–¹æ³•è¿”å›çš„ä¸œè¥¿ï¼Œé‚£ä¹ˆå°±é€‰æ‹©ä¸€ä¸ªè¾ƒå¼±çš„ï¼ˆæ³¨æ„æ˜¯ç›¸è¾ƒäºæœ€å¼ºçš„è¾ƒå¼±ï¼‰è¿”å›è¿”å›ç±»å‹ã€‚</p><h2 id="const-ness"><a class="anchor" href="#const-ness">#</a> Const-ness</h2><blockquote><p>n some languages, such as unmanaged C++, it is possible to declare methods or parameters as a constant that forbids the code in an instance method from changing any of the objectâ€™s fields or prevents the code from modifying any of the objects passed into the method. The CLR does not provide for this, and many programmers have been lamenting this missing feature. Because the CLR doesnâ€™t offer this feature, no language (including C#) can offer this feature.</p></blockquote><blockquote><p>First, you should note that in unmanaged C++, marking an instance method or parameter as const ensured only that the programmer could not write normal code that would modify the object or parameter. Inside the method, it was always possible to write code that could mutate the object/ parameter by either casting away the const-ness or by getting the address of the object/argument and then writing to the address. In a sense, unmanaged C++ lied to programmers, making them believe that their constant objects/arguments couldnâ€™t be written to even though they could.</p></blockquote><blockquote><p>When designing a typeâ€™s implementation, the developer can just avoid writing code that manipulates the object/arguments. For example, strings are immutable because the String class doesnâ€™t offer any methods that can change a string object.</p></blockquote><blockquote><p>Also, it would be very difficult for Microsoft to endow the CLR with the ability to verify that a constant object/argument isnâ€™t being mutated. The CLR would have to verify at each write that the write was not occurring to a constant object, and this would hurt performance significantly. Of course, a detected violation would result in the CLR throwing an exception. Furthermore, constant support adds a lot of complexity for developers. For example, if a type is immutable, all derived types would have to respect this. In addition, an immutable type would probably have to consist of fields that are also of immutable types.</p></blockquote><blockquote><p>These are just some of the reasons why the CLR does not support constant objects/arguments.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šæœ‰çš„è¯­è¨€ï¼ˆæ¯”å¦‚éæ‰˜ç®¡ C++ï¼‰å…è®¸å°†æ–¹æ³•æˆ–å‚æ•°å£°æ˜ä¸ºå¸¸é‡ï¼Œä»è€Œç¦æ­¢å®ä¾‹æ–¹æ³•ä¸­çš„ä»£ç æ›´æ”¹å¯¹è±¡çš„ä»»ä½•å­—æ®µï¼Œæˆ–è€…æ›´æ”¹ä¼ ç»™æ–¹æ³•çš„ä»»ä½•å¯¹è±¡ã€‚CLR æ²¡æœ‰æä¾›è¿™ä¸ªåŠŸèƒ½ï¼Œæ—¢ç„¶ CLR éƒ½ä¸æä¾›ï¼Œé‚£ä¹ˆé¢å‘å®ƒçš„ä»»ä½•ç¼–ç¨‹è¯­è¨€ï¼ˆåŒ…æ‹¬ C#ï¼‰è‡ªç„¶ä¹Ÿæ— æ³•æä¾›ã€‚ä¸è¿‡éæ‰˜ç®¡ C++ å°†å®ä¾‹æ–¹æ³•æˆ–å‚æ•°å£°æ˜ä¸º <code>const</code> åªèƒ½é˜²æ­¢ç¨‹åºå‘˜ç”¨ä¸€èˆ¬çš„ä»£ç æ¥æ›´æ”¹å¯¹è±¡æˆ–å‚æ•°ã€‚æ–¹æ³•å†…éƒ¨æ€»æ˜¯å¯ä»¥æ›´æ”¹å¯¹è±¡æˆ–å®å‚çš„ã€‚ä¾‹å¦‚ç”¨å¼ºåˆ¶ç±»å‹è½¬æ¢å»æ‰ â€œå¸¸é‡æ€§â€ï¼Œæˆ–è€…é€šè¿‡è·å–å¯¹è±¡ / å®å‚çš„åœ°å€ï¼Œåœ¨å‘é‚£ä¸ªåœ°å€å†™å…¥ã€‚å®ç°ç±»å‹æ—¶ï¼Œå¼€å‘äººå‘˜å¯ä»¥é¿å…å†™æ“çºµå¯¹è±¡æˆ–å®å‚çš„ä»£ç ã€‚ä¾‹å¦‚ï¼ŒString ç±»å°±æ²¡æœ‰æä¾›ä»»ä½•èƒ½æ›´æ”¹ String å¯¹è±¡çš„æ–¹æ³•ï¼Œæ‰€ä»¥å­—ç¬¦ä¸²æ˜¯ä¸å¯å˜ï¼ˆimmutableï¼‰çš„ã€‚æ­¤å¤–ï¼ŒMicrosoft å¾ˆéš¾ä¸º CLR èµ‹äºˆéªŒè¯å¸¸é‡å¯¹è±¡ / å®å‚æœªè¢«æ›´æ”¹çš„èƒ½åŠ›ã€‚CLR å°†ä¸å¾—ä¸å¯¹æ¯ä¸ªå†™å…¥æ“ä½œè¿›è¡ŒéªŒè¯ï¼Œç¡®å®šè¯¥å†™å…¥é’ˆå¯¹çš„ä¸æ˜¯å¸¸é‡å¯¹è±¡ã€‚è¿™å¯¹æ€§èƒ½å½±å“å¾ˆå¤§ã€‚å½“ç„¶ï¼Œå¦‚æœæ£€æµ‹åˆ°æœ‰è¿åå¸¸é‡æ€§çš„åœ°æ–¹ï¼Œä¼šé€ æˆ CLR æŠ›å‡ºå¼‚å¸¸ã€‚æ­¤å¤–ï¼Œå¦‚æœæ”¯æŒå¸¸é‡æ€§ï¼Œè¿˜ä¼šç»™å¼€å‘äººå‘˜å¸¦æ¥å¤§é‡å¤æ‚æ€§ã€‚ä¾‹å¦‚ï¼Œå¦‚æœç±»å‹æ˜¯ä¸å¯å˜çš„ï¼Œå®ƒçš„æ‰€æœ‰æ´¾ç”Ÿç±»å‹éƒ½ä¸å¾—ä¸éµå®ˆè¿™ä¸ªçº¦å®šã€‚é™¤æ­¤ä¹‹å¤–ï¼Œåœ¨ä¸å¯å˜çš„ç±»å‹ä¸­ï¼Œå­—æ®µä¹Ÿå¿…é¡»ä¸å¯å˜ã€‚è€ƒè™‘åˆ°ç§ç§åŸå› ï¼ŒCLR æ²¡æœ‰æä¾›å¯¹å¸¸é‡å¯¹è±¡ / å®å‚çš„æ”¯æŒã€‚</p><div class="tags"><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> è¯»ä¹¦ç¬”è®°</a> <a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C#</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2022-11-01 14:23:08" itemprop="dateModified" datetime="2022-11-01T14:23:08+08:00">2022-11-01</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(ï¿£â–½ï¿£)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Sakupinera WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Sakupinera Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Sakupinera PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Sakupinera <i class="ic i-at"><em>@</em></i>Sakupinera</li><li class="link"><strong>Post link: </strong><a href="http://sakupinera.github.io/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/" title="CLR via C# - Chapter 9 Parameters">http://sakupinera.github.io/2022/10/27/csharp/clr-via-csharp/Chapter 9 Parameters/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipet4bz0yj20zk0m8e81.jpg" title="CLR via C# - Chapter 8 Methods"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 8 Methods</h3></a></div><div class="item right"><a href="/2022/10/28/csharp/clr-via-csharp/Chapter%2010%20Properties/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipesng5oej20zk0m87d4.jpg" title="CLR via C# - Chapter 10 Properties"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 10 Properties</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-9-parameters"><span class="toc-number">1.</span> <span class="toc-text">Chapter 9 Parameters</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#optional-and-named-parameters"><span class="toc-number">1.1.</span> <span class="toc-text">Optional and Named Parameters</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rules-and-guidelines"><span class="toc-number">1.1.1.</span> <span class="toc-text">Rules and Guidelines</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#the-defaultparametervalue-and-optional-attributes"><span class="toc-number">1.1.2.</span> <span class="toc-text">The DefaultParameterValue and Optional Attributes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#implicitly-typed-local-variables"><span class="toc-number">1.2.</span> <span class="toc-text">Implicitly Typed Local Variables</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#passing-parameters-by-reference-to-a-method"><span class="toc-number">1.3.</span> <span class="toc-text">Passing Parameters by Reference to a Method</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#passing-a-variable-number-of-arguments-to-a-method"><span class="toc-number">1.4.</span> <span class="toc-text">Passing a Variable Number of Arguments to a Method</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#parameter-and-return-type-guidelines"><span class="toc-number">1.5.</span> <span class="toc-text">Parameter and Return Type Guidelines</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const-ness"><span class="toc-number">1.6.</span> <span class="toc-text">Const-ness</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"><ul><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/" rel="bookmark" title="CLR via C# - Chapter 1 The CLRâ€™s Execution Model">CLR via C# - Chapter 1 The CLRâ€™s Execution Model</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/" rel="bookmark" title="CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types">CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%203%20Shared%20Assemblies%20and%20Strongly%20Named%20Assemblies/" rel="bookmark" title="CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies">CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies</a></li><li><a href="/2022/09/27/csharp/clr-via-csharp/Chapter%204%20Type%20Fundamentals/" rel="bookmark" title="CLR via C# - Chapter 4 Type Fundamentals">CLR via C# - Chapter 4 Type Fundamentals</a></li><li><a href="/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/" rel="bookmark" title="CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals">CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals</a></li><li><a href="/2022/10/21/csharp/clr-via-csharp/Chapter%206%20Type%20and%20Member%20Basics/" rel="bookmark" title="CLR via C# - Chapter 6 Type and Member Basics">CLR via C# - Chapter 6 Type and Member Basics</a></li><li><a href="/2022/10/24/csharp/clr-via-csharp/Chapter%207%20Constants%20and%20Fields/" rel="bookmark" title="CLR via C# - Chapter 7 Constants and Fields">CLR via C# - Chapter 7 Constants and Fields</a></li><li><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" rel="bookmark" title="CLR via C# - Chapter 8 Methods">CLR via C# - Chapter 8 Methods</a></li><li class="active"><a href="/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/" rel="bookmark" title="CLR via C# - Chapter 9 Parameters">CLR via C# - Chapter 9 Parameters</a></li><li><a href="/2022/10/28/csharp/clr-via-csharp/Chapter%2010%20Properties/" rel="bookmark" title="CLR via C# - Chapter 10 Properties">CLR via C# - Chapter 10 Properties</a></li><li><a href="/2022/10/29/csharp/clr-via-csharp/Chapter%2011%20Events/" rel="bookmark" title="CLR via C# - Chapter 11 Events">CLR via C# - Chapter 11 Events</a></li><li><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" rel="bookmark" title="CLR via C# - Chapter 12 Generics">CLR via C# - Chapter 12 Generics</a></li><li><a href="/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/" rel="bookmark" title="CLR via C# - Chapter 13 Interfaces">CLR via C# - Chapter 13 Interfaces</a></li><li><a href="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/" rel="bookmark" title="CLR via C# - Chapter 14 Chars, Strings, and Working with Text">CLR via C# - Chapter 14 Chars, Strings, and Working with Text</a></li><li><a href="/2022/11/17/csharp/clr-via-csharp/Chapter%2015%20Enumerated%20Types%20and%20Bit%20Flags/" rel="bookmark" title="CLR via C# - Chapter 15 Enumerated Types and Bit Flags">CLR via C# - Chapter 15 Enumerated Types and Bit Flags</a></li><li><a href="/2022/11/19/csharp/clr-via-csharp/Chapter%2016%20Arrays/" rel="bookmark" title="CLR via C# - Chapter 16 Arrays">CLR via C# - Chapter 16 Arrays</a></li><li><a href="/2022/11/21/csharp/clr-via-csharp/Chapter%2017%20Delegates/" rel="bookmark" title="CLR via C# - Chapter 17 Delegates">CLR via C# - Chapter 17 Delegates</a></li><li><a href="/2022/11/22/csharp/clr-via-csharp/Chapter%2018%20Custom%20Attributes/" rel="bookmark" title="CLR via C# - Chapter 18 Custom Attributes">CLR via C# - Chapter 18 Custom Attributes</a></li><li><a href="/2022/11/23/csharp/clr-via-csharp/Chapter%2019%20Nullable%20Value%20Types/" rel="bookmark" title="CLR via C# - Chapter 19 Nullable Value Types">CLR via C# - Chapter 19 Nullable Value Types</a></li><li><a href="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/" rel="bookmark" title="CLR via C# - Chapter 20 Exceptions and State Management">CLR via C# - Chapter 20 Exceptions and State Management</a></li><li><a href="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/" rel="bookmark" title="CLR via C# - Chapter 21 The Managed Heap and Garbage  Collection">CLR via C# - Chapter 21 The Managed Heap and Garbage Collection</a></li><li><a href="/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/" rel="bookmark" title="CLR via C# - Chapter 22 CLR Hosting and AppDomains">CLR via C# - Chapter 22 CLR Hosting and AppDomains</a></li><li><a href="/2022/11/29/csharp/clr-via-csharp/Chapter%2023%20Assembly%20Loading%20and%20Reflection/" rel="bookmark" title="CLR via C# - Chapter 23 Assembly Loading and Reflection">CLR via C# - Chapter 23 Assembly Loading and Reflection</a></li><li><a href="/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/" rel="bookmark" title="CLR via C# - Chapter 24 Runtime Serialization">CLR via C# - Chapter 24 Runtime Serialization</a></li><li><a href="/2022/12/06/csharp/clr-via-csharp/Chapter%2025%20Interoperating%20with%20WinRT%20%20Components/" rel="bookmark" title="CLR via C# - Chapter 25 Interoperating with WinRT Components">CLR via C# - Chapter 25 Interoperating with WinRT Components</a></li><li><a href="/2023/02/06/csharp/clr-via-csharp/Chapter%2026%20Thread%20Basics/" rel="bookmark" title="CLR via C# - Chapter 26 Thread Basics">CLR via C# - Chapter 26 Thread Basics</a></li><li><a href="/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations">CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations</a></li><li><a href="/2023/02/08/csharp/clr-via-csharp/Chapter%2028%20IO-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 28 IO-Bound Asynchronous Operations">CLR via C# - Chapter 28 IO-Bound Asynchronous Operations</a></li><li><a href="/2023/02/09/csharp/clr-via-csharp/Chapter%2029%20Primitive%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 29 Primitive Thread Synchronization">CLR via C# - Chapter 29 Primitive Thread Synchronization</a></li><li><a href="/2023/02/10/csharp/clr-via-csharp/Chapter%2030%20Hybrid%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 30 Hybrid Thread Synchronization">CLR via C# - Chapter 30 Hybrid Thread Synchronization</a></li></ul></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sakupinera" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Sakupinera</p><div class="description" itemprop="description">ä¿æŒä½ çš„å†³å¿ƒï¼</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">89</span> <span class="name">posts</span></a></div><div class="item categories"><a href="/categories/"><span class="count">17</span> <span class="name">categories</span></a></div><div class="item tags"><a href="/tags/"><span class="count">8</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nha3VwaW5lcmE=" title="https:&#x2F;&#x2F;github.com&#x2F;sakupinera"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9zYWt1cGluZXJh" title="https:&#x2F;&#x2F;twitter.com&#x2F;sakupinera"><i class="ic i-twitter"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQwNzIyOTA3MQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;407229071"><i class="ic i-cloud-music"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMjIzMDczOTg/c3BtX2lkX2Zyb209MzMzLjEwMDcuMC4w" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;22307398?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li><li class="item"><a href="/games/" rel="section"><i class="ic i-flag"></i>games</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-person"></i>About</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/10/28/csharp/clr-via-csharp/Chapter%2010%20Properties/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/09/30/computer-graphics/games101/%E7%9D%80%E8%89%B2/" title="GAMES101 - Shadingï¼ˆç€è‰²ï¼‰">GAMES101 - Shadingï¼ˆç€è‰²ï¼‰</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2023/02/10/csharp/clr-via-csharp/Chapter%2030%20Hybrid%20Thread%20Synchronization%20Constructs/" title="CLR via C# - Chapter 30 Hybrid Thread Synchronization">CLR via C# - Chapter 30 Hybrid Thread Synchronization</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2022/12/09/cpp/cpp-primer/Chapter%201%20Getting%20Started/" title="C++ Primer - Chapter 1 Getting Started">C++ Primer - Chapter 1 Getting Started</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Language/" title="In Language">Language</a> <i class="ic i-angle-right"></i> <a href="/categories/Language/Japanese/" title="In Japanese">Japanese</a></div><span><a href="/2024/10/23/language/japanese/%E6%97%A5%E6%9C%AC%E8%AA%9E%E3%81%AE%E5%8B%89%E5%BC%B7/" title="æ—¥æœ¬èªã®å‹‰å¼·">æ—¥æœ¬èªã®å‹‰å¼·</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" title="CLR via C# - Chapter 12 Generics">CLR via C# - Chapter 12 Generics</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/" title="GAMES101 - Cameras, Lenses and Light Fieldsï¼ˆç›¸æœºï¼Œé€é•œå’Œå…‰åœºï¼‰">GAMES101 - Cameras, Lenses and Light Fieldsï¼ˆç›¸æœºï¼Œé€é•œå’Œå…‰åœºï¼‰</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2022/12/16/cpp/cpp-primer/Chapter%208%20The%20IO%20Library/" title="C++ Primer - Chapter 8 The IO Library">C++ Primer - Chapter 8 The IO Library</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/10/03/computer-graphics/games101/%E5%87%A0%E4%BD%95/" title="GAMES101 - Geometryï¼ˆå‡ ä½•ï¼‰">GAMES101 - Geometryï¼ˆå‡ ä½•ï¼‰</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2023/02/09/csharp/clr-via-csharp/Chapter%2029%20Primitive%20Thread%20Synchronization%20Constructs/" title="CLR via C# - Chapter 29 Primitive Thread Synchronization">CLR via C# - Chapter 29 Primitive Thread Synchronization</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/12/06/csharp/clr-via-csharp/Chapter%2025%20Interoperating%20with%20WinRT%20%20Components/" title="CLR via C# - Chapter 25 Interoperating with WinRT Components">CLR via C# - Chapter 25 Interoperating with WinRT Components</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 â€“ <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Sakupinera @ Hanamai Sora</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="Symbols count total">2.2m words</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="Reading time total">34:05</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/10/27/csharp/clr-via-csharp/Chapter 9 Parameters/",favicon:{show:"ï¼ˆâ—Â´3ï½€â—ï¼‰Goooood",hide:"(Â´Ğ”ï½€)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/shifuku.model.json"},display:{position:"left",width:250,height:500},mobile:{show:!1},react:{opacity:.9},log:!1})</script></body></html>