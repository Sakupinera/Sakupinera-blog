<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sakupinera" href="http://sakupinera.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sakupinera" href="http://sakupinera.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sakupinera" href="http://sakupinera.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="读书笔记,C#"><link rel="canonical" href="http://sakupinera.github.io/2022/10/28/csharp/clr-via-csharp/Chapter%2010%20Properties/"><title>CLR via C# - Chapter 10 Properties - CLR-via-CSharp - CSharp | Hanamai Sora = Sakupinera</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">CLR via C# - Chapter 10 Properties</h1><div class="meta"><span class="item" title="Created: 2022-10-28 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2022-10-28T00:00:00+08:00">2022-10-28</time> </span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">Symbols count in article</span> <span>45k</span> <span class="text">words</span> </span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">Reading time</span> <span>41 mins.</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hanamai Sora</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s2.loli.net/2023/03/08/OQq9sc7VlKfnvGL.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/Jxa8Trdmc4uFsqW.png"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/hub7DjxPVYvzoB4.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/Y2t3E6QUohFwG1R.png"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/Rft6Y9pgTV5E17J.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/J4XewNCOu8fzIy9.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/" itemprop="item" rel="index" title="In CSharp"><span itemprop="name">CSharp</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/CLR-via-CSharp/" itemprop="item" rel="index" title="In CLR-via-CSharp"><span itemprop="name">CLR-via-CSharp</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://sakupinera.github.io/2022/10/28/csharp/clr-via-csharp/Chapter%2010%20Properties/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Sakupinera"><meta itemprop="description" content=", 保持你的决心！"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakupinera"></span><div class="body md" itemprop="articleBody"><h1 id="chapter-10-properties"><a class="anchor" href="#chapter-10-properties">#</a> Chapter 10 Properties</h1><h2 id="parameterless-properties"><a class="anchor" href="#parameterless-properties">#</a> Parameterless Properties</h2><blockquote><p>Many types define state information that can be retrieved or altered. Frequently, this state information is implemented as field members of the type. For example, here’s a type definition that contains two fields.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name">String</span> Name<span class="token punctuation">;</span> <span class="token comment">// The employee's name </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name">Int32</span> Age<span class="token punctuation">;</span> <span class="token comment">// The employee's age </span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>If you were to create an instance of this type, you could easily get or set any of this state information with code similar to the following.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Employee</span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre>e<span class="token punctuation">.</span>Name <span class="token operator">=</span> <span class="token string">"Jeffrey Richter"</span><span class="token punctuation">;</span> <span class="token comment">// Set the employee's Name. </span></pre></td></tr><tr><td data-num="3"></td><td><pre>e<span class="token punctuation">.</span>Age <span class="token operator">=</span> <span class="token number">48</span><span class="token punctuation">;</span> <span class="token comment">// Set the employee's Age. </span></pre></td></tr><tr><td data-num="4"></td><td><pre>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "Jeffrey Richter"</span></pre></td></tr></table></figure><blockquote><p>Querying and setting an object’s state information in the way I just demonstrated is very common. However, I would argue that the preceding code should never be implemented as shown. One of the hallmarks of object-oriented design and programming is data encapsulation. Data encapsulation means that your type’s fields should never be publicly exposed because it’s too easy to write code that improperly uses the fields, corrupting the object’s state. For example, a developer could easily corrupt an Employee object with code like the following.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>e<span class="token punctuation">.</span>Age <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// How could someone be –5 years old?</span></pre></td></tr></table></figure><blockquote><p>There are additional reasons for encapsulating access to a type’s data field. For example, you might want access to a field to execute some side effect, cache some value, or lazily create some internal object. You might also want access to the field to be thread-safe. Or perhaps the field is a logical field whose value isn’t represented by bytes in memory but whose value is instead calculated using some algorithm.</p></blockquote><blockquote><p>For any of these reasons, when designing a type, I strongly suggest that all of your fields be private. Then, to allow a user of your type to get or set state information, you expose methods for that specific purpose. Methods that wrap access to a field are typically called accessor methods. These accessor methods can optionally perform sanity checking and ensure that the object’s state is never corrupted. For example, I’d rewrite the previous class as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">String</span> m_Name<span class="token punctuation">;</span> <span class="token comment">// Field is now private </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_Age<span class="token punctuation">;</span> <span class="token comment">// Field is now private </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">String</span> <span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">return</span><span class="token punctuation">(</span>m_Name<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SetName</span><span class="token punctuation">(</span><span class="token class-name">String</span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> m_Name <span class="token operator">=</span> <span class="token keyword">value</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token function">GetAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">return</span><span class="token punctuation">(</span>m_Age<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SetAge</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">value</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ArgumentOutOfRangeException</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">,</span> <span class="token keyword">value</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token string">"The value must be greater than or equal to 0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> m_Age <span class="token operator">=</span> <span class="token keyword">value</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Although this is a simple example, you should still be able to see the enormous benefit you get from encapsulating the data fields. You should also be able to see how easy it is to make read-only or write-only properties: just don’t implement one of the accessor methods. Alternatively, you could allow only derived types to modify the value by marking the SetXxx method as protected.</p></blockquote><blockquote><p>Encapsulating the data as shown earlier has two disadvantages. First, you have to write more code because you now have to implement additional methods. Second, users of the type must now call methods rather than simply refer to a single field name.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>e<span class="token punctuation">.</span><span class="token function">SetName</span><span class="token punctuation">(</span><span class="token string">"Jeffrey Richter"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Updates the employee's name </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">String</span> EmployeeName <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Retrieves the employee's name </span></pre></td></tr><tr><td data-num="3"></td><td><pre>e<span class="token punctuation">.</span><span class="token function">SetAge</span><span class="token punctuation">(</span><span class="token number">48</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Updates the employee's age </span></pre></td></tr><tr><td data-num="4"></td><td><pre>e<span class="token punctuation">.</span><span class="token function">SetAge</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Throws ArgumentOutOfRangeException </span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token class-name">Int32</span> EmployeeAge <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">GetAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Retrieves the employee's age</span></pre></td></tr></table></figure><blockquote><p>Personally, I think these disadvantages are quite minor. Nevertheless, programming languages and the CLR offer a mechanism called properties that alleviates the first disadvantage a little and removes the second disadvantage entirely.</p></blockquote><blockquote><p>The class shown here uses properties and is functionally identical to the class shown earlier.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">String</span> m_Name<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_Age<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">String</span> Name <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span><span class="token punctuation">(</span>m_Name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">set</span> <span class="token punctuation">&#123;</span> m_Name <span class="token operator">=</span> <span class="token keyword">value</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// The 'value' keyword always identifies the new value.</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> Age <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span><span class="token punctuation">(</span>m_Age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">set</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">value</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// The 'value' keyword always identifies the new value.</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ArgumentOutOfRangeException</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">,</span> <span class="token keyword">value</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token string">"The value must be greater than or equal to 0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> m_Age <span class="token operator">=</span> <span class="token keyword">value</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>As you can see, properties complicate the definition of the type slightly, but the fact that they allow you to write your code as follows more than compensates for the extra work.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>e<span class="token punctuation">.</span>Name <span class="token operator">=</span> <span class="token string">"Jeffrey Richter"</span><span class="token punctuation">;</span> <span class="token comment">// "Sets" the employee name </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">String</span> EmployeeName <span class="token operator">=</span> e<span class="token punctuation">.</span>Name<span class="token punctuation">;</span> <span class="token comment">// "Gets" the employee's name </span></pre></td></tr><tr><td data-num="3"></td><td><pre>e<span class="token punctuation">.</span>Age <span class="token operator">=</span> <span class="token number">48</span><span class="token punctuation">;</span> <span class="token comment">// "Sets" the employee's age </span></pre></td></tr><tr><td data-num="4"></td><td><pre>e<span class="token punctuation">.</span>Age <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// Throws ArgumentOutOfRangeException </span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token class-name">Int32</span> EmployeeAge <span class="token operator">=</span> e<span class="token punctuation">.</span>Age<span class="token punctuation">;</span> <span class="token comment">// "Gets" the employee's age</span></pre></td></tr></table></figure><blockquote><p>You can think of properties as smart fields: fields with additional logic behind them. The CLR supports static, instance, abstract, and virtual properties. In addition, properties can be marked with any accessibility modifier (discussed in Chapter 6, “Type and Member Basics”) and defined within an interface (discussed in Chapter 13, “Interfaces”).</p></blockquote><blockquote><p>Each property has a name and a type (which can’t be void). It isn’t possible to overload properties (that is, have two properties with the same name if their types are different). When you define a property, you typically specify both a get and a set method. However, you can leave out the set method to define a read-only property or leave out the get method to define a write-only property.</p></blockquote><blockquote><p>It’s also quite common for the property’s get/set methods to manipulate a private field defined within the type. This field is commonly referred to as the backing field. The get and set methods don’t have to access a backing field, however. For example, the <code>System.Threading.Thread</code> type offers a Priority property that communicates directly with the operating system; the Thread object doesn’t maintain a field for a thread’s priority. Another example of properties without backing fields are those read-only properties calculated at run time—for example, the length of a zero-terminated array or the area of a rectangle when you have its height and width.</p></blockquote><blockquote><p>When you define a property, depending on its definition, the compiler will emit either two or three of the following items into the resulting managed assembly:</p></blockquote><ul><li>A method representing the property’s get accessor method. This is emitted only if you define a get accessor method for the property.</li><li>A method representing the property’s set accessor method. This is emitted only if you define a set accessor method for the property.</li><li>A property definition in the managed assembly’s metadata. This is always emitted.</li></ul><blockquote><p>Refer back to the Employee type shown earlier. As the compiler compiles this type, it comes across the Name and Age properties. Because both properties have get and set accessor methods, the compiler emits four method definitions into the Employee type. It’s as though the original source were written as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">String</span> m_Name<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_Age<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">String</span> <span class="token function">get_Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">return</span> m_Name<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">set_Name</span><span class="token punctuation">(</span><span class="token class-name">String</span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> m_Name <span class="token operator">=</span> <span class="token keyword">value</span><span class="token punctuation">;</span> <span class="token comment">// The argument 'value' always identifies the new value. </span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token function">get_Age</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">return</span> m_Age<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">set_Age</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">value</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// The 'value' always identifies the new value. </span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ArgumentOutOfRangeException</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">,</span> <span class="token keyword">value</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token string">"The value must be greater than or equal to 0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> m_Age <span class="token operator">=</span> <span class="token keyword">value</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The compiler automatically generates names for these methods by prepending get_ or set_ to the property name specified by the developer.</p></blockquote><blockquote><p>C# has built-in support for properties. When the C# compiler sees code that’s trying to get or set a property, the compiler actually emits a call to one of these methods. If you’re using a programming language that doesn’t directly support properties, you can still access properties by calling the desired accessor method. The effect is exactly the same; it’s just that the source code doesn’t look as pretty.</p></blockquote><blockquote><p>In addition to emitting the accessor methods, compilers also emit a property definition entry into the managed assembly’s metadata for each property defined in the source code. This entry contains some flags and the type of the property, and it refers to the get and set accessor methods. This information exists simply to draw an association between the abstract concept of a “property” and its accessor methods. Compilers and other tools can use this metadata, which can be obtained by using the <code>System.Reflection.PropertyInfo</code> class. The CLR doesn’t use this metadata information and requires only the accessor methods at run time.</p></blockquote><h3 id="automatically-implemented-properties"><a class="anchor" href="#automatically-implemented-properties">#</a> Automatically Implemented Properties</h3><blockquote><p>If you are creating a property to simply encapsulate a backing field, then C# offers a simplified syntax known as automatically implemented properties (AIPs), as shown here for the Name property.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// This property is an automatically implemented property</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">String</span> Name <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_Age<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> Age <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span><span class="token punctuation">(</span>m_Age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">set</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">value</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// The 'value' keyword always identifies the new value.</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ArgumentOutOfRangeException</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">,</span> <span class="token keyword">value</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token string">"The value must be greater than or equal to 0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> m_Age <span class="token operator">=</span> <span class="token keyword">value</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When you declare a property and do not provide an implementation for the get/set methods, then the C# compiler will automatically declare for you a private field. In this example, the field will be of type String, the type of the property. And, the compiler will automatically implement the get_Name and set_Name methods for you to return the value in the field and to set the field’s value, respectively.</p></blockquote><blockquote><p>You might wonder what the value of doing this is, as opposed to just declaring a public String field called Name. Well, there is a big difference. Using the AIP syntax means that you have created a property. Any code that accesses this property is actually calling get and set methods. If you decide later to implement the get and/or set method yourself instead of accepting the compiler’s default implementation, then any code that accesses the property will not have to be recompiled. However, if you declared Name as a field and then you later change it to a property, then all code that accessed the field will have to be recompiled so that it now accesses the property methods.</p></blockquote><ul><li>Personally, I do not like the compiler’s AIP feature, so I usually avoid it for the following reason: The syntax for a field declaration can include initialization so that you are declaring and initializing the field in one line of code. However, there is no convenient syntax to set an AIP to an initial value. Therefore, you must explicitly initialize each AIP in each constructor method.</li><li>The runtime serialization engines persist the name of the field in a serialized stream. The name of the backing field for an AIP is determined by the compiler, and it could actually change the name of this backing field every time you recompile your code, negating the ability to deserialize instances of any types that contain an AIP. Do not use the AIP feature with any type you intend to serialize or deserialize.</li><li>When debugging, you cannot put a breakpoint on an AIP get or set method, so you cannot easily detect when an application is getting or setting this property. You can set breakpoints on manually implemented properties, which can be quite handy when tracking down bugs.</li></ul><blockquote><p>You should also know that when you use AIPs, the property must be readable and writable; that is, the compiler must produce both get and set methods. This makes sense because a write-only field is not useful without the ability to read its value; likewise, a read-only field would always have its default value. In addition, because you do not know the name of the compiler-generated backing field, your code must always access the property by using the property name. And, if you decide you want to explicitly implement one of the accessor methods, then you must explicitly implement both accessor methods and you are not using the AIP feature anymore. For a single property, the AIP feature is an all-or-nothing deal.</p></blockquote><h3 id="defining-properties-intelligently"><a class="anchor" href="#defining-properties-intelligently">#</a> Defining Properties Intelligently</h3><blockquote><p>Personally, I don’t like properties and I wish that they were not supported in the Microsoft .NET Framework and its programming languages. The reason is that properties look like fields, but they are methods. This has been known to cause a phenomenal amount of confusion. When a programmer sees code that appears to be accessing a field, there are many assumptions that the programmer makes that may not be true for a property. For example:</p></blockquote><ul><li>A property may be read-only or write-only; field access is always readable and writable. If you define a property, it is best to offer both get and set accessor methods.</li><li>A property method may throw an exception; field access never throws an exception.</li><li>A property cannot be passed as an out or ref parameter to a method; a field can. For example, the following code will not compile.</li></ul><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name">String</span> Name <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">set</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">MethodWithOutParam</span><span class="token punctuation">(</span><span class="token keyword">out</span> <span class="token class-name">String</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> n <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// For the line of code below, the C# compiler emits the following: </span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// error CS0206: A property, indexer or dynamic member access may not </span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// be passed as an out or ref parameter </span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token function">MethodWithOutParam</span><span class="token punctuation">(</span><span class="token keyword">out</span> Name<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>A property method can take a long time to execute; field access always completes immediately. A common reason to use properties is to perform thread synchronization, which can stop the thread forever, and therefore, a property should not be used if thread synchronization is required. In that situation, a method is preferred. Also, if your class can be accessed remotely (for example, your class is derived from <code>System.MarshalByRefObject</code> ), calling the property method will be very slow, and therefore, a method is preferred to a property. In my opinion, classes derived from <code>MarshalByRefObject</code> should never use properties.</li><li>If called multiple times in a row, a property method may return a different value each time; a field returns the same value each time. The <code>System.DateTime</code> class has a read-only Now property that returns the current date and time. Each time you query this property, it will return a different value. This is a mistake, and Microsoft wishes that they could fix the class by making Now a method instead of a property. Environment’s <code>TickCount</code> property is another example of this mistake.</li><li>A property method may cause observable side effects; field access never does. In other words, a user of a type should be able to set various properties defined by a type in any order he or she chooses without noticing any different behavior in the type.</li><li>A property method may require additional memory or return a reference to something that is not actually part of the object’s state, so modifying the returned object has no effect on the original object; querying a field always returns a reference to an object that is guaranteed to be part of the original object’s state. Working with a property that returns a copy can be very confusing to developers, and this characteristic is frequently not documented.</li></ul><blockquote><p>It has come to my attention that people use properties far more often than they should. If you examine this list of differences between properties and fields, you’ll see that there are very few circumstances in which defining a property is actually useful and will not cause confusion for developers. The only thing that properties buy you is some simplified syntax; there is no performance benefit compared to calling a non-property method, and understandability of the code is reduced. If I had been involved in the design of the .NET Framework and compilers, I would have not offered properties at all; instead, I would have programmers actually implement GetXxx and SetXxx methods as desired. Then, if compilers wanted to offer some special, simplified syntax for calling these methods, so be it. But I’d want the compiler to use syntax that is different from field access syntax so that programmers really understand what they are doing—a method call.</p></blockquote><p><strong>属性和 Visual Studio 调试器</strong></p><p>Microsoft Visual Studio 允许在调试器的监视窗口中输入一个对象的属性。这样一来，每次遇到一个断点，调试器都会调用属性的 <code>get</code> 访问器方法，并显示返回值。这个技术在查错时很有用，但也有可能造成 bug，并损害调试性能。例如，假定为网络共享中的文件创建了一个 <code>FileStream</code> ，然后将 <code>FileStream</code> 的 <code>Length</code> 属性添加到调试器的监视窗口中。现在，每次遇到一个端点，调试器都会调用 <code>Length</code> 的 <code>get</code> 访问器方法，该方法内部向服务器发出一个网络请求来获取文件的当前长度！</p><p>类似地，如果属性的 <code>get</code> 访问器方法有一个 side effect，那么每次抵达断点，都会执行这个 side effect。例如，假定属性的 <code>get</code> 访问器方法每次调用时都递增一个计数器，这个计数器每次抵达断点时也会递增。考虑到可能有这些问题，Visual Studio 允许为监视窗口中显示的属性关闭属性求值。要在 Visual Studio 中关闭属性求值，请选择 &quot;工具&quot; | &quot;选项&quot; | &quot;调试&quot; | “常规”。然后，在如果 10-1 所示的列表框中，清除勾选 “启用属性求值和其他隐式函数调用”。注意，即使清除了这个选项，仍可将属性添加到监视窗口，然后手动强制 Visual Studio 对它进行求值。为此，单击监视窗口 “值” 列中的强制求值圆圈即可。</p><p><img data-src="/2022/10/28/csharp/clr-via-csharp/Chapter%2010%20Properties/image-20221031123303408.png" alt="image-20221031123303408"></p><h3 id="object-and-collection-initializers"><a class="anchor" href="#object-and-collection-initializers">#</a> Object and Collection Initializers</h3><blockquote><p>It is very common to construct an object and then set some of the object’s public properties (or fields). To simplify this common programming pattern, the C# language supports a special object initialization syntax. The following is an example.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Employee</span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Name <span class="token operator">=</span> <span class="token string">"Jeff"</span><span class="token punctuation">,</span> Age <span class="token operator">=</span> <span class="token number">45</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>With this one statement, I am constructing an Employee object, calling its parameterless constructor, and then setting its public Name property to &quot;Jeff&quot; and its public Age property to 45. In fact, the preceding code is identical to the following, which you could verify by examining the Intermediate Language (IL) for both of these code fragments.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Employee</span> _tempVar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>_tempVar<span class="token punctuation">.</span>Name <span class="token operator">=</span> <span class="token string">"Jeff"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>_tempVar<span class="token punctuation">.</span>Age <span class="token operator">=</span> <span class="token number">45</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// Only assign to e if the assignments above don't throw an exception.</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// This prevents e from referring to a partially initialized object.</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token class-name">Employee</span> e <span class="token operator">=</span> _tempVar<span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>The real benefit of the object initializer syntax is that it allows you to code in an expression context (as opposed to a statement context), permitting composability of functions, which in turn increases code readability. For example, I can now write the following.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Name <span class="token operator">=</span> <span class="token string">"Jeff"</span><span class="token punctuation">,</span> Age <span class="token operator">=</span> <span class="token number">45</span> <span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToUpper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>So now, in one statement, I have constructed an Employee object, called its constructor, initialized two public properties, and then, using the resulting expression, called ToString on it followed by calling ToUpper. For more about composability of functions, see the “Extension Methods” section in Chapter 8, “Methods.”</p></blockquote><blockquote><p>As a small side note, C# also lets you omit the parentheses before the open brace if you want to call a parameterless constructor. The following line produces the same IL as the preceding line.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Employee</span> <span class="token punctuation">&#123;</span> Name <span class="token operator">=</span> “Jeff”<span class="token punctuation">,</span> Age <span class="token operator">=</span> <span class="token number">45</span> <span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToUpper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>If a property’s type implements the IEnumerable or IEnumerable interface, then the property is considered to be a collection, and initializing a collection is an additive operation as opposed to a replacement operation. For example, suppose I have the following class definition.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Classroom</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">List<span class="token punctuation">&lt;</span>String<span class="token punctuation">></span></span> m_students <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">List<span class="token punctuation">&lt;</span>String<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">List<span class="token punctuation">&lt;</span>String<span class="token punctuation">></span></span> Students <span class="token punctuation">&#123;</span> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> m_students<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Classroom</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>I can now have code that constructs a Classroom object and initializes the Students collection as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">M</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Classroom</span> classroom <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Classroom</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> Students <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token string">"Jeff"</span><span class="token punctuation">,</span> <span class="token string">"Kristin"</span><span class="token punctuation">,</span> <span class="token string">"Aidan"</span><span class="token punctuation">,</span> <span class="token string">"Grant"</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// Show the 4 students in the classroom</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> student <span class="token keyword">in</span> classroom<span class="token punctuation">.</span>Students<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When compiling this code, the compiler sees that the Students property is of type List and that this type implements the <code>IEnumerable</code> interface. Now, the compiler assumes that the List type offers a method called Add (because most collection classes actually offer an Add method that adds items to the collection). The compiler then generates code to call the collection’s Add method. So, the preceding code is converted by the compiler into the following</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">M</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Classroom</span> classroom <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Classroom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> classroom<span class="token punctuation">.</span>Students<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">"Jeff"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> classroom<span class="token punctuation">.</span>Students<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">"Kristin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> classroom<span class="token punctuation">.</span>Students<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">"Aidan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> classroom<span class="token punctuation">.</span>Students<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">"Grant"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// Show the 4 students in the classroom</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> student <span class="token keyword">in</span> classroom<span class="token punctuation">.</span>Students<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>If the property’s type implements <code>IEnumerable</code> or <code>IEnumerable</code> but the type doesn’t offer an Add method, then the compiler does not let you use the collection initialize syntax to add items to the collection; instead, the compiler issues something like the following message: error CS0117: ' <code>System.Collections.Generic.IEnumerable</code> ' does not contain a definition for 'Add'.</p></blockquote><blockquote><p>Some collection’s Add methods take multiple arguments—for example, Dictionary’s Add method.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token class-name">TKey</span> key<span class="token punctuation">,</span> <span class="token class-name">TValue</span> <span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>You can pass multiple arguments to an Add method by using nested braces in a collection initializer, as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token keyword">var</span></span> table <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Dictionary<span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> Int32<span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token punctuation">&#123;</span> <span class="token string">"Jeffrey"</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> <span class="token string">"Kristin"</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> <span class="token string">"Aidan"</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> <span class="token string">"Grant"</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>The preceding line is identical to the following.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token keyword">var</span></span> table <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Dictionary<span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> Int32<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>table<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">"Jeffrey"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>table<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">"Kristin"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>table<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">"Aidan"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>table<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">"Grant"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="anonymous-types"><a class="anchor" href="#anonymous-types">#</a> Anonymous Types</h3><blockquote><p>C#’s anonymous type feature allows you to automatically declare an immutable tuple type by using a very simple and succinct syntax. A tuple type is a type that contains a collection of properties that are usually related to each other in some way.1 In the top line of the following code, I am defining a class with two properties (Name of type String, and Year of type Int32), constructing an instance of this type, and setting its Name property to &quot;Jeff&quot; and its Year property to 1964.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Define a type, construct an instance of it, &amp; initialize its properties</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name"><span class="token keyword">var</span></span> o1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">&#123;</span> Name <span class="token operator">=</span> <span class="token string">"Jeff"</span><span class="token punctuation">,</span> Year <span class="token operator">=</span> <span class="token number">1964</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// Display the properties on the console:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Name=&#123;0&#125;, Year=&#123;1&#125;"</span><span class="token punctuation">,</span> o1<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> o1<span class="token punctuation">.</span>Year<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Displays: Name=Jeff, Year=1964</span></pre></td></tr></table></figure><blockquote><p>This top line of code creates an anonymous type because I did not specify a type name after the new keyword, so the compiler will create a type name for me automatically and not tell me what it is (which is why it is called an anonymous type). The line of code uses the object initializer syntax discussed in the previous section to declare the properties and also to initialize these properties. Also, because I (the developer) do not know the name of the type at compile time, I do not know what type to declare the variable o1 as. However, this is not a problem, because I can use C#’s implicitly typed local variable feature (var), as discussed in Chapter 9, “Parameters,” to have the compiler infer the type from the expression on the right of the assignment operator (=).</p></blockquote><blockquote><p>Now, let’s focus on what the compiler is actually doing. When you write a line of code like this:</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token keyword">var</span></span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">&#123;</span> property1 <span class="token operator">=</span> expression1<span class="token punctuation">,</span> <span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">,</span> propertyN <span class="token operator">=</span> expressionN <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>the compiler infers the type of each expression, creates private fields of these inferred types, creates public read-only properties for each of the fields, and creates a constructor that accepts all these expressions. The constructor’s code initializes the private read-only fields from the expression results passed in to it. In addition, the compiler overrides Object’s Equals, GetHashCode, and ToString methods and generates code inside all these methods. In effect, the class that the compiler generates looks like the following.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">CompilerGenerated</span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token operator">&lt;</span><span class="token operator">></span>f__AnonymousType0<span class="token operator">&lt;</span><span class="token range operator">..</span><span class="token punctuation">.</span><span class="token operator">></span><span class="token punctuation">:</span> Object <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">t1</span> f1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">t1</span> p1 <span class="token punctuation">&#123;</span> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> f1<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">tn</span> fn<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">tn</span> pn <span class="token punctuation">&#123;</span> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> fn<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token operator">&lt;</span><span class="token operator">></span><span class="token generic-method"><span class="token function">f__AnonymousType0</span><span class="token generic class-name"><span class="token punctuation">&lt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">t1</span> a1<span class="token punctuation">,</span> <span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token class-name">tn</span> an<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> f1 <span class="token operator">=</span> a1<span class="token punctuation">;</span> <span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">;</span> fn <span class="token operator">=</span> an<span class="token punctuation">;</span> <span class="token comment">// Set all fields</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name">Boolean</span> <span class="token function">Equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// Return false if any fields don't match; else true</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name">Int32</span> <span class="token function">GetHashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// Returns a hash code generated from each fields' hash code</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name">String</span> <span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token comment">// Return comma-separated set of property name = value pairs</span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The compiler generates Equals and GetHashCode methods so that instances of the anonymous type can be placed in a hash table collection. The properties are readonly as opposed to read/write to help prevent the object’s hashcode from changing. Changing the hashcode for an object used as a key in a hashtable can prevent the object from being found. The compiler generates the ToString method to help with debugging. In the Visual Studio debugger, you can place the mouse cursor over a variable that refers to an instance of an anonymous type, and Visual Studio will invoke the ToString method and show the resulting string in a datatip window. By the way, Visual Studio’s IntelliSense will suggest the property names as you write code in the editor—a very nice feature.</p></blockquote><blockquote><p>The compiler supports two additional syntaxes for declaring a property inside an anonymous type where it can infer the property names and types from variables.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">String</span> Name <span class="token operator">=</span> <span class="token string">"Grant"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">DateTime</span> dt <span class="token operator">=</span> DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// Anonymous type with two properties</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 1. String Name property set to Grant</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 2. Int32 Year property set to the year inside the dt</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token class-name"><span class="token keyword">var</span></span> o2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">&#123;</span> Name<span class="token punctuation">,</span> dt<span class="token punctuation">.</span>Year <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>In this example, the compiler determines that the first property should be called Name. Because Name is the name of a local variable, the compiler sets the type of the property to be the same type as the local variable: String. For the second property, the compiler uses the name of the field/property: Year. Year is an Int32 property of the DateTime class, and therefore the Year property in the anonymous type will also be an Int32. Now, when the compiler constructs an instance of this anonymous type, it will set the instance’s Name property to the same value that is in the Name local variable so the Name property will refer to the same &quot;Grant&quot; string. The compiler will set the instance’s Year property to the same value that is returned from dt’s Year property.</p></blockquote><blockquote><p>The compiler is very intelligent about defining anonymous types. If the compiler sees that you are defining multiple anonymous types in your source code that have the identical structure, the compiler will create just one definition for the anonymous type and create multiple instances of that type. By “same structure,” I mean that the anonymous types have the same type and name for each property and that these properties are specified in the same order. In the preceding code examples, the type of variable o1 and the type of variable o2 will be the same type because the two lines of code are defining an anonymous type with a Name/String property and a Year/Int32 property, and Name comes before Year.</p></blockquote><blockquote><p>Because the two variables are of the same type, we get to do some cool things, such as checking whether the two objects contain equal values and assigning a reference to one object into the other’s variable, as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// One type allows equality and assignment operations.</span></pre></td></tr><tr><td data-num="2"></td><td><pre>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Objects are equal: "</span> <span class="token operator">+</span> o1<span class="token punctuation">.</span><span class="token function">Equals</span><span class="token punctuation">(</span>o2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>o1 <span class="token operator">=</span> o2<span class="token punctuation">;</span> <span class="token comment">// Assignment</span></pre></td></tr></table></figure><blockquote><p>Also, because of this type identity, we can create an implicitly typed array (discussed in the “Initializing Array Elements” section in Chapter 16, “Arrays”) of anonymous types.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// This works because all of the objects are of the same anonymous type</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name"><span class="token keyword">var</span></span> people <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> o1<span class="token punctuation">,</span> <span class="token comment">// From earlier in this section</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">new</span> <span class="token punctuation">&#123;</span> Name <span class="token operator">=</span> <span class="token string">"Kristin"</span><span class="token punctuation">,</span> Year <span class="token operator">=</span> <span class="token number">1970</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">new</span> <span class="token punctuation">&#123;</span> Name <span class="token operator">=</span> <span class="token string">"Aidan"</span><span class="token punctuation">,</span> Year <span class="token operator">=</span> <span class="token number">2003</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">new</span> <span class="token punctuation">&#123;</span> Name <span class="token operator">=</span> <span class="token string">"Grant"</span><span class="token punctuation">,</span> Year <span class="token operator">=</span> <span class="token number">2008</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// This shows how to walk through the array of anonymous types (var is required)</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> person <span class="token keyword">in</span> people<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Person=&#123;0&#125;, Year=&#123;1&#125;"</span><span class="token punctuation">,</span> person<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> person<span class="token punctuation">.</span>Year<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>Anonymous types are most commonly used with the Language Integrated Query (LINQ) technology, where you perform a query that results in a collection of objects that are all of the same anonymous type. Then, you process the objects in the resulting collection. All this takes place in the same method. Here is an example that returns all the files in my document directory that have been modified within the past seven days.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">String</span> myDocuments <span class="token operator">=</span> Environment<span class="token punctuation">.</span><span class="token function">GetFolderPath</span><span class="token punctuation">(</span>Environment<span class="token punctuation">.</span>SpecialFolder<span class="token punctuation">.</span>MyDocuments<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name"><span class="token keyword">var</span></span> query <span class="token operator">=</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">from</span> pathname <span class="token keyword">in</span> Directory<span class="token punctuation">.</span><span class="token function">GetFiles</span><span class="token punctuation">(</span>myDocuments<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">let</span> LastWriteTime <span class="token operator">=</span> File<span class="token punctuation">.</span><span class="token function">GetLastWriteTime</span><span class="token punctuation">(</span>pathname<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">where</span> <span class="token class-name">LastWriteTime</span> <span class="token operator">></span> <span class="token punctuation">(</span>DateTime<span class="token punctuation">.</span>Now <span class="token operator">-</span> TimeSpan<span class="token punctuation">.</span><span class="token function">FromDays</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">orderby</span> LastWriteTime</pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">select</span> <span class="token keyword">new</span> <span class="token punctuation">&#123;</span> Path <span class="token operator">=</span> pathname<span class="token punctuation">,</span> LastWriteTime <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// Set of anonymous type objects</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> file <span class="token keyword">in</span> query<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"LastWriteTime=&#123;0&#125;, Path=&#123;1&#125;"</span><span class="token punctuation">,</span> file<span class="token punctuation">.</span>LastWriteTime<span class="token punctuation">,</span> file<span class="token punctuation">.</span>Path<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>Instances of anonymous types are not supposed to leak outside of a method. A method cannot be prototyped as accepting a parameter of an anonymous type because there is no way to specify the anonymous type. Similarly, a method cannot indicate that it returns a reference to an anonymous type. Although it is possible to treat an instance of an anonymous type as an Object (because all anonymous types are derived from Object), there is no way to cast a variable of type Object back into an anonymous type because you don’t know the name of the anonymous type at compile time. If you want to pass a tuple around, then you should consider using the <code>System.Tuple</code> type discussed in the next section.</p></blockquote><h3 id="the-systemtuple-type"><a class="anchor" href="#the-systemtuple-type">#</a> The System.Tuple Type</h3><blockquote><p>In the System namespace, Microsoft has defined several generic Tuple types (all derived from Object) that differ by arity (the number of generic parameters). Here is what the simplest and most complex ones essentially look like.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// This is the simplest:</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">[</span>Serializable<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Tuple<span class="token punctuation">&lt;</span>T1<span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">T1</span> m_Item1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Tuple</span><span class="token punctuation">(</span><span class="token class-name">T1</span> item1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> m_Item1 <span class="token operator">=</span> item1<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">T1</span> Item1 <span class="token punctuation">&#123;</span> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> m_Item1<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// This is the most complex:</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Serializable</span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Tuple<span class="token punctuation">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">,</span> T3<span class="token punctuation">,</span> T4<span class="token punctuation">,</span> T5<span class="token punctuation">,</span> T6<span class="token punctuation">,</span> T7<span class="token punctuation">,</span> TRest<span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">T1</span> m_Item1<span class="token punctuation">;</span> <span class="token keyword">private</span> <span class="token class-name">T2</span> m_Item2<span class="token punctuation">;</span> <span class="token keyword">private</span> <span class="token class-name">T3</span> m_Item3<span class="token punctuation">;</span> <span class="token keyword">private</span> <span class="token class-name">T4</span> m_Item4<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">T5</span> m_Item5<span class="token punctuation">;</span> <span class="token keyword">private</span> <span class="token class-name">T6</span> m_Item6<span class="token punctuation">;</span> <span class="token keyword">private</span> <span class="token class-name">T7</span> m_Item7<span class="token punctuation">;</span> <span class="token keyword">private</span> <span class="token class-name">TRest</span> m_Rest<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Tuple</span><span class="token punctuation">(</span><span class="token class-name">T1</span> item1<span class="token punctuation">,</span> <span class="token class-name">T2</span> item2<span class="token punctuation">,</span> <span class="token class-name">T3</span> item3<span class="token punctuation">,</span> <span class="token class-name">T4</span> item4<span class="token punctuation">,</span> <span class="token class-name">T5</span> item5<span class="token punctuation">,</span> <span class="token class-name">T6</span> item6<span class="token punctuation">,</span> <span class="token class-name">T7</span> item7<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token class-name">TRest</span> rest<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> m_Item1 <span class="token operator">=</span> item1<span class="token punctuation">;</span> m_Item2 <span class="token operator">=</span> item2<span class="token punctuation">;</span> m_Item3 <span class="token operator">=</span> item3<span class="token punctuation">;</span> m_Item4 <span class="token operator">=</span> item4<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre> m_Item5 <span class="token operator">=</span> item5<span class="token punctuation">;</span> m_Item6 <span class="token operator">=</span> item6<span class="token punctuation">;</span> m_Item7 <span class="token operator">=</span> item7<span class="token punctuation">;</span> m_Rest <span class="token operator">=</span> rest<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">T1</span> Item1 <span class="token punctuation">&#123;</span> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> m_Item1<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">T2</span> Item2 <span class="token punctuation">&#123;</span> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> m_Item2<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">T3</span> Item3 <span class="token punctuation">&#123;</span> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> m_Item3<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">T4</span> Item4 <span class="token punctuation">&#123;</span> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> m_Item4<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">T5</span> Item5 <span class="token punctuation">&#123;</span> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> m_Item5<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">T6</span> Item6 <span class="token punctuation">&#123;</span> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> m_Item6<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">T7</span> Item7 <span class="token punctuation">&#123;</span> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> m_Item7<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">TRest</span> Rest <span class="token punctuation">&#123;</span> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> m_Rest<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Like anonymous types, after a Tuple is created, it is immutable (all properties are read-only). I don’t show it here, but the Tuple classes also offer CompareTo, Equals, GetHashCode, and ToString methods, as well as a Size property. In addition, all the Tuple types implement the <code>IStructuralEquatable</code> , <code>IStructuralComparable</code> , and <code>IComparable</code> interfaces so that you can compare two Tuple objects with each other to see how their fields compare with each other. Refer to the SDK documentation to learn more about these methods and interfaces</p></blockquote><blockquote><p>Here is an example of a method that uses a Tuple type to return two pieces of information to a caller.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Returns minimum in Item1 &amp; maximum in Item2</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name">Tuple<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">,</span> Int32<span class="token punctuation">></span></span> <span class="token function">MinMax</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> a<span class="token punctuation">,</span> <span class="token class-name">Int32</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Tuple<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">,</span> Int32<span class="token punctuation">></span></span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">Min</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">Max</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// This shows how to call the method and how to use the returned Tuple</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">TupleTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> minmax <span class="token operator">=</span> <span class="token function">MinMax</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Min=&#123;0&#125;, Max=&#123;1&#125;"</span><span class="token punctuation">,</span> minmax<span class="token punctuation">.</span>Item1<span class="token punctuation">,</span> minmax<span class="token punctuation">.</span>Item2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Min=2, Max=6</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Of course, it is very important that the producer and consumer of the Tuple have a clear understanding of what is being returned in the Item# properties. With anonymous types, the properties are given actual names based on the source code that defines the anonymous type. With Tuple types, the properties are assigned their Item# names by Microsoft and you cannot change this at all. Unfortunately, these names have no real meaning or significance, so it is up to the producer and consumer to assign meanings to them. This also reduces code readability and maintainability so you should add comments to your code explaining what the producer/consumer understanding is.</p></blockquote><blockquote><p>The compiler can only infer generic types when calling a generic method, not when you are calling a constructor. For this reason, the System namespace also includes a non-generic, static Tuple class containing a bunch of static Create methods that can infer generic types from arguments. This class acts as a factory for creating Tuple objects, and it exists simply to simplify your code. Here is a rewrite of the <code>MinMax</code> method shown earlier using the static Tuple class.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Returns minimum in Item1 &amp; maximum in Item2</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name">Tuple<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">,</span> Int32<span class="token punctuation">></span></span> <span class="token function">MinMax</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> a<span class="token punctuation">,</span> <span class="token class-name">Int32</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">return</span> Tuple<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">Min</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">Max</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Simpler syntax</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>If you want to create a Tuple with more than <span class="token class-name">eight</span> elements <span class="token keyword">in</span> it<span class="token punctuation">,</span> then you would pass another </pre></td></tr><tr><td data-num="6"></td><td><pre>Tuple <span class="token keyword">for</span> the Rest parameter <span class="token keyword">as</span> <span class="token class-name">follows<span class="token punctuation">.</span></span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">var</span> t <span class="token operator">=</span> Tuple<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> Tuple<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"&#123;0&#125;, &#123;1&#125;, &#123;2&#125;, &#123;3&#125;, &#123;4&#125;, &#123;5&#125;, &#123;6&#125;, &#123;7&#125;, &#123;8&#125;"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="9"></td><td><pre> t<span class="token punctuation">.</span>Item1<span class="token punctuation">,</span> t<span class="token punctuation">.</span>Item2<span class="token punctuation">,</span> t<span class="token punctuation">.</span>Item3<span class="token punctuation">,</span> t<span class="token punctuation">.</span>Item4<span class="token punctuation">,</span> t<span class="token punctuation">.</span>Item5<span class="token punctuation">,</span> t<span class="token punctuation">.</span>Item6<span class="token punctuation">,</span> t<span class="token punctuation">.</span>Item7<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> t<span class="token punctuation">.</span>Rest<span class="token punctuation">.</span>Item1<span class="token punctuation">.</span>Item1<span class="token punctuation">,</span> t<span class="token punctuation">.</span>Rest<span class="token punctuation">.</span>Item1<span class="token punctuation">.</span>Item2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>💡注意：除了匿名类型和 <code>Tuple</code> 类型，还可研究一下 <code>System.Dynamic.ExpandoObject</code> 类 (在 <code>System.Core.dll</code> 程序集中定义)。这个类和 C# 的 <code>dynamic</code> 类型 (参见 5.5 节 “ <code>dynamic</code> 基元类型”) 配合使用，就可用另一种方式将一系列属性 (键 / 值对) 组合到一起。虽然实现不了编译时的类型安全性，但语法看起来不错 (虽然得不到 “智能感知” 支持)，而且还可以在 C# 和 Python 这样的动态语言之间传递 <code>ExpandoObject</code> 对象。以下是使用了一个 <code>ExpandoObject</code> 的示例代码：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token keyword">dynamic</span></span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">System<span class="token punctuation">.</span>Dynamic<span class="token punctuation">.</span>ExpandoObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>e<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token comment">// Add an Int32 'x' property whose value is 6</span></pre></td></tr><tr><td data-num="3"></td><td><pre>e<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token string">"Jeff"</span><span class="token punctuation">;</span> <span class="token comment">// Add a String 'y' property whose value is "Jeff"</span></pre></td></tr><tr><td data-num="4"></td><td><pre>e<span class="token punctuation">.</span>z <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// Add an Object 'z' property whose value is null</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// See all the properties and their values:</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> v <span class="token keyword">in</span> <span class="token punctuation">(</span>IDictionary<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Key=&#123;0&#125;, V=&#123;1&#125;"</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span>Key<span class="token punctuation">,</span> v<span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// Remove the 'x' property and its value</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token class-name"><span class="token keyword">var</span></span> d <span class="token operator">=</span> <span class="token punctuation">(</span>IDictionary<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span><span class="token punctuation">)</span>e<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>d<span class="token punctuation">.</span><span class="token function">Remove</span><span class="token punctuation">(</span><span class="token string">"x"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>💡小结：面向对象设计和编程的重要原则之一就是数据封装，意味着类型的字段永远不应该公开，否则很容易因为不恰当使用字段而破坏对象的状态。强烈建议将所有字段都设为 private。要允许用户或类型获取或设置状态信息，就公开一个针对该用途的方法。封装了字段访问的方法通常称为访问器（accessor）方法。访问器方法可选择对数据的合理性进行检查，确保对象的状态永远不被破环。但是，像这样进行数据封装有两个缺点。首先，因为不得不实现额外的方法，所以必须写更多的代码；其次，类型的用户必须调用方法，而不能直接引用字段名。属性允许源代码用简化语法来调用方法。它缓解了第一个缺点所造成的影响，同时完全消除了第二个缺点。CLR 支持两种属性：无参属性，平时说的属性就是指它；有参属性，它在不同的编程语言中有不同的称呼。例如，C# 将有参属性成为索引器，Microsoft Visual Basic 将有参属性称为默认属性。可将属性想象成智能字段，即背后有额外逻辑的字段。CLR 支持静态、实例、抽象和虚属性。另外，属性可用任意 “可访问性” 修饰符来标记，而且可以在接口中定义。每个属性都有名称和类型（类型不能是 void）。属性不能重载，即不能定义名称相同、类型不同的两个属性。定义属性时通常同时指定 get 和 set 两个方法。但可省略 set 方法来定义只读属性，或省略 get 方法来定义只写属性。经常利用属性的 get 和 set 方法操纵类型中定义的私有字段。私有字段通常称为支持字段（backing field）。但 get 和 set 方法并非一定要访问支持字段。编译器在你指定的属性名之前自动附加 get_和 set_前缀来生成方法名。C# 内建了对属性的支持。除了生成访问器方法，针对源代码中定义的每一个属性，编译器还会再托管程序集的元数据中生成一个属性定义项。在这个记录项中，包含了一些标志（flags）以及属性的类型。另外，它还引用了 get 和 set 访问器方法。CLR 不使用这种元数据信息，在运行时只需要访问器方法。如果只是为了封装一个支持字段而创建属性，C# 还提供了一种更简洁的语法，称为自动实现的属性（AIP）。声明属性而不提供 get/set 方法的实现，C# 会自动为你声明一个私有字段。使用 AIP，意味着你已经创建了一个属性。访问该属性的任何代码实际都会调用 get 和 set 方法。如果以后决定自己实现 get 和 / 或 set 方法，而不是接受编译器的默认实现，访问属性的任何代码都不必重新编译。但是 AIP 也有一些缺点，例如没有简单的语法初始化 AIP。所以，必须在每个构造器方法中显式初始化每个 AIP。此外，AIP 的支持字段名称由编译器决定，每次重新编译代码都可能更改这个名称。因此，任何类型只要含有一个 AIP，就没办法对该类型的实例进行反序列化。在任何想要序列化或反序列化的类型中，都不要使用 AIP 功能。还要注意，如果使用 AIP，属性必然是可读和可写的。换言之，编译器肯定同时生成 get 和 set 方法。换言之，AIP 是作用于整个属性的；要么都用，要么都不用。不能显式实现一个访问器方法，而让另一个自动实现。属性和字段之间存在一些区别，例如，属性不能作为 out 或 ref 参数传给方法，而字段可以。属性方法可能花较长时间执行，字段访问则总是立即完成。属性唯一的好处就是提供了简化的语法。和调用普通方法（非属性中的方法）相比，属性不仅不会提升代码的性能，还会妨碍对代码的理解。C# 语言支持一种特殊的对象之中特殊的对象初始化语法（用花括号初始公共属性（或字段））。如果想调用的本来就是一个无参构造器，C# 还允许省略起始大括号之前的圆括号。如果属性的类型实现了 <code>IEnumerable</code> 或 <code>IEnumerable&lt;T&gt;</code> 接口，属性就被认为是集合，而集合的初始化是一种相加（additive）操作，而非替换（replacement）操作。如果属性的类型实现了 <code>IEnumerable或IEnumerable&lt;T&gt;</code> ，但未提供 Add 方法，编译器就不允许使用集合初始化语法向集合中添加数据项。通过在集合初始化器中嵌套大括号的方式，可向 Add 方法传递多个实参。利用 C# 的匿名类型功能，可以用很简洁的语法来自动声明不可变（immutable）的元组类型。元组类型是含有一组属性的类型，这些属性通常以某种方式相互关联。编译器会推断每个表达式的类型，创建推断类型的私有字段，为每个字段创建公开只读属性，并创建一个构造器来接受所有这些表达式。在构造器的代码中，会用传给它的表达式的求值结果来初始化私有只读字段。除此之外，编译器还会重写 Object 的 Equals，GetHashCode 和 ToString 方法，并生成所有这些方法的代码。编译器会生成 Equals 和 GetHashCode 方法，因此匿名类型的实例能放到哈希表集合中。属性是只读的，而非可读可写，目的是防止对象的哈希码发生改变。编译器在定义匿名类型时是非常 “善解人意” 的。如果它看到你在源代码中定义了多个匿名类型，而且这些类型具有相同的结构，那么它只会创建一个匿名类型定义，但创建该类型的多个实例。另外，由于这种类型的同一性，所以可以创建一个隐式类型的数组，在其中包含一组匿名类型的对象。匿名类型经常与 LINQ 配合使用。可用 LINQ 执行查询，从而生成一组对象构成的集合，这些对象都是相同的匿名类型。然后可以对结果集合中的对象进行处理。虽然可以将匿名类型的实例视为一个 Object（所有匿名类型都从 Object 派生），但没办法将 Object 类型的变量转型回匿名类型，因为不知道在匿名类型在编译时的名称。和匿名类型相似，Tuple 创建好之后就不可变了（所有属性都只读）。对于匿名类型，属性的实际名称是根据定义匿名类型的源代码来确定的。对于 Tuple 类型，属性一律被 Microsoft 称为 Item#，我们无法对此进行任何改变。所以，应该在自己的代码添加详细的注释，说明每个 Item# 代表着什么。编译器只能在调用泛型方法时推断泛型类型，调用构造器时不能。因此，System 命名空间还包含了一个非泛型静态 Tuple 类，其中包含一组静态 Create 方法，能根据实参推断泛型类型。</p><h2 id="parameterful-properties"><a class="anchor" href="#parameterful-properties">#</a> Parameterful Properties</h2><blockquote><p>In the previous section, the get accessor methods for the properties accepted no parameters. For this reason, I called these properties parameterless properties. These properties are easy to understand because they have the feel of accessing a field. In addition to these field-like properties, programming languages also support what I call parameterful properties, whose get accessor methods accept one or more parameters and whose set accessor methods accept two or more parameters. Different programming languages expose parameterful properties in different ways. Also, languages use different terms to refer to parameterful properties: C# calls them indexers and Visual Basic calls them default properties. In this section, I’ll focus on how C# exposes its indexers by using parameterful properties.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">BitArray</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// Private array of bytes that hold the bits </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Byte<span class="token punctuation">[</span><span class="token punctuation">]</span></span> m_byteArray<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_numBits<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Constructor that allocates the byte array and sets all bits to 0 </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token function">BitArray</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> numBits<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Validate arguments first. </span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>numBits <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ArgumentOutOfRangeException</span><span class="token punctuation">(</span><span class="token string">"numBits must be > 0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// Save the number of bits. </span></pre></td></tr><tr><td data-num="12"></td><td><pre> m_numBits <span class="token operator">=</span> numBits<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token comment">// Allocate the bytes for the bit array. </span></pre></td></tr><tr><td data-num="14"></td><td><pre> m_byteArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Byte</span><span class="token punctuation">[</span><span class="token punctuation">(</span>numBits <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token comment">// This is the indexer (parameterful property). </span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Boolean</span> <span class="token keyword">this</span><span class="token punctuation">[</span><span class="token class-name">Int32</span> bitPos<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token comment">// This is the indexer's get accessor method. </span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token comment">// Validate arguments first </span></pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bitPos <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>bitPos <span class="token operator">>=</span> m_numBits<span class="token punctuation">)</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ArgumentOutOfRangeException</span><span class="token punctuation">(</span><span class="token string">"bitPos"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token comment">// Return the state of the indexed bit. </span></pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token keyword">return</span> <span class="token punctuation">(</span>m_byteArray<span class="token punctuation">[</span>bitPos <span class="token operator">/</span> <span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>bitPos <span class="token operator">%</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token comment">// This is the indexer's set accessor method. </span></pre></td></tr><tr><td data-num="27"></td><td><pre> <span class="token keyword">set</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="28"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bitPos <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>bitPos <span class="token operator">>=</span> m_numBits<span class="token punctuation">)</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="29"></td><td><pre> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ArgumentOutOfRangeException</span><span class="token punctuation">(</span><span class="token string">"bitPos"</span><span class="token punctuation">,</span> bitPos<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="30"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="31"></td><td><pre> <span class="token comment">// Turn the indexed bit on. </span></pre></td></tr><tr><td data-num="32"></td><td><pre> m_byteArray<span class="token punctuation">[</span>bitPos <span class="token operator">/</span> <span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>Byte<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="33"></td><td><pre> <span class="token punctuation">(</span>m_byteArray<span class="token punctuation">[</span>bitPos <span class="token operator">/</span> <span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>bitPos <span class="token operator">%</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="34"></td><td><pre> <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="35"></td><td><pre> <span class="token comment">// Turn the indexed bit off. </span></pre></td></tr><tr><td data-num="36"></td><td><pre> m_byteArray<span class="token punctuation">[</span>bitPos <span class="token operator">/</span> <span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>Byte<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="37"></td><td><pre> <span class="token punctuation">(</span>m_byteArray<span class="token punctuation">[</span>bitPos <span class="token operator">/</span> <span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>bitPos <span class="token operator">%</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="38"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="39"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="40"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="41"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Using the BitArray class’s indexer is incredibly simple.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Allocate a BitArray that can hold 14 bits. </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">BitArray</span> ba <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">BitArray</span><span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// Turn all the even-numbered bits on by calling the set accessor. </span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> <span class="token number">14</span><span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> ba<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// Show the state of all the bits by calling the get accessor. </span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> <span class="token number">14</span><span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Bit "</span> <span class="token operator">+</span> x <span class="token operator">+</span> <span class="token string">" is "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>ba<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token punctuation">?</span> <span class="token string">"On"</span> <span class="token punctuation">:</span> <span class="token string">"Off"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In the BitArray example, the indexer takes one Int32 parameter, bitPos. All indexers must have at least one parameter, but they can have more. These parameters (as well as the return type) can be of any data type (except void). An example of an indexer that has more than one parameter can be found in the System.Drawing.Imaging.ColorMatrix class, which ships in the System.Drawing.dll assembly.</p></blockquote><blockquote><p>It’s quite common to create an indexer to look up values in an associative array. In fact, the System.Collections.Generic.Dictionary type offers an indexer that takes a key and returns the value associated with the key. Unlike parameterless properties, a type can offer multiple, overloaded indexers as long as their signatures differ.</p></blockquote><blockquote><p>Like a parameterless property’s set accessor method, an indexer’s set accessor method also contains a hidden parameter, called value in C#. This parameter indicates the new value desired for the “indexed element.”</p></blockquote><blockquote><p>The CLR doesn’t differentiate parameterless properties and parameterful properties; to the CLR, each is simply a pair of methods and a piece of metadata defined within a type. As mentioned earlier, different programming languages require different syntax to create and use parameterful properties. The fact that C# requires this[...] as the syntax for expressing an indexer was purely a choice made by the C# team. What this choice means is that C# allows indexers to be defined only on instances of objects. C# doesn’t offer syntax allowing a developer to define a static indexer property, although the CLR does support static parameterful properties.</p></blockquote><blockquote><p>Because the CLR treats parameterful properties just as it does parameterless properties, the compiler will emit either two or three of the following items into the resulting managed assembly:</p></blockquote><ul><li><p>A method representing the parameterful property’s get accessor method. This is emitted only if you define a get accessor method for the property.</p></li><li><p>A method representing the parameterful property’s set accessor method. This is emitted only if you define a set accessor method for the property.</p></li><li><p>A property definition in the managed assembly’s metadata, which is always emitted. There’s no special parameterful property metadata definition table because, to the CLR, parameterful properties are just properties.</p></li></ul><blockquote><p>For the BitArray class shown earlier, the compiler compiles the indexer as though the original source code were written as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">BitArray</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// This is the indexer's get accessor method. </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Boolean</span> <span class="token function">get_Item</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> bitPos<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* ... */</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// This is the indexer's set accessor method. </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">set_Item</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> bitPos<span class="token punctuation">,</span> <span class="token class-name">Boolean</span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* ... */</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The compiler automatically generates names for these methods by prepending get_ and set_ to the indexer name. Because the C# syntax for an indexer doesn’t allow the developer to specify an indexer name, the C# compiler team had to choose a default name to use for the accessor methods; they chose Item. Therefore, the method names emitted by the compiler are get_Item and set_Item.</p></blockquote><blockquote><p>When examining the .NET Framework Reference documentation, you can tell if a type offers an indexer by looking for a property named Item. For example, the System.Collections.Generic.List type offers a public instance property named Item; this property is List’s indexer.</p></blockquote><blockquote><p>When you program in C#, you never see the name of Item, so you don’t normally care that the compiler has chosen this name for you. However, if you’re designing an indexer for a type that code written in other programming languages will be accessing, you might want to change the default name, Item, given to your indexer’s get and set accessor methods. C# allows you to rename these methods by applying the System.Runtime.CompilerServices.IndexerNameAttribute custom attribute to the indexer. The following code demonstrates how to do this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>CompilerServices</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">BitArray</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">IndexerName</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token string">"Bit"</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Boolean</span> <span class="token keyword">this</span><span class="token punctuation">[</span><span class="token class-name">Int32</span> bitPos<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// At least one accessor method is defined here </span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Now the compiler will emit methods called get_Bit and set_Bit instead of get_Item and set_ Item. When compiling, the C# compiler sees the IndexerName attribute, and this tells the compiler how to name the methods and the property metadata; the attribute itself is not emitted into the assembly’s metadata.</p></blockquote><blockquote><p>Here’s some Visual Basic code that demonstrates how to access this C# indexer.</p></blockquote><figure class="highlight vb"><figcaption data-lang="Visual Basic"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">' Construct an instance of the BitArray type. </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">Dim</span> ba <span class="token keyword">as</span> <span class="token keyword">New</span> BitArray<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">' Visual Basic uses () instead of [] to specify array elements. </span></pre></td></tr><tr><td data-num="5"></td><td><pre>Console<span class="token punctuation">.</span>WriteLine<span class="token punctuation">(</span>ba<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">' Displays True or False </span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">' Visual Basic also allows you to access the indexer by its name. </span></pre></td></tr><tr><td data-num="7"></td><td><pre>Console<span class="token punctuation">.</span>WriteLine<span class="token punctuation">(</span>ba<span class="token punctuation">.</span>Bit<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">' Displays same as previous line</span></pre></td></tr></table></figure><blockquote><p>In C#, a single type can define multiple indexers as long as the indexers all take different parameter sets. In other programming languages, the IndexerName attribute allows you to define multiple indexers with the same signature because each can have a different name. The reason C# won’t allow you to do this is because its syntax doesn’t refer to the indexer by name; the compiler wouldn’t know which indexer you were referring to. Attempting to compile the following C# source code causes the compiler to generate the following message: error C0111: Type 'SomeType' already defines a member called 'this' with the same parameter types.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>CompilerServices</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// Define a get_Item accessor method. </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token keyword">this</span><span class="token punctuation">[</span><span class="token class-name">Boolean</span> b<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Define a get_Jeff accessor method. </span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">IndexerName</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token string">"Jeff"</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">String</span> <span class="token keyword">this</span><span class="token punctuation">[</span><span class="token class-name">Boolean</span> b<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>You can clearly see that C# thinks of indexers as a way to overload the [] operator, and this operator can’t be used to disambiguate parameterful properties with different method names and identical parameter sets.</p></blockquote><blockquote><p>By the way, the System.String type is an example of a type that changed the name of its indexer. The name of String’s indexer is Chars instead of Item. This read-only property allows you to get an individual character within a string. For programming languages that don’t use [] operator syntax to access this property, Chars was decided to be a more meaningful name.</p></blockquote><p><strong>选择主要的有参属性</strong></p><ul><li>如果定义类型的语言允许多个有参属性应该怎么办？</li><li>从 C# 中如何使用这个类型？</li></ul><p>这两个问题的答案是类型必须选择其中一个有参属性名来作为默认 (主要) 属性，这要求向类本身应用 <code>System.Reflection.DefaultMemberAttribute</code> 的一个实例。要说明的是，该特性可应用于类、结构或接口。在 C# 中编译定义了有参属性的实例，同时会考虑到你可能应用了 <code>IndexerName</code> 特性的情况。在 <code>DefaultMemberAttribute</code> 特性的构造器中，指定了要作为类型的默认有参属性使用的名称。</p><p>因此，如果在 C# 中定义包含有参属性的类型，但没有指定 <code>IndexerName</code> 特性，那么在向该类型应用的 <code>DefaultMember</code> 特性中，会将默认成员的名称指定为 <code>Item</code> 。如果向有参属性应用了 <code>IndexerName</code> 特性，那么在向该类型应用的 <code>DefaultMember</code> 特性中，会将默认成员的名称指定为由 <code>IndexerName</code> 特性指定的字符串名称。记住，如果代码中含有多个名称不一样的有参属性，C# 将无法编译。</p><p>对于支持多个有参属性的编程语言，必须从中选择一个属性方法名，并用 <code>DefaultMemeber</code> 特性来标识。这是 C# 代码唯一能访问的有参属性。</p><blockquote><p>When the C# compiler sees code that is trying to get or set an indexer, the compiler actually emits a call to one of these methods. Some programming languages might not support parameterful properties. To access a parameterful property from one of these languages, you must call the desired accessor method explicitly. To the CLR, there’s no difference between parameterless properties and parameterful properties, so you use the same System.Reflection.PropertyInfo class to find the association between a parameterful property and its accessor methods.</p></blockquote><p>💡小结：除了上节讲到的与字段相似的无参属性，编程语言还支持有参属性，它的 get 访问器方法接受一个或多个参数，set 访问器方法接受两个或多个参数。不同编程语言以不同方式公开有参属性。另外，不同变成语言对有参属性的称呼也不同。C# 称为所引起，VB 则称为默认属性。C# 使用数组风格的语法来公开有参属性（索引器）。换句话说，可将索引器看成是 C# 开发人员对 [] 操作符的重载。所有索引器至少要有一个参数，但可以有更多。这些参数（和返回类型）可以是除了 void 之外的任意类型。经常要创建索引器来查询关联数组（关联数组（associative array）使用字符串索引（称为键）来访问存储在数组中的值（称为值））中的值。 <code>System.Collections.Generic.Dictionary</code> 类型就提供了这样的一个索引器，它获取一个键，并返回与该键关联的值。和无参属性不同，类型可提供多个重载的索引器，只要这些索引器的签名不同。和无参的 set 访问器方法相似，索引器的 set 访问器方法同样包含了一个隐藏参数，在 C# 中称为 value。该参数代表想赋给 “被索引元素” 的新值。CLR 本身不区分无参属性和有参属性。对 CLR 来说，每个属性都只是类型中定义的一对方法和一些元数据。将 this [...] 作为表达索引器的语法，这纯粹是 C# 团队自己的选择。也正是因为这个选择，所以 C# 只允许在对象的实例上定义索引器。C# 不支持定义静态索引器属性，虽然 CLR 是支持静态有参属性的。编译器在索引器名称之前附加 get_或者 set_前缀，从而自动生成这些方法的名称。由于 C# 的索引器语法不允许开发人员指定索引器名称，所以 C# 编译器团队不得不为访问器方法选择一个默认名称，这个默认名称是 Item。IndexerName 特性能告诉编译器如何对方法和属性的元数据进行命名。特性本身不会进入程序集的元数据（这个原因造成 <code>IndexerNameAttribute</code> 类不是 CLI 和 C# 语言的 ECMA 标准的一部分）。C# 允许一个类型定义多个索引器，只要索引器的参数集不同。在其他语言中， <code>IndexerName</code> 特性允许定义多个相同签名的索引器，因为索引器各自可以有不同的名称。C# 不允许这样做，是因为它的语法不是通过名称来引用索引器，编译器不知道你引用的是哪个索引器。编译以下 C# 代码将导致编译器报错： <code>error C0111: 类型“SomeType”已定义了一个名为“this”的具有相同参数类型的成员</code> 。C# 将索引器看成是对 <code>[]</code> 操作符的重载，而 <code>[]</code> 操作符不能用来消除具有不同方法名和相同参数集的有参属性的歧义。有的语言不支持有参属性。要从这种语言中访问有参属性，必须显式调用需要的索引器方法。对于 CLR，无参和有参属性是无区别的，所以可用相同的 <code>System.Reflection.PropertyInfo</code> 类来发现有参属性和它的访问器方法之间的关联。</p><h2 id="the-performance-of-calling-property-accessor-methods"><a class="anchor" href="#the-performance-of-calling-property-accessor-methods">#</a> The Performance of Calling Property Accessor Methods</h2><blockquote><p>For simple get and set accessor methods, the just-in-time (JIT) compiler inlines the code so that there’s no run-time performance hit as a result of using properties rather than fields. Inlining is when the code for a method (or accessor method, in this case) is compiled directly in the method that is making the call. This removes the overhead associated with making a call at run time at the expense of making the compiled method’s code bigger. Because property accessor methods typically contain very little code, inlining them can make the native code smaller and can make it execute faster.</p></blockquote><p>💡注意：JIT 编译器在调试代码时不会内联属性方法，因为内联的代码会变得难以调试。这意味着在程序的发型版本中，访问属性时的性能可能比较快；在程序的调试版本中，可能比较慢。字段访问在调式和发布版本中，速度都很快。</p><p>💡小结：对于简单的 get 和 set 访问器方法，JIT 编译器会将代码内联（inline，或者说嵌入）。内联是指将方法的代码直接编译到调用它的方法中。这就避免了在运行时发出调用所产生的开销，代价是编译好的方法变得更大。由于属性访问器方法包含的代码一般很少，所以内联它们会使生成的本机代码变得更小，而且执行得更快。</p><h2 id="property-accessor-accessibility"><a class="anchor" href="#property-accessor-accessibility">#</a> Property Accessor Accessibility</h2><blockquote><p>Occasionally, when designing a type, it is desired to have one accessibility for a get accessor method and a different accessibility for a set accessor method. The most common scenario is to have a public get accessor and a protected set accessor.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">String</span> m_name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">String</span> Name <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> m_name<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">protected</span> <span class="token keyword">set</span> <span class="token punctuation">&#123;</span>m_name <span class="token operator">=</span> <span class="token keyword">value</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>As you can see from the code above, the Name property is itself declared as a public property, and this means that the get accessor method will be public and therefore callable by all code. However, notice that the set accessor is declared as protected and will be callable only from code defined within <code>SomeType</code> or from code in a class that is derived from <code>SomeType</code> .</p></blockquote><blockquote><p>When defining a property with accessor methods that have different accessibilities, C# syntax requires that the property itself must be declared with the least-restrictive accessibility and that more restrictive accessibility be applied to just one of the accessor methods. In the example above, the property is public, and the set accessor is protected (more restrictive than public).</p></blockquote><p>💡小结：定义属性时，如果两个访问器方法需要不同的可访问性，C# 要求必须为属性本身指定限制最小的可访问性。然后，两个访问器只能选择一个来使用限制较大的。在上面的例子中，属性本身声明为 public，而 set 访问器方法声明为 protected（限制较 public 大）。</p><h2 id="generic-property-accessor-methods"><a class="anchor" href="#generic-property-accessor-methods">#</a> Generic Property Accessor Methods</h2><blockquote><p>Because properties are really just methods, and because C# and the CLR allow methods to be generic, sometimes people want to define properties that introduce their own generic type parameters (as opposed to using the enclosing type’s generic type parameter). However, C# does not allow this. The main reason why properties cannot introduce their own generic type parameters is because they don’t make sense conceptually. A property is supposed to represent a characteristic of an object that can be queried or set. Introducing a generic type parameter would mean that the behavior of the querying/setting could be changed, but conceptually, a property is not supposed to have behavior. If you want your object to expose some behavior—generic or not—define a method, not a property.</p></blockquote><p>💡小结：C# 不允许在定义属性时引入它自己的泛型类型参数。属性本来应该表示可供查询的某个对象特征。一旦引入泛型类型的参数，就意味着有可能改变查询 / 设置行为。但属性不应该和行为沾边。公开对象的行为 -- 无论是不是泛型 -- 都应该定义方法而非属性。</p><div class="tags"><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 读书笔记</a> <a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C#</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2022-11-01 14:28:09" itemprop="dateModified" datetime="2022-11-01T14:28:09+08:00">2022-11-01</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Sakupinera WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Sakupinera Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Sakupinera PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Sakupinera <i class="ic i-at"><em>@</em></i>Sakupinera</li><li class="link"><strong>Post link: </strong><a href="http://sakupinera.github.io/2022/10/28/csharp/clr-via-csharp/Chapter%2010%20Properties/" title="CLR via C# - Chapter 10 Properties">http://sakupinera.github.io/2022/10/28/csharp/clr-via-csharp/Chapter 10 Properties/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;03&#x2F;08&#x2F;Qi9cMFjDZq5V3tB.jpg" title="CLR via C# - Chapter 9 Parameters"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 9 Parameters</h3></a></div><div class="item right"><a href="/2022/10/29/csharp/clr-via-csharp/Chapter%2011%20Events/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;03&#x2F;08&#x2F;AOrFYJ8qeP512Sx.jpg" title="CLR via C# - Chapter 11 Events"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 11 Events</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-10-properties"><span class="toc-number">1.</span> <span class="toc-text">Chapter 10 Properties</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#parameterless-properties"><span class="toc-number">1.1.</span> <span class="toc-text">Parameterless Properties</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#automatically-implemented-properties"><span class="toc-number">1.1.1.</span> <span class="toc-text">Automatically Implemented Properties</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defining-properties-intelligently"><span class="toc-number">1.1.2.</span> <span class="toc-text">Defining Properties Intelligently</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#object-and-collection-initializers"><span class="toc-number">1.1.3.</span> <span class="toc-text">Object and Collection Initializers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#anonymous-types"><span class="toc-number">1.1.4.</span> <span class="toc-text">Anonymous Types</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#the-systemtuple-type"><span class="toc-number">1.1.5.</span> <span class="toc-text">The System.Tuple Type</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#parameterful-properties"><span class="toc-number">1.2.</span> <span class="toc-text">Parameterful Properties</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#the-performance-of-calling-property-accessor-methods"><span class="toc-number">1.3.</span> <span class="toc-text">The Performance of Calling Property Accessor Methods</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#property-accessor-accessibility"><span class="toc-number">1.4.</span> <span class="toc-text">Property Accessor Accessibility</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#generic-property-accessor-methods"><span class="toc-number">1.5.</span> <span class="toc-text">Generic Property Accessor Methods</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"><ul><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/" rel="bookmark" title="CLR via C# - Chapter 1 The CLR’s Execution Model">CLR via C# - Chapter 1 The CLR’s Execution Model</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/" rel="bookmark" title="CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types">CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%203%20Shared%20Assemblies%20and%20Strongly%20Named%20Assemblies/" rel="bookmark" title="CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies">CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies</a></li><li><a href="/2022/09/27/csharp/clr-via-csharp/Chapter%204%20Type%20Fundamentals/" rel="bookmark" title="CLR via C# - Chapter 4 Type Fundamentals">CLR via C# - Chapter 4 Type Fundamentals</a></li><li><a href="/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/" rel="bookmark" title="CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals">CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals</a></li><li><a href="/2022/10/21/csharp/clr-via-csharp/Chapter%206%20Type%20and%20Member%20Basics/" rel="bookmark" title="CLR via C# - Chapter 6 Type and Member Basics">CLR via C# - Chapter 6 Type and Member Basics</a></li><li><a href="/2022/10/24/csharp/clr-via-csharp/Chapter%207%20Constants%20and%20Fields/" rel="bookmark" title="CLR via C# - Chapter 7 Constants and Fields">CLR via C# - Chapter 7 Constants and Fields</a></li><li><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" rel="bookmark" title="CLR via C# - Chapter 8 Methods">CLR via C# - Chapter 8 Methods</a></li><li><a href="/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/" rel="bookmark" title="CLR via C# - Chapter 9 Parameters">CLR via C# - Chapter 9 Parameters</a></li><li class="active"><a href="/2022/10/28/csharp/clr-via-csharp/Chapter%2010%20Properties/" rel="bookmark" title="CLR via C# - Chapter 10 Properties">CLR via C# - Chapter 10 Properties</a></li><li><a href="/2022/10/29/csharp/clr-via-csharp/Chapter%2011%20Events/" rel="bookmark" title="CLR via C# - Chapter 11 Events">CLR via C# - Chapter 11 Events</a></li><li><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" rel="bookmark" title="CLR via C# - Chapter 12 Generics">CLR via C# - Chapter 12 Generics</a></li><li><a href="/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/" rel="bookmark" title="CLR via C# - Chapter 13 Interfaces">CLR via C# - Chapter 13 Interfaces</a></li><li><a href="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/" rel="bookmark" title="CLR via C# - Chapter 14 Chars, Strings, and Working with Text">CLR via C# - Chapter 14 Chars, Strings, and Working with Text</a></li><li><a href="/2022/11/17/csharp/clr-via-csharp/Chapter%2015%20Enumerated%20Types%20and%20Bit%20Flags/" rel="bookmark" title="CLR via C# - Chapter 15 Enumerated Types and Bit Flags">CLR via C# - Chapter 15 Enumerated Types and Bit Flags</a></li><li><a href="/2022/11/19/csharp/clr-via-csharp/Chapter%2016%20Arrays/" rel="bookmark" title="CLR via C# - Chapter 16 Arrays">CLR via C# - Chapter 16 Arrays</a></li><li><a href="/2022/11/21/csharp/clr-via-csharp/Chapter%2017%20Delegates/" rel="bookmark" title="CLR via C# - Chapter 17 Delegates">CLR via C# - Chapter 17 Delegates</a></li><li><a href="/2022/11/22/csharp/clr-via-csharp/Chapter%2018%20Custom%20Attributes/" rel="bookmark" title="CLR via C# - Chapter 18 Custom Attributes">CLR via C# - Chapter 18 Custom Attributes</a></li><li><a href="/2022/11/23/csharp/clr-via-csharp/Chapter%2019%20Nullable%20Value%20Types/" rel="bookmark" title="CLR via C# - Chapter 19 Nullable Value Types">CLR via C# - Chapter 19 Nullable Value Types</a></li><li><a href="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/" rel="bookmark" title="CLR via C# - Chapter 20 Exceptions and State Management">CLR via C# - Chapter 20 Exceptions and State Management</a></li><li><a href="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/" rel="bookmark" title="CLR via C# - Chapter 21 The Managed Heap and Garbage  Collection">CLR via C# - Chapter 21 The Managed Heap and Garbage Collection</a></li><li><a href="/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/" rel="bookmark" title="CLR via C# - Chapter 22 CLR Hosting and AppDomains">CLR via C# - Chapter 22 CLR Hosting and AppDomains</a></li><li><a href="/2022/11/29/csharp/clr-via-csharp/Chapter%2023%20Assembly%20Loading%20and%20Reflection/" rel="bookmark" title="CLR via C# - Chapter 23 Assembly Loading and Reflection">CLR via C# - Chapter 23 Assembly Loading and Reflection</a></li><li><a href="/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/" rel="bookmark" title="CLR via C# - Chapter 24 Runtime Serialization">CLR via C# - Chapter 24 Runtime Serialization</a></li><li><a href="/2022/12/06/csharp/clr-via-csharp/Chapter%2025%20Interoperating%20with%20WinRT%20%20Components/" rel="bookmark" title="CLR via C# - Chapter 25 Interoperating with WinRT Components">CLR via C# - Chapter 25 Interoperating with WinRT Components</a></li><li><a href="/2023/02/06/csharp/clr-via-csharp/Chapter%2026%20Thread%20Basics/" rel="bookmark" title="CLR via C# - Chapter 26 Thread Basics">CLR via C# - Chapter 26 Thread Basics</a></li><li><a href="/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations">CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations</a></li><li><a href="/2023/02/08/csharp/clr-via-csharp/Chapter%2028%20IO-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 28 IO-Bound Asynchronous Operations">CLR via C# - Chapter 28 IO-Bound Asynchronous Operations</a></li><li><a href="/2023/02/09/csharp/clr-via-csharp/Chapter%2029%20Primitive%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 29 Primitive Thread Synchronization">CLR via C# - Chapter 29 Primitive Thread Synchronization</a></li><li><a href="/2023/02/10/csharp/clr-via-csharp/Chapter%2030%20Hybrid%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 30 Hybrid Thread Synchronization">CLR via C# - Chapter 30 Hybrid Thread Synchronization</a></li></ul></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sakupinera" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Sakupinera</p><div class="description" itemprop="description">保持你的决心！</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">86</span> <span class="name">posts</span></a></div><div class="item categories"><a href="/categories/"><span class="count">13</span> <span class="name">categories</span></a></div><div class="item tags"><a href="/tags/"><span class="count">6</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nha3VwaW5lcmE=" title="https:&#x2F;&#x2F;github.com&#x2F;sakupinera"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9zYWt1cGluZXJh" title="https:&#x2F;&#x2F;twitter.com&#x2F;sakupinera"><i class="ic i-twitter"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQwNzIyOTA3MQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;407229071"><i class="ic i-cloud-music"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMjIzMDczOTg/c3BtX2lkX2Zyb209MzMzLjEwMDcuMC4w" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;22307398?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li><li class="item"><a href="/games/" rel="section"><i class="ic i-flag"></i>Games</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-person"></i>About</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/10/29/csharp/clr-via-csharp/Chapter%2011%20Events/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/09/27/csharp/clr-via-csharp/Chapter%204%20Type%20Fundamentals/" title="CLR via C# - Chapter 4 Type Fundamentals">CLR via C# - Chapter 4 Type Fundamentals</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CMake/" title="In CMake">CMake</a></div><span><a href="/2022/08/28/cmake/CMake/" title="CMake">CMake</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/09/05/linux/learn-linux/%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/" title="LearnLinux - 备份与恢复">LearnLinux - 备份与恢复</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/08/28/linux/learn-linux/%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/" title="LearnLinux - 软件包管理">LearnLinux - 软件包管理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2022/12/11/cpp/cpp-primer/Chapter%203%20Strings,%20Vectors,%20and%20Arrays/" title="C++ Primer - Chapter 3 Strings, Vectors, and Arrays">C++ Primer - Chapter 3 Strings, Vectors, and Arrays</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/10/28/csharp/clr-via-csharp/Chapter%2010%20Properties/" title="CLR via C# - Chapter 10 Properties">CLR via C# - Chapter 10 Properties</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/" title="CLR via C# - Chapter 14 Chars, Strings, and Working with Text">CLR via C# - Chapter 14 Chars, Strings, and Working with Text</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/" title="CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types">CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Design-Patterns/" title="In Design-Patterns">Design-Patterns</a></div><span><a href="/2023/03/20/cpp/design-patterns/Design%20Patterns/" title="设计模式（Design Patterns）">设计模式（Design Patterns）</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/08/28/hello-world/" title="Hello World">Hello World</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Sakupinera @ Hanamai Sora</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="Symbols count total">2.2m words</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="Reading time total">33:30</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/10/28/csharp/clr-via-csharp/Chapter 10 Properties/",favicon:{show:"（●´3｀●）Goooood",hide:"(´Д｀)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/shifuku.model.json"},display:{position:"left",width:250,height:500},mobile:{show:!1},react:{opacity:.9},log:!1})</script></body></html>