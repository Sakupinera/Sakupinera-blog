<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sakupinera" href="http://sakupinera.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sakupinera" href="http://sakupinera.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sakupinera" href="http://sakupinera.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="è¯»ä¹¦ç¬”è®°,C#"><link rel="canonical" href="http://sakupinera.github.io/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/"><title>CLR via C# - Chapter 8 Methods - CLR-via-CSharp - CSharp | Hanamai Sora = Sakupinera</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">CLR via C# - Chapter 8 Methods</h1><div class="meta"><span class="item" title="Created: 2022-10-25 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2022-10-25T00:00:00+08:00">2022-10-25</time> </span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">Symbols count in article</span> <span>54k</span> <span class="text">words</span> </span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">Reading time</span> <span>49 mins.</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hanamai Sora</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipetfk5zwj20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclj61ylzj20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclh0m9pdj20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipetv6p75j20zk0m8x6p.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclgrvbd6j20zk0m8qv5.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipetlbztpj20zk0m84qp.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/" itemprop="item" rel="index" title="In CSharp"><span itemprop="name">CSharp</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/CLR-via-CSharp/" itemprop="item" rel="index" title="In CLR-via-CSharp"><span itemprop="name">CLR-via-CSharp</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://sakupinera.github.io/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Sakupinera"><meta itemprop="description" content=", ä¿æŒä½ çš„å†³å¿ƒï¼"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakupinera"></span><div class="body md" itemprop="articleBody"><h1 id="chapter-8-methods"><a class="anchor" href="#chapter-8-methods">#</a> Chapter 8 Methods</h1><h2 id="instance-constructors-and-classes-reference-types"><a class="anchor" href="#instance-constructors-and-classes-reference-types">#</a> Instance Constructors and Classes (Reference Types)</h2><blockquote><p>Constructors are special methods that allow an instance of a type to be initialized to a good state. Constructor methods are always called <code>.ctor</code> (for constructor) in a method definition metadata table. When creating an instance of a reference type, memory is allocated for the instanceâ€™s data fields, the objectâ€™s overhead fields (type object pointer and sync block index) are initialized, and then the typeâ€™s instance constructor is called to set the initial state of the object.</p></blockquote><blockquote><p>When constructing a reference type object, the memory allocated for the object is always zeroed out before the typeâ€™s instance constructor is called. Any fields that the constructor doesnâ€™t explicitly overwrite are guaranteed to have a value of 0 or null.</p></blockquote><blockquote><p>Unlike other methods, instance constructors are never inherited. That is, a class has only the instance constructors that the class itself defines. Because instance constructors are never inherited, you cannot apply the following modifiers to an instance constructor: virtual, new, override, sealed, or abstract. If you define a class that does not explicitly define any constructors, the C# compiler defines a default (parameterless) constructor for you whose implementation simply calls the base classâ€™s parameterless constructor.</p></blockquote><blockquote><p>For example, if you define the following class.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>it is as though you wrote the code as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token function">SomeType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>If the class is abstract, the compiler-produced default constructor has protected accessibility; otherwise, the constructor is given public accessibility. If the base class doesnâ€™t offer a parameterless constructor, the derived class must explicitly call a base class constructor or the compiler will issue an error. If the class is static (sealed and abstract), the compiler will not emit a default constructor at all into the class definition.</p></blockquote><blockquote><p>A type can define several instance constructors. Each constructor must have a different signature, and each can have different accessibility. For verifiable code, a classâ€™s instance constructor must call its base classâ€™s constructor before accessing any of the inherited fields of the base class. The C# compiler will generate a call to the default base classâ€™s constructor automatically if the derived classâ€™s constructor does not explicitly invoke one of the base classâ€™s constructors. Ultimately, <code>System.Object</code> â€™s public, parameterless constructor gets called. This constructor does nothingâ€”it simply returns. This is because <code>System.Object</code> defines no instance data fields, and therefore its constructor has nothing to do.</p></blockquote><blockquote><p>In a few situations, an instance of a type can be created without an instance constructor being called. In particular, calling Objectâ€™s <code>MemberwiseClone</code> method allocates memory, initializes the objectâ€™s overhead fields, and then copies the source objectâ€™s bytes to the new object. Also, a constructor is usually not called when deserializing an object with the runtime serializer. The deserialization code allocates memory for the object without calling a constructor by using the <code>System.Runtime.Serialization.FormatterServices</code> type's <code>GetUninitializedObject</code> or <code>GetSafeUninitializedObject</code> methods (as discussed in Chapter 24, â€œRuntime Serializationâ€).</p></blockquote><p>ğŸ’¡é‡è¦æç¤ºï¼šä¸è¦åœ¨æ„é€ å™¨ä¸­è°ƒç”¨è™šæ–¹æ³•ã€‚åŸå› æ˜¯å‡å¦‚è¢«å®ä¾‹åŒ–çš„ç±»å‹é‡å†™äº†è™šæ–¹æ³•ï¼Œå°±ä¼šæ‰§è¡Œæ´¾ç”Ÿç±»å‹å¯¹è™šæ–¹æ³•çš„å®ç°ã€‚ä½†åœ¨è¿™ä¸ªæ—¶å€™ï¼Œå°šæœªå®Œæˆå¯¹ç»§æ‰¿å±‚æ¬¡ç»“æ„ä¸­çš„æ‰€æœ‰å­—æ®µçš„åˆå§‹åŒ– (è¢«å®ä¾‹åŒ–çš„ç±»å‹çš„æ„é€ å™¨è¿˜æ²¡æœ‰è¿è¡Œå‘¢)ã€‚æ‰€ä»¥ï¼Œè°ƒç”¨è™šæ–¹æ³•ä¼šå¯¼è‡´æ— æ³•é¢„æµ‹çš„è¡Œä¸ºã€‚å½’æ ¹åˆ°åº•ï¼Œè¿™æ˜¯ç”±äºè°ƒç”¨è™šæ–¹æ³•æ—¶ï¼Œç›´åˆ°è¿è¡Œæ—¶ä¹‹å‰éƒ½ä¸ä¼šé€‰æ‹©æ‰§è¡Œè¯¥æ–¹æ³•çš„å®é™…ç±»å‹ã€‚</p><blockquote><p>C# offers a simple syntax that allows the initialization of fields defined within a reference type when an instance of the type is constructed.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When a <code>SomeType</code> object is constructed, its m_x field will be initialized to 5. How does this happen? Well, if you examine the Intermediate Language (IL) for <code>SomeType</code> â€™s constructor method (also called <code>.ctor</code> ), youâ€™ll see the code shown here.</p></blockquote><figure class="highlight clike"><figcaption data-lang="C-like"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">.</span>method public hidebysig specialname rtspecialname </pre></td></tr><tr><td data-num="2"></td><td><pre> instance void <span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> cil managed</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// Code size 14 (0xe)</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">.</span>maxstack <span class="token number">8</span></pre></td></tr><tr><td data-num="6"></td><td><pre> IL_0000<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="7"></td><td><pre> IL_0001<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span><span class="token number">5</span></pre></td></tr><tr><td data-num="8"></td><td><pre> IL_0002<span class="token punctuation">:</span> stfld int32 SomeType<span class="token punctuation">:</span><span class="token punctuation">:</span>m_x</pre></td></tr><tr><td data-num="9"></td><td><pre> IL_0007<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="10"></td><td><pre> IL_0008<span class="token punctuation">:</span> call instance void <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Object<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre> IL_000d<span class="token punctuation">:</span> ret</pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of method SomeType::.ctor</span></pre></td></tr></table></figure><blockquote><p>In this code, you see that <code>SomeType</code> â€™s constructor contains code to store a 5 into m_x and then calls the base classâ€™s constructor. In other words, the C# compiler allows the convenient syntax that lets you initialize the instance fields inline and translates this to code in the constructor method to perform the initialization. This means that you should be aware of code explosion, as illustrated by the following class definition.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">String</span> m_s <span class="token operator">=</span> <span class="token string">"Hi there"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Double</span> m_d <span class="token operator">=</span> <span class="token number">3.14159</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Byte</span> m_b<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Here are some constructors. </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token function">SomeType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token function">SomeType</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">public</span> <span class="token function">SomeType</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">;</span> m_d <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When the compiler generates code for the three constructor methods, the beginning of each method includes the code to initialize m_x, m_s, and m_d. After this initialization code, the compiler inserts a call to the base classâ€™s constructor, and then the compiler appends to the method the code that appears in the constructor methods. For example, the code generated for the constructor that takes a String parameter includes the code to initialize m_x, m_s, and m_d, call the base classâ€™s (Objectâ€™s) constructor, and then overwrite m_d with the value 10. Note that m_b is guaranteed to be initialized to 0 even though no code exists to explicitly initialize it.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šç¼–è¯‘å™¨åœ¨è°ƒç”¨åŸºç±»æ„é€ å™¨å‰ä½¿ç”¨ç®€åŒ–è¯­æ³•å¯¹æ‰€æœ‰å­—æ®µè¿›è¡Œåˆå§‹åŒ–ï¼Œä»¥ç»´æŒæºä»£ç ç»™äººç•™ä¸‹çš„ â€œè¿™äº›å­—æ®µæ€»æ˜¯æœ‰ä¸€ä¸ªå€¼â€ çš„å°è±¡ã€‚ä½†å‡å¦‚åŸºç±»æ„é€ å™¨è°ƒç”¨äº†è™šæ–¹æ³•å¹¶å›è°ƒç”±æ´¾ç”Ÿç±»å®šä¹‰çš„æ–¹æ³•ï¼Œå°±å¯èƒ½å‡ºé—®é¢˜ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä½¿ç”¨ç®€åŒ–è¯­æ³•åˆå§‹åŒ–çš„å­—æ®µåœ¨è°ƒç”¨è™šæ–¹æ³•ä¹‹å‰å°±åˆå§‹åŒ–å¥½äº†ã€‚</p><blockquote><p>Because there are three constructors in the preceding class, the compiler generates the code to initialize m_x, m_s, and m_d three timesâ€”once per constructor. If you have several initialized instance fields and a lot of overloaded constructor methods, you should consider defining the fields without the initialization, creating a single constructor that performs the common initialization, and having each constructor explicitly call the common initialization constructor. This approach will reduce the size of the generated code. Here is an example using C#â€™s ability to explicitly have a constructor call another constructor by using the this keyword.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Do not explicitly initialize the fields here. </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_x<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">String</span> m_s<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Double</span> m_d<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Byte</span> m_b<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// This constructor sets all fields to their default. </span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// All of the other constructors explicitly invoke this constructor. </span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">public</span> <span class="token function">SomeType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> m_x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> m_s <span class="token operator">=</span> <span class="token string">"Hi there"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> m_d <span class="token operator">=</span> <span class="token number">3.14159</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> m_b <span class="token operator">=</span> <span class="token number">0xff</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// This constructor sets all fields to their default, then changes m_x. </span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token keyword">public</span> <span class="token function">SomeType</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> x<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> m_x <span class="token operator">=</span> x<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token comment">// This constructor sets all fields to their default, then changes m_s. </span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token keyword">public</span> <span class="token function">SomeType</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="21"></td><td><pre> m_s <span class="token operator">=</span> s<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token comment">// This constructor sets all fields to their default, then changes m_x &amp; m_s. </span></pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token keyword">public</span> <span class="token function">SomeType</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> x<span class="token punctuation">,</span> <span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="25"></td><td><pre> m_x <span class="token operator">=</span> x<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="26"></td><td><pre> m_s <span class="token operator">=</span> s<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="27"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>ğŸ’¡å°ç»“ï¼šåˆ›å»ºå¼•ç”¨ç±»å‹çš„å®ä¾‹æ—¶ï¼Œé¦–å…ˆä¸ºå®ä¾‹çš„æ•°æ®å­—æ®µåˆ†é…å†…å­˜ï¼Œç„¶ååˆå§‹åŒ–å¯¹è±¡çš„é™„åŠ å­—æ®µï¼ˆç±»å‹å¯¹è±¡æŒ‡é’ˆå’ŒåŒæ­¥å—ç´¢å¼•ï¼‰ï¼Œè¿™äº›é™„åŠ å­—æ®µç§°ä¸º overhead fieldsï¼Œâ€œoverheadâ€ æ˜¯å¼€é”€çš„æ„æ€ï¼Œæ„å‘³ç€æ˜¯åˆ›å»ºå¯¹è±¡æ—¶å¿…é¡»çš„ â€œå¼€é”€â€ã€‚æœ€åè°ƒç”¨ç±»å‹çš„å®ä¾‹æ„é€ å™¨æ¥è®¾ç½®å¯¹è±¡çš„åˆå§‹çŠ¶æ€ã€‚æ„é€ åº”å¼•ç”¨ç±»å‹å¯¹è±¡æ—¶ï¼Œåœ¨è°ƒç”¨ç±»å‹çš„å®ä¾‹æ„é€ å™¨ä¹‹å‰ï¼Œä¸ºå¯¹è±¡åˆ†é…çš„å†…å­˜æ€»æ˜¯å…ˆè¢«å½’é›¶ã€‚æ²¡æœ‰è¢«æ„é€ å™¨æ˜¾ç¤ºé‡å†™çš„æ‰€æœ‰å­—æ®µéƒ½ä¿è¯è·å¾— 0 æˆ– null å€¼ã€‚ç”±äºæ°¸è¿œä¸èƒ½ç»§æ‰¿å®ä¾‹æ„é€ å™¨ï¼Œæ‰€ä»¥å®ä¾‹æ„é€ å™¨ä¸èƒ½ä½¿ç”¨ä»¥ä¸‹ä¿®é¥°ç¬¦ï¼švirtualï¼Œnewï¼Œoverrideï¼Œsealed å’Œ abstractã€‚å¦‚æœç±»çš„ä¿®é¥°ç¬¦ä¸º abstractï¼Œé‚£ä¹ˆç¼–è¯‘å™¨ç”Ÿæˆçš„é»˜è®¤æ„é€ å™¨çš„å¯è®¿é—®æ€§å°±ä¸º protectedï¼›å¦åˆ™ï¼Œæ„é€ å™¨å°±ä¼šè¢«èµ‹äºˆ public å¯è®¿é—®æ€§ã€‚å¦‚æœåŸºç±»æ²¡æœ‰æä¾›æ— å‚æ„é€ å™¨ï¼Œé‚£ä¹ˆæ´¾ç”Ÿç±»å¿…é¡»æ˜¾ç¤ºè°ƒç”¨ä¸€ä¸ªåŸºç±»æ„é€ å™¨ï¼Œå¦åˆ™ç¼–è¯‘å™¨ä¼šæŠ¥é”™ã€‚å¦‚æœç±»çš„ä¿®é¥°ç¬¦ä¸º staticï¼ˆsealed å’Œ abstractï¼Œé™æ€ç±»åœ¨å…ƒæ•°æ®ä¸­æ˜¯æŠ½è±¡å¯†å°ç±»ï¼‰ï¼Œç¼–è¯‘å™¨æ ¹æœ¬ä¸ä¼šåœ¨ç±»çš„å®šä¹‰ä¸­ç”Ÿæˆé»˜è®¤æ„é€ å™¨ã€‚ä¸ºäº†ä½¿ä»£ç  â€œå¯éªŒè¯â€ï¼ˆverifiableï¼‰ï¼Œç±»çš„å®ä¾‹æ„é€ å™¨åœ¨è®¿é—®ä»åŸºç±»ç»§æ‰¿çš„ä»»ä½•å­—æ®µä¹‹å‰ï¼Œå¿…é¡»å…ˆè°ƒç”¨åŸºç±»çš„æ„é€ å™¨ã€‚å¦‚æœæ´¾ç”Ÿç±»çš„æ„é€ å™¨æ²¡æœ‰æ˜¾ç¤ºè°ƒç”¨ä¸€ä¸ªåŸºç±»æ„é€ å™¨ï¼ŒC# ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨ç”Ÿæˆå¯¹é»˜è®¤çš„åŸºç±»æ„é€ å™¨çš„è°ƒç”¨ã€‚æå°‘æ•°æ—¶å€™å¯ä»¥åœ¨ä¸è°ƒç”¨å®ä¾‹æ„é€ å™¨çš„å‰æä¸‹åˆ›å»ºç±»å‹çš„å®ä¾‹ã€‚ä¸€ä¸ªå…¸å‹çš„ä¾‹å­ä½¿ Object çš„ <code>MemberwiseClone</code> æ–¹æ³•ã€‚è¯¥æ–¹æ³•çš„ä½œç”¨æ˜¯åˆ†é…å†…å­˜ï¼Œåˆå§‹åŒ–å¯¹è±¡çš„é™„åŠ å­—æ®µï¼ˆç±»å‹å¯¹è±¡æŒ‡é’ˆå’ŒåŒæ­¥å—ç´¢å¼•ï¼‰ï¼Œç„¶åå°†æºå¯¹è±¡çš„å­—èŠ‚æ•°æ®å¤åˆ¶åˆ°æ–°å¯¹è±¡ä¸­ã€‚å¦å¤–ï¼Œç”¨è¿è¡Œæ—¶åºåˆ—åŒ–å™¨ï¼ˆruntime serializerï¼‰ååºåˆ—åŒ–å¯¹è±¡æ—¶ï¼Œé€šå¸¸ä¹Ÿä¸éœ€è¦è°ƒç”¨æ„é€ å™¨ã€‚ååºåˆ—åŒ–ä»£ç ä½¿ç”¨ <code>System.Runtime.Serialization.FormatterServices</code> ç±»å‹çš„ <code>GetUninitializedObject</code> æˆ–è€… <code>GetSafeUninitializedObject</code> æ–¹æ³•ä¸ºå¯¹è±¡åˆ†é…å†…å­˜ï¼ŒæœŸé—´ä¸ä¼šè°ƒç”¨ä¸€ä¸ªæ„é€ å™¨ã€‚C# ç¼–è¯‘å™¨æä¾›äº†ä¸€ä¸ªç®€åŒ–çš„è¯­æ³•ï¼Œå…è®¸ä»¥ â€œå†…è”â€ æ–¹å¼åˆå§‹åŒ–å®ä¾‹å­—æ®µã€‚åœ¨è¿™äº›åˆå§‹åŒ–ä»£ç ä¹‹åï¼Œç¼–è¯‘å™¨ä¼šæ’å…¥å¯¹åŸºç±»çš„æ„é€ å™¨çš„è°ƒç”¨ã€‚å†ç„¶åï¼Œä¼šæ’å…¥æ„é€ å™¨è‡ªå·±çš„ä»£ç ã€‚åœ¨ C# ä¸­å¯ä»¥åˆ©ç”¨ this å…³é”®å­—æ˜¾ç¤ºè°ƒç”¨å¦ä¸€ä¸ªæ„é€ å™¨ï¼Œè¿™æ ·èƒ½å‡å°‘ç”Ÿæˆçš„ä»£ç ã€‚</p><h2 id="instance-constructors-and-structures-value-types"><a class="anchor" href="#instance-constructors-and-structures-value-types">#</a> Instance Constructors and Structures (Value Types)</h2><blockquote><p>Value type (struct) constructors work quite differently from reference type (class) constructors. The common language runtime (CLR) always allows the creation of value type instances, and there is no way to prevent a value type from being instantiated. For this reason, value types donâ€™t actually even need to have a constructor defined within them, and the C# compiler doesn't emit default parameterless constructors for value types. Examine the following code.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">struct</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name">Int32</span> m_x<span class="token punctuation">,</span> m_y<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name">Point</span> m_topLeft<span class="token punctuation">,</span> m_bottomRight<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>To construct a Rectangle, the new operator must be used, and a constructor must be specified. In this case, the default constructor automatically generated by the C# compiler is called. When memory is allocated for the Rectangle, the memory includes the two instances of the Point value type. For performance reasons, the CLR doesnâ€™t attempt to call a constructor for each value type field contained within the reference type. But as I mentioned earlier, the fields of the value types are initialized to 0/null.</p></blockquote><blockquote><p>The CLR does allow you to define constructors on value types. The only way that these constructors will execute is if you write code to explicitly call one of them, as in Rectangleâ€™s constructor, shown here.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">struct</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name">Int32</span> m_x<span class="token punctuation">,</span> m_y<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> x<span class="token punctuation">,</span> <span class="token class-name">Int32</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> m_x <span class="token operator">=</span> x<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> m_y <span class="token operator">=</span> y<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name">Point</span> m_topLeft<span class="token punctuation">,</span> m_bottomRight<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Rectangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// In C#, new on a value type calls the constructor to </span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token comment">// initialize the value type's fields. </span></pre></td></tr><tr><td data-num="14"></td><td><pre> m_topLeft <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Point</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> m_bottomRight <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Point</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>A value typeâ€™s instance constructor is executed only when explicitly called. So if Rectangleâ€™s constructor didnâ€™t initialize its <code>m_topLeft</code> and <code>m_bottomRight</code> fields by using the new operator to call Pointâ€™s constructor, the m_x and m_y fields in both Point fields would be 0.</p></blockquote><blockquote><p>In the Point value type defined earlier, no default parameterless constructor is defined. However, letâ€™s rewrite that code as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">struct</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name">Int32</span> m_x<span class="token punctuation">,</span> m_y<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> m_x <span class="token operator">=</span> m_y <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name">Point</span> m_topLeft<span class="token punctuation">,</span> m_bottomRight<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Rectangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Now when a new Rectangle is constructed, what do you think the m_x and m_y fields in the two Point fields, <code>m_topLeft</code> and <code>m_bottomRight</code> , would be initialized to: 0 or 5? (Hint: This is a trick question.)</p></blockquote><blockquote><p>Many developers (especially those with a C++ background) would expect the C# compiler to emit code in Rectangleâ€™s constructor that automatically calls Pointâ€™s default parameterless constructor for the Rectangleâ€™s two fields. However, to improve the run-time performance of the application, the C# compiler doesnâ€™t automatically emit this code. In fact, many compilers will never emit code to call a value typeâ€™s default constructor automatically, even if the value type offers a parameterless constructor. To have a value typeâ€™s parameterless constructor execute, the developer must add explicit code to call a value typeâ€™s constructor.</p></blockquote><blockquote><p>Based on the information in the preceding paragraph, you should expect the m_x and m_y fields in Rectangleâ€™s two Point fields to be initialized to 0 in the code shown earlier because there are no explicit calls to Pointâ€™s constructor anywhere in the code.</p></blockquote><blockquote><p>However, I did say that my original question was a trick question. The trick part is that C# doesnâ€™t allow a value type to define a parameterless constructor. So the previous code wonâ€™t actually compile. The C# compiler produces the following message when attempting to compile that code: error CS0568: Structs cannot contain explicit parameterless constructors.</p></blockquote><blockquote><p>C# purposely disallows value types from defining parameterless constructors to remove any confusion a developer might have about when that constructor gets called. If the constructor canâ€™t be defined, the compiler can never generate code to call it automatically. Without a parameterless constructor, a value typeâ€™s fields are always initialized to 0/null.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šä¸¥æ ¼åœ°è¯´ï¼Œåªæœ‰å½“å€¼ç±»å‹çš„å­—æ®µåµŒå¥—åˆ°å¼•ç”¨ç±»å‹ä¸­æ—¶ï¼Œæ‰ä¿è¯è¢«åˆå§‹åŒ–ä¸º 0 æˆ– <code>null</code> ã€‚åŸºäºæ ˆçš„å€¼ç±»å‹å­—æ®µåˆ™æ— æ­¤ä¿è¯ã€‚ä½†æ˜¯ï¼Œä¸ºäº†ç¡®ä¿ä»£ç çš„ â€œå¯éªŒè¯æ€§â€(verifiability)ï¼Œä»»ä½•åŸºäºæ ˆçš„å€¼ç±»å‹å­—æ®µéƒ½å¿…é¡»åœ¨è¯»å–ä¹‹å‰å†™å…¥ (èµ‹å€¼)ã€‚å…è®¸å…ˆè¯»å†å†™ä¼šé€ æˆå®‰å…¨æ¼æ´ã€‚å¯¹äºæ‰€æœ‰åŸºäºæ ˆçš„å€¼ç±»å‹ä¸­çš„å­—æ®µï¼ŒC# å’Œå…¶ä»–èƒ½ç”Ÿæˆ â€œå¯éªŒè¯â€ ä»£ç çš„ç¼–è¯‘å™¨å¯ä»¥ä¿è¯å¯¹å®ƒä»¬è¿›è¡Œ â€œç½®é›¶â€ï¼Œæˆ–è‡³å°‘ä¿è¯åœ¨è¯»å–ä¹‹å‰èµ‹å€¼ï¼Œç¡®ä¿ä¸ä¼šåœ¨è¿è¡Œæ—¶å› éªŒè¯å¤±è´¥è€ŒæŠ›å‡ºå¼‚å¸¸ã€‚æ‰€ä»¥ï¼Œä½ å®Œå…¨å¯ä»¥å¿½ç•¥æœ¬ â€œæ³¨æ„â€ çš„å†…å®¹ï¼Œå‡å®šè‡ªå·±çš„å€¼ç±»å‹çš„å­—æ®µéƒ½ä¼šè¢«åˆå§‹åŒ–ä¸º 0 æˆ– <code>null</code> ã€‚</p><blockquote><p>Keep in mind that although C# doesnâ€™t allow value types with parameterless constructors, the CLR does. So if the unobvious behavior described earlier doesnâ€™t bother you, you can use another programming language (such as IL assembly language) to define your value type with a parameterless constructor.</p></blockquote><blockquote><p>Because C# doesnâ€™t allow value types with parameterless constructors, compiling the following type produces the following message: error CS0573: ' <code>SomeValType.m_x</code> ': cannot have instance field initializers in structs.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">struct</span> <span class="token class-name">SomeValType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// You cannot do inline instance field initialization in a value type. </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In addition, because verifiable code requires that every field of a value type be written to prior to any field being read, any constructors that you do have for a value type must initialize all of the typeâ€™s fields. The following type defines a constructor for the value type but fails to initialize all of the fields.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">struct</span> <span class="token class-name">SomeValType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_x<span class="token punctuation">,</span> m_y<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// C# allows value types to have constructors that take parameters. </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token function">SomeValType</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> m_x <span class="token operator">=</span> x<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Notice that m_y is not initialized here. </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When compiling this type, the C# compiler produces the following message: error CS0171: Field ' <code>SomeValType.m_y</code> ' must be fully assigned before control leaves the constructor. To fix the problem, assign a value (usually 0) to y in the constructor.</p></blockquote><blockquote><p>As an alternative way to initialize all the fields of a value type, you can actually do the following.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// C# allows value types to have constructors that take parameters.</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token function">SomeValType</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// Looks strange but compiles fine and initializes all fields to 0/null.</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">this</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SomeValType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> m_x <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// Overwrite m_x's 0 with x</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Notice that m_y was initialized to 0.</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In a value typeâ€™s constructor, this represents an instance of the value type itself and you can actually assign to it the result of newing up an instance of the value type, which really just zeroes out all the fields. In a reference typeâ€™s constructor, this is considered read-only, so you cannot assign to it at all.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šCLR æ€»æ˜¯å…è®¸åˆ›å»ºå€¼ç±»å‹çš„å®ä¾‹ï¼Œå¹¶ä¸”æ²¡æœ‰åŠæ³•é˜»æ­¢å€¼ç±»å‹çš„å®ä¾‹åŒ–ã€‚æ‰€ä»¥ï¼Œå€¼ç±»å‹å…¶å®å¹¶ä¸éœ€è¦å®šä¹‰æ„é€ å™¨ï¼ŒC# ç¼–è¯‘å™¨æ ¹æœ¬ä¸ä¼šä¸ºå€¼ç±»å‹å†…è”ï¼ˆåµŒå…¥ï¼‰é»˜è®¤çš„æ— å‚æ„é€ å™¨ã€‚è€ƒè™‘åˆ°æ€§èƒ½ï¼ŒCLR ä¸ä¼šä¸ºåŒ…å«åœ¨å¼•ç”¨ç±»å‹ä¸­çš„æ¯ä¸ªå€¼ç±»å‹å­—æ®µéƒ½ä¸»åŠ¨è°ƒç”¨æ„é€ å™¨ã€‚ä½†æ˜¯ï¼Œå¦‚å‰æ‰€è¿°ï¼Œå€¼ç±»å‹çš„å­—æ®µä¼šè¢«åˆå§‹åŒ–ä¸º 0 æˆ– nullã€‚CLR ç¡®å®å…è®¸ä¸ºå€¼ç±»å‹å®šä¹‰æ„é€ å™¨ï¼ˆæœ‰å‚ï¼‰ï¼Œä½†å¿…é¡»æ˜¾ç¤ºè°ƒç”¨æ‰ä¼šæ‰§è¡Œã€‚ä¸ºäº†å¢å¼ºåº”ç”¨ç¨‹åºçš„è¿è¡Œæ—¶æ€§èƒ½ï¼Œå³ä¾¿ç±»å‹æä¾›äº†æ— å‚æ„é€ å™¨ï¼Œè®¸å¤šç¼–è¯‘å™¨ä¹Ÿæ°¸è¿œä¸ä¼šç”Ÿæˆä»£ç æ¥è‡ªåŠ¨è°ƒç”¨å®ƒã€‚ä½†äº‹å®ä¸Šï¼ŒC# ç¼–è¯‘å™¨ä¸å…è®¸å€¼ç±»å‹å®šä¹‰æ— å‚æ„é€ å™¨ã€‚ï¼ˆæµ‹è¯•çš„æ—¶å€™æ˜¯å¯ä»¥å®šä¹‰ï¼Œå¯èƒ½ç”±äº C# ç‰ˆæœ¬ä¸åŒï¼‰å¦‚æœç¼–è¯‘ç±»ä¼¼ä»£ç ï¼ŒC# ç¼–è¯‘å™¨ä¼šæ˜¾ç¤ºä»¥ä¸‹æ¶ˆæ¯ï¼šerror CS0568ï¼šç»“æ„ä¸èƒ½åŒ…å«æ˜¾å¼çš„æ— å‚æ•°æ„é€ å™¨ã€‚ç”±äºä¸èƒ½å®šä¹‰æ— å‚æ„é€ å™¨ï¼Œæ‰€ä»¥ç¼–è¯‘å™¨æ°¸è¿œä¸ä¼šç”Ÿæˆè‡ªåŠ¨è°ƒç”¨å®ƒçš„ä»£ç ã€‚æ²¡æœ‰æ— å‚æ„é€ å™¨ï¼Œå€¼ç±»å‹çš„å­—æ®µæ€»æ˜¯è¢«åˆå§‹åŒ–ä¸º 0 æˆ– nullã€‚æ³¨æ„ï¼Œè™½ç„¶ C# ä¸å…è®¸å€¼ç±»å‹å¸¦æœ‰æ— å‚æ„é€ å™¨ï¼Œä½† CLR å…è®¸ã€‚ç”±äº C# ä¸å…è®¸ä¸ºå€¼ç±»å‹å®šä¹‰æ— å‚æ„é€ å™¨ï¼Œæ‰€ä»¥ä¸èƒ½åœ¨å€¼ç±»å‹ä¸­å†…è”å®ä¾‹å­—æ®µçš„åˆå§‹åŒ–ã€‚å¦‚æœç¼–è¯‘ç±»ä¼¼ä»£ç ï¼ŒC# ç¼–è¯‘å™¨å°†æ˜¾ç¤ºæ¶ˆæ¯ï¼šerror CS0573ï¼šç»“æ„ä¸­ä¸èƒ½æœ‰å®ä¾‹å­—æ®µåˆå§‹å€¼è®¾å®šé¡¹ã€‚ï¼ˆæµ‹è¯•æ—¶æŠ¥é”™ CS8983ï¼Œéœ€è¦æ˜¾å¼å£°æ˜ä¸€ä¸ªæ„é€ å™¨ï¼Œä½†æ˜¯å­—æ®µåˆå§‹å€¼è¿˜æ˜¯ä¸èµ·ä½œç”¨å°±æ˜¯äº†ï¼‰å¦å¤–ï¼Œä¸ºäº†ç”Ÿæˆ â€œå¯éªŒè¯â€ ä»£ç ï¼Œåœ¨è®¿é—®å€¼ç±»å‹çš„ä»»ä½•å­—æ®µå­—æ®µä¹‹å‰ï¼Œéƒ½éœ€è¦å¯¹å…¨éƒ¨å­—æ®µè¿›è¡Œèµ‹å€¼ã€‚å¦åˆ™ï¼ŒC# ç¼–è¯‘å™¨ä¼šæ˜¾å¼æ¶ˆæ¯ï¼šerror CS0171ï¼šåœ¨æ§åˆ¶è¿”å›åˆ°è°ƒç”¨æ–¹ä¹‹å‰ï¼Œå­—æ®µå¿…é¡»å®Œå…¨èµ‹å€¼ã€‚åœ¨å€¼ç±»å‹çš„æ„é€ å™¨ä¸­ï¼Œthis ä»£è¡¨å€¼ç±»å‹æœ¬èº«çš„ä¸€ä¸ªå®ä¾‹ï¼Œç”¨ new åˆ›å»ºçš„å€¼ç±»å‹çš„ä¸€ä¸ªå®ä¾‹å¯ä»¥èµ‹ç»™ thisã€‚åœ¨ new çš„è¿‡ç¨‹ä¸­ï¼Œä¼šå°†æ‰€æœ‰å­—æ®µç½®ä¸ºé›¶ã€‚è€Œåœ¨å¼•ç”¨ç±»å‹çš„æ„é€ å™¨ä¸­ï¼Œthis è¢«è®¤ä¸ºæ˜¯åªè¯»çš„ï¼Œæ‰€ä»¥ä¸èƒ½å¯¹å®ƒè¿›è¡Œèµ‹å€¼ã€‚</p><h2 id="type-constructors"><a class="anchor" href="#type-constructors">#</a> Type Constructors</h2><blockquote><p>n addition to instance constructors, the CLR supports type constructors (also known as static constructors, class constructors, or type initializers). A type constructor can be applied to interfaces (although C# doesnâ€™t allow this), reference types, and value types. Just as instance constructors are used to set the initial state of an instance of a type, type constructors are used to set the initial state of a type. By default, types donâ€™t have a type constructor defined within them. If a type has a type constructor, it can have no more than one. In addition, type constructors never have parameters. In C#, hereâ€™s how to define a reference type and a value type that have type constructors.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SomeRefType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">static</span> <span class="token function">SomeRefType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// This executes the first time a SomeRefType is accessed. </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">struct</span> <span class="token class-name">SomeValType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// C# does allow value types to define parameterless type constructors. </span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">static</span> <span class="token function">SomeValType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// This executes the first time a SomeValType is accessed. </span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Youâ€™ll notice that you define type constructors just as you would parameterless instance constructors, except that you must mark them as static. Also, type constructors should always be private; C# makes them private for you automatically. In fact, if you explicitly mark a type constructor as private (or anything else) in your source code, the C# compiler issues the following error: error CS0515: 'SomeValType.SomeValType()': access modifiers are not allowed on static constructors. Type constructors should be private to prevent any developer-written code from calling them; the CLR is always capable of calling a type constructor.</p></blockquote><p>ğŸ’¡é‡è¦æç¤ºï¼šè™½ç„¶èƒ½åœ¨å€¼ç±»å‹ä¸­å®šä¹‰ç±»å‹æ„é€ å™¨ï¼Œä½†æ°¸è¿œéƒ½ä¸è¦çœŸçš„é‚£ä¹ˆåšï¼Œå› ä¸º CLR æœ‰æ—¶ä¸ä¼šè°ƒç”¨å€¼ç±»å‹çš„é™æ€ç±»å‹æ„é€ å™¨ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼š</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">struct</span> <span class="token class-name">SomeValType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">static</span> <span class="token function">SomeValType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"This never gets displayed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name">Int32</span> m_x<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token class-name">SomeValType<span class="token punctuation">[</span><span class="token punctuation">]</span></span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SomeValType</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>m_x <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>m_x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays 123 </span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The calling of a type constructor is a tricky thing. When the just-in-time (JIT) compiler is compiling a method, it sees what types are referenced in the code. If any of the types define a type constructor, the JIT compiler checks if the typeâ€™s type constructor has already been executed for this <code>AppDomain</code> . If the constructor has never executed, the JIT compiler emits a call to the type constructor into the native code that the JIT compiler is emitting. If the type constructor for the type has already executed, the JIT compiler does not emit the call because it knows that the type is already initialized.</p></blockquote><blockquote><p>Now, after the method has been JIT-compiled, the thread starts to execute it and will eventually get to the code that calls the type constructor. In fact, it is possible that multiple threads will be executing the same method concurrently. The CLR wants to ensure that a typeâ€™s constructor executes only once per <code>AppDomain</code> . To guarantee this, when a type constructor is called, the calling thread acquires a mutually exclusive thread synchronization lock. So if multiple threads attempt to simultaneously call a typeâ€™s static constructor, only one thread will acquire the lock and the other threads will block. The first thread will execute the code in the static constructor. After the first thread leaves the constructor, the waiting threads will wake up and will see that the constructorâ€™s code has already been executed. These threads will not execute the code again; they will simply return from the constructor method. In addition, if any of these methods ever get called again, the CLR knows that the type constructor has already executed and will ensure that the constructor is not called again.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šç”±äº CLR ä¿è¯ä¸€ä¸ªç±»å‹æ„é€ å™¨åœ¨æ¯ä¸ª AppDomain ä¸­æ‰§è¡Œä¸€æ¬¡ï¼Œè€Œä¸” (è¿™ç§æ‰§è¡Œ) æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œæ‰€ä»¥éå¸¸é€‚åˆåœ¨ç±»å‹æ„é€ å™¨ä¸­åˆå§‹åŒ–ç±»å‹éœ€è¦çš„ä»»ä½•å•å®ä¾‹ (Singleton) å¯¹è±¡ã€‚</p><blockquote><p>Within a single thread, there is a potential problem that can occur if two type constructors contain code that reference each other. For example, ClassA has a type constructor containing code that references ClassB, and ClassB has a type constructor containing code that references ClassA. In this situation, the CLR still guarantees that each type constructorâ€™s code executes only once; however, it cannot guarantee that ClassAâ€™s type constructor code has run to completion before executing ClassBâ€™s type constructor. You should certainly try to avoid writing code that sets up this scenario. In fact, because the CLR is responsible for calling type constructors, you should always avoid writing any code that requires type constructors to be called in a specific order.</p></blockquote><blockquote><p>Finally, if a type constructor throws an unhandled exception, the CLR considers the type to be unusable. Attempting to access any fields or methods of the type will cause a System.TypeInitializationException to be thrown.</p></blockquote><blockquote><p>The code in a type constructor has access only to a typeâ€™s static fields, and its usual purpose is to initialize those fields. As it does with instance fields, C# offers a simple syntax that allows you to initialize a typeâ€™s static fields.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Int32</span> s_x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>ğŸ’¡æ³¨æ„ï¼šè™½ç„¶ C# ä¸å…è®¸å€¼ç±»å‹ä¸ºå®ƒçš„å®ä¾‹å­—æ®µä½¿ç”¨å†…è”å­—æ®µåˆå§‹åŒ–è¯­æ³•ï¼Œä½†å¯ä»¥ä¸ºé™æ€å­—æ®µä½¿ç”¨ã€‚æ¢å¥è¯è¯´ï¼Œå¦‚æœå°†å‰é¢å®šä¹‰çš„ <code>SomeType</code> ç±»å‹ä» <code>class</code> æ”¹ä¸º <code>struct</code> ï¼Œé‚£ä¹ˆä»£ç ä¹Ÿèƒ½é€šè¿‡ç¼–è¯‘ï¼Œè€Œä¸”ä¼šåƒä½ é¢„æœŸçš„é‚£æ ·å·¥ä½œã€‚</p><blockquote><p>When this code is built, the compiler automatically generates a type constructor for SomeType. Itâ€™s as if the source code had originally been written as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Int32</span> s_x<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">static</span> <span class="token function">SomeType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> s_x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Using ILDasm.exe, itâ€™s easy to verify what the compiler actually produced by examining the IL for the type constructor. Type constructor methods are always called .cctor (for class constructor) in a method definition metadata table.</p></blockquote><blockquote><p>In the code below, you see that the .cctor method is private and static. In addition, notice that the code in the method does in fact load a 5 into the static field s_x.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">.</span>method <span class="token keyword">private</span> hidebysig specialname rtspecialname <span class="token keyword">static</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">void</span> <span class="token punctuation">.</span><span class="token function">cctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token return-type class-name">cil</span> managed</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// Code size 7 (0x7)</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">.</span>maxstack <span class="token number">8</span></pre></td></tr><tr><td data-num="6"></td><td><pre> IL_0000<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span><span class="token number">5</span></pre></td></tr><tr><td data-num="7"></td><td><pre> IL_0001<span class="token punctuation">:</span> stsfld <span class="token class-name">int32</span> SomeType<span class="token punctuation">::</span><span class="token class-name">s_x</span></pre></td></tr><tr><td data-num="8"></td><td><pre> IL_0006<span class="token punctuation">:</span> ret</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of method SomeType::.cctor</span></pre></td></tr></table></figure><blockquote><p>Type constructors shouldnâ€™t call a base typeâ€™s type constructor. Such a call isnâ€™t necessary because none of a typeâ€™s static fields are shared or inherited from its base type.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šæœ‰çš„è¯­è¨€ (æ¯”å¦‚ Java) å¸Œæœ›åœ¨è®¿é—®ç±»å‹æ—¶è‡ªåŠ¨è°ƒç”¨å®ƒçš„ç±»å‹æ„é€ å™¨ï¼Œå¹¶è°ƒç”¨å®ƒçš„æ‰€æœ‰åŸºç±»å‹çš„ç±»å‹æ„é€ å™¨ã€‚æ­¤å¤–ï¼Œç±»å‹å®ç°çš„æ¥å£ä¹Ÿå¿…é¡»è°ƒç”¨æ¥å£çš„ç±»å‹æ„é€ å™¨ã€‚CLR ä¸æ”¯æŒè¿™ç§è¡Œä¸ºã€‚ä½†æ˜¯ï¼Œä½¿ç”¨ç”± <code>System.Runtime.CompilerServices.RuntimeHelpers</code> æä¾›çš„ <code>RunClassConstructor</code> æ–¹æ³•ï¼Œç¼–è¯‘å™¨å’Œå¼€å‘äººå‘˜å¯ä»¥å®ç°è¿™ç§è¡Œä¸ºã€‚ä»»ä½•è¯­è¨€æƒ³è¦å®ç°è¿™ç§è¡Œä¸ºï¼Œå¯ä»¥å‘Šè¯‰å®ƒçš„ç¼–è¯‘å™¨åœ¨ä¸€ä¸ªç±»å‹çš„ç±»å‹æ„é€ å™¨ä¸­ç”Ÿæˆä»£ç ï¼Œä¸ºæ‰€æœ‰åŸºç±»å‹éƒ½è°ƒç”¨è¿™ä¸ªæ–¹æ³•ï¼Œç”¨ <code>RunClassConstructor</code> æ–¹æ³•è°ƒç”¨ä¸€ä¸ªç±»å‹æ„é€ å™¨ï¼ŒCLR å°±çŸ¥é“ç±»å‹æ„é€ å™¨ä¹‹å‰æ˜¯å¦æ‰§è¡Œè¿‡ã€‚å¦‚æœæ˜¯ï¼ŒCLR ä¸ä¼šå†æ¬¡è°ƒç”¨å®ƒã€‚</p><blockquote><p>Finally, assume that you have this code.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Int32</span> s_x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">static</span> <span class="token function">SomeType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> s_x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In this case, the C# compiler generates a single type constructor method. This constructor first initializes s_x to 5 and then initializes s_x to 10. In other words, when the C# compiler generates IL code for the type constructor, it first emits the code required to initialize the static fields followed by the explicit code contained in your type constructor method.</p></blockquote><p>ğŸ’¡é‡è¦æç¤ºï¼šå¶å°”æœ‰å¼€å‘äººå‘˜é—®æˆ‘ï¼Œæ˜¯å¦å¯ä»¥åœ¨å¸è½½ç±»å‹æ—¶æ‰§è¡Œä¸€äº›ä»£ç ã€‚é¦–å…ˆè¦ææ¸…æ¥šçš„æ˜¯ï¼Œç±»å‹åªæœ‰åœ¨ <code>AppDomain</code> å¸è½½æ—¶æ‰ä¼šå¸è½½ã€‚ <code>AppDomain</code> å¸è½½æ—¶ï¼Œç”¨äºæ ‡è¯†ç±»å‹çš„å¯¹è±¡ (ç±»å‹å¯¹è±¡) å°†æˆä¸º â€œä¸å¯è¾¾â€ çš„å¯¹è±¡ (ä¸å­˜åœ¨å¯¹å®ƒçš„å¼•ç”¨)ï¼Œåƒåœ¾å›æ”¶å™¨ä¼šå›æ”¶ç±»å‹å¯¹è±¡çš„å†…å­˜ã€‚è¿™ä¸ªè¡Œä¸ºå¯¼è‡´è®¸å¤šå¼€å‘äººå‘˜è®¤ä¸ºå¯ä»¥ä¸ºç±»å‹æ·»åŠ ä¸€ä¸ªé™æ€ <code>Finalize</code> æ–¹æ³•ã€‚å½“ç±»å‹å¸è½½æ—¶ï¼Œå°±è‡ªåŠ¨åœ°è°ƒç”¨è¿™ä¸ªæ–¹æ³•ã€‚é—æ†¾çš„æ˜¯ï¼ŒCLR å¹¶ä¸æ”¯æŒé™æ€ <code>Finalize</code> æ–¹æ³•ã€‚ä½†ä¹Ÿä¸æ˜¯å®Œå…¨æ²¡æœ‰åŠæ³•ï¼Œè¦åœ¨ <code>AppDomain</code> å¸è½½æ—¶æ‰§è¡Œä¸€äº›ä»£ç ï¼Œå¯å‘ <code>System.AppDomain</code> ç±»å‹çš„ <code>DomainUnload</code> äº‹ä»¶ç™»è®°ä¸€ä¸ªå›è°ƒæ–¹æ³•ã€‚</p><p>ğŸ’¡å°ç»“ï¼šç±»å‹æ„é€ å™¨å¯ä»¥åº”ç”¨äºæ¥å£ï¼ˆè™½ç„¶ C# ç¼–è¯‘å™¨ä¸å…è®¸ï¼‰ã€å¼•ç”¨ç±»å‹å’Œå€¼ç±»å‹ã€‚å®ä¾‹æ„é€ å™¨çš„ä½œç”¨æ˜¯è®¾ç½®ç±»å‹çš„å®ä¾‹çš„åˆå§‹çŠ¶æ€ã€‚å¯¹åº”åœ°ï¼Œç±»å‹æ„é€ å™¨çš„ä½œç”¨æ˜¯è®¾ç½®ç±»å‹çš„åˆå§‹çŠ¶æ€ã€‚ç±»å‹é»˜è®¤æ²¡æœ‰å®šä¹‰ç±»å‹æ„é€ å™¨ã€‚å¦‚æœå®šä¹‰ï¼Œä¹Ÿåªèƒ½å®šä¹‰ä¸€ä¸ªã€‚æ­¤å¤–ï¼Œç±»å‹æ„é€ å™¨æ°¸è¿œæ²¡æœ‰å‚æ•°ã€‚ç±»å‹æ„é€ å™¨æ€»æ˜¯ç§æœ‰ï¼ŒC# è‡ªåŠ¨æŠŠå®ƒä»¬æ ‡è®°ä¸º privateã€‚ä¹‹æ‰€ä»¥å¿…é¡»ç§æœ‰ï¼Œæ˜¯ä¸ºäº†é˜²æ­¢ä»»ä½•ç”±å¼€å‘äººå‘˜å†™çš„ä»£ç è°ƒç”¨å®ƒï¼Œå¯¹å®ƒçš„è°ƒç”¨æ€»æ˜¯ç”± CLR è´Ÿè´£ã€‚JIT ç¼–è¯‘å™¨åœ¨ç¼–è¯‘ä¸€ä¸ªæ–¹æ³•æ—¶ï¼Œä¼šæŸ¥çœ‹ä»£ç ä¸­éƒ½å¼•ç”¨äº†å“ªäº›ç±»å‹ã€‚ä»»ä½•ä¸€ä¸ªç±»å‹å®šä¹‰äº†ç±»å‹æ„é€ å™¨ï¼ŒJIT ç¼–è¯‘å™¨éƒ½ä¼šæ£€æŸ¥é’ˆå¯¹å½“å‰ <code>AppDomain</code> ï¼Œæ˜¯å¦å·²ç»æ‰§è¡Œäº†è¿™ä¸ªç±»å‹æ„é€ å™¨ã€‚å¦‚æœæ„é€ å™¨ä»æœªæ‰§è¡Œï¼ŒJIT ç¼–è¯‘å™¨ä¼šåœ¨å®ƒç”Ÿæˆçš„æœ¬æœºï¼ˆnativeï¼‰ä»£ç ä¸­æ·»åŠ å¯¹ç±»å‹æ„é€ å™¨çš„è°ƒç”¨ã€‚å¦‚æœç±»å‹æ„é€ å™¨å·²ç»æ‰§è¡Œï¼ŒJIT ç¼–è¯‘å™¨å°±ä¸æ·»åŠ å¯¹å®ƒçš„è°ƒç”¨ã€‚äº‹å®ä¸Šï¼Œå¤šä¸ªçº¿ç¨‹å¯èƒ½åŒæ—¶æ‰§è¡Œç›¸åŒçš„æ–¹æ³•ã€‚CLR å¸Œæœ›ç¡®ä¿åœ¨æ¯ä¸ª <code>AppDomain</code> ä¸­ï¼Œä¸€ä¸ªç±»å‹æ„é€ å™¨åªæ‰§è¡Œä¸€æ¬¡ã€‚ä¸ºäº†ä¿è¯è¿™ä¸€ç‚¹ï¼Œåœ¨è°ƒç”¨ç±»å‹æ„é€ å™¨æ—¶ï¼Œè°ƒç”¨çº¿ç¨‹è¦è·å–ä¸€ä¸ªäº’æ–¥çº¿ç¨‹åŒæ­¥é”ã€‚è¿™æ ·ä¸€æ¥ï¼Œå¦‚æœå¤šä¸ªçº¿ç¨‹è¯•å›¾åŒæ—¶è°ƒç”¨æŸä¸ªç±»å‹çš„é™æ€æ„é€ å™¨ï¼Œåªæœ‰ä¸€ä¸ªçº¿ç¨‹æ‰å¯ä»¥è·å¾—é”ï¼Œå…¶ä»–çº¿ç¨‹ä¼šè¢«é˜»å¡ï¼ˆblockedï¼‰ã€‚ç”±äºæ—¶ CLR è´Ÿè´£ç±»å‹æ„é€ å™¨çš„è°ƒç”¨ï¼Œæ‰€ä»¥ä»»ä½•ä»£ç éƒ½ä¸åº”è¦æ±‚ä»¥ç‰¹å®šçš„é¡ºåºè°ƒç”¨ç±»å‹æ„é€ å™¨ã€‚ç±»å‹æ„é€ å™¨ä¸­çš„ä»£ç åªèƒ½è®¿é—®ç±»å‹çš„é™æ€å­—æ®µï¼Œå¹¶ä¸”å®ƒçš„å¸¸è§„ç”¨é€”å°±æ˜¯åˆå§‹åŒ–è¿™äº›å­—æ®µã€‚ç±»å‹æ„é€ å™¨æ–¹æ³•æ€»æ˜¯å« <code>.cctor</code> ï¼ˆä»£è¡¨ class constructorï¼‰ã€‚ç±»å‹æ„é€ å™¨ä¸åº”è°ƒç”¨åŸºç±»å‹çš„ç±»å‹æ„é€ å™¨ã€‚è¿™ç§è°ƒç”¨ä¹‹æ‰€ä»¥æ²¡å¿…è¦ï¼Œæ˜¯å› ä¸ºç±»å‹ä¸å¯èƒ½æœ‰é™æ€å­—æ®µæ˜¯ä»åŸºç±»å‹åˆ†äº«æˆ–ç»§æ‰¿çš„ã€‚å½“ C# ç¼–è¯‘å™¨ä¸ºç±»å‹æ„é€ å™¨ç”Ÿæˆ IL ä»£ç æ—¶ï¼Œå®ƒé¦–å…ˆç”Ÿæˆçš„æ˜¯åˆå§‹åŒ–é™æ€å­—æ®µæ‰€éœ€çš„ä»£ç ï¼Œç„¶åæ‰ä¼šæ·»åŠ ä½ çš„ç±»å‹æ„é€ å™¨æ–¹æ³•ä¸­æ˜¾å¼åŒ…å«çš„ä»£ç ã€‚</p><h2 id="operator-overload-methods"><a class="anchor" href="#operator-overload-methods">#</a> Operator Overload Methods</h2><blockquote><p>Some programming languages allow a type to define how operators should manipulate instances of the type. For example, a lot of types (such as System.String, System.Decimal, and System.DateTime) overload the equality (==) and inequality (!=) operators. The CLR doesnâ€™t know anything about operator overloading because it doesnâ€™t even know what an operator is. Your programming language defines what each operator symbol means and what code should be generated when these special symbols appear.</p></blockquote><blockquote><p>For example, in C#, applying the + symbol to primitive numbers causes the compiler to generate code that adds the two numbers together. When the + symbol is applied to String objects, the C# compiler generates code that concatenates the two strings together. For inequality, C# uses the != symbol, while Microsoft Visual Basic uses the &lt;&gt; symbol. Finally, the ^ symbol means exclusive OR (XOR) in C#, but it means exponent in Visual Basic.</p></blockquote><blockquote><p>Although the CLR doesnâ€™t know anything about operators, it does specify how languages should expose operator overloads so that they can be readily consumed by code written in a different programming language. Each programming language gets to decide for itself whether it will support operator overloads, and if it does, the syntax for expressing and using them. As far as the CLR is concerned, operator overloads are simply methods.</p></blockquote><blockquote><p>Your choice of programming language determines whether or not you get the support of operator overloading and what the syntax looks like. When you compile your source code, the compiler produces a method that identifies the behavior of the operator. The CLR specification mandates that operator overload methods be public and static methods. In addition, C# (and many other languages) requires that at least one of the operator methodâ€™s parameters must be the same as the type that the operator method is defined within. The reason for this restriction is that it enables the C# compiler to search for a possible operator method to bind to in a reasonable amount of time.</p></blockquote><blockquote><p>Here is an example of an operator overload method defined in a C# class definition.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Complex</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> Complex <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token class-name">Complex</span> c1<span class="token punctuation">,</span> <span class="token class-name">Complex</span> c2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The compiler emits a metadata method definition entry for a method called op_Addition; the method definition entry also has the specialname flag set, indicating that this is a â€œspecialâ€ method. When language compilers (including the C# compiler) see a + operator specified in source code, they look to see if one of the operandâ€™s types defines a specialname method called op_Addition whose parameters are compatible with the operandâ€™s types. If this method exists, the compiler emits code to call this method. If no such method exists, a compilation error occurs.</p></blockquote><blockquote><p>Tables 8-1 and 8-2 show the set of unary and binary operators that C# supports being overloaded, their symbols, and the corresponding Common Language Specification (CLS) method name that the compiler emits. Iâ€™ll explain the tablesâ€™ third columns in the next section.</p></blockquote><p><img data-src="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/image-20221025202233270.png" alt="image-20221025202233270"></p><p><img data-src="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/image-20221025202253493.png" alt="image-20221025202253493"></p><p><img data-src="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/image-20221025202324849.png" alt="image-20221025202324849"></p><blockquote><p>The CLR specification defines many additional operators that can be overloaded, but C# does not support these additional operators. Therefore, they are not in mainstream use, so I will not list them here. If you are interested in the complete list, please see the ECMA specifications (<span class="exturl" data-url="aHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL3B1YmxpY2F0aW9ucy9zdGFuZGFyZHMvRWNtYS0zMzUuaHRt">www.ecma-international.org/publications/standards/Ecma-335.htm</span>) for the Common Language Infrastructure (CLI), Partition I, Concepts and Architecture, Sections 10.3.1 (unary operators) and 10.3.2 (binary operators).</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šæ£€æŸ¥ Framework ç±»åº“ (FCL) çš„æ ¸å¿ƒæ•°å€¼ç±»å‹ ( <code>Int32</code> , <code>Int64</code> å’Œ <code>UInt32</code> ç­‰)ï¼Œä¼šå‘ç°å®ƒä»¬æ²¡æœ‰å®šä¹‰ä»»ä½•æ“ä½œç¬¦é‡è½½æ–¹æ³•ã€‚ä¹‹æ‰€ä»¥ä¸å®šä¹‰ï¼Œæ˜¯å› ä¸ºç¼–è¯‘å™¨ä¼š (åœ¨ä»£ç ä¸­) ä¸“é—¨æŸ¥æ‰¾é’ˆå¯¹è¿™äº›åŸºå…ƒç±»å‹æ‰§è¡Œçš„æ“ä½œ (è¿ç®—)ï¼Œå¹¶ç”Ÿæˆç›´æ¥æ“ä½œè¿™äº›ç±»å‹çš„å®ä¾‹çš„ IL æŒ‡ä»¤ã€‚å¦‚æœç±»å‹è¦æä¾›æ–¹æ³•ï¼Œè€Œä¸”ç¼–è¯‘å™¨è¦ç”Ÿæˆä»£ç æ¥è°ƒç”¨è¿™äº›æ–¹æ³•ï¼Œæ–¹æ³•è°ƒç”¨å°±ä¼šäº§ç”Ÿé¢å¤–çš„è¿è¡Œæ—¶å¼€é”€ã€‚å¦å¤–ï¼Œæ–¹æ³•æœ€ç»ˆéƒ½è¦æ‰§è¡Œä¸€äº› IL æŒ‡ä»¤æ¥å®Œæˆä½ å¸Œæœ›çš„æ“ä½œã€‚è¿™æ­£æ˜¯æ ¸å¿ƒ FCL ç±»å‹æ²¡æœ‰å®šä¹‰ä»»ä½•æ“ä½œç¬¦é‡è½½æ–¹æ³•çš„åŸå› ã€‚å¯¹äºå¼€å‘äººå‘˜ï¼Œè¿™æ„å‘³ç€å‡å¦‚é€‰æ‹©çš„ç¼–ç¨‹è¯­è¨€ä¸æ”¯æŒå…¶ä¸­çš„æŸä¸ª FCL ç±»å‹ï¼Œä¾¿ä¸èƒ½å¯¹è¯¥ç±»å‹çš„å®ä¾‹æ‰§è¡Œä»»ä½•æ“ä½œã€‚</p><h3 id="operators-and-programming-language-interoperability"><a class="anchor" href="#operators-and-programming-language-interoperability">#</a> Operators and Programming Language Interoperability</h3><blockquote><p>Operator overloading can be a very useful tool, allowing developers to express their thoughts with succinct code. However, not all programming languages support operator overloading. When using a language that doesnâ€™t support operator overloading, the language will not know how to interpret the + operator (unless the type is a primitive in that language), and the compiler will emit an error. When using languages that do not support operator overloading, the language should allow you to call the desired op_* method directly (such as op_Addition).</p></blockquote><blockquote><p>If you are using a language that doesnâ€™t support + operator overloading to be defined in a type, obviously, this type could still offer an op_Addition method. From C#, you might expect that you could call this op_Addition method by using the + operator, but you cannot. When the C# compiler detects the + operator, it looks for an op_Addition method that has the specialname metadata flag associated with it so that the compiler knows for sure that the op_Addition method is intended to be an operator overload method. Because the op_Addition method is produced by a language that doesnâ€™t support operator overloads, the method wonâ€™t have the specialname flag associated with it, and the C# compiler will produce a compilation error. Of course, code in any language can explicitly call a method that just happens to be named op_Addition, but the compilers wonâ€™t translate a usage of the + symbol to call this method.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šFCL çš„ <code>System.Decimal</code> ç±»å‹å¾ˆå¥½åœ°æ¼”ç¤ºäº†å¦‚ä½•é‡è½½æ“ä½œç¬¦å¹¶æ ¹æ® Microsoft çš„è®¾è®¡è§„èŒƒå®šä¹‰å‹å¥½æ–¹æ³•åã€‚</p><p>ğŸ’¡å°ç»“ï¼šæœ‰çš„è¯­è¨€å…è®¸ç±»å‹å®šä¹‰æ“ä½œç¬¦åº”è¯¥å¦‚ä½•æ“ä½œç±»å‹çš„å®ä¾‹ã€‚CLR å¯¹æ“ä½œç¬¦é‡è½½ä¸€æ— æ‰€çŸ¥ï¼Œå®ƒç”šè‡³ä¸çŸ¥é“ä»€ä¹ˆæ˜¯æ“ä½œç¬¦ã€‚æ˜¯ç¼–ç¨‹è¯­è¨€å®šä¹‰äº†æ¯ä¸ªæ“ä½œç¬¦çš„å«ä¹‰ï¼Œä»¥åŠå½“è¿™äº›ç‰¹æ®Šç¬¦å·å‡ºç°æ—¶ï¼Œåº”è¯¥ç”Ÿæˆä»€ä¹ˆæ ·çš„ä»£ç ã€‚CLR è§„èŒƒè¦æ±‚æ“ä½œç¬¦é‡è½½æ–¹æ³•å¿…é¡»æ˜¯ public å’Œ static æ–¹æ³•ã€‚å¦å¤–ï¼ŒC#ï¼ˆä»¥åŠå…¶ä»–è®¸å¤šè¯­è¨€ï¼‰è¦æ±‚æ“ä½œç¬¦é‡è½½æ–¹æ³•è‡³å°‘æœ‰ä¸€ä¸ªå‚æ•°çš„ç±»å‹ä¸å½“å‰å®šä¹‰è¿™ä¸ªæ–¹æ³•çš„ç±»å‹ç›¸åŒã€‚ä¹‹æ‰€ä»¥è¦è¿›è¡Œè¿™æ ·çš„é™åˆ¶ï¼Œæ˜¯ä¸ºäº†ä½¿ C# ç¼–è¯‘å™¨èƒ½åœ¨åˆç†çš„æ—¶é—´å†…æ‰¾åˆ°è¦ç»‘å®šçš„æ“ä½œç¬¦æ–¹æ³•ã€‚CLR è§„èŒƒå®šä¹‰äº†è®¸å¤šé¢å¤–çš„å¯é‡è½½çš„æ“ä½œç¬¦ï¼Œä½† C# ä¸æ”¯æŒè¿™äº›é¢å¤–çš„æ“ä½œç¬¦ã€‚ä½¿ç”¨ä¸æ”¯æŒæ“ä½œç¬¦é‡è½½çš„è¯­è¨€æ—¶ï¼Œè¯­è¨€ä¸çŸ¥é“å¦‚ä½•è§£é‡Š + æ“ä½œç¬¦ï¼ˆé™¤éç±»å‹æ˜¯è¯¥è¯­è¨€çš„åŸºå…ƒç±»å‹ï¼‰ï¼Œç¼–è¯‘å™¨ä¼šæŠ¥é”™ã€‚ä½¿ç”¨ä¸æ”¯æŒæ“ä½œç¬¦é‡è½½çš„ç¼–ç¨‹è¯­è¨€æ—¶ï¼Œè¯­è¨€åº”è¯¥å…è®¸ä½ ç›´æ¥è°ƒç”¨å¸Œæœ›çš„ op_* æ–¹æ³•ï¼ˆä¾‹å¦‚ op_Additionï¼‰ã€‚å¦‚æœè¯­è¨€ä¸æ”¯æŒåœ¨ç±»å‹ä¸­å®šä¹‰ + æ“ä½œç¬¦é‡è½½ï¼Œè¿™ä¸ªç±»å‹ä»ç„¶å¯èƒ½æä¾›äº†ä¸€ä¸ª op_Addition æ–¹æ³•ï¼Œä½†æ˜¯åœ¨ C# ä¸­ä½¿ç”¨ + æ“ä½œç¬¦æ˜¯ä¸ä¼šè°ƒç”¨è¿™ä¸ª op_Addition æ–¹æ³•çš„ï¼Œå› ä¸º C# ç¼–è¯‘å™¨åœ¨æ£€æµ‹åˆ°æ“ä½œç¬¦ + æ—¶ï¼Œä¼šæŸ¥æ‰¾å…³è”äº† specialname å…ƒæ•°æ®æ ‡å¿—çš„ op_Addition æ–¹æ³•ï¼Œä»¥ç¡®å®š op_Addition æ–¹æ³•æ˜¯è¦ä½œä¸ºæ“ä½œç¬¦é‡è½½æ–¹æ³•ä½¿ç”¨ã€‚ä½†æ˜¯ç”±äºç°åœ¨è¿™ä¸ª op_Addition æ–¹æ³•æ˜¯ç”±ä¸æ”¯æŒæ“ä½œç¬¦é‡è½½çš„ç¼–ç¨‹è¯­è¨€ç”Ÿæˆçš„ï¼Œæ‰€ä»¥æ–¹æ³•æ²¡æœ‰å…³è” specialname æ ‡è®°ã€‚å› æ­¤ï¼ŒC# ç¼–è¯‘å™¨ä¼šæŠ¥å‘Šç¼–è¯‘é”™è¯¯ã€‚å½“ç„¶ï¼Œç”¨ä»»ä½•ç¼–ç¨‹è¯­è¨€å†™çš„ä»£ç éƒ½å¯ä»¥æ˜¾å¼è°ƒç”¨ç¢°å·§å‘½åä¸º op_Addition çš„æ–¹æ³•ï¼Œä½†ç¼–è¯‘å™¨ä¸ä¼šå°†ä¸€ä¸ª + å·çš„ä½¿ç”¨ç¿»è¯‘æˆå¯¹è¿™ä¸ªæ–¹æ³•çš„è°ƒç”¨ã€‚</p><h2 id="conversion-operator-methods"><a class="anchor" href="#conversion-operator-methods">#</a> Conversion Operator Methods</h2><blockquote><p>Occasionally, you need to convert an object from one type to an object of a different type. For example, Iâ€™m sure youâ€™ve had to convert a Byte to an Int32 at some point in your life. When the source type and the target type are a compilerâ€™s primitive types, the compiler knows how to emit the necessary code to convert the object.</p></blockquote><blockquote><p>If the source type or target type is not a primitive, the compiler emits code that has the CLR perform the conversion (cast). In this case, the CLR just checks if the source objectâ€™s type is the same type as the target type (or derived from the target type). However, it is sometimes natural to want to convert an object of one type to a completely different type. For example, the <code>System.Xml.Linq.XElement</code> class allows you to convert an Extensible Markup Language (XML) element to a Boolean, (U)Int32, (U)Int64, Single, Double, Decimal, String, DateTime, DateTimeOffset, TimeSpan, Guid, or the nullable equivalent of any of these types (except String). You could also imagine that the FCL included a Rational data type and that it might be convenient to convert an Int32 object or a Single object to a Rational object. Moreover, it also might be nice to convert a Rational object to an Int32 or a Single object.</p></blockquote><blockquote><p>To make these conversions, the Rational type should define public constructors that take a single parameter: an instance of the type that youâ€™re converting from. You should also define public instance ToXxx methods that take no parameters (just like the very popular ToString method). Each method will convert an instance of the defining type to the Xxx type. Hereâ€™s how to correctly define conversion constructors and methods for a Rational type.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Constructs a Rational from an Int32 </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Rational</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// Constructs a Rational from a Single </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Rational</span><span class="token punctuation">(</span><span class="token class-name">Single</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Converts a Rational to an Int32 </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token function">ToInt32</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Converts a Rational to a Single </span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Single</span> <span class="token function">ToSingle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>By invoking these constructors and methods, a developer using any programming language can convert an Int32 or a Single object to a Rational object and convert a Rational object to an Int32 or a Single object. The ability to do these conversions can be quite handy, and when designing a type, you should seriously consider what conversion constructors and methods make sense for your type.</p></blockquote><blockquote><p>In the previous section, I discussed how some programming languages offer operator overloading. Well, some programming languages (such as C#) also offer conversion operator overloading. Conversion operators are methods that convert an object from one type to another type. You define a conversion operator method by using special syntax. The CLR specification mandates that conversion overload methods be public and static methods. In addition, C# (and many other languages) requires that either the parameter or the return type must be the same as the type that the conversion method is defined within. The reason for this restriction is that it enables the C# compiler to search for a possible operator method to bind to in a reasonable amount of time. The following code adds four conversion operator methods to the Rational type.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Constructs a Rational from an Int32 </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Rational</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// Constructs a Rational from a Single </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Rational</span><span class="token punctuation">(</span><span class="token class-name">Single</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Converts a Rational to an Int32 </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token function">ToInt32</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Converts a Rational to a Single </span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Single</span> <span class="token function">ToSingle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// Implicitly constructs and returns a Rational from an Int32 </span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">implicit</span> <span class="token keyword">operator</span> <span class="token function">Rational</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Rational</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// Implicitly constructs and returns a Rational from a Single </span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">implicit</span> <span class="token keyword">operator</span> <span class="token function">Rational</span><span class="token punctuation">(</span><span class="token class-name">Single</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Rational</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token comment">// Explicitly returns an Int32 from a Rational </span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">explicit</span> <span class="token keyword">operator</span> <span class="token function">Int32</span><span class="token punctuation">(</span><span class="token class-name">Rational</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token keyword">return</span> r<span class="token punctuation">.</span><span class="token function">ToInt32</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token comment">// Explicitly returns a Single from a Rational </span></pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">explicit</span> <span class="token keyword">operator</span> <span class="token function">Single</span><span class="token punctuation">(</span><span class="token class-name">Rational</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token keyword">return</span> r<span class="token punctuation">.</span><span class="token function">ToSingle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>For conversion operator methods, you must indicate whether a compiler can emit code to call a conversion operator method implicitly or whether the source code must explicitly indicate when the compiler is to emit code to call a conversion operator method. In C#, you use the implicit keyword to indicate to the compiler that an explicit cast doesnâ€™t have to appear in the source code in order to emit code that calls the method. The explicit keyword allows the compiler to call the method only when an explicit cast exists in the source code.</p></blockquote><blockquote><p>After the implicit or explicit keyword, you tell the compiler that the method is a conversion operator by specifying the operator keyword. After the operator keyword, you specify the type that an object is being cast to; in the parentheses, you specify the type that an object is being cast from.</p></blockquote><blockquote><p>Defining the conversion operators in the preceding Rational type allows you to write code like this (in C#).</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Rational</span> r1 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// Implicit cast from Int32 to Rational </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">Rational</span> r2 <span class="token operator">=</span> <span class="token number">2.5F</span><span class="token punctuation">;</span> <span class="token comment">// Implicit cast from Single to Rational </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token punctuation">(</span>Int32<span class="token punctuation">)</span> r1<span class="token punctuation">;</span> <span class="token comment">// Explicit cast from Rational to Int32 </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token class-name">Single</span> s <span class="token operator">=</span> <span class="token punctuation">(</span>Single<span class="token punctuation">)</span> r2<span class="token punctuation">;</span> <span class="token comment">// Explicit cast from Rational to Single </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Under the covers, the C# compiler detects the casts (type conversions) in the code and internally generates IL code that calls the conversion operator methods defined by the Rational type. But what are the names of these methods? Well, compiling the Rational type and examining its metadata shows that the compiler produces one method for each conversion operator defined. For the Rational type, the metadata for the four conversion operator methods looks like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Rational</span> <span class="token function">op_Implicit</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> num<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Rational</span> <span class="token function">op_Implicit</span><span class="token punctuation">(</span><span class="token class-name">Single</span> num<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">op_Explicit</span><span class="token punctuation">(</span><span class="token class-name">Rational</span> r<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Single</span> <span class="token function">op_Explicit</span><span class="token punctuation">(</span><span class="token class-name">Rational</span> r<span class="token punctuation">)</span></pre></td></tr></table></figure><blockquote><p>As you can see, methods that convert an object from one type to another are always named op_ Implicit or op_Explicit. You should define an implicit conversion operator only when precision or magnitude isnâ€™t lost during a conversion, such as when converting an Int32 to a Rational. However, you should define an explicit conversion operator if precision or magnitude is lost during the conversion, as when converting a Rational object to an Int32. If an explicit conversion fails, you should indicate this by having your explicit conversion operator method throw an <code>OverflowException</code> or an <code>InvalidOperationException</code> .</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šä¸¤ä¸ª <code>op_Explicit</code> æ–¹æ³•è·å–ç›¸åŒçš„å‚æ•°ï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ª <code>Rational</code> ã€‚ä½†ä¸¤ä¸ªæ–¹æ³•çš„è¿”å›ç±»å‹ä¸åŒï¼Œä¸€ä¸ªæ˜¯ <code>Int32</code> ï¼Œå¦ä¸€ä¸ªæ˜¯ <code>Single</code> ã€‚è¿™æ˜¯ä»…å‡­è¿”å›ç±»å‹æ¥åŒºåˆ†ä¸¤ä¸ªæ–¹æ³•çš„ä¾‹å­ã€‚CLR å…è®¸åœ¨ä¸€ä¸ªç±»å‹ä¸­å®šä¹‰ä»…è¿”å›ç±»å‹ä¸åŒçš„å¤šä¸ªæ–¹æ³•ã€‚ä½†åªæœ‰æå°‘æ•°è¯­è¨€æ”¯æŒè¿™ä¸ªèƒ½åŠ›ã€‚ä½ å¯èƒ½å·²ç»æ³¨æ„åˆ°äº†ï¼ŒC++ï¼ŒC#ï¼ŒVisual Basic å’Œ Java è¯­è¨€éƒ½ä¸å…è®¸åœ¨ä¸€ä¸ªç±»å‹ä¸­å®šä¹‰ä»…è¿”å›ç±»å‹ä¸åŒçš„å¤šä¸ªæ–¹æ³•ã€‚ä¸ªåˆ«è¯­è¨€ (æ¯”å¦‚ IL æ±‡ç¼–è¯­è¨€) å…è®¸å¼€å‘äººå‘˜æ˜¾å¼é€‰æ‹©è°ƒç”¨å…¶ä¸­å“ªä¸€ä¸ªæ–¹æ³•ã€‚å½“ç„¶ï¼ŒIL æ±‡ç¼–è¯­è¨€çš„ç¨‹åºå‘˜ä¸åº”åˆ©ç”¨è¿™ä¸ªèƒ½åŠ›ï¼Œå¦åˆ™å®šä¹‰çš„æ–¹æ³•æ— æ³•ä»å…¶ä»–è¯­è¨€ä¸­è°ƒç”¨ã€‚è™½ç„¶ C# è¯­è¨€æ²¡æœ‰å‘ C# ç¨‹åºå‘˜å…¬å¼€è¿™ä¸ªèƒ½åŠ›ï¼Œä½†å½“ä¸€ä¸ªç±»å‹å®šä¹‰äº†è½¬æ¢æ“ä½œç¬¦æ–¹æ³•æ—¶ï¼ŒC# ç¼–è¯‘å™¨ä¼šåœ¨å†…éƒ¨åˆ©ç”¨è¿™ä¸ªèƒ½åŠ›ã€‚</p><blockquote><p>C# has full support for conversion operators. When it detects code where youâ€™re using an object of one type and an object of a different type is expected, the compiler searches for an implicit conversion operator method capable of performing the conversion and generates code to call that method. If an implicit conversion operator method exists, the compiler emits a call to it in the resulting IL code. If the compiler sees source code that is explicitly casting an object from one type to another type, the compiler searches for an implicit or explicit conversion operator method. If one exists, the compiler emits the call to the method. If the compiler canâ€™t find an appropriate conversion operator method, it issues an error and doesnâ€™t compile the code.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šä½¿ç”¨å¼ºåˆ¶ç±»å‹è½¬æ¢è¡¨è¾¾å¼æ—¶ï¼ŒC# ç”Ÿæˆä»£ç æ¥è°ƒç”¨æ˜¾å¼è½¬æ¢æ“ä½œç¬¦æ–¹æ³•ã€‚ä½¿ç”¨ C# çš„ <code>as</code> å’Œ <code>is</code> æ“ä½œç¬¦æ—¶ï¼Œåˆ™æ°¸è¿œä¸ä¼šè°ƒç”¨è¿™äº›æ–¹æ³•ã€‚(å‚è§ 4.2 èŠ‚ã€‚)</p><blockquote><p>To really understand operator overload methods and conversion operator methods, I strongly encourage you to examine the <code>System.Decimal</code> type as a role model. Decimal defines several constructors that allow you to convert objects from various types to a Decimal. It also offers several <code>ToXxx</code> methods that let you convert a Decimal object to another type. Finally, the type defines several conversion operators and operator overload methods as well.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šé™¤äº†å®šä¹‰æ„é€ å‡½æ•°å’Œä¸€äº›å…¶ä»–æ–¹æ³•æ¥å®Œæˆç±»å‹è½¬æ¢å¤–ï¼Œæœ‰äº›ç¼–ç¨‹è¯­è¨€ï¼ˆæ¯”å¦‚ C#ï¼‰è¿˜æä¾›äº†è½¬æ¢æ“ä½œç¬¦é‡è½½ã€‚è½¬æ¢æ“ä½œç¬¦æ˜¯å°†å¯¹è±¡ä»ä¸€ç§ç±»å‹è½¬æ¢æˆå¦ä¸€ç§ç±»å‹çš„æ–¹æ³•ã€‚å¯ä»¥ä½¿ç”¨ç‰¹æ®Šçš„è¯­æ³•æ¥å®šä¹‰è½¬æ¢æ“ä½œç¬¦æ–¹æ³•ã€‚CLR è§„èŒƒè¦æ±‚è½¬æ¢æ“ä½œç¬¦é‡è½½æ–¹æ³•å¿…é¡»æ˜¯ public å’Œ static æ–¹æ³•ã€‚æ­¤å¤– C#ï¼ˆä»¥åŠè®¸å¤šå…¶ä»–è¯­è¨€ï¼‰è¦æ±‚å‚æ•°ç±»å‹å’Œæ–¹æ³•è¿”å›ç±»å‹ä¸¤è€…å¿…æœ‰å…¶ä¸€ä¸å®šä¹‰è½¬æ¢æ–¹æ³•çš„ç±»å‹ç›¸åŒã€‚ä¹‹æ‰€ä»¥è¦è¿›è¡Œè¿™ä¸ªé™åˆ¶ï¼Œæ˜¯ä¸ºäº†ä½¿ C# ç¼–è¯‘å™¨èƒ½åœ¨ä¸€ä¸ªåˆç†çš„æ—¶é—´å†…æ‰¾åˆ°è¦ç»‘å®šçš„æ“ä½œç¬¦æ–¹æ³•ã€‚å¯¹äºè½¬æ¢æ“ä½œç¬¦æ–¹æ³•ï¼Œç¼–è¯‘å™¨æ—¢å¯ç”Ÿæˆä»£ç æ¥éšå¼è°ƒç”¨è½¬æ¢æ“ä½œç¬¦æ–¹æ³•ï¼Œä¹Ÿå¯åªæœ‰åœ¨æºä»£ç è¿›è¡Œäº†æ˜¾å¼è½¬å‹æ—¶æ‰ç”Ÿæˆä»£ç æ¥è°ƒç”¨è½¬æ¢æ“ä½œç¬¦æ–¹æ³•ã€‚åœ¨ C# ä¸­ï¼Œimplicit å…³é”®å­—å‘Šè¯‰ç¼–è¯‘å™¨ä¸ºäº†ç”Ÿæˆä»£ç æ¥è°ƒç”¨æ–¹æ³•ï¼Œä¸éœ€è¦å†æºä»£ç ä¸­è¿›è¡Œæ˜¾å¼è½¬å‹ã€‚ç›¸åï¼Œexplicit å…³é”®å­—å‘Šè¯‰ç¼–è¯‘å™¨åªæœ‰åœ¨å‘ç°äº†æ˜¾ç¤ºè½¬å‹æ—¶ï¼Œæ‰è°ƒç”¨æ–¹æ³•ã€‚åœ¨ implicit æˆ– explicit å…³é”®å­—ä¹‹åï¼Œè¦æŒ‡å®š operator å…³é”®å­—å‘Šè¯‰ç¼–è¯‘å™¨è¯¥æ–¹æ³•æ˜¯ä¸€ä¸ªè½¬æ¢æ“ä½œç¬¦ã€‚åœ¨ operator ä¹‹åï¼ŒæŒ‡å®šå¯¹è±¡è¦è½¬æ¢æˆä»€ä¹ˆç±»å‹ã€‚åœ¨åœ†æ‹¬å·å†…ï¼Œåˆ™æŒ‡å®šè¦ä»ä»€ä¹ˆç±»å‹è½¬æ¢ã€‚å°†å¯¹è±¡ä»ä¸€ç§ç±»å‹è½¬æ¢æˆå¦ä¸€ç§ç±»å‹çš„æ–¹æ³•çš„å…ƒæ•°æ®æ€»æ˜¯å«åš op_Implicit æˆ–è€… op_Explicitã€‚åªæœ‰åœ¨è½¬æ¢ä¸æŸå¤±ç²¾åº¦æˆ–æ•°é‡çº§çš„å‰æä¸‹æ‰èƒ½å®šä¹‰éšå¼è½¬æ¢æ“ä½œç¬¦ï¼Œå¦åˆ™å°±åº”è¯¥å®šä¹‰æ˜¾å¼è½¬æ¢æ“ä½œç¬¦ï¼Œå¹¶ä¸”åœ¨æ˜¾å¼è½¬æ¢å¤±è´¥æ—¶æŠ›å‡º <code>OverflowException</code> æˆ–è€… <code>InvalidOperationException</code> å¼‚å¸¸ã€‚å¦‚æœæ£€æµ‹åˆ°ä»£ç ä¸­å­˜åœ¨éšå¼è½¬æ¢çš„ä»£ç ï¼Œå¦‚æœå­˜åœ¨å¯¹åº”çš„éšå¼è½¬æ¢æ“ä½œç¬¦æ–¹æ³•ï¼Œç¼–è¯‘å™¨å°±ä¼šåœ¨ç»“æœ IL ä»£ç ä¸­ç”Ÿæˆå¯¹å®ƒçš„è°ƒç”¨ã€‚å¦‚æœç¼–è¯‘å™¨çœ‹åˆ°çš„æ˜¯å°†å¯¹è±¡ä»ä¸€ç§ç±»å‹æ˜¾å¼è½¬æ¢ä¸ºå¦ä¸€ç§ç±»å‹ï¼Œå°±ä¼šæŸ¥æ‰¾èƒ½æ‰§è¡Œè¿™ç§è½¬æ¢çš„éšå¼æˆ–æ˜¾å¼è½¬æ¢æ“ä½œç¬¦æ–¹æ³•ã€‚å¦‚æœæ‰¾åˆ°ä¸€ä¸ªï¼Œç¼–è¯‘å™¨å°±ç”Ÿæˆ IL ä»£ç æ¥è°ƒç”¨å®ƒã€‚å¦‚æœæ²¡æœ‰æ‰¾åˆ°åˆé€‚çš„è½¬æ¢æ“ä½œç¬¦æ–¹æ³•ï¼Œå°±æŠ¥é”™å¹¶åœæ­¢ç¼–è¯‘ã€‚</p><h2 id="extension-methods"><a class="anchor" href="#extension-methods">#</a> Extension Methods</h2><blockquote><p>The best way to understand C#â€™s extension methods feature is by way of an example. In the â€œ <code>StringBuilder</code> Membersâ€ section in Chapter 14, â€œChars, Strings, and Working with Text,â€ I mention how the <code>StringBuilder</code> class offers fewer methods than the String class for manipulating a string and how strange this is, considering that the <code>StringBuilder</code> class is the preferred way of manipulating a string because it is mutable. So, letâ€™s say that you would like to define some of these missing methods yourself to operate on a <code>StringBuilder</code> . For example, you might want to define your own <code>IndexOf</code> method as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">StringBuilderExtensions</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">IndexOf</span><span class="token punctuation">(</span><span class="token class-name">StringBuilder</span> sb<span class="token punctuation">,</span> <span class="token class-name">Char</span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> sb<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>sb<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token keyword">return</span> index<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Now that you have defined this method, you can use it as the following code demonstrates.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token string">"Hello. My name is Jeff."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// The initial string</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// Change period to exclamation and get # characters in 1st sentence (5).</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">Int32</span> index <span class="token operator">=</span> StringBuilderExtensions<span class="token punctuation">.</span><span class="token function">IndexOf</span><span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">Replace</span><span class="token punctuation">(</span><span class="token char">'.'</span><span class="token punctuation">,</span> <span class="token char">'!'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token char">'!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>This code works just fine, but is it not ideal from a programmerâ€™s perspective. The first problem is that a programmer who wants to get the index of a character within a <code>StringBuilder</code> must know that the <code>StringBuilderExtensions</code> class even exists. The second problem is that the code does not reflect the order of operations that are being performed on the <code>StringBuilder</code> object, making the code difficult to write, read, and maintain. The programmer wants to call Replace first and then call <code>IndexOf</code> ; but when you read the last line of code from left to right, <code>IndexOf</code> appears first on the line and Replace appears second. Of course, you could alleviate this problem and make the codeâ€™s behavior more understandable by rewriting it like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// First, change period to exclamation mark</span></pre></td></tr><tr><td data-num="2"></td><td><pre>sb<span class="token punctuation">.</span><span class="token function">Replace</span><span class="token punctuation">(</span><span class="token char">'.'</span><span class="token punctuation">,</span> <span class="token char">'!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// Now, get # characters in 1st sentence (5)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token class-name">Int32</span> index <span class="token operator">=</span> StringBuilderExtensions<span class="token punctuation">.</span><span class="token function">IndexOf</span><span class="token punctuation">(</span>sb<span class="token punctuation">,</span> <span class="token char">'!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>However, a third problem exists with both versions of this code that affects understanding the codeâ€™s behavior. The use of <code>StringBuilderExtensions</code> is overpowering and detracts a programmerâ€™s mind from the operation that is being performed: <code>IndexOf</code> . If the <code>StringBuilder</code> class had defined its own <code>IndexOf</code> method, then we could rewrite the code above as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Change period to exclamation and get # characters in 1st sentence (5).</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Int32</span> index <span class="token operator">=</span> sb<span class="token punctuation">.</span><span class="token function">Replace</span><span class="token punctuation">(</span><span class="token char">'.'</span><span class="token punctuation">,</span> <span class="token char">'!'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">IndexOf</span><span class="token punctuation">(</span><span class="token char">'!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>Wow, look how great this is in terms of code maintainability! In the <code>StringBuilder</code> object, weâ€™re going to replace a period with an exclamation mark and then find the index of the exclamation mark.</p></blockquote><blockquote><p>Now, I can explain what C#â€™s extension methods feature does. It allows you to define a static method that you can invoke using instance method syntax. Or, in other words, we can now define our own <code>IndexOf</code> method and the three problems mentioned above go away. To turn the <code>IndexOf</code> method into an extension method, we simply add the this keyword before the first argument.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">StringBuilderExtensions</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">IndexOf</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">StringBuilder</span> sb<span class="token punctuation">,</span> <span class="token class-name">Char</span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> sb<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>sb<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token keyword">return</span> index<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Now, when the compiler sees code like the following, the compiler first checks if the <code>StringBuilder</code> class or any of its base classes offers an instance method called <code>IndexOf</code> that takes a single Char parameter.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Int32</span> index <span class="token operator">=</span> sb<span class="token punctuation">.</span><span class="token function">IndexOf</span><span class="token punctuation">(</span><span class="token char">'X'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>If an existing instance method exists, then the compiler produces IL code to call it. If no matching instance method exists, then the compiler will look at any static classes that define static methods called <code>IndexOf</code> that take as their first parameter a type matching the type of the expression being used to invoke the method. This type must also be marked with the this keyword. In this example, the expression is sb, which is of the <code>StringBuilder</code> type. In this case, the compiler is looking specifically for an <code>IndexOf</code> method that takes two parameters: a <code>StringBuilder</code> (marked with the this keyword) and a Char. The compiler will find our <code>IndexOf</code> method and produce IL code that calls our static method.</p></blockquote><blockquote><p>OKâ€”so this now explains how the compiler improves the last two problems related to code understandability that I mentioned earlier. However, I havenâ€™t yet addressed the first problem: how does a programmer know that an <code>IndexOf</code> method even exists that can operate on a <code>StringBuilder</code> object? The answer to this question is found in Microsoft Visual Studioâ€™s IntelliSense feature. In the editor, when you type a period, Visual Studioâ€™s IntelliSense window opens to show you the list of instance methods that are available. Well, that IntelliSense window also shows you any extension methods that exist for the type of expression you have to the left of the period. Figure 8-1 shows Visual Studioâ€™s IntelliSense window; the icon for an extension method has a down arrow next to it, and the tooltip next to the method indicates that the method is really an extension method. This is truly awesome because it is now easy to define your own methods to operate on various types of objects and have other programmers discover your methods naturally when using objects of these types.</p></blockquote><p><img data-src="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/image-20221025222135596.png" alt="image-20221025222135596"></p><h3 id="rules-and-guidelines"><a class="anchor" href="#rules-and-guidelines">#</a> Rules and Guidelines</h3><blockquote><p>There are some additional rules and guidelines that you should know about extension methods:</p></blockquote><ul><li><p>C# supports extension methods only; it does not offer extension properties, extension events, extension operators, and so on.</p></li><li><p>Extension methods (methods with this before their first argument) must be declared in nongeneric, static classes. However, there is no restriction on the name of the class; you can call it whatever you want. Of course, an extension method must have at least one parameter, and only the first parameter can be marked with the this keyword.</p></li><li><p>The C# compiler looks only for extension methods defined in static classes that are themselves defined at the file scope. In other words, if you define the static class nested within another class, the C# compiler will emit the following message: error CS1109: Extension method must be defined in a top-level static class; <code>StringBuilderExtensions</code> is a nested class.</p></li><li><p>Because the static classes can have any name you want, it takes the C# compiler time to find extension methods because it must look at all the file-scope static classes and scan their static methods for a match. To improve performance and also to avoid considering an extension method that you may not want, the C# compiler requires that you â€œimportâ€ extension methods. For example, if someone has defined a <code>StringBuilderExtensions</code> class in a <code>Wintellect</code> namespace, then a programmer who wants to have access to this classâ€™s extension methods must put a using <code>Wintellect</code> ; directive at the top of his or her source code file.</p></li><li><p>It is possible that multiple static classes could define the same extension method. If the compiler detects that two or more extension methods exist, then the compiler issues the following message: error CS0121: The call is ambiguous between the following methods or properties: ' <code>StringBuilderExtensions.IndexOf(string, char)</code> ' and ' <code>AnotherStringBuilderExtensions.IndexOf(string, char)</code> '. To fix this error, you must modify your source code. Specifically, you cannot use the instance method syntax to call this static method anymore; instead you must now use the static method syntax where you explicitly indicate the name of the static class to explicitly tell the compiler which method you want to invoke.</p></li><li><p>You should use this feature sparingly, because not all programmers are familiar with it. For example, when you extend a type with an extension method, you are actually extending derived types with this method as well. Therefore, you should not define an extension method whose first parameter is <code>System.Object</code> , because this method will be callable for all expression types and this will really pollute Visual Studioâ€™s IntelliSense window.</p></li><li><p>There is a potential versioning problem that exists with extension methods. If, in the future, Microsoft adds an <code>IndexOf</code> instance method to their <code>StringBuilder</code> class with the same prototype as my code is attempting to call, then when I recompile my code, the compiler will bind to Microsoftâ€™s <code>IndexOf</code> instance method instead of my static <code>IndexOf</code> method. Because of this, my program will experience different behavior. This versioning problem is another reason why this feature should be used sparingly.</p></li></ul><h3 id="extending-various-types-with-extension-methods"><a class="anchor" href="#extending-various-types-with-extension-methods">#</a> Extending Various Types with Extension Methods</h3><blockquote><p>In this chapter, I demonstrated how to define an extension method for a class, <code>StringBuilder</code> . Iâ€™d like to point out that because an extension method is really the invocation of a static method, the CLR does not emit code ensuring that the value of the expression used to invoke the method is not null.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// sb is null</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// Calling extension method: NullReferenceException will NOT be thrown when calling IndexOf</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// NullReferenceException will be thrown inside IndexOfâ€™s for loop</span></pre></td></tr><tr><td data-num="5"></td><td><pre>sb<span class="token punctuation">.</span><span class="token function">IndexOf</span><span class="token punctuation">(</span><span class="token char">'X'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// Calling instance method: NullReferenceException WILL be thrown when calling Replace</span></pre></td></tr><tr><td data-num="7"></td><td><pre>sb<span class="token punctuation">.</span><span class="token function">Replace</span><span class="token punctuation">(</span><span class="token char">'.'</span><span class="token punctuation">,</span> <span class="token char">'!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>Iâ€™d also like to point <span class="token keyword">out</span> that you can define extension methods <span class="token keyword">for</span> <span class="token keyword">interface</span> <span class="token class-name">types</span><span class="token punctuation">,</span> <span class="token keyword">as</span> <span class="token class-name">the</span> following code shows<span class="token punctuation">.</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">ShowItems</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> collection<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> item <span class="token keyword">in</span> collection<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>The extension method above can now be invoked <span class="token keyword">using</span> any expression <span class="token class-name">that</span> results <span class="token keyword">in</span> a type that </pre></td></tr><tr><td data-num="14"></td><td><pre>implements the IEnumerable<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">interface</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token comment">// Shows each Char on a separate line in the console</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token string">"Grant"</span><span class="token punctuation">.</span><span class="token function">ShowItems</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token comment">// Shows each String on a separate line in the console</span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token keyword">new</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span> <span class="token string">"Jeff"</span><span class="token punctuation">,</span> <span class="token string">"Kristin"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">ShowItems</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token comment">// Shows each Int32 value on a separate line in the console</span></pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">List<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">ShowItems</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>ğŸ’¡é‡è¦æç¤ºï¼šæ‰©å±•æ–¹æ³•æ˜¯ Microsoft çš„ LINQ (<strong>Language Integrated Query</strong>ï¼Œè¯­è¨€é›†æˆæŸ¥è¯¢) æŠ€æœ¯çš„åŸºç¡€ã€‚è¦æƒ³ä»”ç»†ç ”ç©¶æä¾›äº†è®¸å¤šæ‰©å±•æ–¹æ³•çš„ä¸€ä¸ªå…¸å‹çš„ç±»ï¼Œè¯·è‡ªè¡Œåœ¨æ–‡æ¡£ä¸­æŸ¥çœ‹é™æ€ç±» <code>System.Linq.Enumerable</code> åŠå…¶æ‰€æœ‰é™æ€æ‰©å±•æ–¹æ³•ã€‚è¿™ä¸ªç±»ä¸­çš„æ¯ä¸ªæ‰©å±•æ–¹æ³•éƒ½æ‰©å±•äº† <code>IEnumerable</code> æˆ– <code>IEnumerable&lt;T&gt;</code> æ¥å£ã€‚</p><blockquote><p>You can define extension methods for delegate types, too. Here is an example.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">InvokeAndCatch</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>TException<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">Action<span class="token punctuation">&lt;</span>Object<span class="token punctuation">></span></span> d<span class="token punctuation">,</span> <span class="token class-name">Object</span> o<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">where</span> <span class="token class-name">TException</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Exception</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span> <span class="token function">d</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">TException</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>And here is an example of how to invoke it.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Action<span class="token punctuation">&lt;</span>Object<span class="token punctuation">></span></span> action <span class="token operator">=</span> o <span class="token operator">=></span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Throws NullReferenceException</span></pre></td></tr><tr><td data-num="2"></td><td><pre>action<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">InvokeAndCatch</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>NullReferenceException<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Swallows NullReferenceException</span></pre></td></tr></table></figure><blockquote><p>You can also add extension methods to enumerated types. I show an example of this in the â€œAdding Methods to Enumerated Typesâ€ section in Chapter 15, â€œEnumerated Types and Bit Flags.</p></blockquote><blockquote><p>And last but not least, I want to point out that the C# compiler allows you to create a delegate (see Chapter 17, â€œDelegates,â€ for more information) that refers to an extension method over an object.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> Main <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Create an Action delegate that refers to the static ShowItems extension method</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// and has the first argument initialized to reference the "Jeff" string. </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">Action</span> a <span class="token operator">=</span> <span class="token string">"Jeff"</span><span class="token punctuation">.</span>ShowItems<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">.</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">.</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">.</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Invoke the delegate that calls ShowItems passing it a reference to the "Jeff" string.</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In the preceding code, the C# compiler generates IL code to construct an Action delegate. When creating a delegate, the constructor is passed the method that should be called and is also passed a reference to an object that should be passed to the methodâ€™s hidden this parameter. Normally, when you create a delegate that refers to a static method, the object reference is null because static methods donâ€™t have a this parameter. However, in this example, the C# compiler generated some special code that creates a delegate that refers to a static method (ShowItems) and the target object of the static method is the reference to the â€œJeffâ€ string. Later, when the delegate is invoked, the CLR will call the static method and will pass to it the reference to the â€œJeffâ€ string. This is a little hacky, but it works great and it feels natural so long as you donâ€™t think about what is happening internally.</p></blockquote><h3 id="the-extension-attribute"><a class="anchor" href="#the-extension-attribute">#</a> The Extension Attribute</h3><blockquote><p>It would be best if this concept of extension methods was not C#-specific. Specifically, we want programmers to define a set of extension methods in some programming language and for people in other programming languages to take advantage of them. For this to work, the compiler of choice must support searching static types and methods for potentially matching extension methods. And compilers need to do this quickly so that compilation time is kept to a minimum.</p></blockquote><blockquote><p>In C#, when you mark a static methodâ€™s first parameter with the this keyword, the compiler internally applies a custom attribute to the method and this attribute is persisted in the resulting fileâ€™s metadata. The attribute is defined in the System.Core.dll assembly, and it looks like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Defined in the System.Runtime.CompilerServices namespace</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">[</span><span class="token function">AttributeUsage</span><span class="token punctuation">(</span>AttributeTargets<span class="token punctuation">.</span>Method <span class="token operator">|</span> AttributeTargets<span class="token punctuation">.</span>Class <span class="token operator">|</span> AttributeTargets<span class="token punctuation">.</span>Assembly<span class="token punctuation">)</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">ExtensionAttribute</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Attribute</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In addition, this attribute is applied to the metadata for any static class that contains at least one extension method. And this attribute is also applied to the metadata for any assembly that contains at least one static class that contains an extension method. So now, when compiling code that invokes an instance method that doesnâ€™t exist, the compiler can quickly scan all the referenced assemblies to know which ones contain extension methods. Then it can scan only these assemblies for static classes that contain extension methods, and it can scan just the extension methods for potential matches to compile the code as quickly as possible.</p></blockquote><p>ğŸ’¡Note : The ExtensionAttribute class is defined in the System.Core.dll assembly. This means that the resulting assembly produced by the compiler will have a reference to System.Core.dll embedded in it even if I do not use any types from System.Core.dll and do not even reference System.Core.dll when compiling my code. However, this is not too bad a problem because the ExtensionAttribute is used only at compile time; at run time, System.Core.dll will not have to be loaded unless the application consumes something else in this assembly.</p><p>ğŸ’¡å°ç»“ï¼šC# æ‰©å±•æ–¹æ³•å…è®¸åœ¨ä¸€ä¸ªé™æ€ç±»ä¸­å®šä¹‰ä¸€ä¸ªé™æ€æ–¹æ³•ï¼Œå¹¶ç”¨å®ä¾‹æ–¹æ³•çš„è¯­æ³•æ¥è°ƒç”¨ã€‚æ‰©å±•æ–¹æ³•é¡¾åæ€ä¹‰æ—¶å¯¹ç±»è¡Œæ–¹æ³•çš„æ‰©å±•ï¼Œåœ¨è°ƒç”¨æ–¹æ³•æ—¶é¦–å…ˆä¼šæ£€æŸ¥ç±»æˆ–è€…å®ƒçš„ä»»ä½•åŸºç±»æ˜¯å¦å®šä¹‰è¯¥åç§°çš„å®ä¾‹æ–¹æ³•ã€‚å¦‚æœå®šä¹‰äº†ï¼Œå°±ç”Ÿæˆ IL ä»£ç æ¥è°ƒç”¨å®ƒã€‚å¦‚æœæ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„å®ä¾‹æ–¹æ³•ï¼Œå°±ç»§ç»­æ£€æŸ¥æ˜¯å¦æœ‰ä»»ä½•é™æ€ç±»å®šä¹‰äº†è¯¥åç§°çš„é™æ€æ–¹æ³•ï¼Œæ–¹æ³•çš„ç¬¬ä¸€ä¸ªå‚æ•°çš„ç±»å‹å’Œå½“å‰ç”¨äºè°ƒç”¨æ–¹æ³•çš„é‚£ä¸ªè¡¨è¾¾å¼çš„ç±»å‹åŒ¹é…ï¼Œè€Œä¸”è¯¥ç±»å‹å¿…é¡»ç”¨ this å…³é”®å­—æ ‡è¯†ã€‚å…³äºæ‰©å±•æ–¹æ³•ï¼Œæœ‰äº›è§„åˆ™å’ŒåŸåˆ™éœ€è¦æ³¨æ„ã€‚ä¾‹å¦‚ C# åªæ”¯æŒæ‰©å±•æ–¹æ³•ï¼Œä¸æ”¯æŒæ‰©å±•å±æ€§ã€æ‰©å±•äº‹ä»¶ã€æ‰©å±•æ“ä½œç¬¦ç­‰ã€‚æ‰©å±•æ–¹æ³•å¿…é¡»åœ¨éæ³›å‹çš„é™æ€ç±»ä¸­å£°æ˜ã€‚æ‰©å±•æ–¹æ³•è‡³å°‘è¦æœ‰ä¸€ä¸ªå‚æ•°ï¼Œè€Œä¸”åªæœ‰ç¬¬ä¸€ä¸ªå‚æ•°èƒ½ç”¨ this å…³é”®å­—æ ‡è®°ã€‚C# ç¼–è¯‘å™¨åœ¨é™æ€ç±»ä¸­æŸ¥æ‰¾æ‰©å±•æ–¹æ³•æ—¶ï¼Œè¦æ±‚é™æ€ç±»æœ¬èº«å¿…é¡»å…·æœ‰æ–‡ä»¶ä½œç”¨åŸŸã€‚ç”¨ä¸€ä¸ªæ‰©å±•æ–¹æ³•æ‰©å±•ä¸€ä¸ªç±»å‹æ—¶ï¼ŒåŒæ—¶ä¹Ÿæ‰©å±•äº†æ´¾ç”Ÿç±»å‹ã€‚ç”±äºæ‰©å±•æ–¹æ³•å®é™…æ˜¯å¯¹ä¸€ä¸ªé™æ€æ–¹æ³•çš„è°ƒç”¨ï¼Œæ‰€ä»¥ CLR ä¸ä¼šç”Ÿæˆä»£ç å¯¹è°ƒç”¨æ–¹æ³•çš„è¡¨è¾¾å¼çš„å€¼è¿›è¡Œ null å€¼æ£€æŸ¥ï¼ˆä¸ä¿è¯å®ƒéç©ºï¼‰ã€‚æˆ‘ä»¬è¿˜å¯ä»¥ä¸ºæ¥å£ç±»å‹ã€å§”æ‰˜ç±»å‹ã€æšä¸¾ç±»å‹å®šä¹‰æ‰©å±•æ–¹æ³•ã€‚C# ç¼–è¯‘å™¨å…è®¸åˆ›å»ºå§”æ‰˜æ¥å¼•ç”¨ä¸€ä¸ªå¯¹è±¡ä¸Šçš„æ‰©å±•æ–¹æ³•ã€‚åœ¨ C# ä¸­ï¼Œä¸€æ—¦ this å…³é”®å­—æ ‡è®°äº†æŸä¸ªé™æ€æ–¹æ³•çš„ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œç¼–è¯‘å™¨å°±ä¼šåœ¨å†…éƒ¨å‘è¯¥æ–¹æ³•åº”ç”¨ä¸€ä¸ªå®šåˆ¶ç‰¹æ€§ã€‚è¯¥ç‰¹æ€§ä¼šåœ¨æœ€ç»ˆç”Ÿæˆçš„æ–‡ä»¶çš„å…ƒæ•°æ®ä¸­æŒä¹…æ€§åœ°å­˜å‚¨ä¸‹æ¥ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œä»»ä½•é™æ€ç±»åªè¦åŒ…å«è‡³å°‘ä¸€ä¸ªæ‰©å±•æ–¹æ³•ï¼Œå®ƒçš„å…ƒæ•°æ®ä¸­ä¹Ÿä¼šåº”ç”¨è¿™ä¸ªç‰¹æ€§ã€‚ç±»ä¼¼åœ°ï¼Œä»»ä½•ç¨‹åºé›†åªè¦åŒ…å«äº†è‡³å°‘ä¸€ä¸ªç¬¦åˆä¸Šè¿°ç‰¹ç‚¹çš„é™æ€ç±»ï¼Œå®ƒçš„å…ƒæ•°æ®ä¸­ä¹Ÿä¼šåº”ç”¨è¿™ä¸ªç‰¹æ€§ã€‚</p><h2 id="partial-methods"><a class="anchor" href="#partial-methods">#</a> Partial Methods</h2><blockquote><p>Imagine that you use a tool that produces a C# source code file containing a type definition. The tool knows that there are potential places within the code it produces where you might want to customize the typeâ€™s behavior. Normally, customization would be done by having the tool-produced code invoke virtual methods. The tool-produced code would also have to contain definitions for these virtual methods, and the way these methods would be implemented is to do nothing and simply return. Now, if you want to customize the behavior of the class, youâ€™d define your own class, derive it from the base class, and then override any virtual methods implementing it so that it has the behavior you desire. Here is an example.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Tool-produced code in some source code file:</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">String</span> m_name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// Called before changing the m_name field</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">protected</span> <span class="token keyword">virtual</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">OnNameChanging</span><span class="token punctuation">(</span><span class="token class-name">String</span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">String</span> Name <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> m_name<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">set</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token function">OnNameChanging</span><span class="token punctuation">(</span><span class="token keyword">value</span><span class="token punctuation">.</span><span class="token function">ToUpper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Inform class of potential change</span></pre></td></tr><tr><td data-num="11"></td><td><pre> m_name <span class="token operator">=</span> <span class="token keyword">value</span><span class="token punctuation">;</span> <span class="token comment">// Change the field</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">// Developer-produced code in some other source code file:</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Base</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token keyword">protected</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">OnNameChanging</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">IsNullOrEmpty</span><span class="token punctuation">(</span><span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ArgumentNullException</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Unfortunately, there are two problems with the preceding code:</p></blockquote><ul><li><p>The type must be a class that is not sealed. You cannot use this technique for sealed classes or for value types (because value types are implicitly sealed). In addition, you cannot use this technique for static methods because they cannot be overridden.</p></li><li><p>There are efficiency problems here. A type is being defined just to override a method; this wastes a small amount of system resources. And, even if you do not want to override the behavior of <code>OnNameChanging</code> , the base class code still invokes a virtual method that simply does nothing but return. Also, <code>ToUpper</code> is called whether <code>OnNameChanging</code> accesses the argument passed to it or not.</p></li></ul><blockquote><p>C#â€™s partial methods feature allows you the option of overriding the behavior or a type while fixing the aforementioned problems. The code below uses partial methods to accomplish the same semantic as the previous code.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Tool-produced code in some source code file:</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">partial</span> <span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">String</span> m_name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// This defining-partial-method-declaration is called before changing the m_name field</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">partial</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">OnNameChanging</span><span class="token punctuation">(</span><span class="token class-name">String</span> <span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">String</span> Name <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> m_name<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">set</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token function">OnNameChanging</span><span class="token punctuation">(</span><span class="token keyword">value</span><span class="token punctuation">.</span><span class="token function">ToUpper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Inform class of potential change</span></pre></td></tr><tr><td data-num="10"></td><td><pre> m_name <span class="token operator">=</span> <span class="token keyword">value</span><span class="token punctuation">;</span> <span class="token comment">// Change the field</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token comment">// Developer-produced code in some other source code file:</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">partial</span> <span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token comment">// This implementing-partial-method-declaration is called before m_name is changed </span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token keyword">partial</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">OnNameChanging</span><span class="token punctuation">(</span><span class="token class-name">String</span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">IsNullOrEmpty</span><span class="token punctuation">(</span><span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ArgumentNullException</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>There are several things to notice about this new version of the code:</p></blockquote><ul><li><p>The class is now sealed (although it doesnâ€™t have to be). In fact, the class could be a static class or even a value type.</p></li><li><p>The tool-produced code and the developer-produced code are really two partial definitions that ultimately make up one type definition. For more information about partial types, see the â€œPartial Classes, Structures, and Interfacesâ€ section in Chapter 6, â€œType and Member Basics.â€</p></li><li><p>The tool-produced code defined a partial method declaration. This method is marked with the partial token and it has no body.</p></li><li><p>The developer-produced code implemented the partial method declaration. This method is also marked with the partial token and it has a body.</p></li></ul><blockquote><p>Now, when you compile this code, you see the same effect as the original code I showed you. Again, the big benefit here is that you can rerun the tool and produce new code in a new source code file, but your code remains in a separate file and is unaffected. And, this technique works for sealed classes, static classes, and value types.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šåœ¨ Visual Studio ç¼–è¾‘å™¨ä¸­ï¼Œå¦‚æœè¾“å…¥ <code>partial</code> å¹¶æŒ‰ç©ºæ ¼é”®ï¼Œâ€œæ™ºèƒ½æ„ŸçŸ¥â€ çª—å£ä¼šåˆ—å‡ºå½“å‰ç±»å‹å®šä¹‰çš„ã€è¿˜æ²¡æœ‰åŒ¹é…å®ç°çš„æ‰€æœ‰åˆ†éƒ¨æ–¹æ³•å£°æ˜ã€‚å¯ä»¥æ–¹ä¾¿åœ°ä»çª—å£ä¸­é€‰æ‹©ä¸€ä¸ªåˆ†éƒ¨æ–¹æ³•ã€‚ç„¶åï¼ŒVisual Studio ä¼šè‡ªåŠ¨ç”Ÿæˆæ–¹æ³•åŸå‹ã€‚è¿™ä¸ªåŠŸèƒ½æé«˜äº†ç¼–ç¨‹æ•ˆç‡ã€‚</p><blockquote><p>But, there is another big improvement we get with partial methods. Letâ€™s say that you do not need to modify the behavior of the tool-produced type. In this case, you do not supply your source code file at all. If you just compile the tool-produced code by itself, the compiler produces IL code and metadata as if the tool-produced code looked like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Logical equivalent of tool-produced code if there is no </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// implementing partial method declaration:</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">String</span> m_name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">String</span> Name <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> m_name<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">set</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> m_name <span class="token operator">=</span> <span class="token keyword">value</span><span class="token punctuation">;</span> <span class="token comment">// Change the field</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>That is, if there is no implementing partial method declaration, the compiler will not emit any metadata representing the partial method. In addition, the compiler will not emit any IL instructions to call the partial method. And the compiler will not emit code that evaluates any arguments that would have been passed to the partial method. In this example, the compiler will not emit code to call the ToUpper method. The result is that there is less metadata/IL, and the run-time performance is awesome!</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šåˆ†éƒ¨æ–¹æ³•çš„å·¥ä½œæ–¹å¼ç±»ä¼¼äº <code>System.Diagnostics.ConditionalAttribute</code> ç‰¹æ€§ã€‚ç„¶è€Œï¼Œåˆ†éƒ¨æ–¹æ³•åªèƒ½åœ¨å•ä¸ªç±»å‹ä¸­ä½¿ç”¨ï¼Œè€Œ <code>ConditionalAttribute</code> èƒ½ç”¨äºå¯¹å¦ä¸€ä¸ªç±»å‹ä¸­å®šä¹‰çš„æ–¹æ³•è¿›è¡Œæœ‰é€‰æ‹©çš„è°ƒç”¨ã€‚</p><h3 id="rules-and-guidelines-2"><a class="anchor" href="#rules-and-guidelines-2">#</a> Rules and Guidelines</h3><blockquote><p>There are some additional rules and guidelines that you should know about partial methods:</p></blockquote><ul><li><p>They can only be declared within a partial class or struct.</p></li><li><p>Partial methods must always have a return type of void, and they cannot have any parameters marked with the out modifier. These restrictions are in place because at run time, the method may not exist and so you canâ€™t initialize a variable to what the method might return because the method might not exist. Similarly, you canâ€™t have an out parameter because the method would have to initialize it and the method might not exist. A partial method may have ref parameters, may be generic, may be instance or static, and may be marked as unsafe.</p></li><li><p>Of course, the defining partial method declaration and the implementing partial method declaration must have identical signatures. If both have custom attributes applied to them, then the compiler combines both methodsâ€™ attributes together. Any attributes applied to a parameter are also combined.</p></li><li><p>If there is no implementing partial method declaration, then you cannot have any code that attempts to create a delegate that refers to the partial method. Again, the reason is that the method doesnâ€™t exist at run time. The compiler produces this message: error CS0762: Cannot create delegate from method ' <code>Base.OnNameChanging(string)</code> ' because it is a partial method without an implementing declaration.</p></li><li><p>Partial methods are always considered to be private methods. However, the C# compiler forbids you from putting the private keyword before the partial method declaration.</p></li></ul><p>ğŸ’¡å°ç»“ï¼šå‡è®¾æˆ‘ä»¬ç”¨å·¥å…·ç”Ÿæˆäº†åŒ…å«ç±»å‹å®šä¹‰çš„ C# æºä»£ç æ–‡ä»¶ï¼Œå¹¶ä¸”æƒ³è¦åœ¨ä»£ç çš„æŸäº›ä½ç½®å®šä¹‰ç±»å‹çš„è¡Œä¸ºï¼Œæ­£å¸¸æƒ…å†µä¸‹ï¼Œæ˜¯è®©å·¥å…·ç”Ÿæˆçš„ä»£ç è°ƒç”¨è™šæ–¹æ³•æ¥è¿›è¡Œå®šåˆ¶ã€‚ä½†æ˜¯è¿™æ ·çš„ä»£ç å­˜åœ¨ä¸¤ä¸ªé—®é¢˜ã€‚ä¸€æ˜¯ç±»å‹å¿…é¡»æ˜¯éå¯†å°çš„ç±»ã€‚äºŒæ˜¯æ•ˆç‡é—®é¢˜ï¼Œä¼šè°ƒç”¨å¾ˆå¤šå¤šä½™çš„ä»£ç ã€‚åˆ©ç”¨ C# çš„åˆ†éƒ¨æ–¹æ³•åŠŸèƒ½ï¼Œå¯ä»¥è§£å†³ä¸Šè¿°é—®é¢˜çš„åŒæ—¶è¦†ç›–ç±»çš„è¡Œä¸ºã€‚ä½¿ç”¨åˆ†éƒ¨æ–¹æ³•çš„å¥½å¤„åœ¨äºï¼Œå¯ä»¥é‡æ–°è¿è¡Œå·¥å…·ï¼Œåœ¨æ–°çš„æºä»£ç æ–‡ä»¶ä¸­ç”Ÿæˆæ–°çš„ä»£ç ï¼Œä½†æˆ‘ä»¬è‡ªå·±çš„ä»£ç æ—¶å­˜å‚¨åœ¨ä¸€ä¸ªå•ç‹¬çš„æ–‡ä»¶ä¸­çš„ï¼Œä¸ä¼šæ”¶åˆ°å½±å“ã€‚å¦å¤–ï¼Œè¿™ä¸ªæŠ€æœ¯å¯ç”¨äºå¯†å°ç±»ã€é™æ€ç±»ä»¥åŠå€¼ç±»å‹ã€‚å¦‚æœæ²¡æœ‰å®ç°åˆ†å¸ƒæ–¹æ³•ï¼Œç¼–è¯‘å™¨ä¸ä¼šç”Ÿæˆä»»ä½•ä»£è¡¨åˆ†å¸ƒæ–¹æ³•çš„å…ƒæ•°æ®ã€‚æ­¤å¤–ï¼Œç¼–è¯‘å™¨ä¸ä¼šç”Ÿæˆä»»ä½•è°ƒç”¨åˆ†éƒ¨æ–¹æ³•çš„ IL æŒ‡ä»¤ã€‚è€Œä¸”ï¼Œç¼–è¯‘å™¨ä¸ä¼šç”Ÿæˆå¯¹æœ¬è¯¥ä¼ ç»™åˆ†éƒ¨æ–¹æ³•çš„å®å‚è¿›è¡Œæ±‚å€¼çš„ IL æŒ‡ä»¤ã€‚å¯¹äºåˆ†éƒ¨æ–¹æ³•ï¼Œæœ‰ä¸€äº›è§„åˆ™å’ŒåŸåˆ™éœ€è¦æ³¨æ„ã€‚å®ƒä»¬åªèƒ½åœ¨åˆ†éƒ¨ç±»æˆ–ç»“æ„ä¸­å£°æ˜ã€‚åˆ†éƒ¨æ–¹æ³•çš„è¿”å›ç±»å‹å§‹ç»ˆæ˜¯ voidï¼Œä»»ä½•å‚æ•°éƒ½ä¸èƒ½ç”¨ out ä¿®é¥°ç¬¦æ¥æ ‡è®°ã€‚ä¹‹æ‰€ä»¥æœ‰è¿™ä¸¤ä¸ªé™åˆ¶ï¼Œæ˜¯å› ä¸ºæ–¹æ³•åœ¨è¿è¡Œæ—¶å¯èƒ½ä¸å­˜åœ¨ï¼Œæ‰€ä»¥ä¸èƒ½å°†å˜é‡åˆå§‹åŒ–ä¸ºæ–¹æ³•ä¹Ÿè®¸ä¼šè¿”å›çš„ä¸œè¥¿ã€‚ç±»ä¼¼åœ°ï¼Œä¸å…è®¸ <code>out</code> å‚æ•°æ˜¯å› ä¸ºæ–¹æ³•å¿…é¡»åˆå§‹åŒ–å®ƒï¼Œè€Œæ–¹æ³•å¯èƒ½ä¸å­˜åœ¨ã€‚åˆ†éƒ¨æ–¹æ³•å¯ä»¥æœ‰ <code>ref</code> å‚æ•°ï¼Œå¯ä»¥æ˜¯æ³›å‹æ–¹æ³•ï¼Œå¯ä»¥æ˜¯å®ä¾‹æˆ–é™æ€æ–¹æ³•ï¼Œè€Œä¸”å¯æ ‡è®°ä¸º <code>unsafe</code> ã€‚å½“ç„¶ï¼Œåˆ†éƒ¨æ–¹æ³•çš„å£°æ˜å’Œå®ç°å¿…é¡»å…·æœ‰å®Œå…¨ä¸€è‡´çš„ç­¾åã€‚å¦‚æœä¸¤è€…éƒ½åº”äº†å®šåˆ¶ç‰¹æ€§ï¼Œç¼–è¯‘å™¨ä¼šåˆå¹¶ä¸¤ä¸ªæ–¹æ³•çš„ç‰¹æ€§ã€‚åº”ç”¨äºå‚æ•°çš„ä»»ä½•ç‰¹æ€§ä¹Ÿä¼šåˆå¹¶ã€‚å¦‚æœæ²¡æœ‰å¯¹åº”çš„å®ç°éƒ¨åˆ†ï¼Œä¾¿ä¸èƒ½åœ¨ä»£ç ä¸­åˆ›å»ºä¸€ä¸ªå§”æ‰˜æ¥å¼•ç”¨è¿™ä¸ªåˆ†éƒ¨æ–¹æ³•ã€‚è¿™åŒæ ·æ˜¯ç”±äºæ–¹æ³•åœ¨è¿è¡Œæ—¶ä¸å­˜åœ¨ã€‚åˆ†éƒ¨æ–¹æ³•æ€»æ˜¯è¢«è§†ä¸º <code>private</code> æ–¹æ³•ï¼Œä½† C# ç¼–è¯‘å™¨ç¦æ­¢åœ¨åˆ†éƒ¨æ–¹æ³•å£°æ˜ä¹‹å‰æ·»åŠ  <code>private</code> å…³é”®å­—ã€‚</p><div class="tags"><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> è¯»ä¹¦ç¬”è®°</a> <a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C#</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2022-12-02 19:56:57" itemprop="dateModified" datetime="2022-12-02T19:56:57+08:00">2022-12-02</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(ï¿£â–½ï¿£)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Sakupinera WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Sakupinera Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Sakupinera PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Sakupinera <i class="ic i-at"><em>@</em></i>Sakupinera</li><li class="link"><strong>Post link: </strong><a href="http://sakupinera.github.io/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" title="CLR via C# - Chapter 8 Methods">http://sakupinera.github.io/2022/10/25/csharp/clr-via-csharp/Chapter 8 Methods/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/10/24/csharp/clr-via-csharp/Chapter%207%20Constants%20and%20Fields/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipeybxm1pj20zk0m8niv.jpg" title="CLR via C# - Chapter 7 Constants and Fields"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 7 Constants and Fields</h3></a></div><div class="item right"><a href="/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipeyhsblkj20zk0m81kx.jpg" title="CLR via C# - Chapter 9 Parameters"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 9 Parameters</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-8-methods"><span class="toc-number">1.</span> <span class="toc-text">Chapter 8 Methods</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#instance-constructors-and-classes-reference-types"><span class="toc-number">1.1.</span> <span class="toc-text">Instance Constructors and Classes (Reference Types)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#instance-constructors-and-structures-value-types"><span class="toc-number">1.2.</span> <span class="toc-text">Instance Constructors and Structures (Value Types)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-constructors"><span class="toc-number">1.3.</span> <span class="toc-text">Type Constructors</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#operator-overload-methods"><span class="toc-number">1.4.</span> <span class="toc-text">Operator Overload Methods</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#operators-and-programming-language-interoperability"><span class="toc-number">1.4.1.</span> <span class="toc-text">Operators and Programming Language Interoperability</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#conversion-operator-methods"><span class="toc-number">1.5.</span> <span class="toc-text">Conversion Operator Methods</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#extension-methods"><span class="toc-number">1.6.</span> <span class="toc-text">Extension Methods</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rules-and-guidelines"><span class="toc-number">1.6.1.</span> <span class="toc-text">Rules and Guidelines</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extending-various-types-with-extension-methods"><span class="toc-number">1.6.2.</span> <span class="toc-text">Extending Various Types with Extension Methods</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#the-extension-attribute"><span class="toc-number">1.6.3.</span> <span class="toc-text">The Extension Attribute</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#partial-methods"><span class="toc-number">1.7.</span> <span class="toc-text">Partial Methods</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rules-and-guidelines-2"><span class="toc-number">1.7.1.</span> <span class="toc-text">Rules and Guidelines</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"><ul><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/" rel="bookmark" title="CLR via C# - Chapter 1 The CLRâ€™s Execution Model">CLR via C# - Chapter 1 The CLRâ€™s Execution Model</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/" rel="bookmark" title="CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types">CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%203%20Shared%20Assemblies%20and%20Strongly%20Named%20Assemblies/" rel="bookmark" title="CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies">CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies</a></li><li><a href="/2022/09/27/csharp/clr-via-csharp/Chapter%204%20Type%20Fundamentals/" rel="bookmark" title="CLR via C# - Chapter 4 Type Fundamentals">CLR via C# - Chapter 4 Type Fundamentals</a></li><li><a href="/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/" rel="bookmark" title="CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals">CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals</a></li><li><a href="/2022/10/21/csharp/clr-via-csharp/Chapter%206%20Type%20and%20Member%20Basics/" rel="bookmark" title="CLR via C# - Chapter 6 Type and Member Basics">CLR via C# - Chapter 6 Type and Member Basics</a></li><li><a href="/2022/10/24/csharp/clr-via-csharp/Chapter%207%20Constants%20and%20Fields/" rel="bookmark" title="CLR via C# - Chapter 7 Constants and Fields">CLR via C# - Chapter 7 Constants and Fields</a></li><li class="active"><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" rel="bookmark" title="CLR via C# - Chapter 8 Methods">CLR via C# - Chapter 8 Methods</a></li><li><a href="/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/" rel="bookmark" title="CLR via C# - Chapter 9 Parameters">CLR via C# - Chapter 9 Parameters</a></li><li><a href="/2022/10/28/csharp/clr-via-csharp/Chapter%2010%20Properties/" rel="bookmark" title="CLR via C# - Chapter 10 Properties">CLR via C# - Chapter 10 Properties</a></li><li><a href="/2022/10/29/csharp/clr-via-csharp/Chapter%2011%20Events/" rel="bookmark" title="CLR via C# - Chapter 11 Events">CLR via C# - Chapter 11 Events</a></li><li><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" rel="bookmark" title="CLR via C# - Chapter 12 Generics">CLR via C# - Chapter 12 Generics</a></li><li><a href="/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/" rel="bookmark" title="CLR via C# - Chapter 13 Interfaces">CLR via C# - Chapter 13 Interfaces</a></li><li><a href="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/" rel="bookmark" title="CLR via C# - Chapter 14 Chars, Strings, and Working with Text">CLR via C# - Chapter 14 Chars, Strings, and Working with Text</a></li><li><a href="/2022/11/17/csharp/clr-via-csharp/Chapter%2015%20Enumerated%20Types%20and%20Bit%20Flags/" rel="bookmark" title="CLR via C# - Chapter 15 Enumerated Types and Bit Flags">CLR via C# - Chapter 15 Enumerated Types and Bit Flags</a></li><li><a href="/2022/11/19/csharp/clr-via-csharp/Chapter%2016%20Arrays/" rel="bookmark" title="CLR via C# - Chapter 16 Arrays">CLR via C# - Chapter 16 Arrays</a></li><li><a href="/2022/11/21/csharp/clr-via-csharp/Chapter%2017%20Delegates/" rel="bookmark" title="CLR via C# - Chapter 17 Delegates">CLR via C# - Chapter 17 Delegates</a></li><li><a href="/2022/11/22/csharp/clr-via-csharp/Chapter%2018%20Custom%20Attributes/" rel="bookmark" title="CLR via C# - Chapter 18 Custom Attributes">CLR via C# - Chapter 18 Custom Attributes</a></li><li><a href="/2022/11/23/csharp/clr-via-csharp/Chapter%2019%20Nullable%20Value%20Types/" rel="bookmark" title="CLR via C# - Chapter 19 Nullable Value Types">CLR via C# - Chapter 19 Nullable Value Types</a></li><li><a href="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/" rel="bookmark" title="CLR via C# - Chapter 20 Exceptions and State Management">CLR via C# - Chapter 20 Exceptions and State Management</a></li><li><a href="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/" rel="bookmark" title="CLR via C# - Chapter 21 The Managed Heap and Garbage  Collection">CLR via C# - Chapter 21 The Managed Heap and Garbage Collection</a></li><li><a href="/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/" rel="bookmark" title="CLR via C# - Chapter 22 CLR Hosting and AppDomains">CLR via C# - Chapter 22 CLR Hosting and AppDomains</a></li><li><a href="/2022/11/29/csharp/clr-via-csharp/Chapter%2023%20Assembly%20Loading%20and%20Reflection/" rel="bookmark" title="CLR via C# - Chapter 23 Assembly Loading and Reflection">CLR via C# - Chapter 23 Assembly Loading and Reflection</a></li><li><a href="/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/" rel="bookmark" title="CLR via C# - Chapter 24 Runtime Serialization">CLR via C# - Chapter 24 Runtime Serialization</a></li><li><a href="/2022/12/06/csharp/clr-via-csharp/Chapter%2025%20Interoperating%20with%20WinRT%20%20Components/" rel="bookmark" title="CLR via C# - Chapter 25 Interoperating with WinRT Components">CLR via C# - Chapter 25 Interoperating with WinRT Components</a></li><li><a href="/2023/02/06/csharp/clr-via-csharp/Chapter%2026%20Thread%20Basics/" rel="bookmark" title="CLR via C# - Chapter 26 Thread Basics">CLR via C# - Chapter 26 Thread Basics</a></li><li><a href="/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations">CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations</a></li><li><a href="/2023/02/08/csharp/clr-via-csharp/Chapter%2028%20IO-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 28 IO-Bound Asynchronous Operations">CLR via C# - Chapter 28 IO-Bound Asynchronous Operations</a></li><li><a href="/2023/02/09/csharp/clr-via-csharp/Chapter%2029%20Primitive%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 29 Primitive Thread Synchronization">CLR via C# - Chapter 29 Primitive Thread Synchronization</a></li><li><a href="/2023/02/10/csharp/clr-via-csharp/Chapter%2030%20Hybrid%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 30 Hybrid Thread Synchronization">CLR via C# - Chapter 30 Hybrid Thread Synchronization</a></li></ul></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sakupinera" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Sakupinera</p><div class="description" itemprop="description">ä¿æŒä½ çš„å†³å¿ƒï¼</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">89</span> <span class="name">posts</span></a></div><div class="item categories"><a href="/categories/"><span class="count">17</span> <span class="name">categories</span></a></div><div class="item tags"><a href="/tags/"><span class="count">8</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nha3VwaW5lcmE=" title="https:&#x2F;&#x2F;github.com&#x2F;sakupinera"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQwNzIyOTA3MQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;407229071"><i class="ic i-cloud-music"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMjIzMDczOTg/c3BtX2lkX2Zyb209MzMzLjEwMDcuMC4w" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;22307398?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li><li class="item"><a href="/games/" rel="section"><i class="ic i-flag"></i>games</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-person"></i>About</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/10/24/csharp/clr-via-csharp/Chapter%207%20Constants%20and%20Fields/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2022/12/12/cpp/cpp-primer/Chapter%204%20Expressions/" title="C++ Primer - Chapter 4 Expressions">C++ Primer - Chapter 4 Expressions</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/21/csharp/clr-via-csharp/Chapter%2017%20Delegates/" title="CLR via C# - Chapter 17 Delegates">CLR via C# - Chapter 17 Delegates</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/" title="CLR via C# - Chapter 22 CLR Hosting and AppDomains">CLR via C# - Chapter 22 CLR Hosting and AppDomains</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/" title="CLR via C# - Chapter 13 Interfaces">CLR via C# - Chapter 13 Interfaces</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/09/06/computer-graphics/games101/%E5%90%91%E9%87%8F%E5%92%8C%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" title="GAMES101 - å‘é‡å’Œçº¿æ€§ä»£æ•°">GAMES101 - å‘é‡å’Œçº¿æ€§ä»£æ•°</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/" title="CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations">CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/09/27/csharp/clr-via-csharp/Chapter%204%20Type%20Fundamentals/" title="CLR via C# - Chapter 4 Type Fundamentals">CLR via C# - Chapter 4 Type Fundamentals</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/" title="CLR via C# - Chapter 1 The CLRâ€™s Execution Model">CLR via C# - Chapter 1 The CLRâ€™s Execution Model</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/10/24/csharp/clr-via-csharp/Chapter%207%20Constants%20and%20Fields/" title="CLR via C# - Chapter 7 Constants and Fields">CLR via C# - Chapter 7 Constants and Fields</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2023/02/08/csharp/clr-via-csharp/Chapter%2028%20IO-Bound%20Asynchronous%20Operations/" title="CLR via C# - Chapter 28 IO-Bound Asynchronous Operations">CLR via C# - Chapter 28 IO-Bound Asynchronous Operations</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 â€“ <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Sakupinera @ Hanamai Sora</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="Symbols count total">2.2m words</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="Reading time total">34:05</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/10/25/csharp/clr-via-csharp/Chapter 8 Methods/",favicon:{show:"ï¼ˆâ—Â´3ï½€â—ï¼‰Goooood",hide:"(Â´Ğ”ï½€)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/shifuku.model.json"},display:{position:"left",width:250,height:500},mobile:{show:!1},react:{opacity:.9},log:!1})</script></body></html>