<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sakupinera" href="http://sakupinera.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sakupinera" href="http://sakupinera.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sakupinera" href="http://sakupinera.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="读书笔记,C#"><link rel="canonical" href="http://sakupinera.github.io/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/"><title>CLR via C# - Chapter 8 Methods - CLR-via-CSharp - CSharp | Hanamai Sora = Sakupinera</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">CLR via C# - Chapter 8 Methods</h1><div class="meta"><span class="item" title="Created: 2022-10-25 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2022-10-25T00:00:00+08:00">2022-10-25</time> </span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">Symbols count in article</span> <span>54k</span> <span class="text">words</span> </span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">Reading time</span> <span>49 mins.</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hanamai Sora</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipetfk5zwj20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclj61ylzj20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclh0m9pdj20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipetv6p75j20zk0m8x6p.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclgrvbd6j20zk0m8qv5.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipetlbztpj20zk0m84qp.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/" itemprop="item" rel="index" title="In CSharp"><span itemprop="name">CSharp</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/CLR-via-CSharp/" itemprop="item" rel="index" title="In CLR-via-CSharp"><span itemprop="name">CLR-via-CSharp</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://sakupinera.github.io/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Sakupinera"><meta itemprop="description" content=", 保持你的决心！"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakupinera"></span><div class="body md" itemprop="articleBody"><h1 id="chapter-8-methods"><a class="anchor" href="#chapter-8-methods">#</a> Chapter 8 Methods</h1><h2 id="instance-constructors-and-classes-reference-types"><a class="anchor" href="#instance-constructors-and-classes-reference-types">#</a> Instance Constructors and Classes (Reference Types)</h2><blockquote><p>Constructors are special methods that allow an instance of a type to be initialized to a good state. Constructor methods are always called <code>.ctor</code> (for constructor) in a method definition metadata table. When creating an instance of a reference type, memory is allocated for the instance’s data fields, the object’s overhead fields (type object pointer and sync block index) are initialized, and then the type’s instance constructor is called to set the initial state of the object.</p></blockquote><blockquote><p>When constructing a reference type object, the memory allocated for the object is always zeroed out before the type’s instance constructor is called. Any fields that the constructor doesn’t explicitly overwrite are guaranteed to have a value of 0 or null.</p></blockquote><blockquote><p>Unlike other methods, instance constructors are never inherited. That is, a class has only the instance constructors that the class itself defines. Because instance constructors are never inherited, you cannot apply the following modifiers to an instance constructor: virtual, new, override, sealed, or abstract. If you define a class that does not explicitly define any constructors, the C# compiler defines a default (parameterless) constructor for you whose implementation simply calls the base class’s parameterless constructor.</p></blockquote><blockquote><p>For example, if you define the following class.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>it is as though you wrote the code as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token function">SomeType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>If the class is abstract, the compiler-produced default constructor has protected accessibility; otherwise, the constructor is given public accessibility. If the base class doesn’t offer a parameterless constructor, the derived class must explicitly call a base class constructor or the compiler will issue an error. If the class is static (sealed and abstract), the compiler will not emit a default constructor at all into the class definition.</p></blockquote><blockquote><p>A type can define several instance constructors. Each constructor must have a different signature, and each can have different accessibility. For verifiable code, a class’s instance constructor must call its base class’s constructor before accessing any of the inherited fields of the base class. The C# compiler will generate a call to the default base class’s constructor automatically if the derived class’s constructor does not explicitly invoke one of the base class’s constructors. Ultimately, <code>System.Object</code> ’s public, parameterless constructor gets called. This constructor does nothing—it simply returns. This is because <code>System.Object</code> defines no instance data fields, and therefore its constructor has nothing to do.</p></blockquote><blockquote><p>In a few situations, an instance of a type can be created without an instance constructor being called. In particular, calling Object’s <code>MemberwiseClone</code> method allocates memory, initializes the object’s overhead fields, and then copies the source object’s bytes to the new object. Also, a constructor is usually not called when deserializing an object with the runtime serializer. The deserialization code allocates memory for the object without calling a constructor by using the <code>System.Runtime.Serialization.FormatterServices</code> type's <code>GetUninitializedObject</code> or <code>GetSafeUninitializedObject</code> methods (as discussed in Chapter 24, “Runtime Serialization”).</p></blockquote><p>💡重要提示：不要在构造器中调用虚方法。原因是假如被实例化的类型重写了虚方法，就会执行派生类型对虚方法的实现。但在这个时候，尚未完成对继承层次结构中的所有字段的初始化 (被实例化的类型的构造器还没有运行呢)。所以，调用虚方法会导致无法预测的行为。归根到底，这是由于调用虚方法时，直到运行时之前都不会选择执行该方法的实际类型。</p><blockquote><p>C# offers a simple syntax that allows the initialization of fields defined within a reference type when an instance of the type is constructed.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When a <code>SomeType</code> object is constructed, its m_x field will be initialized to 5. How does this happen? Well, if you examine the Intermediate Language (IL) for <code>SomeType</code> ’s constructor method (also called <code>.ctor</code> ), you’ll see the code shown here.</p></blockquote><figure class="highlight clike"><figcaption data-lang="C-like"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">.</span>method public hidebysig specialname rtspecialname </pre></td></tr><tr><td data-num="2"></td><td><pre> instance void <span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> cil managed</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// Code size 14 (0xe)</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">.</span>maxstack <span class="token number">8</span></pre></td></tr><tr><td data-num="6"></td><td><pre> IL_0000<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="7"></td><td><pre> IL_0001<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span><span class="token number">5</span></pre></td></tr><tr><td data-num="8"></td><td><pre> IL_0002<span class="token punctuation">:</span> stfld int32 SomeType<span class="token punctuation">:</span><span class="token punctuation">:</span>m_x</pre></td></tr><tr><td data-num="9"></td><td><pre> IL_0007<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="10"></td><td><pre> IL_0008<span class="token punctuation">:</span> call instance void <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Object<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre> IL_000d<span class="token punctuation">:</span> ret</pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of method SomeType::.ctor</span></pre></td></tr></table></figure><blockquote><p>In this code, you see that <code>SomeType</code> ’s constructor contains code to store a 5 into m_x and then calls the base class’s constructor. In other words, the C# compiler allows the convenient syntax that lets you initialize the instance fields inline and translates this to code in the constructor method to perform the initialization. This means that you should be aware of code explosion, as illustrated by the following class definition.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">String</span> m_s <span class="token operator">=</span> <span class="token string">"Hi there"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Double</span> m_d <span class="token operator">=</span> <span class="token number">3.14159</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Byte</span> m_b<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Here are some constructors. </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token function">SomeType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token function">SomeType</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">public</span> <span class="token function">SomeType</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">;</span> m_d <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When the compiler generates code for the three constructor methods, the beginning of each method includes the code to initialize m_x, m_s, and m_d. After this initialization code, the compiler inserts a call to the base class’s constructor, and then the compiler appends to the method the code that appears in the constructor methods. For example, the code generated for the constructor that takes a String parameter includes the code to initialize m_x, m_s, and m_d, call the base class’s (Object’s) constructor, and then overwrite m_d with the value 10. Note that m_b is guaranteed to be initialized to 0 even though no code exists to explicitly initialize it.</p></blockquote><p>💡注意：编译器在调用基类构造器前使用简化语法对所有字段进行初始化，以维持源代码给人留下的 “这些字段总是有一个值” 的印象。但假如基类构造器调用了虚方法并回调由派生类定义的方法，就可能出问题。在这种情况下，使用简化语法初始化的字段在调用虚方法之前就初始化好了。</p><blockquote><p>Because there are three constructors in the preceding class, the compiler generates the code to initialize m_x, m_s, and m_d three times—once per constructor. If you have several initialized instance fields and a lot of overloaded constructor methods, you should consider defining the fields without the initialization, creating a single constructor that performs the common initialization, and having each constructor explicitly call the common initialization constructor. This approach will reduce the size of the generated code. Here is an example using C#’s ability to explicitly have a constructor call another constructor by using the this keyword.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Do not explicitly initialize the fields here. </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_x<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">String</span> m_s<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Double</span> m_d<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Byte</span> m_b<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// This constructor sets all fields to their default. </span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// All of the other constructors explicitly invoke this constructor. </span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">public</span> <span class="token function">SomeType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> m_x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> m_s <span class="token operator">=</span> <span class="token string">"Hi there"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> m_d <span class="token operator">=</span> <span class="token number">3.14159</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> m_b <span class="token operator">=</span> <span class="token number">0xff</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// This constructor sets all fields to their default, then changes m_x. </span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token keyword">public</span> <span class="token function">SomeType</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> x<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> m_x <span class="token operator">=</span> x<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token comment">// This constructor sets all fields to their default, then changes m_s. </span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token keyword">public</span> <span class="token function">SomeType</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="21"></td><td><pre> m_s <span class="token operator">=</span> s<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token comment">// This constructor sets all fields to their default, then changes m_x &amp; m_s. </span></pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token keyword">public</span> <span class="token function">SomeType</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> x<span class="token punctuation">,</span> <span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="25"></td><td><pre> m_x <span class="token operator">=</span> x<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="26"></td><td><pre> m_s <span class="token operator">=</span> s<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="27"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>💡小结：创建引用类型的实例时，首先为实例的数据字段分配内存，然后初始化对象的附加字段（类型对象指针和同步块索引），这些附加字段称为 overhead fields，“overhead” 是开销的意思，意味着是创建对象时必须的 “开销”。最后调用类型的实例构造器来设置对象的初始状态。构造应引用类型对象时，在调用类型的实例构造器之前，为对象分配的内存总是先被归零。没有被构造器显示重写的所有字段都保证获得 0 或 null 值。由于永远不能继承实例构造器，所以实例构造器不能使用以下修饰符：virtual，new，override，sealed 和 abstract。如果类的修饰符为 abstract，那么编译器生成的默认构造器的可访问性就为 protected；否则，构造器就会被赋予 public 可访问性。如果基类没有提供无参构造器，那么派生类必须显示调用一个基类构造器，否则编译器会报错。如果类的修饰符为 static（sealed 和 abstract，静态类在元数据中是抽象密封类），编译器根本不会在类的定义中生成默认构造器。为了使代码 “可验证”（verifiable），类的实例构造器在访问从基类继承的任何字段之前，必须先调用基类的构造器。如果派生类的构造器没有显示调用一个基类构造器，C# 编译器会自动生成对默认的基类构造器的调用。极少数时候可以在不调用实例构造器的前提下创建类型的实例。一个典型的例子使 Object 的 <code>MemberwiseClone</code> 方法。该方法的作用是分配内存，初始化对象的附加字段（类型对象指针和同步块索引），然后将源对象的字节数据复制到新对象中。另外，用运行时序列化器（runtime serializer）反序列化对象时，通常也不需要调用构造器。反序列化代码使用 <code>System.Runtime.Serialization.FormatterServices</code> 类型的 <code>GetUninitializedObject</code> 或者 <code>GetSafeUninitializedObject</code> 方法为对象分配内存，期间不会调用一个构造器。C# 编译器提供了一个简化的语法，允许以 “内联” 方式初始化实例字段。在这些初始化代码之后，编译器会插入对基类的构造器的调用。再然后，会插入构造器自己的代码。在 C# 中可以利用 this 关键字显示调用另一个构造器，这样能减少生成的代码。</p><h2 id="instance-constructors-and-structures-value-types"><a class="anchor" href="#instance-constructors-and-structures-value-types">#</a> Instance Constructors and Structures (Value Types)</h2><blockquote><p>Value type (struct) constructors work quite differently from reference type (class) constructors. The common language runtime (CLR) always allows the creation of value type instances, and there is no way to prevent a value type from being instantiated. For this reason, value types don’t actually even need to have a constructor defined within them, and the C# compiler doesn't emit default parameterless constructors for value types. Examine the following code.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">struct</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name">Int32</span> m_x<span class="token punctuation">,</span> m_y<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name">Point</span> m_topLeft<span class="token punctuation">,</span> m_bottomRight<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>To construct a Rectangle, the new operator must be used, and a constructor must be specified. In this case, the default constructor automatically generated by the C# compiler is called. When memory is allocated for the Rectangle, the memory includes the two instances of the Point value type. For performance reasons, the CLR doesn’t attempt to call a constructor for each value type field contained within the reference type. But as I mentioned earlier, the fields of the value types are initialized to 0/null.</p></blockquote><blockquote><p>The CLR does allow you to define constructors on value types. The only way that these constructors will execute is if you write code to explicitly call one of them, as in Rectangle’s constructor, shown here.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">struct</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name">Int32</span> m_x<span class="token punctuation">,</span> m_y<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> x<span class="token punctuation">,</span> <span class="token class-name">Int32</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> m_x <span class="token operator">=</span> x<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> m_y <span class="token operator">=</span> y<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name">Point</span> m_topLeft<span class="token punctuation">,</span> m_bottomRight<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Rectangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// In C#, new on a value type calls the constructor to </span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token comment">// initialize the value type's fields. </span></pre></td></tr><tr><td data-num="14"></td><td><pre> m_topLeft <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Point</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> m_bottomRight <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Point</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>A value type’s instance constructor is executed only when explicitly called. So if Rectangle’s constructor didn’t initialize its <code>m_topLeft</code> and <code>m_bottomRight</code> fields by using the new operator to call Point’s constructor, the m_x and m_y fields in both Point fields would be 0.</p></blockquote><blockquote><p>In the Point value type defined earlier, no default parameterless constructor is defined. However, let’s rewrite that code as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">struct</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name">Int32</span> m_x<span class="token punctuation">,</span> m_y<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> m_x <span class="token operator">=</span> m_y <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name">Point</span> m_topLeft<span class="token punctuation">,</span> m_bottomRight<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Rectangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Now when a new Rectangle is constructed, what do you think the m_x and m_y fields in the two Point fields, <code>m_topLeft</code> and <code>m_bottomRight</code> , would be initialized to: 0 or 5? (Hint: This is a trick question.)</p></blockquote><blockquote><p>Many developers (especially those with a C++ background) would expect the C# compiler to emit code in Rectangle’s constructor that automatically calls Point’s default parameterless constructor for the Rectangle’s two fields. However, to improve the run-time performance of the application, the C# compiler doesn’t automatically emit this code. In fact, many compilers will never emit code to call a value type’s default constructor automatically, even if the value type offers a parameterless constructor. To have a value type’s parameterless constructor execute, the developer must add explicit code to call a value type’s constructor.</p></blockquote><blockquote><p>Based on the information in the preceding paragraph, you should expect the m_x and m_y fields in Rectangle’s two Point fields to be initialized to 0 in the code shown earlier because there are no explicit calls to Point’s constructor anywhere in the code.</p></blockquote><blockquote><p>However, I did say that my original question was a trick question. The trick part is that C# doesn’t allow a value type to define a parameterless constructor. So the previous code won’t actually compile. The C# compiler produces the following message when attempting to compile that code: error CS0568: Structs cannot contain explicit parameterless constructors.</p></blockquote><blockquote><p>C# purposely disallows value types from defining parameterless constructors to remove any confusion a developer might have about when that constructor gets called. If the constructor can’t be defined, the compiler can never generate code to call it automatically. Without a parameterless constructor, a value type’s fields are always initialized to 0/null.</p></blockquote><p>💡注意：严格地说，只有当值类型的字段嵌套到引用类型中时，才保证被初始化为 0 或 <code>null</code> 。基于栈的值类型字段则无此保证。但是，为了确保代码的 “可验证性”(verifiability)，任何基于栈的值类型字段都必须在读取之前写入 (赋值)。允许先读再写会造成安全漏洞。对于所有基于栈的值类型中的字段，C# 和其他能生成 “可验证” 代码的编译器可以保证对它们进行 “置零”，或至少保证在读取之前赋值，确保不会在运行时因验证失败而抛出异常。所以，你完全可以忽略本 “注意” 的内容，假定自己的值类型的字段都会被初始化为 0 或 <code>null</code> 。</p><blockquote><p>Keep in mind that although C# doesn’t allow value types with parameterless constructors, the CLR does. So if the unobvious behavior described earlier doesn’t bother you, you can use another programming language (such as IL assembly language) to define your value type with a parameterless constructor.</p></blockquote><blockquote><p>Because C# doesn’t allow value types with parameterless constructors, compiling the following type produces the following message: error CS0573: ' <code>SomeValType.m_x</code> ': cannot have instance field initializers in structs.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">struct</span> <span class="token class-name">SomeValType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// You cannot do inline instance field initialization in a value type. </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In addition, because verifiable code requires that every field of a value type be written to prior to any field being read, any constructors that you do have for a value type must initialize all of the type’s fields. The following type defines a constructor for the value type but fails to initialize all of the fields.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">struct</span> <span class="token class-name">SomeValType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_x<span class="token punctuation">,</span> m_y<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// C# allows value types to have constructors that take parameters. </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token function">SomeValType</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> m_x <span class="token operator">=</span> x<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Notice that m_y is not initialized here. </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When compiling this type, the C# compiler produces the following message: error CS0171: Field ' <code>SomeValType.m_y</code> ' must be fully assigned before control leaves the constructor. To fix the problem, assign a value (usually 0) to y in the constructor.</p></blockquote><blockquote><p>As an alternative way to initialize all the fields of a value type, you can actually do the following.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// C# allows value types to have constructors that take parameters.</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token function">SomeValType</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// Looks strange but compiles fine and initializes all fields to 0/null.</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">this</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SomeValType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> m_x <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// Overwrite m_x's 0 with x</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Notice that m_y was initialized to 0.</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In a value type’s constructor, this represents an instance of the value type itself and you can actually assign to it the result of newing up an instance of the value type, which really just zeroes out all the fields. In a reference type’s constructor, this is considered read-only, so you cannot assign to it at all.</p></blockquote><p>💡小结：CLR 总是允许创建值类型的实例，并且没有办法阻止值类型的实例化。所以，值类型其实并不需要定义构造器，C# 编译器根本不会为值类型内联（嵌入）默认的无参构造器。考虑到性能，CLR 不会为包含在引用类型中的每个值类型字段都主动调用构造器。但是，如前所述，值类型的字段会被初始化为 0 或 null。CLR 确实允许为值类型定义构造器（有参），但必须显示调用才会执行。为了增强应用程序的运行时性能，即便类型提供了无参构造器，许多编译器也永远不会生成代码来自动调用它。但事实上，C# 编译器不允许值类型定义无参构造器。（测试的时候是可以定义，可能由于 C# 版本不同）如果编译类似代码，C# 编译器会显示以下消息：error CS0568：结构不能包含显式的无参数构造器。由于不能定义无参构造器，所以编译器永远不会生成自动调用它的代码。没有无参构造器，值类型的字段总是被初始化为 0 或 null。注意，虽然 C# 不允许值类型带有无参构造器，但 CLR 允许。由于 C# 不允许为值类型定义无参构造器，所以不能在值类型中内联实例字段的初始化。如果编译类似代码，C# 编译器将显示消息：error CS0573：结构中不能有实例字段初始值设定项。（测试时报错 CS8983，需要显式声明一个构造器，但是字段初始值还是不起作用就是了）另外，为了生成 “可验证” 代码，在访问值类型的任何字段字段之前，都需要对全部字段进行赋值。否则，C# 编译器会显式消息：error CS0171：在控制返回到调用方之前，字段必须完全赋值。在值类型的构造器中，this 代表值类型本身的一个实例，用 new 创建的值类型的一个实例可以赋给 this。在 new 的过程中，会将所有字段置为零。而在引用类型的构造器中，this 被认为是只读的，所以不能对它进行赋值。</p><h2 id="type-constructors"><a class="anchor" href="#type-constructors">#</a> Type Constructors</h2><blockquote><p>n addition to instance constructors, the CLR supports type constructors (also known as static constructors, class constructors, or type initializers). A type constructor can be applied to interfaces (although C# doesn’t allow this), reference types, and value types. Just as instance constructors are used to set the initial state of an instance of a type, type constructors are used to set the initial state of a type. By default, types don’t have a type constructor defined within them. If a type has a type constructor, it can have no more than one. In addition, type constructors never have parameters. In C#, here’s how to define a reference type and a value type that have type constructors.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SomeRefType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">static</span> <span class="token function">SomeRefType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// This executes the first time a SomeRefType is accessed. </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">struct</span> <span class="token class-name">SomeValType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// C# does allow value types to define parameterless type constructors. </span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">static</span> <span class="token function">SomeValType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// This executes the first time a SomeValType is accessed. </span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>You’ll notice that you define type constructors just as you would parameterless instance constructors, except that you must mark them as static. Also, type constructors should always be private; C# makes them private for you automatically. In fact, if you explicitly mark a type constructor as private (or anything else) in your source code, the C# compiler issues the following error: error CS0515: 'SomeValType.SomeValType()': access modifiers are not allowed on static constructors. Type constructors should be private to prevent any developer-written code from calling them; the CLR is always capable of calling a type constructor.</p></blockquote><p>💡重要提示：虽然能在值类型中定义类型构造器，但永远都不要真的那么做，因为 CLR 有时不会调用值类型的静态类型构造器。下面是一个例子：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">struct</span> <span class="token class-name">SomeValType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">static</span> <span class="token function">SomeValType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"This never gets displayed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name">Int32</span> m_x<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token class-name">SomeValType<span class="token punctuation">[</span><span class="token punctuation">]</span></span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SomeValType</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>m_x <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>m_x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays 123 </span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The calling of a type constructor is a tricky thing. When the just-in-time (JIT) compiler is compiling a method, it sees what types are referenced in the code. If any of the types define a type constructor, the JIT compiler checks if the type’s type constructor has already been executed for this <code>AppDomain</code> . If the constructor has never executed, the JIT compiler emits a call to the type constructor into the native code that the JIT compiler is emitting. If the type constructor for the type has already executed, the JIT compiler does not emit the call because it knows that the type is already initialized.</p></blockquote><blockquote><p>Now, after the method has been JIT-compiled, the thread starts to execute it and will eventually get to the code that calls the type constructor. In fact, it is possible that multiple threads will be executing the same method concurrently. The CLR wants to ensure that a type’s constructor executes only once per <code>AppDomain</code> . To guarantee this, when a type constructor is called, the calling thread acquires a mutually exclusive thread synchronization lock. So if multiple threads attempt to simultaneously call a type’s static constructor, only one thread will acquire the lock and the other threads will block. The first thread will execute the code in the static constructor. After the first thread leaves the constructor, the waiting threads will wake up and will see that the constructor’s code has already been executed. These threads will not execute the code again; they will simply return from the constructor method. In addition, if any of these methods ever get called again, the CLR knows that the type constructor has already executed and will ensure that the constructor is not called again.</p></blockquote><p>💡注意：由于 CLR 保证一个类型构造器在每个 AppDomain 中执行一次，而且 (这种执行) 是线程安全的，所以非常适合在类型构造器中初始化类型需要的任何单实例 (Singleton) 对象。</p><blockquote><p>Within a single thread, there is a potential problem that can occur if two type constructors contain code that reference each other. For example, ClassA has a type constructor containing code that references ClassB, and ClassB has a type constructor containing code that references ClassA. In this situation, the CLR still guarantees that each type constructor’s code executes only once; however, it cannot guarantee that ClassA’s type constructor code has run to completion before executing ClassB’s type constructor. You should certainly try to avoid writing code that sets up this scenario. In fact, because the CLR is responsible for calling type constructors, you should always avoid writing any code that requires type constructors to be called in a specific order.</p></blockquote><blockquote><p>Finally, if a type constructor throws an unhandled exception, the CLR considers the type to be unusable. Attempting to access any fields or methods of the type will cause a System.TypeInitializationException to be thrown.</p></blockquote><blockquote><p>The code in a type constructor has access only to a type’s static fields, and its usual purpose is to initialize those fields. As it does with instance fields, C# offers a simple syntax that allows you to initialize a type’s static fields.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Int32</span> s_x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>💡注意：虽然 C# 不允许值类型为它的实例字段使用内联字段初始化语法，但可以为静态字段使用。换句话说，如果将前面定义的 <code>SomeType</code> 类型从 <code>class</code> 改为 <code>struct</code> ，那么代码也能通过编译，而且会像你预期的那样工作。</p><blockquote><p>When this code is built, the compiler automatically generates a type constructor for SomeType. It’s as if the source code had originally been written as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Int32</span> s_x<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">static</span> <span class="token function">SomeType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> s_x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Using ILDasm.exe, it’s easy to verify what the compiler actually produced by examining the IL for the type constructor. Type constructor methods are always called .cctor (for class constructor) in a method definition metadata table.</p></blockquote><blockquote><p>In the code below, you see that the .cctor method is private and static. In addition, notice that the code in the method does in fact load a 5 into the static field s_x.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">.</span>method <span class="token keyword">private</span> hidebysig specialname rtspecialname <span class="token keyword">static</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">void</span> <span class="token punctuation">.</span><span class="token function">cctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token return-type class-name">cil</span> managed</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// Code size 7 (0x7)</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">.</span>maxstack <span class="token number">8</span></pre></td></tr><tr><td data-num="6"></td><td><pre> IL_0000<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span><span class="token number">5</span></pre></td></tr><tr><td data-num="7"></td><td><pre> IL_0001<span class="token punctuation">:</span> stsfld <span class="token class-name">int32</span> SomeType<span class="token punctuation">::</span><span class="token class-name">s_x</span></pre></td></tr><tr><td data-num="8"></td><td><pre> IL_0006<span class="token punctuation">:</span> ret</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of method SomeType::.cctor</span></pre></td></tr></table></figure><blockquote><p>Type constructors shouldn’t call a base type’s type constructor. Such a call isn’t necessary because none of a type’s static fields are shared or inherited from its base type.</p></blockquote><p>💡注意：有的语言 (比如 Java) 希望在访问类型时自动调用它的类型构造器，并调用它的所有基类型的类型构造器。此外，类型实现的接口也必须调用接口的类型构造器。CLR 不支持这种行为。但是，使用由 <code>System.Runtime.CompilerServices.RuntimeHelpers</code> 提供的 <code>RunClassConstructor</code> 方法，编译器和开发人员可以实现这种行为。任何语言想要实现这种行为，可以告诉它的编译器在一个类型的类型构造器中生成代码，为所有基类型都调用这个方法，用 <code>RunClassConstructor</code> 方法调用一个类型构造器，CLR 就知道类型构造器之前是否执行过。如果是，CLR 不会再次调用它。</p><blockquote><p>Finally, assume that you have this code.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Int32</span> s_x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">static</span> <span class="token function">SomeType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> s_x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In this case, the C# compiler generates a single type constructor method. This constructor first initializes s_x to 5 and then initializes s_x to 10. In other words, when the C# compiler generates IL code for the type constructor, it first emits the code required to initialize the static fields followed by the explicit code contained in your type constructor method.</p></blockquote><p>💡重要提示：偶尔有开发人员问我，是否可以在卸载类型时执行一些代码。首先要搞清楚的是，类型只有在 <code>AppDomain</code> 卸载时才会卸载。 <code>AppDomain</code> 卸载时，用于标识类型的对象 (类型对象) 将成为 “不可达” 的对象 (不存在对它的引用)，垃圾回收器会回收类型对象的内存。这个行为导致许多开发人员认为可以为类型添加一个静态 <code>Finalize</code> 方法。当类型卸载时，就自动地调用这个方法。遗憾的是，CLR 并不支持静态 <code>Finalize</code> 方法。但也不是完全没有办法，要在 <code>AppDomain</code> 卸载时执行一些代码，可向 <code>System.AppDomain</code> 类型的 <code>DomainUnload</code> 事件登记一个回调方法。</p><p>💡小结：类型构造器可以应用于接口（虽然 C# 编译器不允许）、引用类型和值类型。实例构造器的作用是设置类型的实例的初始状态。对应地，类型构造器的作用是设置类型的初始状态。类型默认没有定义类型构造器。如果定义，也只能定义一个。此外，类型构造器永远没有参数。类型构造器总是私有，C# 自动把它们标记为 private。之所以必须私有，是为了防止任何由开发人员写的代码调用它，对它的调用总是由 CLR 负责。JIT 编译器在编译一个方法时，会查看代码中都引用了哪些类型。任何一个类型定义了类型构造器，JIT 编译器都会检查针对当前 <code>AppDomain</code> ，是否已经执行了这个类型构造器。如果构造器从未执行，JIT 编译器会在它生成的本机（native）代码中添加对类型构造器的调用。如果类型构造器已经执行，JIT 编译器就不添加对它的调用。事实上，多个线程可能同时执行相同的方法。CLR 希望确保在每个 <code>AppDomain</code> 中，一个类型构造器只执行一次。为了保证这一点，在调用类型构造器时，调用线程要获取一个互斥线程同步锁。这样一来，如果多个线程试图同时调用某个类型的静态构造器，只有一个线程才可以获得锁，其他线程会被阻塞（blocked）。由于时 CLR 负责类型构造器的调用，所以任何代码都不应要求以特定的顺序调用类型构造器。类型构造器中的代码只能访问类型的静态字段，并且它的常规用途就是初始化这些字段。类型构造器方法总是叫 <code>.cctor</code> （代表 class constructor）。类型构造器不应调用基类型的类型构造器。这种调用之所以没必要，是因为类型不可能有静态字段是从基类型分享或继承的。当 C# 编译器为类型构造器生成 IL 代码时，它首先生成的是初始化静态字段所需的代码，然后才会添加你的类型构造器方法中显式包含的代码。</p><h2 id="operator-overload-methods"><a class="anchor" href="#operator-overload-methods">#</a> Operator Overload Methods</h2><blockquote><p>Some programming languages allow a type to define how operators should manipulate instances of the type. For example, a lot of types (such as System.String, System.Decimal, and System.DateTime) overload the equality (==) and inequality (!=) operators. The CLR doesn’t know anything about operator overloading because it doesn’t even know what an operator is. Your programming language defines what each operator symbol means and what code should be generated when these special symbols appear.</p></blockquote><blockquote><p>For example, in C#, applying the + symbol to primitive numbers causes the compiler to generate code that adds the two numbers together. When the + symbol is applied to String objects, the C# compiler generates code that concatenates the two strings together. For inequality, C# uses the != symbol, while Microsoft Visual Basic uses the &lt;&gt; symbol. Finally, the ^ symbol means exclusive OR (XOR) in C#, but it means exponent in Visual Basic.</p></blockquote><blockquote><p>Although the CLR doesn’t know anything about operators, it does specify how languages should expose operator overloads so that they can be readily consumed by code written in a different programming language. Each programming language gets to decide for itself whether it will support operator overloads, and if it does, the syntax for expressing and using them. As far as the CLR is concerned, operator overloads are simply methods.</p></blockquote><blockquote><p>Your choice of programming language determines whether or not you get the support of operator overloading and what the syntax looks like. When you compile your source code, the compiler produces a method that identifies the behavior of the operator. The CLR specification mandates that operator overload methods be public and static methods. In addition, C# (and many other languages) requires that at least one of the operator method’s parameters must be the same as the type that the operator method is defined within. The reason for this restriction is that it enables the C# compiler to search for a possible operator method to bind to in a reasonable amount of time.</p></blockquote><blockquote><p>Here is an example of an operator overload method defined in a C# class definition.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Complex</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> Complex <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token class-name">Complex</span> c1<span class="token punctuation">,</span> <span class="token class-name">Complex</span> c2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The compiler emits a metadata method definition entry for a method called op_Addition; the method definition entry also has the specialname flag set, indicating that this is a “special” method. When language compilers (including the C# compiler) see a + operator specified in source code, they look to see if one of the operand’s types defines a specialname method called op_Addition whose parameters are compatible with the operand’s types. If this method exists, the compiler emits code to call this method. If no such method exists, a compilation error occurs.</p></blockquote><blockquote><p>Tables 8-1 and 8-2 show the set of unary and binary operators that C# supports being overloaded, their symbols, and the corresponding Common Language Specification (CLS) method name that the compiler emits. I’ll explain the tables’ third columns in the next section.</p></blockquote><p><img data-src="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/image-20221025202233270.png" alt="image-20221025202233270"></p><p><img data-src="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/image-20221025202253493.png" alt="image-20221025202253493"></p><p><img data-src="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/image-20221025202324849.png" alt="image-20221025202324849"></p><blockquote><p>The CLR specification defines many additional operators that can be overloaded, but C# does not support these additional operators. Therefore, they are not in mainstream use, so I will not list them here. If you are interested in the complete list, please see the ECMA specifications (<span class="exturl" data-url="aHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL3B1YmxpY2F0aW9ucy9zdGFuZGFyZHMvRWNtYS0zMzUuaHRt">www.ecma-international.org/publications/standards/Ecma-335.htm</span>) for the Common Language Infrastructure (CLI), Partition I, Concepts and Architecture, Sections 10.3.1 (unary operators) and 10.3.2 (binary operators).</p></blockquote><p>💡注意：检查 Framework 类库 (FCL) 的核心数值类型 ( <code>Int32</code> , <code>Int64</code> 和 <code>UInt32</code> 等)，会发现它们没有定义任何操作符重载方法。之所以不定义，是因为编译器会 (在代码中) 专门查找针对这些基元类型执行的操作 (运算)，并生成直接操作这些类型的实例的 IL 指令。如果类型要提供方法，而且编译器要生成代码来调用这些方法，方法调用就会产生额外的运行时开销。另外，方法最终都要执行一些 IL 指令来完成你希望的操作。这正是核心 FCL 类型没有定义任何操作符重载方法的原因。对于开发人员，这意味着假如选择的编程语言不支持其中的某个 FCL 类型，便不能对该类型的实例执行任何操作。</p><h3 id="operators-and-programming-language-interoperability"><a class="anchor" href="#operators-and-programming-language-interoperability">#</a> Operators and Programming Language Interoperability</h3><blockquote><p>Operator overloading can be a very useful tool, allowing developers to express their thoughts with succinct code. However, not all programming languages support operator overloading. When using a language that doesn’t support operator overloading, the language will not know how to interpret the + operator (unless the type is a primitive in that language), and the compiler will emit an error. When using languages that do not support operator overloading, the language should allow you to call the desired op_* method directly (such as op_Addition).</p></blockquote><blockquote><p>If you are using a language that doesn’t support + operator overloading to be defined in a type, obviously, this type could still offer an op_Addition method. From C#, you might expect that you could call this op_Addition method by using the + operator, but you cannot. When the C# compiler detects the + operator, it looks for an op_Addition method that has the specialname metadata flag associated with it so that the compiler knows for sure that the op_Addition method is intended to be an operator overload method. Because the op_Addition method is produced by a language that doesn’t support operator overloads, the method won’t have the specialname flag associated with it, and the C# compiler will produce a compilation error. Of course, code in any language can explicitly call a method that just happens to be named op_Addition, but the compilers won’t translate a usage of the + symbol to call this method.</p></blockquote><p>💡注意：FCL 的 <code>System.Decimal</code> 类型很好地演示了如何重载操作符并根据 Microsoft 的设计规范定义友好方法名。</p><p>💡小结：有的语言允许类型定义操作符应该如何操作类型的实例。CLR 对操作符重载一无所知，它甚至不知道什么是操作符。是编程语言定义了每个操作符的含义，以及当这些特殊符号出现时，应该生成什么样的代码。CLR 规范要求操作符重载方法必须是 public 和 static 方法。另外，C#（以及其他许多语言）要求操作符重载方法至少有一个参数的类型与当前定义这个方法的类型相同。之所以要进行这样的限制，是为了使 C# 编译器能在合理的时间内找到要绑定的操作符方法。CLR 规范定义了许多额外的可重载的操作符，但 C# 不支持这些额外的操作符。使用不支持操作符重载的语言时，语言不知道如何解释 + 操作符（除非类型是该语言的基元类型），编译器会报错。使用不支持操作符重载的编程语言时，语言应该允许你直接调用希望的 op_* 方法（例如 op_Addition）。如果语言不支持在类型中定义 + 操作符重载，这个类型仍然可能提供了一个 op_Addition 方法，但是在 C# 中使用 + 操作符是不会调用这个 op_Addition 方法的，因为 C# 编译器在检测到操作符 + 时，会查找关联了 specialname 元数据标志的 op_Addition 方法，以确定 op_Addition 方法是要作为操作符重载方法使用。但是由于现在这个 op_Addition 方法是由不支持操作符重载的编程语言生成的，所以方法没有关联 specialname 标记。因此，C# 编译器会报告编译错误。当然，用任何编程语言写的代码都可以显式调用碰巧命名为 op_Addition 的方法，但编译器不会将一个 + 号的使用翻译成对这个方法的调用。</p><h2 id="conversion-operator-methods"><a class="anchor" href="#conversion-operator-methods">#</a> Conversion Operator Methods</h2><blockquote><p>Occasionally, you need to convert an object from one type to an object of a different type. For example, I’m sure you’ve had to convert a Byte to an Int32 at some point in your life. When the source type and the target type are a compiler’s primitive types, the compiler knows how to emit the necessary code to convert the object.</p></blockquote><blockquote><p>If the source type or target type is not a primitive, the compiler emits code that has the CLR perform the conversion (cast). In this case, the CLR just checks if the source object’s type is the same type as the target type (or derived from the target type). However, it is sometimes natural to want to convert an object of one type to a completely different type. For example, the <code>System.Xml.Linq.XElement</code> class allows you to convert an Extensible Markup Language (XML) element to a Boolean, (U)Int32, (U)Int64, Single, Double, Decimal, String, DateTime, DateTimeOffset, TimeSpan, Guid, or the nullable equivalent of any of these types (except String). You could also imagine that the FCL included a Rational data type and that it might be convenient to convert an Int32 object or a Single object to a Rational object. Moreover, it also might be nice to convert a Rational object to an Int32 or a Single object.</p></blockquote><blockquote><p>To make these conversions, the Rational type should define public constructors that take a single parameter: an instance of the type that you’re converting from. You should also define public instance ToXxx methods that take no parameters (just like the very popular ToString method). Each method will convert an instance of the defining type to the Xxx type. Here’s how to correctly define conversion constructors and methods for a Rational type.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Constructs a Rational from an Int32 </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Rational</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// Constructs a Rational from a Single </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Rational</span><span class="token punctuation">(</span><span class="token class-name">Single</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Converts a Rational to an Int32 </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token function">ToInt32</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Converts a Rational to a Single </span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Single</span> <span class="token function">ToSingle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>By invoking these constructors and methods, a developer using any programming language can convert an Int32 or a Single object to a Rational object and convert a Rational object to an Int32 or a Single object. The ability to do these conversions can be quite handy, and when designing a type, you should seriously consider what conversion constructors and methods make sense for your type.</p></blockquote><blockquote><p>In the previous section, I discussed how some programming languages offer operator overloading. Well, some programming languages (such as C#) also offer conversion operator overloading. Conversion operators are methods that convert an object from one type to another type. You define a conversion operator method by using special syntax. The CLR specification mandates that conversion overload methods be public and static methods. In addition, C# (and many other languages) requires that either the parameter or the return type must be the same as the type that the conversion method is defined within. The reason for this restriction is that it enables the C# compiler to search for a possible operator method to bind to in a reasonable amount of time. The following code adds four conversion operator methods to the Rational type.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Constructs a Rational from an Int32 </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Rational</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// Constructs a Rational from a Single </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Rational</span><span class="token punctuation">(</span><span class="token class-name">Single</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Converts a Rational to an Int32 </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token function">ToInt32</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Converts a Rational to a Single </span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Single</span> <span class="token function">ToSingle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// Implicitly constructs and returns a Rational from an Int32 </span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">implicit</span> <span class="token keyword">operator</span> <span class="token function">Rational</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Rational</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// Implicitly constructs and returns a Rational from a Single </span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">implicit</span> <span class="token keyword">operator</span> <span class="token function">Rational</span><span class="token punctuation">(</span><span class="token class-name">Single</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Rational</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token comment">// Explicitly returns an Int32 from a Rational </span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">explicit</span> <span class="token keyword">operator</span> <span class="token function">Int32</span><span class="token punctuation">(</span><span class="token class-name">Rational</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token keyword">return</span> r<span class="token punctuation">.</span><span class="token function">ToInt32</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token comment">// Explicitly returns a Single from a Rational </span></pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">explicit</span> <span class="token keyword">operator</span> <span class="token function">Single</span><span class="token punctuation">(</span><span class="token class-name">Rational</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token keyword">return</span> r<span class="token punctuation">.</span><span class="token function">ToSingle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>For conversion operator methods, you must indicate whether a compiler can emit code to call a conversion operator method implicitly or whether the source code must explicitly indicate when the compiler is to emit code to call a conversion operator method. In C#, you use the implicit keyword to indicate to the compiler that an explicit cast doesn’t have to appear in the source code in order to emit code that calls the method. The explicit keyword allows the compiler to call the method only when an explicit cast exists in the source code.</p></blockquote><blockquote><p>After the implicit or explicit keyword, you tell the compiler that the method is a conversion operator by specifying the operator keyword. After the operator keyword, you specify the type that an object is being cast to; in the parentheses, you specify the type that an object is being cast from.</p></blockquote><blockquote><p>Defining the conversion operators in the preceding Rational type allows you to write code like this (in C#).</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Rational</span> r1 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// Implicit cast from Int32 to Rational </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">Rational</span> r2 <span class="token operator">=</span> <span class="token number">2.5F</span><span class="token punctuation">;</span> <span class="token comment">// Implicit cast from Single to Rational </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token punctuation">(</span>Int32<span class="token punctuation">)</span> r1<span class="token punctuation">;</span> <span class="token comment">// Explicit cast from Rational to Int32 </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token class-name">Single</span> s <span class="token operator">=</span> <span class="token punctuation">(</span>Single<span class="token punctuation">)</span> r2<span class="token punctuation">;</span> <span class="token comment">// Explicit cast from Rational to Single </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Under the covers, the C# compiler detects the casts (type conversions) in the code and internally generates IL code that calls the conversion operator methods defined by the Rational type. But what are the names of these methods? Well, compiling the Rational type and examining its metadata shows that the compiler produces one method for each conversion operator defined. For the Rational type, the metadata for the four conversion operator methods looks like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Rational</span> <span class="token function">op_Implicit</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> num<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Rational</span> <span class="token function">op_Implicit</span><span class="token punctuation">(</span><span class="token class-name">Single</span> num<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">op_Explicit</span><span class="token punctuation">(</span><span class="token class-name">Rational</span> r<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Single</span> <span class="token function">op_Explicit</span><span class="token punctuation">(</span><span class="token class-name">Rational</span> r<span class="token punctuation">)</span></pre></td></tr></table></figure><blockquote><p>As you can see, methods that convert an object from one type to another are always named op_ Implicit or op_Explicit. You should define an implicit conversion operator only when precision or magnitude isn’t lost during a conversion, such as when converting an Int32 to a Rational. However, you should define an explicit conversion operator if precision or magnitude is lost during the conversion, as when converting a Rational object to an Int32. If an explicit conversion fails, you should indicate this by having your explicit conversion operator method throw an <code>OverflowException</code> or an <code>InvalidOperationException</code> .</p></blockquote><p>💡注意：两个 <code>op_Explicit</code> 方法获取相同的参数，也就是一个 <code>Rational</code> 。但两个方法的返回类型不同，一个是 <code>Int32</code> ，另一个是 <code>Single</code> 。这是仅凭返回类型来区分两个方法的例子。CLR 允许在一个类型中定义仅返回类型不同的多个方法。但只有极少数语言支持这个能力。你可能已经注意到了，C++，C#，Visual Basic 和 Java 语言都不允许在一个类型中定义仅返回类型不同的多个方法。个别语言 (比如 IL 汇编语言) 允许开发人员显式选择调用其中哪一个方法。当然，IL 汇编语言的程序员不应利用这个能力，否则定义的方法无法从其他语言中调用。虽然 C# 语言没有向 C# 程序员公开这个能力，但当一个类型定义了转换操作符方法时，C# 编译器会在内部利用这个能力。</p><blockquote><p>C# has full support for conversion operators. When it detects code where you’re using an object of one type and an object of a different type is expected, the compiler searches for an implicit conversion operator method capable of performing the conversion and generates code to call that method. If an implicit conversion operator method exists, the compiler emits a call to it in the resulting IL code. If the compiler sees source code that is explicitly casting an object from one type to another type, the compiler searches for an implicit or explicit conversion operator method. If one exists, the compiler emits the call to the method. If the compiler can’t find an appropriate conversion operator method, it issues an error and doesn’t compile the code.</p></blockquote><p>💡注意：使用强制类型转换表达式时，C# 生成代码来调用显式转换操作符方法。使用 C# 的 <code>as</code> 和 <code>is</code> 操作符时，则永远不会调用这些方法。(参见 4.2 节。)</p><blockquote><p>To really understand operator overload methods and conversion operator methods, I strongly encourage you to examine the <code>System.Decimal</code> type as a role model. Decimal defines several constructors that allow you to convert objects from various types to a Decimal. It also offers several <code>ToXxx</code> methods that let you convert a Decimal object to another type. Finally, the type defines several conversion operators and operator overload methods as well.</p></blockquote><p>💡小结：除了定义构造函数和一些其他方法来完成类型转换外，有些编程语言（比如 C#）还提供了转换操作符重载。转换操作符是将对象从一种类型转换成另一种类型的方法。可以使用特殊的语法来定义转换操作符方法。CLR 规范要求转换操作符重载方法必须是 public 和 static 方法。此外 C#（以及许多其他语言）要求参数类型和方法返回类型两者必有其一与定义转换方法的类型相同。之所以要进行这个限制，是为了使 C# 编译器能在一个合理的时间内找到要绑定的操作符方法。对于转换操作符方法，编译器既可生成代码来隐式调用转换操作符方法，也可只有在源代码进行了显式转型时才生成代码来调用转换操作符方法。在 C# 中，implicit 关键字告诉编译器为了生成代码来调用方法，不需要再源代码中进行显式转型。相反，explicit 关键字告诉编译器只有在发现了显示转型时，才调用方法。在 implicit 或 explicit 关键字之后，要指定 operator 关键字告诉编译器该方法是一个转换操作符。在 operator 之后，指定对象要转换成什么类型。在圆括号内，则指定要从什么类型转换。将对象从一种类型转换成另一种类型的方法的元数据总是叫做 op_Implicit 或者 op_Explicit。只有在转换不损失精度或数量级的前提下才能定义隐式转换操作符，否则就应该定义显式转换操作符，并且在显式转换失败时抛出 <code>OverflowException</code> 或者 <code>InvalidOperationException</code> 异常。如果检测到代码中存在隐式转换的代码，如果存在对应的隐式转换操作符方法，编译器就会在结果 IL 代码中生成对它的调用。如果编译器看到的是将对象从一种类型显式转换为另一种类型，就会查找能执行这种转换的隐式或显式转换操作符方法。如果找到一个，编译器就生成 IL 代码来调用它。如果没有找到合适的转换操作符方法，就报错并停止编译。</p><h2 id="extension-methods"><a class="anchor" href="#extension-methods">#</a> Extension Methods</h2><blockquote><p>The best way to understand C#’s extension methods feature is by way of an example. In the “ <code>StringBuilder</code> Members” section in Chapter 14, “Chars, Strings, and Working with Text,” I mention how the <code>StringBuilder</code> class offers fewer methods than the String class for manipulating a string and how strange this is, considering that the <code>StringBuilder</code> class is the preferred way of manipulating a string because it is mutable. So, let’s say that you would like to define some of these missing methods yourself to operate on a <code>StringBuilder</code> . For example, you might want to define your own <code>IndexOf</code> method as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">StringBuilderExtensions</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">IndexOf</span><span class="token punctuation">(</span><span class="token class-name">StringBuilder</span> sb<span class="token punctuation">,</span> <span class="token class-name">Char</span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> sb<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>sb<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token keyword">return</span> index<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Now that you have defined this method, you can use it as the following code demonstrates.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token string">"Hello. My name is Jeff."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// The initial string</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// Change period to exclamation and get # characters in 1st sentence (5).</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">Int32</span> index <span class="token operator">=</span> StringBuilderExtensions<span class="token punctuation">.</span><span class="token function">IndexOf</span><span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">Replace</span><span class="token punctuation">(</span><span class="token char">'.'</span><span class="token punctuation">,</span> <span class="token char">'!'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token char">'!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>This code works just fine, but is it not ideal from a programmer’s perspective. The first problem is that a programmer who wants to get the index of a character within a <code>StringBuilder</code> must know that the <code>StringBuilderExtensions</code> class even exists. The second problem is that the code does not reflect the order of operations that are being performed on the <code>StringBuilder</code> object, making the code difficult to write, read, and maintain. The programmer wants to call Replace first and then call <code>IndexOf</code> ; but when you read the last line of code from left to right, <code>IndexOf</code> appears first on the line and Replace appears second. Of course, you could alleviate this problem and make the code’s behavior more understandable by rewriting it like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// First, change period to exclamation mark</span></pre></td></tr><tr><td data-num="2"></td><td><pre>sb<span class="token punctuation">.</span><span class="token function">Replace</span><span class="token punctuation">(</span><span class="token char">'.'</span><span class="token punctuation">,</span> <span class="token char">'!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// Now, get # characters in 1st sentence (5)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token class-name">Int32</span> index <span class="token operator">=</span> StringBuilderExtensions<span class="token punctuation">.</span><span class="token function">IndexOf</span><span class="token punctuation">(</span>sb<span class="token punctuation">,</span> <span class="token char">'!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>However, a third problem exists with both versions of this code that affects understanding the code’s behavior. The use of <code>StringBuilderExtensions</code> is overpowering and detracts a programmer’s mind from the operation that is being performed: <code>IndexOf</code> . If the <code>StringBuilder</code> class had defined its own <code>IndexOf</code> method, then we could rewrite the code above as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Change period to exclamation and get # characters in 1st sentence (5).</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Int32</span> index <span class="token operator">=</span> sb<span class="token punctuation">.</span><span class="token function">Replace</span><span class="token punctuation">(</span><span class="token char">'.'</span><span class="token punctuation">,</span> <span class="token char">'!'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">IndexOf</span><span class="token punctuation">(</span><span class="token char">'!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>Wow, look how great this is in terms of code maintainability! In the <code>StringBuilder</code> object, we’re going to replace a period with an exclamation mark and then find the index of the exclamation mark.</p></blockquote><blockquote><p>Now, I can explain what C#’s extension methods feature does. It allows you to define a static method that you can invoke using instance method syntax. Or, in other words, we can now define our own <code>IndexOf</code> method and the three problems mentioned above go away. To turn the <code>IndexOf</code> method into an extension method, we simply add the this keyword before the first argument.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">StringBuilderExtensions</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">IndexOf</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">StringBuilder</span> sb<span class="token punctuation">,</span> <span class="token class-name">Char</span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> sb<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>sb<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token keyword">return</span> index<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Now, when the compiler sees code like the following, the compiler first checks if the <code>StringBuilder</code> class or any of its base classes offers an instance method called <code>IndexOf</code> that takes a single Char parameter.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Int32</span> index <span class="token operator">=</span> sb<span class="token punctuation">.</span><span class="token function">IndexOf</span><span class="token punctuation">(</span><span class="token char">'X'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>If an existing instance method exists, then the compiler produces IL code to call it. If no matching instance method exists, then the compiler will look at any static classes that define static methods called <code>IndexOf</code> that take as their first parameter a type matching the type of the expression being used to invoke the method. This type must also be marked with the this keyword. In this example, the expression is sb, which is of the <code>StringBuilder</code> type. In this case, the compiler is looking specifically for an <code>IndexOf</code> method that takes two parameters: a <code>StringBuilder</code> (marked with the this keyword) and a Char. The compiler will find our <code>IndexOf</code> method and produce IL code that calls our static method.</p></blockquote><blockquote><p>OK—so this now explains how the compiler improves the last two problems related to code understandability that I mentioned earlier. However, I haven’t yet addressed the first problem: how does a programmer know that an <code>IndexOf</code> method even exists that can operate on a <code>StringBuilder</code> object? The answer to this question is found in Microsoft Visual Studio’s IntelliSense feature. In the editor, when you type a period, Visual Studio’s IntelliSense window opens to show you the list of instance methods that are available. Well, that IntelliSense window also shows you any extension methods that exist for the type of expression you have to the left of the period. Figure 8-1 shows Visual Studio’s IntelliSense window; the icon for an extension method has a down arrow next to it, and the tooltip next to the method indicates that the method is really an extension method. This is truly awesome because it is now easy to define your own methods to operate on various types of objects and have other programmers discover your methods naturally when using objects of these types.</p></blockquote><p><img data-src="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/image-20221025222135596.png" alt="image-20221025222135596"></p><h3 id="rules-and-guidelines"><a class="anchor" href="#rules-and-guidelines">#</a> Rules and Guidelines</h3><blockquote><p>There are some additional rules and guidelines that you should know about extension methods:</p></blockquote><ul><li><p>C# supports extension methods only; it does not offer extension properties, extension events, extension operators, and so on.</p></li><li><p>Extension methods (methods with this before their first argument) must be declared in nongeneric, static classes. However, there is no restriction on the name of the class; you can call it whatever you want. Of course, an extension method must have at least one parameter, and only the first parameter can be marked with the this keyword.</p></li><li><p>The C# compiler looks only for extension methods defined in static classes that are themselves defined at the file scope. In other words, if you define the static class nested within another class, the C# compiler will emit the following message: error CS1109: Extension method must be defined in a top-level static class; <code>StringBuilderExtensions</code> is a nested class.</p></li><li><p>Because the static classes can have any name you want, it takes the C# compiler time to find extension methods because it must look at all the file-scope static classes and scan their static methods for a match. To improve performance and also to avoid considering an extension method that you may not want, the C# compiler requires that you “import” extension methods. For example, if someone has defined a <code>StringBuilderExtensions</code> class in a <code>Wintellect</code> namespace, then a programmer who wants to have access to this class’s extension methods must put a using <code>Wintellect</code> ; directive at the top of his or her source code file.</p></li><li><p>It is possible that multiple static classes could define the same extension method. If the compiler detects that two or more extension methods exist, then the compiler issues the following message: error CS0121: The call is ambiguous between the following methods or properties: ' <code>StringBuilderExtensions.IndexOf(string, char)</code> ' and ' <code>AnotherStringBuilderExtensions.IndexOf(string, char)</code> '. To fix this error, you must modify your source code. Specifically, you cannot use the instance method syntax to call this static method anymore; instead you must now use the static method syntax where you explicitly indicate the name of the static class to explicitly tell the compiler which method you want to invoke.</p></li><li><p>You should use this feature sparingly, because not all programmers are familiar with it. For example, when you extend a type with an extension method, you are actually extending derived types with this method as well. Therefore, you should not define an extension method whose first parameter is <code>System.Object</code> , because this method will be callable for all expression types and this will really pollute Visual Studio’s IntelliSense window.</p></li><li><p>There is a potential versioning problem that exists with extension methods. If, in the future, Microsoft adds an <code>IndexOf</code> instance method to their <code>StringBuilder</code> class with the same prototype as my code is attempting to call, then when I recompile my code, the compiler will bind to Microsoft’s <code>IndexOf</code> instance method instead of my static <code>IndexOf</code> method. Because of this, my program will experience different behavior. This versioning problem is another reason why this feature should be used sparingly.</p></li></ul><h3 id="extending-various-types-with-extension-methods"><a class="anchor" href="#extending-various-types-with-extension-methods">#</a> Extending Various Types with Extension Methods</h3><blockquote><p>In this chapter, I demonstrated how to define an extension method for a class, <code>StringBuilder</code> . I’d like to point out that because an extension method is really the invocation of a static method, the CLR does not emit code ensuring that the value of the expression used to invoke the method is not null.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// sb is null</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// Calling extension method: NullReferenceException will NOT be thrown when calling IndexOf</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// NullReferenceException will be thrown inside IndexOf’s for loop</span></pre></td></tr><tr><td data-num="5"></td><td><pre>sb<span class="token punctuation">.</span><span class="token function">IndexOf</span><span class="token punctuation">(</span><span class="token char">'X'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// Calling instance method: NullReferenceException WILL be thrown when calling Replace</span></pre></td></tr><tr><td data-num="7"></td><td><pre>sb<span class="token punctuation">.</span><span class="token function">Replace</span><span class="token punctuation">(</span><span class="token char">'.'</span><span class="token punctuation">,</span> <span class="token char">'!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>I’d also like to point <span class="token keyword">out</span> that you can define extension methods <span class="token keyword">for</span> <span class="token keyword">interface</span> <span class="token class-name">types</span><span class="token punctuation">,</span> <span class="token keyword">as</span> <span class="token class-name">the</span> following code shows<span class="token punctuation">.</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">ShowItems</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> collection<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> item <span class="token keyword">in</span> collection<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>The extension method above can now be invoked <span class="token keyword">using</span> any expression <span class="token class-name">that</span> results <span class="token keyword">in</span> a type that </pre></td></tr><tr><td data-num="14"></td><td><pre>implements the IEnumerable<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">interface</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token comment">// Shows each Char on a separate line in the console</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token string">"Grant"</span><span class="token punctuation">.</span><span class="token function">ShowItems</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token comment">// Shows each String on a separate line in the console</span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token keyword">new</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span> <span class="token string">"Jeff"</span><span class="token punctuation">,</span> <span class="token string">"Kristin"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">ShowItems</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token comment">// Shows each Int32 value on a separate line in the console</span></pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">List<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">ShowItems</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>💡重要提示：扩展方法是 Microsoft 的 LINQ (<strong>Language Integrated Query</strong>，语言集成查询) 技术的基础。要想仔细研究提供了许多扩展方法的一个典型的类，请自行在文档中查看静态类 <code>System.Linq.Enumerable</code> 及其所有静态扩展方法。这个类中的每个扩展方法都扩展了 <code>IEnumerable</code> 或 <code>IEnumerable&lt;T&gt;</code> 接口。</p><blockquote><p>You can define extension methods for delegate types, too. Here is an example.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">InvokeAndCatch</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>TException<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">Action<span class="token punctuation">&lt;</span>Object<span class="token punctuation">></span></span> d<span class="token punctuation">,</span> <span class="token class-name">Object</span> o<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">where</span> <span class="token class-name">TException</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Exception</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span> <span class="token function">d</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">TException</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>And here is an example of how to invoke it.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Action<span class="token punctuation">&lt;</span>Object<span class="token punctuation">></span></span> action <span class="token operator">=</span> o <span class="token operator">=></span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Throws NullReferenceException</span></pre></td></tr><tr><td data-num="2"></td><td><pre>action<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">InvokeAndCatch</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>NullReferenceException<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Swallows NullReferenceException</span></pre></td></tr></table></figure><blockquote><p>You can also add extension methods to enumerated types. I show an example of this in the “Adding Methods to Enumerated Types” section in Chapter 15, “Enumerated Types and Bit Flags.</p></blockquote><blockquote><p>And last but not least, I want to point out that the C# compiler allows you to create a delegate (see Chapter 17, “Delegates,” for more information) that refers to an extension method over an object.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> Main <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Create an Action delegate that refers to the static ShowItems extension method</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// and has the first argument initialized to reference the "Jeff" string. </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">Action</span> a <span class="token operator">=</span> <span class="token string">"Jeff"</span><span class="token punctuation">.</span>ShowItems<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">.</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">.</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">.</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Invoke the delegate that calls ShowItems passing it a reference to the "Jeff" string.</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In the preceding code, the C# compiler generates IL code to construct an Action delegate. When creating a delegate, the constructor is passed the method that should be called and is also passed a reference to an object that should be passed to the method’s hidden this parameter. Normally, when you create a delegate that refers to a static method, the object reference is null because static methods don’t have a this parameter. However, in this example, the C# compiler generated some special code that creates a delegate that refers to a static method (ShowItems) and the target object of the static method is the reference to the “Jeff” string. Later, when the delegate is invoked, the CLR will call the static method and will pass to it the reference to the “Jeff” string. This is a little hacky, but it works great and it feels natural so long as you don’t think about what is happening internally.</p></blockquote><h3 id="the-extension-attribute"><a class="anchor" href="#the-extension-attribute">#</a> The Extension Attribute</h3><blockquote><p>It would be best if this concept of extension methods was not C#-specific. Specifically, we want programmers to define a set of extension methods in some programming language and for people in other programming languages to take advantage of them. For this to work, the compiler of choice must support searching static types and methods for potentially matching extension methods. And compilers need to do this quickly so that compilation time is kept to a minimum.</p></blockquote><blockquote><p>In C#, when you mark a static method’s first parameter with the this keyword, the compiler internally applies a custom attribute to the method and this attribute is persisted in the resulting file’s metadata. The attribute is defined in the System.Core.dll assembly, and it looks like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Defined in the System.Runtime.CompilerServices namespace</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">[</span><span class="token function">AttributeUsage</span><span class="token punctuation">(</span>AttributeTargets<span class="token punctuation">.</span>Method <span class="token operator">|</span> AttributeTargets<span class="token punctuation">.</span>Class <span class="token operator">|</span> AttributeTargets<span class="token punctuation">.</span>Assembly<span class="token punctuation">)</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">ExtensionAttribute</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Attribute</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In addition, this attribute is applied to the metadata for any static class that contains at least one extension method. And this attribute is also applied to the metadata for any assembly that contains at least one static class that contains an extension method. So now, when compiling code that invokes an instance method that doesn’t exist, the compiler can quickly scan all the referenced assemblies to know which ones contain extension methods. Then it can scan only these assemblies for static classes that contain extension methods, and it can scan just the extension methods for potential matches to compile the code as quickly as possible.</p></blockquote><p>💡Note : The ExtensionAttribute class is defined in the System.Core.dll assembly. This means that the resulting assembly produced by the compiler will have a reference to System.Core.dll embedded in it even if I do not use any types from System.Core.dll and do not even reference System.Core.dll when compiling my code. However, this is not too bad a problem because the ExtensionAttribute is used only at compile time; at run time, System.Core.dll will not have to be loaded unless the application consumes something else in this assembly.</p><p>💡小结：C# 扩展方法允许在一个静态类中定义一个静态方法，并用实例方法的语法来调用。扩展方法顾名思义时对类行方法的扩展，在调用方法时首先会检查类或者它的任何基类是否定义该名称的实例方法。如果定义了，就生成 IL 代码来调用它。如果没有找到匹配的实例方法，就继续检查是否有任何静态类定义了该名称的静态方法，方法的第一个参数的类型和当前用于调用方法的那个表达式的类型匹配，而且该类型必须用 this 关键字标识。关于扩展方法，有些规则和原则需要注意。例如 C# 只支持扩展方法，不支持扩展属性、扩展事件、扩展操作符等。扩展方法必须在非泛型的静态类中声明。扩展方法至少要有一个参数，而且只有第一个参数能用 this 关键字标记。C# 编译器在静态类中查找扩展方法时，要求静态类本身必须具有文件作用域。用一个扩展方法扩展一个类型时，同时也扩展了派生类型。由于扩展方法实际是对一个静态方法的调用，所以 CLR 不会生成代码对调用方法的表达式的值进行 null 值检查（不保证它非空）。我们还可以为接口类型、委托类型、枚举类型定义扩展方法。C# 编译器允许创建委托来引用一个对象上的扩展方法。在 C# 中，一旦 this 关键字标记了某个静态方法的第一个参数，编译器就会在内部向该方法应用一个定制特性。该特性会在最终生成的文件的元数据中持久性地存储下来。除此之外，任何静态类只要包含至少一个扩展方法，它的元数据中也会应用这个特性。类似地，任何程序集只要包含了至少一个符合上述特点的静态类，它的元数据中也会应用这个特性。</p><h2 id="partial-methods"><a class="anchor" href="#partial-methods">#</a> Partial Methods</h2><blockquote><p>Imagine that you use a tool that produces a C# source code file containing a type definition. The tool knows that there are potential places within the code it produces where you might want to customize the type’s behavior. Normally, customization would be done by having the tool-produced code invoke virtual methods. The tool-produced code would also have to contain definitions for these virtual methods, and the way these methods would be implemented is to do nothing and simply return. Now, if you want to customize the behavior of the class, you’d define your own class, derive it from the base class, and then override any virtual methods implementing it so that it has the behavior you desire. Here is an example.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Tool-produced code in some source code file:</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">String</span> m_name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// Called before changing the m_name field</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">protected</span> <span class="token keyword">virtual</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">OnNameChanging</span><span class="token punctuation">(</span><span class="token class-name">String</span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">String</span> Name <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> m_name<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">set</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token function">OnNameChanging</span><span class="token punctuation">(</span><span class="token keyword">value</span><span class="token punctuation">.</span><span class="token function">ToUpper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Inform class of potential change</span></pre></td></tr><tr><td data-num="11"></td><td><pre> m_name <span class="token operator">=</span> <span class="token keyword">value</span><span class="token punctuation">;</span> <span class="token comment">// Change the field</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">// Developer-produced code in some other source code file:</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Base</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token keyword">protected</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">OnNameChanging</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">IsNullOrEmpty</span><span class="token punctuation">(</span><span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ArgumentNullException</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Unfortunately, there are two problems with the preceding code:</p></blockquote><ul><li><p>The type must be a class that is not sealed. You cannot use this technique for sealed classes or for value types (because value types are implicitly sealed). In addition, you cannot use this technique for static methods because they cannot be overridden.</p></li><li><p>There are efficiency problems here. A type is being defined just to override a method; this wastes a small amount of system resources. And, even if you do not want to override the behavior of <code>OnNameChanging</code> , the base class code still invokes a virtual method that simply does nothing but return. Also, <code>ToUpper</code> is called whether <code>OnNameChanging</code> accesses the argument passed to it or not.</p></li></ul><blockquote><p>C#’s partial methods feature allows you the option of overriding the behavior or a type while fixing the aforementioned problems. The code below uses partial methods to accomplish the same semantic as the previous code.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Tool-produced code in some source code file:</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">partial</span> <span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">String</span> m_name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// This defining-partial-method-declaration is called before changing the m_name field</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">partial</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">OnNameChanging</span><span class="token punctuation">(</span><span class="token class-name">String</span> <span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">String</span> Name <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> m_name<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">set</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token function">OnNameChanging</span><span class="token punctuation">(</span><span class="token keyword">value</span><span class="token punctuation">.</span><span class="token function">ToUpper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Inform class of potential change</span></pre></td></tr><tr><td data-num="10"></td><td><pre> m_name <span class="token operator">=</span> <span class="token keyword">value</span><span class="token punctuation">;</span> <span class="token comment">// Change the field</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token comment">// Developer-produced code in some other source code file:</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">partial</span> <span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token comment">// This implementing-partial-method-declaration is called before m_name is changed </span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token keyword">partial</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">OnNameChanging</span><span class="token punctuation">(</span><span class="token class-name">String</span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">IsNullOrEmpty</span><span class="token punctuation">(</span><span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ArgumentNullException</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>There are several things to notice about this new version of the code:</p></blockquote><ul><li><p>The class is now sealed (although it doesn’t have to be). In fact, the class could be a static class or even a value type.</p></li><li><p>The tool-produced code and the developer-produced code are really two partial definitions that ultimately make up one type definition. For more information about partial types, see the “Partial Classes, Structures, and Interfaces” section in Chapter 6, “Type and Member Basics.”</p></li><li><p>The tool-produced code defined a partial method declaration. This method is marked with the partial token and it has no body.</p></li><li><p>The developer-produced code implemented the partial method declaration. This method is also marked with the partial token and it has a body.</p></li></ul><blockquote><p>Now, when you compile this code, you see the same effect as the original code I showed you. Again, the big benefit here is that you can rerun the tool and produce new code in a new source code file, but your code remains in a separate file and is unaffected. And, this technique works for sealed classes, static classes, and value types.</p></blockquote><p>💡注意：在 Visual Studio 编辑器中，如果输入 <code>partial</code> 并按空格键，“智能感知” 窗口会列出当前类型定义的、还没有匹配实现的所有分部方法声明。可以方便地从窗口中选择一个分部方法。然后，Visual Studio 会自动生成方法原型。这个功能提高了编程效率。</p><blockquote><p>But, there is another big improvement we get with partial methods. Let’s say that you do not need to modify the behavior of the tool-produced type. In this case, you do not supply your source code file at all. If you just compile the tool-produced code by itself, the compiler produces IL code and metadata as if the tool-produced code looked like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Logical equivalent of tool-produced code if there is no </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// implementing partial method declaration:</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">String</span> m_name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">String</span> Name <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> m_name<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">set</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> m_name <span class="token operator">=</span> <span class="token keyword">value</span><span class="token punctuation">;</span> <span class="token comment">// Change the field</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>That is, if there is no implementing partial method declaration, the compiler will not emit any metadata representing the partial method. In addition, the compiler will not emit any IL instructions to call the partial method. And the compiler will not emit code that evaluates any arguments that would have been passed to the partial method. In this example, the compiler will not emit code to call the ToUpper method. The result is that there is less metadata/IL, and the run-time performance is awesome!</p></blockquote><p>💡注意：分部方法的工作方式类似于 <code>System.Diagnostics.ConditionalAttribute</code> 特性。然而，分部方法只能在单个类型中使用，而 <code>ConditionalAttribute</code> 能用于对另一个类型中定义的方法进行有选择的调用。</p><h3 id="rules-and-guidelines-2"><a class="anchor" href="#rules-and-guidelines-2">#</a> Rules and Guidelines</h3><blockquote><p>There are some additional rules and guidelines that you should know about partial methods:</p></blockquote><ul><li><p>They can only be declared within a partial class or struct.</p></li><li><p>Partial methods must always have a return type of void, and they cannot have any parameters marked with the out modifier. These restrictions are in place because at run time, the method may not exist and so you can’t initialize a variable to what the method might return because the method might not exist. Similarly, you can’t have an out parameter because the method would have to initialize it and the method might not exist. A partial method may have ref parameters, may be generic, may be instance or static, and may be marked as unsafe.</p></li><li><p>Of course, the defining partial method declaration and the implementing partial method declaration must have identical signatures. If both have custom attributes applied to them, then the compiler combines both methods’ attributes together. Any attributes applied to a parameter are also combined.</p></li><li><p>If there is no implementing partial method declaration, then you cannot have any code that attempts to create a delegate that refers to the partial method. Again, the reason is that the method doesn’t exist at run time. The compiler produces this message: error CS0762: Cannot create delegate from method ' <code>Base.OnNameChanging(string)</code> ' because it is a partial method without an implementing declaration.</p></li><li><p>Partial methods are always considered to be private methods. However, the C# compiler forbids you from putting the private keyword before the partial method declaration.</p></li></ul><p>💡小结：假设我们用工具生成了包含类型定义的 C# 源代码文件，并且想要在代码的某些位置定义类型的行为，正常情况下，是让工具生成的代码调用虚方法来进行定制。但是这样的代码存在两个问题。一是类型必须是非密封的类。二是效率问题，会调用很多多余的代码。利用 C# 的分部方法功能，可以解决上述问题的同时覆盖类的行为。使用分部方法的好处在于，可以重新运行工具，在新的源代码文件中生成新的代码，但我们自己的代码时存储在一个单独的文件中的，不会收到影响。另外，这个技术可用于密封类、静态类以及值类型。如果没有实现分布方法，编译器不会生成任何代表分布方法的元数据。此外，编译器不会生成任何调用分部方法的 IL 指令。而且，编译器不会生成对本该传给分部方法的实参进行求值的 IL 指令。对于分部方法，有一些规则和原则需要注意。它们只能在分部类或结构中声明。分部方法的返回类型始终是 void，任何参数都不能用 out 修饰符来标记。之所以有这两个限制，是因为方法在运行时可能不存在，所以不能将变量初始化为方法也许会返回的东西。类似地，不允许 <code>out</code> 参数是因为方法必须初始化它，而方法可能不存在。分部方法可以有 <code>ref</code> 参数，可以是泛型方法，可以是实例或静态方法，而且可标记为 <code>unsafe</code> 。当然，分部方法的声明和实现必须具有完全一致的签名。如果两者都应了定制特性，编译器会合并两个方法的特性。应用于参数的任何特性也会合并。如果没有对应的实现部分，便不能在代码中创建一个委托来引用这个分部方法。这同样是由于方法在运行时不存在。分部方法总是被视为 <code>private</code> 方法，但 C# 编译器禁止在分部方法声明之前添加 <code>private</code> 关键字。</p><div class="tags"><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 读书笔记</a> <a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C#</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2022-12-02 19:56:57" itemprop="dateModified" datetime="2022-12-02T19:56:57+08:00">2022-12-02</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Sakupinera WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Sakupinera Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Sakupinera PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Sakupinera <i class="ic i-at"><em>@</em></i>Sakupinera</li><li class="link"><strong>Post link: </strong><a href="http://sakupinera.github.io/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" title="CLR via C# - Chapter 8 Methods">http://sakupinera.github.io/2022/10/25/csharp/clr-via-csharp/Chapter 8 Methods/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/10/24/csharp/clr-via-csharp/Chapter%207%20Constants%20and%20Fields/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipeybxm1pj20zk0m8niv.jpg" title="CLR via C# - Chapter 7 Constants and Fields"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 7 Constants and Fields</h3></a></div><div class="item right"><a href="/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipeyhsblkj20zk0m81kx.jpg" title="CLR via C# - Chapter 9 Parameters"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 9 Parameters</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-8-methods"><span class="toc-number">1.</span> <span class="toc-text">Chapter 8 Methods</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#instance-constructors-and-classes-reference-types"><span class="toc-number">1.1.</span> <span class="toc-text">Instance Constructors and Classes (Reference Types)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#instance-constructors-and-structures-value-types"><span class="toc-number">1.2.</span> <span class="toc-text">Instance Constructors and Structures (Value Types)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-constructors"><span class="toc-number">1.3.</span> <span class="toc-text">Type Constructors</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#operator-overload-methods"><span class="toc-number">1.4.</span> <span class="toc-text">Operator Overload Methods</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#operators-and-programming-language-interoperability"><span class="toc-number">1.4.1.</span> <span class="toc-text">Operators and Programming Language Interoperability</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#conversion-operator-methods"><span class="toc-number">1.5.</span> <span class="toc-text">Conversion Operator Methods</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#extension-methods"><span class="toc-number">1.6.</span> <span class="toc-text">Extension Methods</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rules-and-guidelines"><span class="toc-number">1.6.1.</span> <span class="toc-text">Rules and Guidelines</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extending-various-types-with-extension-methods"><span class="toc-number">1.6.2.</span> <span class="toc-text">Extending Various Types with Extension Methods</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#the-extension-attribute"><span class="toc-number">1.6.3.</span> <span class="toc-text">The Extension Attribute</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#partial-methods"><span class="toc-number">1.7.</span> <span class="toc-text">Partial Methods</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rules-and-guidelines-2"><span class="toc-number">1.7.1.</span> <span class="toc-text">Rules and Guidelines</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"><ul><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/" rel="bookmark" title="CLR via C# - Chapter 1 The CLR’s Execution Model">CLR via C# - Chapter 1 The CLR’s Execution Model</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/" rel="bookmark" title="CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types">CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%203%20Shared%20Assemblies%20and%20Strongly%20Named%20Assemblies/" rel="bookmark" title="CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies">CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies</a></li><li><a href="/2022/09/27/csharp/clr-via-csharp/Chapter%204%20Type%20Fundamentals/" rel="bookmark" title="CLR via C# - Chapter 4 Type Fundamentals">CLR via C# - Chapter 4 Type Fundamentals</a></li><li><a href="/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/" rel="bookmark" title="CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals">CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals</a></li><li><a href="/2022/10/21/csharp/clr-via-csharp/Chapter%206%20Type%20and%20Member%20Basics/" rel="bookmark" title="CLR via C# - Chapter 6 Type and Member Basics">CLR via C# - Chapter 6 Type and Member Basics</a></li><li><a href="/2022/10/24/csharp/clr-via-csharp/Chapter%207%20Constants%20and%20Fields/" rel="bookmark" title="CLR via C# - Chapter 7 Constants and Fields">CLR via C# - Chapter 7 Constants and Fields</a></li><li class="active"><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" rel="bookmark" title="CLR via C# - Chapter 8 Methods">CLR via C# - Chapter 8 Methods</a></li><li><a href="/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/" rel="bookmark" title="CLR via C# - Chapter 9 Parameters">CLR via C# - Chapter 9 Parameters</a></li><li><a href="/2022/10/28/csharp/clr-via-csharp/Chapter%2010%20Properties/" rel="bookmark" title="CLR via C# - Chapter 10 Properties">CLR via C# - Chapter 10 Properties</a></li><li><a href="/2022/10/29/csharp/clr-via-csharp/Chapter%2011%20Events/" rel="bookmark" title="CLR via C# - Chapter 11 Events">CLR via C# - Chapter 11 Events</a></li><li><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" rel="bookmark" title="CLR via C# - Chapter 12 Generics">CLR via C# - Chapter 12 Generics</a></li><li><a href="/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/" rel="bookmark" title="CLR via C# - Chapter 13 Interfaces">CLR via C# - Chapter 13 Interfaces</a></li><li><a href="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/" rel="bookmark" title="CLR via C# - Chapter 14 Chars, Strings, and Working with Text">CLR via C# - Chapter 14 Chars, Strings, and Working with Text</a></li><li><a href="/2022/11/17/csharp/clr-via-csharp/Chapter%2015%20Enumerated%20Types%20and%20Bit%20Flags/" rel="bookmark" title="CLR via C# - Chapter 15 Enumerated Types and Bit Flags">CLR via C# - Chapter 15 Enumerated Types and Bit Flags</a></li><li><a href="/2022/11/19/csharp/clr-via-csharp/Chapter%2016%20Arrays/" rel="bookmark" title="CLR via C# - Chapter 16 Arrays">CLR via C# - Chapter 16 Arrays</a></li><li><a href="/2022/11/21/csharp/clr-via-csharp/Chapter%2017%20Delegates/" rel="bookmark" title="CLR via C# - Chapter 17 Delegates">CLR via C# - Chapter 17 Delegates</a></li><li><a href="/2022/11/22/csharp/clr-via-csharp/Chapter%2018%20Custom%20Attributes/" rel="bookmark" title="CLR via C# - Chapter 18 Custom Attributes">CLR via C# - Chapter 18 Custom Attributes</a></li><li><a href="/2022/11/23/csharp/clr-via-csharp/Chapter%2019%20Nullable%20Value%20Types/" rel="bookmark" title="CLR via C# - Chapter 19 Nullable Value Types">CLR via C# - Chapter 19 Nullable Value Types</a></li><li><a href="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/" rel="bookmark" title="CLR via C# - Chapter 20 Exceptions and State Management">CLR via C# - Chapter 20 Exceptions and State Management</a></li><li><a href="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/" rel="bookmark" title="CLR via C# - Chapter 21 The Managed Heap and Garbage  Collection">CLR via C# - Chapter 21 The Managed Heap and Garbage Collection</a></li><li><a href="/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/" rel="bookmark" title="CLR via C# - Chapter 22 CLR Hosting and AppDomains">CLR via C# - Chapter 22 CLR Hosting and AppDomains</a></li><li><a href="/2022/11/29/csharp/clr-via-csharp/Chapter%2023%20Assembly%20Loading%20and%20Reflection/" rel="bookmark" title="CLR via C# - Chapter 23 Assembly Loading and Reflection">CLR via C# - Chapter 23 Assembly Loading and Reflection</a></li><li><a href="/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/" rel="bookmark" title="CLR via C# - Chapter 24 Runtime Serialization">CLR via C# - Chapter 24 Runtime Serialization</a></li><li><a href="/2022/12/06/csharp/clr-via-csharp/Chapter%2025%20Interoperating%20with%20WinRT%20%20Components/" rel="bookmark" title="CLR via C# - Chapter 25 Interoperating with WinRT Components">CLR via C# - Chapter 25 Interoperating with WinRT Components</a></li><li><a href="/2023/02/06/csharp/clr-via-csharp/Chapter%2026%20Thread%20Basics/" rel="bookmark" title="CLR via C# - Chapter 26 Thread Basics">CLR via C# - Chapter 26 Thread Basics</a></li><li><a href="/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations">CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations</a></li><li><a href="/2023/02/08/csharp/clr-via-csharp/Chapter%2028%20IO-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 28 IO-Bound Asynchronous Operations">CLR via C# - Chapter 28 IO-Bound Asynchronous Operations</a></li><li><a href="/2023/02/09/csharp/clr-via-csharp/Chapter%2029%20Primitive%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 29 Primitive Thread Synchronization">CLR via C# - Chapter 29 Primitive Thread Synchronization</a></li><li><a href="/2023/02/10/csharp/clr-via-csharp/Chapter%2030%20Hybrid%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 30 Hybrid Thread Synchronization">CLR via C# - Chapter 30 Hybrid Thread Synchronization</a></li></ul></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sakupinera" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Sakupinera</p><div class="description" itemprop="description">保持你的决心！</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">89</span> <span class="name">posts</span></a></div><div class="item categories"><a href="/categories/"><span class="count">17</span> <span class="name">categories</span></a></div><div class="item tags"><a href="/tags/"><span class="count">8</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nha3VwaW5lcmE=" title="https:&#x2F;&#x2F;github.com&#x2F;sakupinera"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQwNzIyOTA3MQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;407229071"><i class="ic i-cloud-music"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMjIzMDczOTg/c3BtX2lkX2Zyb209MzMzLjEwMDcuMC4w" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;22307398?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li><li class="item"><a href="/games/" rel="section"><i class="ic i-flag"></i>games</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-person"></i>About</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/10/24/csharp/clr-via-csharp/Chapter%207%20Constants%20and%20Fields/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2022/12/12/cpp/cpp-primer/Chapter%204%20Expressions/" title="C++ Primer - Chapter 4 Expressions">C++ Primer - Chapter 4 Expressions</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/21/csharp/clr-via-csharp/Chapter%2017%20Delegates/" title="CLR via C# - Chapter 17 Delegates">CLR via C# - Chapter 17 Delegates</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/" title="CLR via C# - Chapter 22 CLR Hosting and AppDomains">CLR via C# - Chapter 22 CLR Hosting and AppDomains</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/" title="CLR via C# - Chapter 13 Interfaces">CLR via C# - Chapter 13 Interfaces</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/09/06/computer-graphics/games101/%E5%90%91%E9%87%8F%E5%92%8C%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" title="GAMES101 - 向量和线性代数">GAMES101 - 向量和线性代数</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/" title="CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations">CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/09/27/csharp/clr-via-csharp/Chapter%204%20Type%20Fundamentals/" title="CLR via C# - Chapter 4 Type Fundamentals">CLR via C# - Chapter 4 Type Fundamentals</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/" title="CLR via C# - Chapter 1 The CLR’s Execution Model">CLR via C# - Chapter 1 The CLR’s Execution Model</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/10/24/csharp/clr-via-csharp/Chapter%207%20Constants%20and%20Fields/" title="CLR via C# - Chapter 7 Constants and Fields">CLR via C# - Chapter 7 Constants and Fields</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2023/02/08/csharp/clr-via-csharp/Chapter%2028%20IO-Bound%20Asynchronous%20Operations/" title="CLR via C# - Chapter 28 IO-Bound Asynchronous Operations">CLR via C# - Chapter 28 IO-Bound Asynchronous Operations</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Sakupinera @ Hanamai Sora</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="Symbols count total">2.2m words</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="Reading time total">34:05</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/10/25/csharp/clr-via-csharp/Chapter 8 Methods/",favicon:{show:"（●´3｀●）Goooood",hide:"(´Д｀)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/shifuku.model.json"},display:{position:"left",width:250,height:500},mobile:{show:!1},react:{opacity:.9},log:!1})</script></body></html>