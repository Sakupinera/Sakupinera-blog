<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sakupinera" href="http://sakupinera.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sakupinera" href="http://sakupinera.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sakupinera" href="http://sakupinera.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="学习笔记,CG"><link rel="canonical" href="http://sakupinera.github.io/2022/10/21/computer-graphics/games101/%E6%B8%B2%E6%9F%93%E4%B8%AD%E7%9A%84%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/"><title>GAMES101 - Advanced Topics in Rendering（渲染中的高级主题） - GAMES101 - Computer-Graphics | Hanamai Sora = Sakupinera</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">GAMES101 - Advanced Topics in Rendering（渲染中的高级主题）</h1><div class="meta"><span class="item" title="Created: 2022-10-21 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2022-10-21T00:00:00+08:00">2022-10-21</time> </span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">Symbols count in article</span> <span>8.8k</span> <span class="text">words</span> </span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">Reading time</span> <span>8 mins.</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hanamai Sora</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s2.loli.net/2023/03/08/y7LRpQIrAdzbUek.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/lrzLEXqhHuVUcP2.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/AK1D84aqsYghTOC.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/Qi9cMFjDZq5V3tB.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/psd5JEM2ADHakIt.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/utEsOX73wkq1ycI.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Computer-Graphics/" itemprop="item" rel="index" title="In Computer-Graphics"><span itemprop="name">Computer-Graphics</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Computer-Graphics/GAMES101/" itemprop="item" rel="index" title="In GAMES101"><span itemprop="name">GAMES101</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://sakupinera.github.io/2022/10/21/computer-graphics/games101/%E6%B8%B2%E6%9F%93%E4%B8%AD%E7%9A%84%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Sakupinera"><meta itemprop="description" content=", 保持你的决心！"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakupinera"></span><div class="body md" itemprop="articleBody"><h1 id="advanced-topics-in-rendering渲染中的高级主题"><a class="anchor" href="#advanced-topics-in-rendering渲染中的高级主题">#</a> Advanced Topics in Rendering（渲染中的高级主题）</h1><h2 id="advanced-light-transport"><a class="anchor" href="#advanced-light-transport">#</a> Advanced Light Transport</h2><p><img data-src="image-20221015102020490.png" alt="image-20221015102020490"></p><p>在高级的光线传播里，我们会说到无偏的和有偏的光线传播方法。无偏光线传播里的代表有双向路径追踪（BDPT）以及 Metropolis 光线传播（MLT）。有偏光线传播会提到光子映射（Photon mapping）以及 VCM。我们还会提到实时辐射度算法，相当于把间接光表示成很多很小的光源。我们先来看看什么是无偏和有偏。</p><p><img data-src="image-20221015102039788.png" alt="image-20221015102039788"></p><p>我们做光线追踪，很多方法都用到了蒙特卡洛的估计方法。蒙特卡洛的估计方法有些是无偏的，也就是说蒙特卡洛估计出来的结果如果无论用多少个样本，它的期望永远都是我们要的真实值，那么这个估计方法就是无偏的。相应的其它的情况那么就都是有偏的了，也就是说估计出来的期望和我们最后要的值不一样。在有偏里面有一个特殊情况，就是在一个极限的定义下，如果用的样本的数量足够多，这种情况下得到的期望值会收敛到正确值，我们称这种情况为 consistent。</p><p><img data-src="image-20221015102104065.png" alt="image-20221015102104065"></p><p>我们之前说路径追踪，是利用了光路的可逆性从相机开始的路径追踪，这条路径连接了相机和光源。而对于双向路径追踪，它会生成两个不同的半路径，从光源会打出一些从光源出发的半路径，从摄像机出发也可以生成一系列的半路径，双向路径追踪会把半路径直接的端点给连起来，由此形成一条完整的路径。这个思想是非常简单的，但是实现起来却十分困难。</p><p><img data-src="image-20221015102125072.png" alt="image-20221015102125072"></p><p>双向路径追踪在有些条件下效果非常好，例如在上面场景中，左边是路径追踪，右边是双向路径追踪，而且每个像素都是用的 32 个样本，为什么双向路径追踪比单向路径追踪效果好这么多呢？这是因为如果我们想要找到一条带有大量能量的路径对于这个场景来说不太容易，场景中有一盏光源，这个光源仅仅只朝着上方向打光，也就是说整个场景实际上都是被间接光给照亮的。对于这种情况来说，如果我们做路径追踪从摄像机出发射出光线，打到墙面之后由于是漫反射表面所以很难弹射到光源位置，也就是说，当光线传播在光源这半边比较容易算的时候，那么 BDPT 的效果就会更好，但是它会慢很多。</p><p><img data-src="image-20221015102148513.png" alt="image-20221015102148513"></p><p>Metropolis 光线传播用到了统计学上一个采样的工具，这个工具叫作马尔科夫链，假如当前有一个样本，马尔科夫链可以告诉我们根据当前的样本生成的跟它靠近的下一个样本。它可以做到给定足够的时间的情况下，马克可夫链的蒙特卡罗方法可以生成一系列以任意函数的形状为 PDF 生成的样本。我们之前说过蒙特卡罗方法可以用任意的 PDF 来采样一个函数，但我们并没有说用什么样的 PDF 采样一个函数是最合适的，结论是当我们采样的 PDF 和我们要积分的函数形状一致的时候，这个时候得到的 Variance 是最小的。任何未知的函数都可以通过马尔科夫链的方法生成一系列的样本，使得这些样本的分布它就是和被积函数的形状一致。既然是有一个样本可以变出更多的样本出来，反映到路径追踪就是在已经有一个路径的情况下，可以在它周围产生更多跟它相似的路径，例如在上图中我们已经找到了一条蓝色的光路，现在对这条光路做一些微小的扰动，改变一下各个交点的位置就能形成一条新的路径。我们通过这种在一个 path 周围产生更多新的 path 的方法，最后我们就可以把所有的 path 的都找到，这就是 Metropolis 方法的实现原理。</p><p>注：Metropolis 是人名。</p><p><img data-src="image-20221015102214630.png" alt="image-20221015102214630"></p><p>Metropolis 方法在很多情况下效果都是不错的，它非常适合做困难的光路传播，因为我们只要能找到其中的一条作为种子，那么在它的周围就能不断的找到更多的路径。在上图中左边半开的门，光线只能通过门缝进来，右边是泳池底下波纹的形状，这个现象叫作 Caustics，也就是说光线通过聚焦打在泳池底部，然后被我们看见，其间经过了两次折射，一次漫反射，这种路径我们简写为 SDS（Specular-Diffuse-Specular），路径追踪解这种 Path 非常困难，这是因为当路径打到水底的时候由于 Diffuse 根本不知道光线被反射到哪里去，只有打到很少的一部分才可以在水面和光源连线，形成一条有效的光路。但只要我们能找到一些光路，MLT 可以在周围找到更多的光路，所以它的效果看上去就很好。</p><p><img data-src="image-20221015102236016.png" alt="image-20221015102236016"></p><p>但 MLT 也存在它的问题。Metroplis 方法很难在理论上分析它最后会收敛的速度，如果是用 Path Tracing 大概是能有一个估计的，我们能知道它会以什么样的一个速度进行收敛，简单的蒙特卡洛方法是可以分析 Variance 的，例如如果要提高一倍的 Sample 的数量，是不是能够降低一倍的 Variance，是有这么一系列的关系的。但是 Metroplis 方法很难估计这样的关系，所以我们不知道什么时候能够收敛，或者说什么时候能变得没有噪声。它还有一个问题就是它所有的操作都是局部的，也就是每个像素都自己做自己的，那么有些像素它就收敛的快，有些像素收敛的慢，那么最后我们图像看上去就比较赃，就像是上面这副图我们所看到的情况一样。因为我们根本不知道一张图什么时候收敛，那就更不可能作为渲染动画的方法，因为每帧对应的画面各自有些地方收敛有些地方没收敛，最后看上去动画就抖得非常厉害。</p><p><img data-src="image-20221015102257087.png" alt="image-20221015102257087"></p><p>光子映射是一个有偏的估计。它特别适合用来渲染所谓的 Caustics，它还适合处理 SDS 路径，在上图中我们可以比较直观的看到渲染的结果。</p><p><img data-src="image-20221015102318424.png" alt="image-20221015102318424"></p><p><img data-src="image-20221015102333762.png" alt="image-20221015102333762"></p><p>光子映射可以分为两个步骤进行。其中的一种实现方法是：第一步从光源出发往外辐射光子，光子往各个不同的方向打，如果碰到一些物体该反射的反射，该折射的折射，直到光子打到 Diffuse 的物体上就停下来。这一步做完之后，就把所有光子给整理起来，我们就直到所有光子在哪里。第二步从摄像机开始同样打出一些路径，它们同样该反射的反射，该折射的折射，直到打到 Diffuse 的物体上就停下来。之后我们可以把这两步给合起来做一个计算，我们要做一个局部的密度估计。这个计算建立在一个观察上，一开始我们辐射了一大堆的光子分布在物体表面上，现在又有一大堆从摄像机出发的光线也打在物体表面上了，要想判断物体表面哪些地方应该亮，哪些地方不应该亮，就是光子分布越集中的地方就越亮，光子分布越不集中的地方就越不亮，所以在第二趟打到各种不同的 Diffuse 物体表面的时候就要做局部的密度估计，也就是对任意一个着色点，我们取它周围 N 个最近的光子，这需要把所有的光子组织成一个自上而下的加速结构模式，这样我们可以迅速地定位到一个着色点周围有多少个光子，之后我们还需要计算这 N 个光子所占据的着色点周围的面积，然后计算光子的密度。</p><p><img data-src="image-20221015102355855.png" alt="image-20221015102355855"></p><p>既然要求局部光子的密度，自然就会涉及到 N 取多大的问题。如果用很少的光子数量，自然就会得到很有噪声的一张图，但如果我们找特别多的光子数量，我们法线最后生成的图会变模糊，为什么会这样呢？我们在做局部密度估计的时候，应该算的是当前这个点的密度是多少，也就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>N</mi><mi mathvariant="normal">/</mi><mi>d</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">dN/dA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mord">/</span><span class="mord mathnormal">d</span><span class="mord mathnormal">A</span></span></span></span>，但我们是给了一定的光子数去算它实际的面积，也就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>N</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">Δ</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">\Delta{N}/\Delta{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">N</span></span><span class="mord">/</span><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal">A</span></span></span></span></span>，这两个结果正常来说应该挺接近的，但是它们绝对不相等，也就是说，我们对密度的估计结果并不准确，这也是这个方法是有偏估计的原因。但是假如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">\Delta{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal">A</span></span></span></span></span> 足够小的时候，那么我们的结果就接近正确，也就是说，如果我们能打出更多的光子并且我们不改变 N 的大小，那么这个 N 个光子一定会覆盖一个更小的区域，那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">\Delta{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal">A</span></span></span></span></span> 也就会更接近于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">dA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">A</span></span></span></span>。这些说明，当我们有无限多的光子的情况下，我们这么做就能得到一个正确的结果，这也就是我们为什么又说它是一个 consistent（一致的）方法。但是只要我们光子打出的不是无限多，那么结果多少都会有点糊，所有这个方法是有偏的但是一致的方法。</p><p><img data-src="image-20221015102413796.png" alt="image-20221015102413796"></p><p>到这里我们已经可以很好的理解有偏和无偏，只要我们得到的结果有任何一点模糊，那么就是有偏的，而一致指的是在样本无限多的情况下，就能让结果收敛到正确的结果。我们之前是找一个着色点周围 N 个光子求面积，那能不能固定一个面积数里面有多少个光子来求密度呢？但是这样做的话，我们最后得到的结果一定是有偏的并且不一致的，这是因为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">\Delta{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal">A</span></span></span></span></span> 永远都不可能和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">dA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">A</span></span></span></span> 相同。</p><p><img data-src="image-20221015102436898.png" alt="image-20221015102436898"></p><p>VCM 把双向的路径追踪和光子映射结合了起来。也就是在我们做 BDPT 的过程中，如果有的 path 满足这样一种性质，例如在上图中，左边红色的 path 和右边绿色的 path 它们最后的端点非常接近（在同一个局部的面上），这个时候就认为其中一半过来的就类似于光子，这个时候再用光子映射把这部分的光路它们两个 Sub-path 的贡献给结合在一起。</p><p><img data-src="image-20221015102455149.png" alt="image-20221015102455149"></p><p>还有一种跟之前的完全不一样的方法，叫作实时辐射度算法（Instant Radiosity），有时也被称之为 many-light 方法。我们之前分析光线传播的时候，提到过并不区分光线是反射来的还是自己发出来的，它们都是 Radiance，实时辐射度算法就用到了这种思想。已经被照亮的面，我们都可以认为它们是光源，然后用它们来照亮别人。一开始会先从光源打出很多 light sub-paths，这些路径会停在某些地方，我们认为停住的那些地方就成为了新的光源，它们成为了新的光源之后，当我们再去看一个着色点的时候就用所有这些新的光源去照亮这个着色点，这样的话就相当于我们考虑了光源弹射两次的情况。总结起来就是，首先生成一系列的 VPL（Virtual Point Light），然后在摄像机看向这个场景的时候用这些 VPL 去照亮着色点。</p><p><img data-src="image-20221015102518739.png" alt="image-20221015102518739"></p><p>这个方法的有点就是非常快，就单说 many-light rendering，也是平时研究很活跃的一个话题。但它也存在一些问题，例如在右边的这个用 VPL 渲染的场景中，我们发现有些地方会莫名其妙的发光，特别是在一些窄的缝隙会弧线问题，这个和我们之前推出的距离平方项有关系，我们在推 Light Sampling 的时候把对立体角的采样改成了对面积的采样，如果光源和着色点之间的距离极近，那么就相当于除以了一个接近零的数，所以得到的结果会非常大。还有一点需要注意的就是，VPL 不能处理 Glossy 材质的物体。</p><h2 id="advanced-appearance-modeling"><a class="anchor" href="#advanced-appearance-modeling">#</a> Advanced Appearance Modeling</h2><p><img data-src="image-20221015102549911.png" alt="image-20221015102549911"></p><p>我们接下来来说一下更高级的外观建模，我们之前说过外观就是材质，材质就是 BRDF（对于表面模型来说）。我们接下来会提到一些非表面的模型，例如散射介质（参与介质）、毛发、颗粒状物体等等。表面模型里面也有些复杂一些的，例如半透明材质、布料、细节比较多的模型等等。最后我们还会提到一些程序化生成的模型。</p><h2 id="non-surface-models"><a class="anchor" href="#non-surface-models">#</a> Non-Surface Models</h2><p><img data-src="image-20221015102611686.png" alt="image-20221015102611686"></p><p><img data-src="image-20221015102628995.png" alt="image-20221015102628995"></p><p><img data-src="image-20221015102655537.png" alt="image-20221015102655537"></p><p>当一根光线在行进的过程中，如果穿进了一个参与介质，这里我们假设有一根光线穿进了云层，那么会有若干事情发生。第一，如果云中间有光源那么它会发光，我们先不考虑这种情况；第二，如果光线行进的过程中打到了云里的小晶体，它会把这条光线随机的打到其他方向上去；第三，光线在传播过程很有可能会接收到从其他方向散射过来的光；第四，传播过程中有些能量可能逐渐就被吸收了，可以想象一下乌云。总结起来就是，光线在传播过程中会发生两样事情，要么被吸收，要么被反射。</p><p><img data-src="image-20221015102726123.png" alt="image-20221015102726123"></p><p>那么光线是怎么散射的呢？是不是说光线会被均匀的散射到不同的方向上去呢？我们类比一下物体表面的散射，只有当物体表面是 Diffuse 材质的时候才认为光线是均匀的散射到各个方向上去，同样的道理对于参与介质也是一样，在任何一个点都会往各个方向散射，怎么散射由一个函数来定义，这个函数叫作相位函数（Phase Function），相位函数决定了是均匀的往各个方向散射，还是主要往一个特定的方向散射。也就是说我们在规定不同散射的方法，这就很像 BRDF，BRDF 决定光线如何反射，而 Phase Function 是在决定光线应该如何散射。</p><p><img data-src="image-20221015102740795.png" alt="image-20221015102740795"></p><p>那么我们该如何渲染参与介质呢？假设我们现在已经在参与介质中的某个地方，光线往某一方向走，能走多远说明了介质的吸收能力有多强，停下来的时候就要重新考虑要把光线往某个方向散射，直到找到一条 path，之后光源和各个弹射的地方相连计算整个路径的贡献。中间有很多数学的计算，我们这里不再考虑渲染方程，因为渲染方程告诉我们的是光线如何与物体表面作用，而没有说怎么和体积作用。</p><p><img data-src="image-20221015102753428.png" alt="image-20221015102753428"></p><p><img data-src="image-20221015102810455.png" alt="image-20221015102810455"></p><p><img data-src="image-20221015102822725.png" alt="image-20221015102822725"></p><p><img data-src="image-20221015102841523.png" alt="image-20221015102841523"></p><p>另外还有一些材质也是不定义在物体表面上，例如头发。头发是一根一根的，所以要想描述头发的光学属性，我们就要考虑光线和这种圆柱形成的曲线去作用，而不再是和一个面去作用。通过上面这张图，我们发现人的头发会形成两种不同类型的高光，一种是无色的高光，另外一种是有色的高光。</p><p><img data-src="image-20221015102856232.png" alt="image-20221015102856232"></p><p>从一开始有人研究头发开始，人们就广泛的采用一个简单的模型，也就是 Kajiya-Kay Model。有一根光线打到圆柱上，光线打到圆柱上会往四面八方散射，对于头发来说我们可以把它考虑成会产生漏斗形的散射，同时也会有一些光被散射到四面八方去，这就好像是 Diffuse+Specular 一样，和之前我们求表面很像。</p><p><img data-src="image-20221015102910937.png" alt="image-20221015102910937"></p><p>用上面的方法我们会得到上面这种头发材质，但是效果看上去不怎么好。</p><p><img data-src="image-20221015102937860.png" alt="image-20221015102937860"></p><p>一个被广泛应用的模型叫作 Marschner Model。当光线打到一根圆柱的时候，会存在一部分能量被反射掉（R），也有一部分能量折射会穿进去然后再穿出去（TT），还有一种是光线进入到头发里面，在头发的内壁上发生反射再往回走穿出去（TRT），通过这种方式就能定义各种不同的光线传播。我们之前说过，描述一个材质就是描述它应该和光线如何作用。</p><p><img data-src="image-20221015103000250.png" alt="image-20221015103000250"></p><p>Marschner Model 把头发当成是一个玻璃的圆柱，并且把外层称为 cuticle，内层称为 cortex，并且头发内部有色素，如果有光线穿进头发，在传播过程中会被部分吸收，然后再穿出去。Marschner Model 考虑了我们之前说的三种光线和圆柱的作用，也就是 R、TT、TRT。</p><p><img data-src="image-20221015103024963.png" alt="image-20221015103024963"></p><p>把这些综合考虑在一块儿，就能得到非常好的头发渲染效果。但我们上面定义的只是光线如何和一根头发进行作用，如果要考虑光线和多根头发作用，那么就要考虑光线打到一根头发出来之后又会打到第二根头发，以此类推，直到从无数根头发里面弹射出光线到我们的眼中。</p><p><img data-src="image-20221015103044443.png" alt="image-20221015103044443"></p><p><img data-src="image-20221015103100208.png" alt="image-20221015103100208"></p><p><img data-src="image-20221015103128140.png" alt="image-20221015103128140"></p><p>那么人的头发能不能用来描述动物的毛发呢？通过上面的图，我们发现如果把人的头发的模型应用到动物身上，会发现不对，右边的图才是我们想要的结果。这也说明，人的头发的模型不足以描述光线如何与动物毛发作用。</p><p><img data-src="image-20221015103153485.png" alt="image-20221015103153485"></p><p>那这到底是怎么回事呢？我们可以先看看它们在生物上的结构，如果我们研究人和动物毛发我们会发现一些共同点。我们把毛发沿径向切开，其中最外面的表皮叫作 Cuticle，里面是 Cortex，最内层的髓质叫作 Medulla。髓质内部的结构非常复杂，光线进入之后会像是进入了散射介质一样被散射到四面八方上去。人和动物都有上面提到的三种结构，但是对于动物来说最内层的髓质却大的可怕，也就是光线进去之后更容易的会发生散射，这就是我们之前的模型没能描述的一个东西。</p><p><img data-src="image-20221015103209625.png" alt="image-20221015103209625"></p><p><img data-src="image-20221015103236989.png" alt="image-20221015103236989"></p><p><img data-src="image-20221015103309750.png" alt="image-20221015103309750"></p><p>所以就有人提出了 Double Cylinder Model（双层圆柱模型），双层圆柱模型把髓质这一层给精准的描述了出来。</p><p><img data-src="image-20221015103334689.png" alt="image-20221015103334689"></p><p>双层圆柱模型增加了两种光线在穿过髓质的时候会发散到各个方向上去的情况，分别是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><msup><mi>T</mi><mi>s</mi></msup></mrow><annotation encoding="application/x-tex">TT^s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.664392em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span></span></span></span> 和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>R</mi><msup><mi>T</mi><mi>s</mi></msup></mrow><annotation encoding="application/x-tex">TRT^s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="mord mathnormal" style="margin-right:.00773em">R</span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.664392em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span></span></span></span>。</p><p><img data-src="image-20221015103356190.png" alt="image-20221015103356190"></p><p>于是我们便可以用五个不同的分量来模拟动物毛发的材质效果。PS：闫老师发明的。</p><p><img data-src="image-20221015103427282.png" alt="image-20221015103427282"></p><p><img data-src="image-20221015103520083.png" alt="image-20221015103520083"></p><p><img data-src="image-20221015103538058.png" alt="image-20221015103538058"></p><p><img data-src="image-20221015103557296.png" alt="image-20221015103557296"></p><p>其他还有一类材质被称之为颗粒材质，例如沙子、盐、糖等等。</p><p><img data-src="image-20221015103625631.png" alt="image-20221015103625631"></p><p>当一堆这种颗粒状的物体在一起的时候就会很麻烦，所以人们就想出了一些简化的方法，例如计算每一个单元上各种颗粒成分的占比，但是生成一张布满颗粒的图花费的时间是相当多的，到现在颗粒材质也没有得到非常好的解决。</p><p><img data-src="image-20221015103644039.png" alt="image-20221015103644039"></p><p><img data-src="image-20221015103715105.png" alt="image-20221015103715105"></p><h2 id="surface-models"><a class="anchor" href="#surface-models">#</a> Surface Models</h2><p><img data-src="image-20221015103740542.png" alt="image-20221015103740542"></p><p><img data-src="image-20221015103754728.png" alt="image-20221015103754728"></p><p>前面提到了非表面的一些模型，接下来我们再来说说表面的一些模型，例如 Translucent 材质。其中玉石就是一个典型的代表，光线在穿过透明介质过程中，不仅涉及到吸收，还涉及到散射。这说明光线可以从某一个地方进入这个表面，并且从另一个地方出这个表面。</p><p><img data-src="image-20221015103822679.png" alt="image-20221015103822679"></p><p>反映在物理上就是，光线从一个点进入了某个表面，在物体内部进行了大量的散射，最后再从另一个点钻出去。为了描述光线这样一种散射方式，我们定义了次表面散射（Subsurface Scattering）。</p><p><img data-src="image-20221015103838634.png" alt="image-20221015103838634"></p><p>BSSRDF 可以理解成对 BRDF 的延伸，我们平常说的 BRDF 是光线打到一个点之后又从这个点出来，但是在 BSSRDF 上，我们就可以理解成光线从一个点进来可以从任意一个其他的地方出去。因此此表面散射对应的 BSSRDF 就是定义了光线从哪个点进来、从哪个方向进来、从哪个点出去、从哪个方向出去。那么相应的渲染方程也要改写，也就是原本对于各个方向积分，现在考虑一个着色点，由于它的次表面性质，也就说明其他着色点也是有可能贡献到这个着色点的，并且沿着一个方向去的，也就是说我们不能只考虑从各个方向上进来的光，还得考虑从各个方向进到其他着色点的光，所以我们不仅要对方向进行积分，也要对面积进行积分。</p><p><img data-src="image-20221015103901481.png" alt="image-20221015103901481"></p><p>人们发现 Translucent 材质看上去就是，当一根光线打在这个物体上，就好像这个物体的地下出现了一个光源从底下照亮这个着色点周围的一片，为了物理上的真实，大家发现这一个光源还不够，还得在上方再对应一个光源，所以相当于是有两个光源，用这两个光源去照亮着色点周围这一块儿，就很像次表面散射得出来的结果，这个方法叫作 Dipole Approximation。</p><p><img data-src="image-20221015103915841.png" alt="image-20221015103915841"></p><p><img data-src="image-20221015103927829.png" alt="image-20221015103927829"></p><p><img data-src="image-20221015103944270.png" alt="image-20221015103944270"></p><p><img data-src="image-20221015104000545.png" alt="image-20221015104000545"></p><p><img data-src="image-20221015104024137.png" alt="image-20221015104024137"></p><p><img data-src="image-20221015104043849.png" alt="image-20221015104043849"></p><p>说完次表面散射，我们再来说另外一个也是和表面相关的材质，也就是布料。为了理解布料，首先我们要清楚它的制作原理，布料是一系列缠绕的纤维构成的，但是它的缠绕有几个不同的层级。不同的纤维首先缠绕成股，不同的股再经过缠绕形成线，然后再用线给织成布料。</p><p><img data-src="image-20221015104058253.png" alt="image-20221015104058253"></p><p>对于布来说，既然是缠绕而成的，那么要算它的表面模型就非常头疼，因为它一定会和纺织的方向有关，或者说和织法有关。通过各种各样编织的方案，我们就能知道它最后看上去是什么样子，也就得到了一个 BRDF 的模型。</p><p><img data-src="image-20221015104114603.png" alt="image-20221015104114603"></p><p>当然这里用 BRDF 模型肯定有些问题，如果这个布本身真的是在一个表面上，那么我们把它当作一个平面没有问题，但是像天鹅绒这种材质，它本身就不是一个平面，那么用 BRDF 来表示就不合理。</p><p><img data-src="image-20221015104126201.png" alt="image-20221015104126201"></p><p>一个更准确的做法，是把织物当做是在空间中分布的体积，然后把空间中分布的体积划分成超级细小的格子，每一个格子里面大概知道它纤维的朝向分布之类的信息，之后我们就能把这些性质转换成光线的吸收和散射，这就像是在渲染云一样，我们不再把布料当作面而是一个体积，但是相应的计算量也会急剧上升。</p><p><img data-src="image-20221015104141652.png" alt="image-20221015104141652"></p><p>还有一种做法是，因为布料本身就是纤维，并且我们知道这些纤维是怎么缠绕的，那么一个最暴力的做法就是把每一根纤维给渲染出来，也就是把它当成人的头发一样进行渲染，得到的结果自然看起来会很真实，但是同样计算量也是非常非常惊人的。</p><p><img data-src="image-20221015104154405.png" alt="image-20221015104154405"></p><p><img data-src="image-20221015104207342.png" alt="image-20221015104207342"></p><p><img data-src="image-20221015104231369.png" alt="image-20221015104231369"></p><p><img data-src="image-20221015104256547.png" alt="image-20221015104256547"></p><p>现实生活中，一束光打在车子上，我们会明显的看到车上会有划痕，包括鼠标上的高光也是由很多小的凸起形成的高光，而不是一个光滑的表面形成的。也就是说，真实世界中很多东西都是不完美的，但是我们的描述方法却会得到一些很完美的东西。</p><p><img data-src="image-20221015104313730.png" alt="image-20221015104313730"></p><p><img data-src="image-20221015104327522.png" alt="image-20221015104327522"></p><p><img data-src="image-20221015104347291.png" alt="image-20221015104347291"></p><p><img data-src="image-20221015104501822.png" alt="image-20221015104501822"></p><p><img data-src="image-20221015104750805.png" alt="image-20221015104750805"></p><p>我们之前讲过微表面模型最重要的是这些微表面的法线分布，但实际上大家描述这个分布用到的是一些非常简单的模型，例如正态分布，但如果我们用这种分布去描述法线的分布，得到的自然是一些看上去并没有什么细节的结果，但是实际上我们想要看到的是法线的分布基本满足统计的规律，但它又带有自己的细节，如果我们能把这些考虑进去，那么自然而然就能得到好一点的结果。</p><p><img data-src="image-20221015104809224.png" alt="image-20221015104809224"></p><p><img data-src="image-20221015104829393.png" alt="image-20221015104829393"></p><p><img data-src="image-20221015104848416.png" alt="image-20221015104848416"></p><p><img data-src="image-20221015104911510.png" alt="image-20221015104911510"></p><p>虽然我们可以定义各种各样的细节，但是渲染出它们却非常困难，例如上面这个蜗牛渲染出来大概会花费一个月的时间。</p><p><img data-src="image-20221015104927602.png" alt="image-20221015104927602"></p><p>之所以渲染很困难，根本原因在于我们认为每一个小的微表面是一个镜面，那么从摄像机打一根光线过去，打到任意一个表面都能知道它的法线，那么就知道镜面反射的方向是什么，因此很难通过反射的方式让反射的光线打到光源上去，同理从光源打过来也是一样。</p><p><img data-src="image-20221015104948396.png" alt="image-20221015104948396"></p><p>所以这里会考虑一个像素会覆盖很多的微表面，如果我们能够能够把这些微表面的法线分布算出来，那么就能替代原本光滑的分布，并且用在微表面的模型里。</p><p><img data-src="image-20221015105003352.png" alt="image-20221015105003352"></p><p>如果我们考虑一个像素覆盖了多大的范围，那么就能得到各种各样神奇的法线分布（NDF）。如果一个像素覆盖了非常多的微表面，那么这些微表面自然而言就会显示出一些统计学的规律。如果覆盖的范围比较小，那么它就会显示出一些很独特的性质。</p><p><img data-src="image-20221015105018594.png" alt="image-20221015105018594"></p><p>并且不同类型的法线贴图会引起不同的法线分布。</p><p><img data-src="image-20221015105032921.png" alt="image-20221015105032921"></p><p><img data-src="image-20221015105115185.png" alt="image-20221015105115185"></p><p><img data-src="image-20221015105133366.png" alt="image-20221015105133366"></p><p><img data-src="image-20221015105157368.png" alt="image-20221015105157368"></p><p><img data-src="image-20221015105219786.png" alt="image-20221015105219786"></p><p>当我们引入这些细节之后，如果还是在用几何光学来解释就不对，当物体非常小的时候，小到和光线的波长相当的时候，我们就不能假设光线的传播是沿着直线传播，而是需要假设这个光线是一个波，因为会涉及到衍射、干涉之类的现象发生。这些现象在这种微型的细节上就会发生。</p><p><img data-src="image-20221015105241021.png" alt="image-20221015105241021"></p><p><img data-src="image-20221015105258792.png" alt="image-20221015105258792"></p><p><img data-src="image-20221015105317934.png" alt="image-20221015105317934"></p><p>波动光学得到的 BRDF 和几何光学得到的 BRDF 挺像的，但是又有自己的特点，也就是不连续的特点，这是由于光会发生干涉，干涉会引起有些地方加强有些地方减弱，就会形成这种不连续的效果。</p><p><img data-src="image-20221015105338681.png" alt="image-20221015105338681"></p><p><img data-src="image-20221015105402461.png" alt="image-20221015105402461"></p><p><img data-src="image-20221015105419429.png" alt="image-20221015105419429"></p><p><img data-src="image-20221015105433598.png" alt="image-20221015105433598"></p><h2 id="procedural-appearance"><a class="anchor" href="#procedural-appearance">#</a> Procedural Appearance</h2><p><img data-src="image-20221015105503138.png" alt="image-20221015105503138"></p><p>最后一个话题有关于程序化生成的外观，程序化生成指的是用一定的方式来指导它的生成，而不需要真正地去生成它，可以动态的去查询它。例如这个花瓶刷碎了，我们可以看到花瓶内部的花纹到底是什么样子的，也就是可以定义一个三维的纹理，但是存储量在三维的情况下瞬间就会上去，所以我们不存储这个三维的纹理，而是什么时候要用，什么时候去查，就好像我们有一个空间中的函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x,y,x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.03588em">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>，然后给定任意的 xyz，立刻能得到一个值就行。</p><p><img data-src="image-20221015105524755.png" alt="image-20221015105524755"></p><p>这种函数有一个特定的名字，叫作噪声函数。这些函数允许我们得到一些很神奇的 noise，由于它们定义在空间中，所以即使上面的花瓶摔碎，我们也能看到它的切面长什么样。之所以叫 Procedural，实际上就是随用随取的意思。</p><p><img data-src="image-20221015105756080.png" alt="image-20221015105756080"></p><p>像游戏中车子上的锈，我们就能靠生成一系列的噪声，如果这些噪声我们认为是在 [0,1] 的范围，我们可以对它做二值化以及各种后期的处理，只要处理得当，我们就能得到任意不同的效果。</p><p><img data-src="image-20221015105820351.png" alt="image-20221015105820351"></p><p><img data-src="image-20221015105833004.png" alt="image-20221015105833004"></p><p><img data-src="image-20221015105854036.png" alt="image-20221015105854036"></p><p><img data-src="image-20221015105925085.png" alt="image-20221015105925085"></p><div class="tags"><a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 学习笔记</a> <a href="/tags/CG/" rel="tag"><i class="ic i-tag"></i> CG</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2022-10-21 11:34:45" itemprop="dateModified" datetime="2022-10-21T11:34:45+08:00">2022-10-21</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Sakupinera WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Sakupinera Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Sakupinera PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Sakupinera <i class="ic i-at"><em>@</em></i>Sakupinera</li><li class="link"><strong>Post link: </strong><a href="http://sakupinera.github.io/2022/10/21/computer-graphics/games101/%E6%B8%B2%E6%9F%93%E4%B8%AD%E7%9A%84%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/" title="GAMES101 - Advanced Topics in Rendering（渲染中的高级主题）">http://sakupinera.github.io/2022/10/21/computer-graphics/games101/渲染中的高级主题/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/10/21/csharp/clr-via-csharp/Chapter%206%20Type%20and%20Member%20Basics/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;03&#x2F;08&#x2F;dhkXYZz7ENHoCeL.png" title="CLR via C# - Chapter 6 Type and Member Basics"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 6 Type and Member Basics</h3></a></div><div class="item right"><a href="/2022/10/24/csharp/clr-via-csharp/Chapter%207%20Constants%20and%20Fields/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;03&#x2F;08&#x2F;2TxzVwj8obvGftU.jpg" title="CLR via C# - Chapter 7 Constants and Fields"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 7 Constants and Fields</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#advanced-topics-in-rendering%E6%B8%B2%E6%9F%93%E4%B8%AD%E7%9A%84%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">Advanced Topics in Rendering（渲染中的高级主题）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#advanced-light-transport"><span class="toc-number">1.1.</span> <span class="toc-text">Advanced Light Transport</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#advanced-appearance-modeling"><span class="toc-number">1.2.</span> <span class="toc-text">Advanced Appearance Modeling</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#non-surface-models"><span class="toc-number">1.3.</span> <span class="toc-text">Non-Surface Models</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#surface-models"><span class="toc-number">1.4.</span> <span class="toc-text">Surface Models</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#procedural-appearance"><span class="toc-number">1.5.</span> <span class="toc-text">Procedural Appearance</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"><ul><li><a href="/2022/09/06/computer-graphics/games101/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%A6%82%E8%BF%B0/" rel="bookmark" title="GAMES101 - 计算机图形学概述">GAMES101 - 计算机图形学概述</a></li><li><a href="/2022/09/06/computer-graphics/games101/%E5%90%91%E9%87%8F%E5%92%8C%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" rel="bookmark" title="GAMES101 - 向量和线性代数">GAMES101 - 向量和线性代数</a></li><li><a href="/2022/09/18/computer-graphics/games101/%E5%8F%98%E6%8D%A2/" rel="bookmark" title="GAMES101 - Transformation（变换）">GAMES101 - Transformation（变换）</a></li><li><a href="/2022/09/22/computer-graphics/games101/%E5%85%89%E6%A0%85%E5%8C%96/" rel="bookmark" title="GAMES101 - Rasterization（光栅化）">GAMES101 - Rasterization（光栅化）</a></li><li><a href="/2022/09/30/computer-graphics/games101/%E7%9D%80%E8%89%B2/" rel="bookmark" title="GAMES101 - Shading（着色）">GAMES101 - Shading（着色）</a></li><li><a href="/2022/10/03/computer-graphics/games101/%E5%87%A0%E4%BD%95/" rel="bookmark" title="GAMES101 - Geometry（几何）">GAMES101 - Geometry（几何）</a></li><li><a href="/2022/10/09/computer-graphics/games101/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/" rel="bookmark" title="GAMES101 - Ray Tracing（光线追踪）">GAMES101 - Ray Tracing（光线追踪）</a></li><li><a href="/2022/10/14/computer-graphics/games101/%E6%9D%90%E8%B4%A8%E4%B8%8E%E5%A4%96%E8%A7%82/" rel="bookmark" title="GAMES101 - Materials and Appearances（材质与外观）">GAMES101 - Materials and Appearances（材质与外观）</a></li><li class="active"><a href="/2022/10/21/computer-graphics/games101/%E6%B8%B2%E6%9F%93%E4%B8%AD%E7%9A%84%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/" rel="bookmark" title="GAMES101 - Advanced Topics in Rendering（渲染中的高级主题）">GAMES101 - Advanced Topics in Rendering（渲染中的高级主题）</a></li><li><a href="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/" rel="bookmark" title="GAMES101 - Cameras, Lenses and Light Fields（相机，透镜和光场）">GAMES101 - Cameras, Lenses and Light Fields（相机，透镜和光场）</a></li><li><a href="/2023/08/20/computer-graphics/games101/%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/" rel="bookmark" title="GAMES101 - Color and Perception（颜色与感知）">GAMES101 - Color and Perception（颜色与感知）</a></li></ul></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sakupinera" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Sakupinera</p><div class="description" itemprop="description">保持你的决心！</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">86</span> <span class="name">posts</span></a></div><div class="item categories"><a href="/categories/"><span class="count">13</span> <span class="name">categories</span></a></div><div class="item tags"><a href="/tags/"><span class="count">6</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nha3VwaW5lcmE=" title="https:&#x2F;&#x2F;github.com&#x2F;sakupinera"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9zYWt1cGluZXJh" title="https:&#x2F;&#x2F;twitter.com&#x2F;sakupinera"><i class="ic i-twitter"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQwNzIyOTA3MQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;407229071"><i class="ic i-cloud-music"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMjIzMDczOTg/c3BtX2lkX2Zyb209MzMzLjEwMDcuMC4w" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;22307398?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li><li class="item"><a href="/games/" rel="section"><i class="ic i-flag"></i>Games</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-person"></i>About</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/10/21/csharp/clr-via-csharp/Chapter%206%20Type%20and%20Member%20Basics/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/10/24/csharp/clr-via-csharp/Chapter%207%20Constants%20and%20Fields/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2023/02/09/csharp/clr-via-csharp/Chapter%2029%20Primitive%20Thread%20Synchronization%20Constructs/" title="CLR via C# - Chapter 29 Primitive Thread Synchronization">CLR via C# - Chapter 29 Primitive Thread Synchronization</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2022/12/13/cpp/cpp-primer/Chapter%205%20Statements/" title="C++ Primer - Chapter 5 Statements">C++ Primer - Chapter 5 Statements</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2023/01/07/cpp/cpp-primer/Chapter%2015%20Object-Oriented%20Programming/" title="C++ Primer - Chapter 15 Object-Oriented Programming">C++ Primer - Chapter 15 Object-Oriented Programming</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" title="CLR via C# - Chapter 12 Generics">CLR via C# - Chapter 12 Generics</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/" title="CLR via C# - Chapter 20 Exceptions and State Management">CLR via C# - Chapter 20 Exceptions and State Management</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/08/28/hello-world/" title="Hello World">Hello World</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2022/12/16/cpp/cpp-primer/Chapter%208%20The%20IO%20Library/" title="C++ Primer - Chapter 8 The IO Library">C++ Primer - Chapter 8 The IO Library</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2023/08/20/computer-graphics/games101/%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/" title="GAMES101 - Color and Perception（颜色与感知）">GAMES101 - Color and Perception（颜色与感知）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/09/05/linux/learn-linux/%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/" title="LearnLinux - 备份与恢复">LearnLinux - 备份与恢复</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/08/28/linux/learn-linux/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/" title="LearnLinux - 权限管理">LearnLinux - 权限管理</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Sakupinera @ Hanamai Sora</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="Symbols count total">2.2m words</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="Reading time total">33:30</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/10/21/computer-graphics/games101/渲染中的高级主题/",favicon:{show:"（●´3｀●）Goooood",hide:"(´Д｀)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/shifuku.model.json"},display:{position:"left",width:250,height:500},mobile:{show:!1},react:{opacity:.9},log:!1})</script></body></html>