<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sakupinera" href="http://sakupinera.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sakupinera" href="http://sakupinera.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sakupinera" href="http://sakupinera.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="è¯»ä¹¦ç¬”è®°,C#"><link rel="canonical" href="http://sakupinera.github.io/2022/10/21/csharp/clr-via-csharp/Chapter%206%20Type%20and%20Member%20Basics/"><title>CLR via C# - Chapter 6 Type and Member Basics - CLR-via-CSharp - CSharp | Hanamai Sora = Sakupinera</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">CLR via C# - Chapter 6 Type and Member Basics</h1><div class="meta"><span class="item" title="Created: 2022-10-21 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2022-10-21T00:00:00+08:00">2022-10-21</time> </span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">Symbols count in article</span> <span>48k</span> <span class="text">words</span> </span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">Reading time</span> <span>44 mins.</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hanamai Sora</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipet4bz0yj20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giciszlczyj20zk0m816d.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gicitf0kl1j20zk0m87fe.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipeuv80yoj20zk0m8kjl.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipevuctzzj20zk0m84qp.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gicis3attqj20zk0m8k7l.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/" itemprop="item" rel="index" title="In CSharp"><span itemprop="name">CSharp</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/CLR-via-CSharp/" itemprop="item" rel="index" title="In CLR-via-CSharp"><span itemprop="name">CLR-via-CSharp</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://sakupinera.github.io/2022/10/21/csharp/clr-via-csharp/Chapter%206%20Type%20and%20Member%20Basics/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Sakupinera"><meta itemprop="description" content=", ä¿æŒä½ çš„å†³å¿ƒï¼"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakupinera"></span><div class="body md" itemprop="articleBody"><h1 id="chapter-6-type-and-member-basics"><a class="anchor" href="#chapter-6-type-and-member-basics">#</a> Chapter 6 Type and Member Basics</h1><h2 id="the-different-kinds-of-type-members"><a class="anchor" href="#the-different-kinds-of-type-members">#</a> The Different Kinds of Type Members</h2><blockquote><p>A type can define zero or more of the following kinds of members:</p><ul><li><p>Constants A constant is a symbol that identifies a never-changing data value. These symbols are typically used to make code more readable and maintainable. Constants are always associated with a type, not an instance of a type. Logically, constants are always static members. Discussed in Chapter 7, â€œConstants and Fields.â€</p></li><li><p>Fields A field represents a read-only or read/write data value. A field can be static, in which case the field is considered part of the typeâ€™s state. A field can also be instance (nonstatic), in which case itâ€™s considered part of an objectâ€™s state. I strongly encourage you to make fields private so that the state of the type or object canâ€™t be corrupted by code outside of the defining type. Discussed in Chapter 7.</p></li><li><p>Instance constructors An instance constructor is a special method used to initialize a new objectâ€™s instance fields to a good initial state. Discussed in Chapter 8, â€œMethods.â€</p></li><li><p>Type constructors A type constructor is a special method used to initialize a typeâ€™s static fields to a good initial state. Discussed in Chapter 8.</p></li><li><p>Methods A method is a function that performs operations that change or query the state of a type (static method) or an object (instance method). Methods typically read and write to the fields of the type or object. Discussed in Chapter 8.</p></li><li><p>Operator overloads An operator overload is a method that defines how an object should be manipulated when certain operators are applied to the object. Because not all programming languages support operator overloading, operator overload methods are not part of the Common Language Specification (CLS). Discussed in Chapter 8.</p></li><li><p>Conversion operators A conversion operator is a method that defines how to implicitly or explicitly cast or convert an object from one type to another type. As with operator overload methods, not all programming languages support conversion operators, so theyâ€™re not part of the CLS. Discussed in Chapter 8.</p></li><li><p>Properties A property is a mechanism that allows a simple, field-like syntax for setting or querying part of the logical state of a type (static property) or object (instance property) while ensuring that the state doesnâ€™t become corrupt. Properties can be parameterless (very common) or parameterful (fairly uncommon but used frequently with collection classes). Discussed in Chapter 10, â€œProperties.â€</p></li><li><p>Events A static event is a mechanism that allows a type to send a notification to one or more static or instance methods. An instance (nonstatic) event is a mechanism that allows an object to send a notification to one or more static or instance methods. Events are usually raised in response to a state change occurring in the type or object offering the event. An event consists of two methods that allow static or instance methods to register and unregister interest in the event. In addition to the two methods, events typically use a delegate field to maintain the set of registered methods. Discussed in Chapter 11, â€œEvents.â€</p></li><li><p>Types A type can define other types nested within it. This approach is typically used to break a large, complex type down into smaller building blocks to simplify the implementation.</p></li></ul></blockquote><blockquote><p>Again, the purpose of this chapter isnâ€™t to describe these various members in detail but to set the stage and explain what these various members all have in common.</p></blockquote><blockquote><p>Regardless of the programming language youâ€™re using, the corresponding compiler must process your source code and produce metadata and Intermediate Language (IL) code for each kind of member in the preceding list. The format of the metadata is identical regardless of the source programming language you use, and this feature is what makes the CLR a common language run time. The metadata is the common information that all languages produce and consume, enabling code in one programming language to seamlessly access code written in a completely different programming language.</p></blockquote><blockquote><p>This common metadata format is also used by the CLR, which determines how constants, fields, constructors, methods, properties, and events all behave at run time. Simply stated, metadata is the key to the whole Microsoft .NET Framework development platform; it enables the seamless integration of languages, types, and objects.</p></blockquote><blockquote><p>The following C# code shows a type definition that contains an example of all the possible members. The code shown here will compile (with warnings), but it isnâ€™t representative of a type that youâ€™d normally create; most of the methods do nothing of any real value. Right now, I just want to show you how the compiler translates this type and its members into metadata. Once again, Iâ€™ll discuss the individual members in the next few chapters.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 1 </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// Nested class </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">SomeNestedType</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// 2 </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// Constant, read-only, and static read/write field</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">const</span> <span class="token class-name">Int32</span>  c_SomeConstant <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 3 </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">String</span> m_SomeReadOnlyField <span class="token operator">=</span> <span class="token string">"2"</span><span class="token punctuation">;</span> <span class="token comment">// 4 </span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Int32</span>  s_SomeReadWriteField <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// 5 </span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// Type constructor </span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">static</span> <span class="token function">SomeType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// 6 </span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// Instance constructors </span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">public</span> <span class="token function">SomeType</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// 7</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">public</span> <span class="token function">SomeType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// 8</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token comment">// Instance and static methods </span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token keyword">private</span> <span class="token return-type class-name">String</span> <span class="token function">InstanceMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// 9</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// 10</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token comment">// Instance property </span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> SomeProp <span class="token punctuation">&#123;</span> <span class="token comment">// 11 </span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// 12 </span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token keyword">set</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// 13 </span></pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token comment">// Instance parameterful property (indexer)</span></pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token keyword">this</span><span class="token punctuation">[</span><span class="token class-name">String</span> s<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 14 </span></pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// 15 </span></pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token keyword">set</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// 16 </span></pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="27"></td><td><pre> <span class="token comment">// Instance event </span></pre></td></tr><tr><td data-num="28"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">event</span> <span class="token class-name">EventHandler</span> SomeEvent<span class="token punctuation">;</span> <span class="token comment">// 17 </span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>If you were to compile the type just defined and examine the metadata in ILDasm.exe, youâ€™d see the output shown in Figure 6-1.</p></blockquote><p><img data-src="/2022/10/21/csharp/clr-via-csharp/Chapter%206%20Type%20and%20Member%20Basics/image-20221016165335955.png" alt="image-20221016165335955"></p><blockquote><p>Notice that all the members defined in the source code cause the compiler to emit some metadata. In fact, some of the members cause the compiler to generate additional members as well as additional metadata. For example, the event member (17) causes the compiler to emit a field, two methods, and some additional metadata. I donâ€™t expect you to fully understand what youâ€™re seeing here now. But as you read the next few chapters, I encourage you to look back to this example to see how the member is defined and what effect it has on the metadata produced by the compiler.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šç±»å‹ä¸­å¯ä»¥å®šä¹‰å„ç§å„æ ·çš„æˆå‘˜ï¼Œè¿™äº›æˆå‘˜æœ‰ï¼šå¸¸é‡ã€å­—æ®µã€å®ä¾‹æ„é€ å™¨ã€ç±»å‹æ„é€ å™¨ã€æ–¹æ³•ã€æ“ä½œç¬¦é‡è½½ã€è½¬æ¢æ“ä½œç¬¦ã€å±æ€§ã€äº‹ä»¶ã€ç±»å‹ã€‚å€¼å¾—ä¸€æçš„æ˜¯ï¼ŒC# ä¸­çš„å¸¸é‡æ€»ä¸ç±»å‹å…³è”ï¼Œä¸ä¸ç±»å‹çš„å®ä¾‹å…³è”ã€‚å¸¸é‡é€»è¾‘ä¸Šæ€»æ˜¯é™æ€æˆå‘˜ã€‚æ— è®ºä»€ä¹ˆç¼–ç¨‹è¯­è¨€ï¼Œç¼–è¯‘å™¨éƒ½å¿…é¡»èƒ½å¤„ç†æºä»£ç ï¼Œä¸ºä¸Šè¿°æ¯ç§æˆå‘˜ç”Ÿæˆå…ƒæ•°æ®å’Œ IL ä»£ç ã€‚æ‰€æœ‰ç¼–ç¨‹è¯­è¨€ç”Ÿæˆçš„å…ƒæ•°æ®æ ¼å¼å®Œå…¨ä¸€è‡´ã€‚è¿™æ­£æ˜¯ CLR æˆä¸º â€œå…¬å…±è¯­è¨€è¿è¡Œæ—¶â€ çš„åŸå› ã€‚å…ƒæ•°æ®æ˜¯æ‰€æœ‰è¯­è¨€éƒ½ç”Ÿæˆå’Œä½¿ç”¨çš„å…¬å…±ä¿¡æ¯ã€‚æ­£æ˜¯ç”±äºæœ‰å…ƒæ•°æ®ï¼Œç”¨ä¸€ç§è¯­è¨€å†™çš„ä»£ç æ‰èƒ½æ— ç¼è®¿é—®ç”¨å¦ä¸€ç§è¯­è¨€å†™çš„ä»£ç ã€‚<span class="exturl" data-url="aHR0cDovL3huLS1NaWNyb3NvZnQtdWs2bnM2eXcwMGQ1cGZ3YjM5cC5ORVQ=">å…ƒæ•°æ®æ˜¯æ•´ä¸ª Microsoft.NET</span> Framework å¼€å‘å¹³å°çš„å…³é”®ï¼Œå®ƒå®ç°äº†ç¼–ç¨‹è¯­è¨€ã€ç±»å‹å’Œå¯¹è±¡çš„æ— ç¼é›†æˆï¼Œæºä»£ç ä¸­å®šä¹‰çš„æ‰€æœ‰æˆå‘˜éƒ½ä¼šé€ æˆç¼–è¯‘å™¨ç”Ÿæˆå…ƒæ•°æ®ã€‚</p><h2 id="type-visibility"><a class="anchor" href="#type-visibility">#</a> Type Visibility</h2><blockquote><p>When defining a type at file scope (versus defining a type nested within another type), you can specify the typeâ€™s visibility as being either public or internal. A public type is visible to all code within the defining assembly as well as all code written in other assemblies. An internal type is visible to all code within the defining assembly, and the type is not visible to code written in other assemblies. If you do not explicitly specify either of these when you define a type, the C# compiler sets the typeâ€™s visibility to internal (the more restrictive of the two). Here are some examples.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// The type below has public visibility and can be accessed by code </span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// in this assembly as well as code written in other assemblies. </span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThisIsAPublicType</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// The type below has internal visibility and can be accessed by code </span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// in this assembly only. </span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">ThisIsAnInternalType</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// The type below is internal because public/internal </span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// is not explicitly stated. </span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">ThisIsAlsoAnInternalType</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="friend-assemblies"><a class="anchor" href="#friend-assemblies">#</a> Friend Assemblies</h3><blockquote><p>Imagine the following scenario: a company has one team, TeamA, that is defining a bunch of utility types in one assembly, and they expect these types to be used by members in another team, TeamB. For various reasons such as time schedules or geographical location, or perhaps different cost centers or reporting structures, these two teams cannot build all of their types into a single assembly; instead, each team produces its own assembly file.</p></blockquote><blockquote><p>In order for TeamBâ€™s assembly to use TeamAâ€™s types, TeamA must define all of their utility types as public. However, this means that their types are publicly visible to any and all assemblies; developers in another company could write code that uses the public utility types, and this is not desirable. Maybe the utility types make certain assumptions that TeamB ensures when they write code that uses TeamAâ€™s types. What weâ€™d like to have is a way for TeamA to define their types as internal while still allowing TeamB to access the types. The CLR and C# support this via friend assemblies. This friend assembly feature is also useful when you want to have one assembly containing code that performs unit tests against the internal types within another assembly.</p></blockquote><blockquote><p>When an assembly is built, it can indicate other assemblies it considers â€œfriendsâ€ by using the <code>InternalsVisibleTo</code> attribute defined in the <code>System.Runtime.CompilerServices</code> namespace. The attribute has a string parameter that identifies the friend assemblyâ€™s name and public key (the string you pass to the attribute must not include a version, culture, or processor architecture). Note that friend assemblies can access all of an assemblyâ€™s internal types as well as these typeâ€™s internal members. Here is an example of how an assembly can specify two other strongly named assemblies named â€œWintellectâ€ and â€œMicrosoftâ€ as its friend assemblies.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>CompilerServices</span><span class="token punctuation">;</span> <span class="token comment">// For InternalsVisibleTo attribute </span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// This assembly's internal types can be accessed by any code written </span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// in the following two assemblies (regardless of version or culture): </span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token target keyword">assembly</span><span class="token punctuation">:</span><span class="token class-name">InternalsVisibleTo</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token string">"Wintellect, PublicKey=12345678...90abcdef"</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token target keyword">assembly</span><span class="token punctuation">:</span><span class="token class-name">InternalsVisibleTo</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token string">"Microsoft, PublicKey=b77a5c56...1934e089"</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SomeInternalType</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">AnotherInternalType</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Accessing the above assemblyâ€™s internal types from a friend assembly is trivial. For example, hereâ€™s how a friend assembly called â€œWintellectâ€ with a public key of â€œ12345678...90abcdefâ€ can access the internal type <code>SomeInternalType</code> in the preceding assembly.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name">Object</span> <span class="token function">SomeMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// This "Wintellect" assembly accesses the other assembly's </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// internal type as if it were a public type </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token class-name">SomeInternalType</span> sit <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SomeInternalType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">return</span> sit<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Because the internal members of the types in an assembly become accessible to friend assemblies, you should think carefully about what accessibility you specify for your typeâ€™s members and which assemblies you declare as your friends. Note that the C# compiler requires you to use the /out: compiler switch when compiling the friend assembly (the assembly that does not contain the <code>InternalsVisibleTo</code> attribute). The switch is required because the compiler needs to know the name of the assembly being compiled in order to determine if the resulting assembly should be considered a friend assembly. You would think that the C# compiler could determine this on its own because it normally determines the output file name on its own; however, the compiler doesnâ€™t decide on an output file name until it is finished compiling the code. So requiring the /out: compiler switch improves the performance of compiling significantly.</p></blockquote><blockquote><p>Also, if you are compiling a module (as opposed to an assembly) using C#â€™s /t:module switch, and this module is going to become part of a friend assembly, you need to compile the module by using the C# compilerâ€™s /moduleassemblyname: switch as well. This tells the compiler what assembly the module will be a part of so the compiler can allow code in the module to access the other assemblyâ€™s internal types.</p></blockquote><p>ğŸ’¡å°ç»“ï¼špublic ç±»å‹ä¸ä»…å¯¹å®šä¹‰ç¨‹åºé›†ä¸­çš„æ‰€æœ‰ä»£ç å¯è§ï¼Œè¿˜å¯¹å…¶ä»–ç¨‹åºé›†ä¸­çš„ä»£ç å¯è§ã€‚internal ç±»å‹åˆ™ä»…å¯¹å®šä¹‰ç¨‹åºé›†ä¸­çš„æ‰€æœ‰ä»£ç å¯è§ï¼Œå¯¹å…¶ä»–ç¨‹åºé›†ä¸­çš„ä»£ç ä¸å¯è§ã€‚å®šä¹‰ç±»å‹æ—¶ä¸æ˜¾ç¤ºæŒ‡å®šå¯è§æ€§ï¼ŒC# ç¼–è¯‘å™¨ä¼šå°†å…¶é»˜è®¤ä¸º internal çº§åˆ«çš„å¯è§æ€§ã€‚æœ‰æ—¶æˆ‘ä»¬ä¼šå¸Œæœ›ç½‘æ–‡å¦ä¸€ä¸ªç¨‹åºé›†ä¸­çš„ internal ç±»å‹ï¼ŒCLR å’Œ C# é€šè¿‡å‹å…ƒç¨‹åºé›†ï¼ˆfriend assemblyï¼‰æä¾›è¿™æ–¹é¢çš„æ”¯æŒã€‚ç”¨ä¸€ä¸ªç¨‹åºé›†ä¸­çš„ä»£ç å¯¹å¦ä¸€ä¸ªç¨‹åºé›†ä¸­çš„å†…éƒ¨ç±»å‹è¿›è¡Œå•å…ƒæµ‹è¯•æ—¶ï¼Œå‹å…ƒç¨‹åºé›†åŠŸèƒ½ä¹Ÿèƒ½æ´¾ä¸Šç”¨åœºã€‚ç”Ÿæˆç¨‹åºé›†æ—¶ï¼Œå¯ç”¨ <code>System.Runtime.CompilerServices</code> å‘½åç©ºé—´ä¸­çš„ <code>InternalsVisibleTo</code> ç‰¹æ€§è¡¨æ˜å®ƒè®¤ä¸ºæ˜¯ â€œå‹å…ƒâ€ çš„å…¶ä»–ç¨‹åºé›†ã€‚è¯¥ç‰¹æ€§è·å–æ ‡è¯†å‹å…ƒç¨‹åºé›†åç§°å’Œå…¬é’¥çš„å­—ç¬¦ä¸²å‚æ•°ï¼ˆä¼ ç»™è¯¥ç‰¹æ€§çš„å­—ç¬¦ä¸²ç»ä¸èƒ½åŒ…å«ç‰ˆæœ¬ã€è¯­è¨€æ–‡åŒ–å’Œå¤„ç†å™¨æ¶æ„ï¼‰ã€‚C# ç¼–è¯‘å™¨åœ¨ç¼–è¯‘å‹å…ƒç¨‹åºé›†ï¼ˆä¸å« <code>InternalsVisibleTo</code> ç‰¹æ€§çš„ç¨‹åºé›†ï¼‰æ—¶è¦æ±‚ä½¿ç”¨ç¼–è¯‘å™¨å¼€å…³ <code>/out:&lt;file&gt;</code> ã€‚ä½¿ç”¨è¿™ä¸ªç¼–è¯‘å™¨å¼€å…³çš„åŸå› åœ¨äºï¼Œç¼–è¯‘å™¨éœ€è¦çŸ¥é“å‡†å¤‡ç¼–è¯‘çš„ç¨‹åºé›†çš„åç§°ï¼Œä»è€Œåˆ¤æ–­ç”Ÿæˆçš„ç¨‹åºé›†æ˜¯ä¸æ˜¯å‹å…ƒç¨‹åºé›†ã€‚åŒæ ·åœ°ï¼Œå¦‚æœä½¿ç”¨ C# ç¼–è¯‘å™¨çš„ <code>/t:module</code> å¼€å…³æ¥ç¼–è¯‘æ¨¡å—ï¼ˆè€Œä¸æ˜¯ç¼–è¯‘æˆç¨‹åºé›†ï¼‰ï¼Œè€Œä¸”è¯¥æ¨¡å—å°†æˆä¸ºæŸä¸ªå‹å…ƒç¨‹åºé›†çš„ä¸€éƒ¨åˆ†ï¼Œé‚£ä¹ˆè¿˜éœ€è¦ä½¿ç”¨ C# ç¼–è¯‘å™¨çš„ <code>/moduleassemblyname:&lt;string&gt;</code> å¼€å…³æ¥ç¼–è¯‘è¯¥æ¨¡å—ã€‚</p><h2 id="member-accessibility"><a class="anchor" href="#member-accessibility">#</a> Member Accessibility</h2><blockquote><p>When defining a typeâ€™s member (which includes nested types), you can specify the memberâ€™s accessibility. A memberâ€™s accessibility indicates which members can be legally accessed from referent code. The CLR defines the set of possible accessibility modifiers, but each programming language chooses the syntax and term it wants developers to use when applying the accessibility to a member. For example, the CLR uses the term Assembly to indicate that a member is accessible to any code within the same assembly, whereas the C# term for this is internal.</p></blockquote><blockquote><p>Table 6-1 shows the six accessibility modifiers that can be applied to a member. The rows of the table are in order from most restrictive (Private) to least restrictive (Public).</p></blockquote><p><img data-src="/2022/10/21/csharp/clr-via-csharp/Chapter%206%20Type%20and%20Member%20Basics/image-20221018205025332.png" alt="image-20221018205025332"></p><blockquote><p>Of course, for any member to be accessible, it must be defined in a type that is visible. For example, if AssemblyA defines an internal type with a public method, code in AssemblyB cannot call the public method because the internal type is not visible to AssemblyB.</p></blockquote><blockquote><p>When compiling code, the language compiler is responsible for checking that the code is referencing types and members correctly. If the code references some type or member incorrectly, the compiler has the responsibility of emitting the appropriate error message. In addition, the just-in-time (JIT) compiler also ensures that references to fields and methods are legal when compiling IL code into native CPU instructions at run time. For example, if the JIT compiler detects code that is improperly attempting to access a private field or method, the JIT compiler throws a <code>FieldAccessException</code> or a <code>MethodAccessException</code> , respectively.</p></blockquote><blockquote><p>Verifying the IL code ensures that a referenced memberâ€™s accessibility is properly honored at run time, even if a language compiler ignored checking the accessibility. Another, more likely, possibility is that the language compiler compiled code that accessed a public member in another type (in another assembly); but at run time, a different version of the assembly is loaded, and in this new version, the public member has changed and is now protected or private.</p></blockquote><blockquote><p>In C#, if you do not explicitly declare a memberâ€™s accessibility, the compiler usually (but not always) defaults to selecting private (the most restrictive of them all). The CLR requires that all members of an interface type be public. The C# compiler knows this and forbids the programmer from explicitly specifying accessibility on interface members; the compiler just makes all the members public for you.</p></blockquote><blockquote><p>Furthermore, youâ€™ll notice the CLR offers an accessibility called Family and Assembly. However, C# doesnâ€™t expose this in the language. The C# team felt that this accessibility was for the most part useless and decided not to incorporate it into the C# language.</p></blockquote><p>ğŸ’¡Noteï¼šä» C#7.2 å¼€å§‹æ”¯æŒ private protectedï¼Œå®ƒæ˜¯ protected å’Œ internal å¯è®¿é—®æ€§çš„äº¤é›†ã€‚è‹¥ä¸€ä¸ªæˆå‘˜æ˜¯ private protected çš„ï¼Œé‚£ä¹ˆè¯¥æˆå‘˜åªèƒ½å¤Ÿåœ¨å…¶ç±»å‹ä¸­æˆ–è¢«å…¶ç›¸åŒç¨‹åºé›†ä¸­çš„å­ç±»å‹è®¿é—®ï¼ˆå®ƒçš„å¯è®¿é—®æ€§æ¯” protected å’Œ internal éƒ½ä½ï¼‰ã€‚</p><blockquote><p>When a derived type is overriding a member defined in its base type, the C# compiler requires that the original member and the overriding member have the same accessibility. That is, if the member in the base class is protected, the overriding member in the derived class must also be protected. However, this is a C# restriction, not a CLR restriction. When deriving from a base class, the CLR allows a memberâ€™s accessibility to become less restrictive but not more restrictive. For example, a class can override a protected method defined in its base class and make the overridden method public (more accessible). However, a class cannot override a protected method defined in its base class and make the overridden method private (less accessible). The reason a class cannot make a base class method more restricted is because a user of the derived class could always cast to the base type and gain access to the base classâ€™s method. If the CLR allowed the derived typeâ€™s method to be less accessible, it would be making a claim that was not enforceable.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šå®šä¹‰ç±»å‹çš„æˆå‘˜ï¼ˆåŒ…æ‹¬åµŒå¥—ç±»å‹ï¼‰æ—¶ï¼Œå¯æŒ‡å®šæˆå‘˜çš„å¯è®¿é—®æ€§ã€‚ä»»ä½•æˆå‘˜è¦æƒ³è¢«è®¿é—®ï¼Œéƒ½å¿…é¡»åœ¨å¯è§çš„ç±»å‹ä¸­å®šä¹‰ã€‚ç¼–è¯‘ä»£ç æ—¶ï¼Œç¼–ç¨‹è¯­è¨€çš„ç¼–è¯‘å™¨ä¼šæ£€æŸ¥ä»£ç æ˜¯ä¸æ˜¯æ­£ç¡®å¼•ç”¨äº†ç±»å‹å’Œæˆå‘˜ã€‚å¦‚æœä»£ç ä¸æ­£ç¡®åœ°å¼•ç”¨äº†ç±»å‹æˆ–æˆå‘˜ï¼Œç¼–è¯‘å™¨ä¼šç”Ÿæˆä¸€æ¡åˆé€‚çš„é”™è¯¯æ¶ˆæ¯ã€‚å¦å¤–ï¼Œåœ¨è¿è¡Œæ—¶å°† IL ä»£ç ç¼–è¯‘æˆæœ¬æœº CPU æŒ‡ä»¤æ—¶ï¼ŒJIT ç¼–è¯‘å™¨ä¹Ÿä¼šç¡®ä¿å¯¹å­—æ®µå’Œæ–¹æ³•çš„å¼•ç”¨åˆæ³•ã€‚é€šè¿‡å¯¹ IL ä»£ç è¿›è¡ŒéªŒè¯ï¼Œå¯ç¡®ä¿è¢«å¼•ç”¨æˆå‘˜çš„å¯è®¿é—®æ€§åœ¨è¿è¡Œæ—¶å¾—åˆ°æ­£ç¡®å…‘ç° -- å³ä½¿è¯­è¨€çš„ç¼–è¯‘å™¨å¿½ç•¥äº†å¯¹å¯è®¿é—®æ€§çš„æ£€æŸ¥ã€‚åœ¨ C# ä¸­ï¼Œå¦‚æœæ²¡æœ‰æ˜¾å¼å£°æ˜æˆå‘˜çš„å¯è®¿é—®æ€§ï¼Œç¼–è¯‘å™¨é€šå¸¸é»˜è®¤é€‰æ‹© privateã€‚CLR è¦æ±‚æ¥å£ç±»å‹çš„æ‰€æœ‰æˆå‘˜éƒ½å…·æœ‰ public å¯è®¿é—®æ€§ã€‚C# ç¼–è¯‘å™¨çŸ¥é“è¿™ä¸€ç‚¹ï¼Œå› æ­¤ç¦æ­¢å¼€å‘äººå‘˜æ˜¾å¼æŒ‡å®šæ¥å£æˆå‘˜çš„å¯è®¿é—®æ€§ï¼›ç¼–è¯‘å™¨è‡ªåŠ¨å°†æ‰€æœ‰æˆå‘˜çš„å¯è®¿é—®æ€§è®¾ä¸º publicã€‚æ´¾ç”Ÿç±»å‹é‡å†™åŸºç±»å‹å®šä¹‰çš„æˆå‘˜æ—¶ï¼ŒC# ç¼–è¯‘å™¨è¦æ±‚åŸå§‹æˆå‘˜å’Œé‡å†™æˆå‘˜å…·æœ‰ç›¸åŒçš„å¯è®¿é—®æ€§ã€‚ä½†è¿™æ—¶ C# çš„é™åˆ¶ï¼Œä¸æ˜¯ CLR çš„ã€‚ä»åŸºç±»æ´¾ç”Ÿæ—¶ï¼ŒCLR å…è®¸æ”¾å®½ä½†ä¸å…è®¸æ”¶ç´§æˆå‘˜çš„å¯è®¿é—®æ€§é™åˆ¶ã€‚ä¹‹æ‰€ä»¥ä¸èƒ½åœ¨æ´¾ç”Ÿç±»ä¸­æ”¶ç´§å¯¹åŸºç±»æ–¹æ³•çš„è®¿é—®ï¼Œæ˜¯å› ä¸º CLR æ‰¿è¯ºæ´¾ç”Ÿç±»æ€»èƒ½è½¬å‹ä¸ºåŸºç±»ï¼Œå¹¶è·å–å¯¹åŸºç±»æ–¹æ³•çš„è®¿é—®æƒã€‚å¦‚æœå…è®¸æ´¾ç”Ÿç±»æ”¶ç´§é™åˆ¶ï¼ŒCLR çš„æ‰¿è¯ºå°±æ— æ³•å…‘ç°äº†ã€‚</p><h2 id="static-classes"><a class="anchor" href="#static-classes">#</a> Static Classes</h2><blockquote><p>There are certain classes that are never intended to be instantiated, such as Console, Math, Environment, and ThreadPool. These classes have only static members and, in fact, the classes exist simply as a way to group a set of related members together. For example, the Math class defines a bunch of methods that do math-related operations. C# allows you to define non-instantiable classes by using the C# static keyword. This keyword can be applied only to classes, not structures (value types) because the CLR always allows value types to be instantiated and there is no way to stop or prevent this.</p></blockquote><blockquote><p>The compiler enforces many restrictions on a static class:</p><ul><li>The class must be derived directly from System.Object because deriving from any other base class makes no sense because inheritance applies only to objects, and you cannot create an instance of a static class.</li><li>The class must not implement any interfaces because interface methods are callable only when using an instance of a class.</li><li>The class must define only static members (fields, methods, properties, and events). Any instance members cause the compiler to generate an error.</li><li>The class cannot be used as a field, method parameter, or local variable because all of these would indicate a variable that refers to an instance, and this is not allowed. If the compiler detects any of these uses, the compiler issues an error.</li></ul></blockquote><blockquote><p>Here is an example of a static class that defines some static members; this code compiles (with a warning) but the class doesnâ€™t do anything interesting.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">AStaticClass</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">AStaticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">String</span> AStaticProperty <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> s_AStaticField<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">set</span> <span class="token punctuation">&#123;</span> s_AStaticField <span class="token operator">=</span> <span class="token keyword">value</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">String</span> s_AStaticField<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">event</span> <span class="token class-name">EventHandler</span> AStaticEvent<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>If you compile the code above into a library (DLL) assembly and look at the result by using ILDasm.exe, youâ€™ll see what is shown in Figure 6-2. As you can see in Figure 6-2, defining a class by using the static keyword causes the C# compiler to make the class both abstract and sealed. Furthermore, the compiler will not emit an instance constructor method into the type. Notice that there is no instance constructor (.ctor) method shown in Figure 6-2.</p></blockquote><p><img data-src="/2022/10/21/csharp/clr-via-csharp/Chapter%206%20Type%20and%20Member%20Basics/image-20221018220116471.png" alt="image-20221018220116471"></p><p>ğŸ’¡å°ç»“ï¼šæœ‰ä¸€äº›æ°¸è¿œä¸éœ€è¦å®ä¾‹åŒ–çš„ç±»ï¼Œè¿™äº›ç±»å¸¸è¢«ç§°ä½œå·¥å…·ç±»ã€‚åœ¨ C# ä¸­ï¼Œè¦ç”¨ static å…³é”®å­—å®šä¹‰ä¸å¯å®ä¾‹åŒ–çš„ç±»ã€‚è¯¥å…³é”®å­—åªèƒ½åº”ç”¨äºç±»ï¼Œä¸èƒ½åº”ç”¨äºç»“æ„ï¼ˆå€¼ç±»å‹ï¼‰ã€‚å› ä¸º CLR æ€»æ˜¯å…è®¸å€¼ç±»å‹å®ä¾‹åŒ–ï¼Œè¿™æ—¶æ²¡åŠæ³•é˜»æ­¢çš„ã€‚C# ç¼–è¯‘å™¨å¯¹é™æ€ç±»è¿›è¡Œäº†ä¸€äº›é™åˆ¶ï¼Œä¾‹å¦‚é™æ€ç±»å¿…é¡»ç›´æ¥ä»åŸºç±» <code>System.Object</code> æ´¾ç”Ÿï¼Œä»å…¶ä»–ä»»ä½•åŸºç±»æ´¾ç”Ÿéƒ½æ²¡æœ‰æ„ä¹‰ã€‚é™æ€ç±»ä¸èƒ½å®ç°ä»»ä½•æ¥å£ï¼Œè¿™æ—¶å› ä¸ºåªæœ‰ä½¿ç”¨ç±»çš„å®ä¾‹æ—¶ï¼Œæ‰å¯è°ƒç”¨ç±»çš„æ¥å£æ–¹æ³•ã€‚ä½¿ç”¨å…³é”®å­— static å®šä¹‰ç±»ï¼Œå°†å¯¼è‡´ C# ç¼–è¯‘å™¨å°†è¯¥ç±»æ ‡è®°ä¸º abstract å’Œ sealedã€‚å¦å¤–ï¼Œç¼–è¯‘å™¨ä¹Ÿä¸ä¼šåœ¨ç±»å‹ä¸­ç”Ÿæˆå®ä¾‹æ„é€ å™¨æ–¹æ³•ã€‚</p><h2 id="partial-classes-structures-and-interfaces"><a class="anchor" href="#partial-classes-structures-and-interfaces">#</a> Partial Classes, Structures, and Interfaces</h2><blockquote><p>In this section, I discuss partial classes, structures, and interfaces. The partial keyword tells the C# compiler that the source code for a single class, structure, or interface definition may span one or more source code files. It should be noted that the compiler combines all of a typeâ€™s partials together at compile time; the CLR always works on complete type definitions. There are three main reasons why you might want to split the source code for a type across multiple files:</p><ul><li><p>Source control Suppose a typeâ€™s definition consists of a lot of source code, and a programmer checks it out of source control to make changes. No other programmer will be able to modify the type at the same time without doing a merge later. Using the partial keyword allows you to split the code for the type across multiple source code files, each of which can be checked out individually so that multiple programmers can edit the type at the same time.</p></li><li><p>Splitting a class, structure, or interface into distinct logical units within a single file I sometimes create a single type that provides multiple features so that the type can provide a complete solution. To simplify my implementation, I will sometimes declare the same partial type repeatedly within a single source code file. Then, in each part of the partial type, I implement one feature with all its fields, methods, properties, events, and so on. This allows me to easily see all the members that provide a single feature grouped together, which simplifies my coding. Also, I can easily comment out a part of the partial type to remove a whole feature from the type and replace it with another implementation (via a new part of the partial type).</p></li><li><p>Code spitters In Microsoft Visual Studio, when you create a new project, some source code files are created automatically as part of the project. These source code files contain templates that give you a head start at building these kinds of projects. When you use the Visual Studio designers and drag and drop controls onto the design surface, Visual Studio writes source code for you automatically and spits this code into the source code files. This really improves your productivity. Historically, the generated code was emitted into the same source code file that you were working on. The problem with this is that you might edit the generated code accidentally and cause the designers to stop functioning correctly. Starting with Visual Studio 2005, when you create a new form, user control, and so on, Visual Studio creates two source code files: one for your code and the other for the code generated by the designer. Because the designer code is in a separate file, youâ€™ll be far less likely to accidentally edit it.</p></li></ul></blockquote><blockquote><p>The partial keyword is applied to the types in all files. When the files are compiled together, the compiler combines the code to produce one type that is in the resulting .exe or .dll assembly file (or .netmodule module file). As I stated in the beginning of this section, the partial types feature is completely implemented by the C# compiler; the CLR knows nothing about partial types at all. This is why all of the source code files for the type must use the same programming language, and they must all be compiled together as a single compilation unit.</p></blockquote><p>ğŸ’¡å°ç»“ï¼špartial å…³é”®å­—å‘Šè¯‰ C# ç¼–è¯‘å™¨ï¼šç±»ã€ç»“æ„æˆ–æ¥å£çš„å®šä¹‰æºä»£ç å¯èƒ½è¦åˆ†æ•£åˆ°ä¸€ä¸ªæˆ–å¤šä¸ªæºä»£ç æ–‡ä»¶ä¸­ã€‚å°†ç±»å‹æºä»£ç åˆ†æ•£åˆ°å¤šä¸ªæ–‡ä»¶çš„åŸå› å¯èƒ½æœ‰ä»¥ä¸‹å‡ ç§ï¼šæºä»£ç æ§åˆ¶ã€åœ¨åŒä¸€ä¸ªæ–‡ä»¶ä¸­å°†ç±»æˆ–ç»“æ„åˆ†è§£æˆä¸åŒçš„é€»è¾‘å•å…ƒã€ä»£ç æ‹†åˆ†ã€‚è¦å°† partial å…³é”®å­—åº”ç”¨äºæ‰€æœ‰æ–‡ä»¶ä¸­çš„ç±»å‹ï¼Œè¿™äº›æ–‡ä»¶ç¼–è¯‘åˆ°ä¸€èµ·æ—¶ï¼Œç¼–è¯‘å™¨ä¼šåˆå¹¶ä»£ç ï¼Œåœ¨æœ€åçš„.exe æˆ–.dll ç¨‹åºé›†æ–‡ä»¶ï¼ˆæˆ–.netmodule æ¨¡å—æ–‡ä»¶ï¼‰ä¸­ç”Ÿæˆå•ä¸ªç±»å‹ã€‚â€œåˆ†å¸ƒç±»å‹â€ åŠŸèƒ½å®Œå…¨ç”± C# ç¼–è¯‘å™¨å®ç°ï¼ŒCLR å¯¹è¯¥åŠŸèƒ½ä¸€æ— æ‰€çŸ¥ï¼Œè¿™è§£é‡Šäº†ä¸€ä¸ªç±»å‹çš„æ‰€æœ‰æºä»£ç æ–‡ä»¶ä¸ºä»€ä¹ˆå¿…é¡»ä½¿ç”¨ç›¸åŒçš„è¯­è¨€ï¼Œè€Œä¸”å¿…é¡»ä½œä¸ºä¸€ä¸ªç¼–è¯‘å•å…ƒç¼–è¯‘åˆ°ä¸€èµ·ã€‚</p><h2 id="components-polymorphism-and-versioning"><a class="anchor" href="#components-polymorphism-and-versioning">#</a> Components, Polymorphism, and Versioning</h2><blockquote><p>Object-oriented programming (OOP) has been around for many, many years. When it was first used in the late 1970s/early 1980s, applications were much smaller in size and all the code to make the application run was written by one company. Sure, there were operating systems back then and applications did make use of what they could out of those operating systems, but the operating systems offered very few features compared with the operating systems of today.</p></blockquote><blockquote><p>Today, software is much more complex and users demand that applications offer rich features such as GUIs, menu items, mouse input, tablet input, printer output, networking, and so on. For this reason, our operating systems and development platforms have grown substantially over recent years. Furthermore, it is no longer feasible or even cost effective for application developers to write all of the code necessary for their application to work the way users expect. Today, applications consist of code produced by many different companies. This code is stitched together using an object-oriented paradigm.</p></blockquote><blockquote><p>Component Software Programming (CSP) is OOP brought to this level. Here are some attributes of a component:</p><p>â–  A component (an assembly in the .NET Framework) has the feeling of being â€œpublished.â€</p><p>â–  A component has an identity (a name, version, culture, and public key).</p><p>â–  A component forever maintains its identity (the code in an assembly is never statically linked into another assembly; .NET always uses dynamic linking).</p><p>â–  A component clearly indicates the components it depends upon (reference metadata tables).</p><p>â–  A component should document its classes and members. C# offers this by allowing in-source Extensible Markup Language (XML) documentation along with the compilerâ€™s /doc commandline switch.</p><p>â–  A component must specify the security permissions it requires. The CLRâ€™s code access security (CAS) facilities enable this.</p><p>â–  A component publishes an interface (object model) that wonâ€™t change for any servicings. A servicing is a new version of a component whose intention is to be backward compatible with the original version of the component. Typically, a servicing version includes bug fixes, security patches, and possibly some small feature enhancements. But a servicing cannot require any new dependencies or any additional security permissions.</p></blockquote><blockquote><p>As indicated by the last bullet, a big part of CSP has to do with versioning. Components will change over time and components will ship on different time schedules. Versioning introduces a whole new level of complexity for CSP that didnâ€™t exist with OOP, with which all code was written, tested, and shipped as a single unit by a single company. In this section, Iâ€™m going to focus on component versioning.</p></blockquote><blockquote><p>In the .NET Framework, a version number consists of four parts: a major part, a minor part, a build part, and a revision part. For example, an assembly whose version number is 1.2.3.4 has a major part of 1, a minor part of 2, a build part of 3, and a revision part of 4. The major/minor parts are typically used to represent a consistent and stable feature set for an assembly and the build/revision parts are typically used to represent a servicing of this assemblyâ€™s feature set.</p></blockquote><blockquote><p>Letâ€™s say that a company ships an assembly with version 2.7.0.0. If the company later wants to fix a bug in this component, they would produce a new assembly in which only the build/revision parts of the version are changed, something like version 2.7.1.34. This indicates that the assembly is a servicing whose intention is to be backward compatible with the original component (version 2.7.0.0).</p></blockquote><blockquote><p>On the other hand, if the company wants to make a new version of the assembly that has significant changes to it and is therefore not intended to be backward compatible with the original assembly, the company is really creating a new component and the new assembly should be given a version number in which the major/minor parts are different from the existing component (version 3.0.0.0, for example).</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šæ­¤å¤„åªæ˜¯è¯´æ˜åº”è¯¥å¦‚ä½•çœ‹å¾…ç‰ˆæœ¬å·ã€‚é—æ†¾çš„æ˜¯ï¼ŒCLR ä¸ä»¥è¿™ç§æ–¹å¼çœ‹å¾…ç‰ˆæœ¬å·ã€‚ç°åœ¨ï¼ŒCLR å°†ç‰ˆæœ¬å·çœ‹æˆæ˜¯å›ºå®šå€¼ï¼Œå¦‚æœæŸä¸ªç¨‹åºé›†ä¾èµ–ç‰ˆæœ¬å·ä¸º 1.2.3.4 çš„å¦ ä¸ªç¨‹åºé›†ï¼ŒCLR åªä¼šå°è¯•åŠ è½½ç‰ˆæœ¬å·ä¸º 1.2.3.4 çš„ç¨‹åºé›† (é™¤éè®¾ç½®äº†ç»‘å®šé‡å®šå‘)ã€‚</p><blockquote><p>Now that weâ€™ve looked at how we use version numbers to update a componentâ€™s identity to reflect a new version, letâ€™s take a look at some of the features offered by the CLR and programming languages (such as C#) that allow developers to write code that is resilient to changes that may be occurring in components that they are using.</p></blockquote><blockquote><p>Versioning issues come into play when a type defined in a component (assembly) is used as the base class for a type in another component (assembly). Obviously, if the base class versions (changes) underneath the derived class, the behavior of the derived class changes as well, probably in a way that causes the class to behave improperly. This is particularly true in polymorphism scenarios in which a derived type overrides virtual methods defined by a base type.</p></blockquote><blockquote><p>C# offers five keywords that you can apply to types and/or type members that impact component versioning. These keywords map directly to features supported in the CLR to support component versioning. Table 6-2 contains the C# keywords related to component versioning and indicates how each keyword affects a type or type member definition.</p></blockquote><p><img data-src="/2022/10/21/csharp/clr-via-csharp/Chapter%206%20Type%20and%20Member%20Basics/image-20221018212558664.png" alt="image-20221018212558664"></p><blockquote><p>I will demonstrate the value and use of all these keywords in the upcoming section titled â€œDealing with Virtual Methods When Versioning Types.â€ But before we get to a versioning scenario, letâ€™s focus on how the CLR actually calls virtual methods.</p></blockquote><h3 id="how-the-clr-calls-virtual-methods-properties-and-events"><a class="anchor" href="#how-the-clr-calls-virtual-methods-properties-and-events">#</a> How the CLR Calls Virtual Methods, Properties, and Events</h3><blockquote><p>In this section, I will be focusing on methods, but this discussion is relevant to virtual properties and virtual events as well. Properties and events are actually implemented as methods; this will be shown in their corresponding chapters.</p></blockquote><blockquote><p>Methods represent code that performs some operation on the type (static methods) or an instance of the type (nonstatic methods). All methods have a name, a signature, and a return type (that may be void). The CLR allows a type to define multiple methods with the same name as long as each method has a different set of parameters or a different return type. So itâ€™s possible to define two methods with the same name and same parameters as long as the methods have a different return type. However, except for IL assembly language, Iâ€™m not aware of any language that takes advantage of this â€œfeatureâ€; most languages (including C#) require that methods differ by parameters and ignore a methodâ€™s return type when determining uniqueness. (C# actually relaxes this restriction when defining conversion operator methods; see Chapter 8 for details.)</p></blockquote><blockquote><p>The Employee class shown below defines three different kinds of methods.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// A nonvirtual instance method </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token function">GetYearsEmployed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// A virtual method (virtual implies instance) </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token return-type class-name">String</span> <span class="token function">GetProgressReport</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// A static method </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Employee</span> <span class="token function">Lookup</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When the compiler compiles this code, the compiler emits three entries in the resulting assemblyâ€™s method definition table. Each entry has flags set indicating if the method is instance, virtual, or static.</p></blockquote><blockquote><p>When code is written to call any of these methods, the compiler emitting the calling code examines the method definitionâ€™s flags to determine how to emit the proper IL code so that the call is made correctly. The CLR offers two IL instructions for calling a method:</p><p>â–  The <code>call</code> IL instruction can be used to call static, instance, and virtual methods. When the <code>call</code> instruction is used to call a static method, you must specify the type that defines the method that the CLR should call. When the <code>call</code> instruction is used to call an instance or virtual method, you must specify a variable that refers to an object. The <code>call</code> instruction assumes that this variable is not null. In other words, the type of the variable itself indicates which type defines the method that the CLR should call. If the variableâ€™s type doesnâ€™t define the method, base types are checked for a matching method. The <code>call</code> instruction is frequently used to call a virtual method nonvirtually.</p><p>â–  The <code>callvirt</code> IL instruction can be used to call instance and virtual methods, not static methods. When the <code>callvirt</code> instruction is used to call an instance or virtual method, you must specify a variable that refers to an object. When the <code>callvirt</code> IL instruction is used to call a nonvirtual instance method, the type of the variable indicates which type defines the method that the CLR should call. When the <code>callvirt</code> IL instruction is used to call a virtual instance method, the CLR discovers the actual type of the object being used to make the call and then calls the method polymorphically. In order to determine the type, the variable being used to make the call must not be null. In other words, when compiling this call, the JIT compiler generates code that verifies that the variableâ€™s value is not null. If it is null, the callvirt instruction causes the CLR to throw a <code>NullReferenceException</code> . This additional check means that the callvirt IL instruction executes slightly more slowly than the call instruction. Note that this null check is performed even when the callvirt instruction is used to call a nonvirtual instance method.</p></blockquote><blockquote><p>So now, letâ€™s put this together to see how C# uses these different IL instructions.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Call a static method </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token class-name">Object</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> o<span class="token punctuation">.</span><span class="token function">GetHashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Call a virtual instance method </span></pre></td></tr><tr><td data-num="7"></td><td><pre> o<span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Call a nonvirtual instance method </span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>If you were to compile the code above and look at the resulting IL, youâ€™d see the following.</p></blockquote><figure class="highlight clike"><figcaption data-lang="C-like"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">.</span>method public hidebysig static void <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> cil managed <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token punctuation">.</span>entrypoint</pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// Code size 26 (0x1a) </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token punctuation">.</span>maxstack <span class="token number">1</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">.</span>locals init <span class="token punctuation">(</span>object o<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> IL_0000<span class="token punctuation">:</span> call void System<span class="token punctuation">.</span>Console<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> IL_0005<span class="token punctuation">:</span> newobj instance void System<span class="token punctuation">.</span>Object<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> IL_000a<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">0</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> IL_000b<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> IL_000c<span class="token punctuation">:</span> callvirt instance int32 System<span class="token punctuation">.</span>Object<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">GetHashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> IL_0011<span class="token punctuation">:</span> pop </pre></td></tr><tr><td data-num="12"></td><td><pre> IL_0012<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> IL_0013<span class="token punctuation">:</span> callvirt instance class <span class="token class-name">System<span class="token punctuation">.</span>Type</span> System<span class="token punctuation">.</span>Object<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> IL_0018<span class="token punctuation">:</span> pop </pre></td></tr><tr><td data-num="15"></td><td><pre> IL_0019<span class="token punctuation">:</span> ret </pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of method Program::Main</span></pre></td></tr></table></figure><blockquote><p>Notice that the C# compiler uses the call IL instruction to call Consoleâ€™s WriteLine method. This is expected because WriteLine is a static method. Next, notice that the <code>callvirt</code> IL instruction is used to call <code>GetHashCode</code> . This is also expected, because <code>GetHashCode</code> is a virtual method. Finally, notice that the C# compiler also uses the <code>callvirt</code> IL instruction to call the <code>GetType</code> method. This is surprising because <code>GetType</code> is not a virtual method. However, this works because while JIT-compiling this code, the CLR will know that <code>GetType</code> is not a virtual method, and so the JIT-compiled code will simply call <code>GetType</code> nonvirtually.</p></blockquote><blockquote><p>Of course, the question is, why didnâ€™t the C# compiler simply emit the call instruction instead? The answer is because the C# team decided that the JIT compiler should generate code to verify that the object being used to make the call is not null. This means that calls to nonvirtual instance methods are a little slower than they could be. It also means that the following C# code will cause a <code>NullReferenceException</code> to be thrown. In some other programming languages, the intention of the following code would run just fine.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token function">GetFive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token class-name">Program</span> p <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token class-name">Int32</span> x <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">GetFive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// In C#, NullReferenceException is thrown </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Theoretically, the preceding code is fine. Sure, the variable p is null, but when calling a nonvirtual method ( <code>GetFive</code> ), the CLR needs to know just the data type of p, which is Program. If <code>GetFive</code> did get called, the value of the this argument would be null. Because the argument is not used inside the <code>GetFive</code> method, no <code>NullReferenceException</code> would be thrown. However, because the C# compiler emits a <code>callvirt</code> instruction instead of a call instruction, the preceding code will end up throwing the <code>NullReferenceException</code> .</p></blockquote><p>ğŸ’¡é‡è¦æç¤ºï¼šå°†æ–¹æ³•å®šä¹‰ä¸ºéè™šæ–¹æ³•åï¼Œå°†æ¥æ°¸è¿œéƒ½ä¸è¦æŠŠå®ƒæ›´æ”¹ä¸ºè™šæ–¹æ³•ã€‚è¿™æ˜¯å› ä¸ºæŸäº›ç¼–è¯‘å™¨ä¼šç”¨ <code>call</code> è€Œä¸æ˜¯ <code>callvirt</code> è°ƒç”¨éè™šæ–¹æ³•ã€‚å¦‚æœæ–¹æ³•ä»éè™šå˜æˆè™šï¼Œè€Œå¼•ç”¨ä»£ç æ²¡æœ‰é‡æ–°ç¼–è¯‘ï¼Œä¼šä»¥éè™šæ–¹å¼è°ƒç”¨è™šæ–¹æ³•ï¼Œé€ æˆåº”ç”¨ç¨‹åºè¡Œä¸ºæ— æ³•é¢„æ–™ã€‚ç”¨ C# å†™çš„å¼•ç”¨ä»£ç ä¸ä¼šå‡ºé—®é¢˜ï¼Œå› ä¸º C# ç”¨ <code>callvirt</code> æŒ‡ä»¤è°ƒç”¨æ‰€æœ‰å®ä¾‹æ–¹æ³•ã€‚ä½†å¦‚æœå¼•ç”¨ä»£ç æ˜¯ç”¨å…¶ä»–è¯­è¨€å†™çš„ï¼Œå°±å¯èƒ½å‡ºé—®é¢˜ã€‚</p><blockquote><p>Sometimes, the compiler will use a call instruction to call a virtual method instead of using a <code>callvirt</code> instruction. At first, this may seem surprising, but the code below demonstrates why it is sometimes required.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>xxxxxxxxxx <span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">SomeClass</span> <span class="token punctuation">&#123;</span> <span class="token comment">// ToString is a virtual method defined in the base class: Object. public override String ToString() &#123; // Compiler uses the 'call' IL instruction to call // Objectâ€™s ToString method nonvirtually. // If the compiler were to use 'callvirt' instead of 'call', this // method would call itself recursively until the stack overflowed. return base.ToString(); &#125;&#125;</span></pre></td></tr></table></figure><blockquote><p>When calling base.ToString (a virtual method), the C# compiler emits a call instruction to ensure that the <code>ToString</code> method in the base type is called nonvirtually. This is required because if <code>ToString</code> were called virtually, the call would execute recursively until the threadâ€™s stack overflowed, which obviously is not desired.</p></blockquote><blockquote><p>Compilers tend to use the call instruction when calling methods defined by a value type because value types are sealed. This implies that there can be no polymorphism even for their virtual methods, which causes the performance of the call to be faster. In addition, the nature of a value type instance guarantees it can never be null, so a <code>NullReferenceException</code> will never be thrown. Finally, if you were to call a value typeâ€™s virtual method virtually, the CLR would need to have a reference to the value typeâ€™s type object in order to refer to the method table within it. This requires boxing the value type. Boxing puts more pressure on the heap, forcing more frequent garbage collections and hurting performance.</p></blockquote><blockquote><p>Regardless of whether call or callvirt is used to call an instance or virtual method, these methods always receive a hidden this argument as the methodâ€™s first parameter. The this argument refers to the object being operated on.</p></blockquote><blockquote><p>When designing a type, you should try to minimize the number of virtual methods you define. First, calling a virtual method is slower than calling a nonvirtual method. Second, virtual methods cannot be inlined by the JIT compiler, which further hurts performance. Third, virtual methods make versioning of components more brittle, as described in the next section. Fourth, when defining a base type, it is common to offer a set of convenience overloaded methods. If you want these methods to be polymorphic, the best thing to do is to make the most complex method virtual and leave all of the convenience overloaded methods nonvirtual. By the way, following this guideline will also improve the ability to version a component without adversely affecting the derived types. Here is an example.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Set</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// This convenience overload is not virtual </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token class-name">Object</span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">return</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token keyword">value</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> m_length<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// This convenience overload is not virtual </span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token class-name">Object</span> <span class="token keyword">value</span><span class="token punctuation">,</span> <span class="token class-name">Int32</span> startIndex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">return</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token keyword">value</span><span class="token punctuation">,</span> startIndex<span class="token punctuation">,</span> m_length <span class="token operator">-</span> startIndex<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// The most feature-rich method is virtual and can be overridden</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token return-type class-name">Int32</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token class-name">Object</span> <span class="token keyword">value</span><span class="token punctuation">,</span> <span class="token class-name">Int32</span> startIndex<span class="token punctuation">,</span> <span class="token class-name">Int32</span> endIndex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token comment">// Actual implementation that can be overridden goes here... </span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// Other methods go here </span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="using-type-visibility-and-member-accessibility-intelligently"><a class="anchor" href="#using-type-visibility-and-member-accessibility-intelligently">#</a> Using Type Visibility and Member Accessibility Intelligently</h3><blockquote><p>With the .NET Framework, applications are composed of types defined in multiple assemblies produced by various companies. This means that the developer has little control over the components he or she is using and the types defined within those components. The developer typically doesnâ€™t have access to the source code (and probably doesnâ€™t even know what programming language was used to create the component), and components tend to version with different schedules. Furthermore, due to polymorphism and protected members, a base class developer must trust the code written by the derived class developer. And, of course, the developer of a derived class must trust the code that he is inheriting from a base class. These are just some of the issues that you need to really think about when designing components and types.</p></blockquote><blockquote><p>In this section, Iâ€™d like to say just a few words about how to design a type with these issues in mind. Specifically, Iâ€™m going to focus on the proper way to set type visibility and member accessibility so that youâ€™ll be most successful.</p></blockquote><blockquote><p>First, when defining a new type, compilers should make the class sealed by default so that the class cannot be used as a base class. Instead, many compilers, including C#, default to unsealed classes and allow the programmer to explicitly mark a class as sealed by using the sealed keyword. Obviously, it is too late now, but I think that todayâ€™s compilers have chosen the wrong default and it would be nice if this could change with future compilers. There are three reasons why a sealed class is better than an unsealed class:</p><ul><li><p><strong>Versioning</strong> When a class is originally sealed, it can change to unsealed in the future without breaking compatibility. However, after a class is unsealed, you can never change it to sealed in the future as this would break all derived classes. In addition, if the unsealed class defines any unsealed virtual methods, ordering of the virtual method calls must be maintained with new versions or there is the potential of breaking derived types in the future.</p></li><li><p><strong>Performance</strong> As discussed in the previous section, calling a virtual method doesnâ€™t perform as well as calling a nonvirtual method because the CLR must look up the type of the object at run time in order to determine which type defines the method to call. However, if the JIT compiler sees a call to a virtual method using a sealed type, the JIT compiler can produce more efficient code by calling the method nonvirtually. It can do this because it knows there canâ€™t possibly be a derived class if the class is sealed. For example, in the code below, the JIT compiler can call the virtual <code>ToString</code> method nonvirtually.</p></li></ul><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_x<span class="token punctuation">,</span> m_y<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> x<span class="token punctuation">,</span> <span class="token class-name">Int32</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> m_x <span class="token operator">=</span> x<span class="token punctuation">;</span> m_y <span class="token operator">=</span> y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name">String</span> <span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">return</span> String<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"(&#123;0&#125;, &#123;1&#125;)"</span><span class="token punctuation">,</span> m_x<span class="token punctuation">,</span> m_y<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token class-name">Point</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Point</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// The C# compiler emits the callvirt instruction here but the </span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// JIT compiler will optimize this call and produce code that </span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// calls ToString nonvirtually because p's type is Point, </span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token comment">// which is a sealed class </span></pre></td></tr><tr><td data-num="14"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li><strong>Security and predictability</strong> A class must protect its own state and not allow itself to ever become corrupted. When a class is unsealed, a derived class can access and manipulate the base classâ€™s state if any data fields or methods that internally manipulate fields are accessible and not private. In addition, a virtual method can be overridden by a derived class, and the derived class can decide whether to call the base classâ€™s implementation. By making a method, property, or event virtual, the base class is giving up some control over its behavior and its state. Unless carefully thought out, this can cause the object to behave unpredictably, and it opens up potential security holes.</li></ul></blockquote><blockquote><p>The problem with a sealed class is that it can be a big inconvenience to users of the type. Occasionally, developers want to create a class derived from an existing type in order to attach some additional fields or state information for their applicationâ€™s own use. In fact, they may even want to define some helper or convenience methods on the derived type to manipulate these additional fields. Although the CLR offers no mechanism to extend an already-built type with helper methods or fields, you can simulate helper methods by using C#â€™s extension methods (discussed in Chapter 8) and you can simulate tacking state onto an object by using the <code>ConditionalWeakTable</code> class (discussed in Chapter 21, â€œThe Managed Heap and Garbage Collection.â€</p></blockquote><blockquote><p>Here are the guidelines I follow when I define my own classes:</p><ul><li><p>When defining a class, I always explicitly make it sealed unless I truly intend for the class to be a base class that allows specialization by derived classes. As stated earlier, this is the opposite of what C# and many other compilers default to today. I also default to making the class internal unless I want the class to be publicly exposed outside of my assembly. Fortunately, if you do not explicitly indicate a typeâ€™s visibility, the C# compiler defaults to internal. If I really feel that it is important to define a class that others can derive but I do not want to allow specialization, I will simulate creating a closed class by using the above technique of sealing the virtual methods that my class inherits.</p></li><li><p>Inside the class, I always define my data fields as private and I never waver on this. Fortunately, C# does default to making fields private. Iâ€™d actually prefer it if C# mandated that all fields be private and that you could not make fields protected, internal, public, and so on. Exposing state is the easiest way to get into problems, have your object behave unpredictably, and open potential security holes. This is true even if you just declare some fields as internal. Even within a single assembly, it is too hard to track all code that references a field, especially if several developers are writing code that gets compiled into the same assembly.</p></li><li><p>Inside the class, I always define my methods, properties, and events as private and nonvirtual. Fortunately, C# defaults to this as well. Certainly, Iâ€™ll make a method, property, or event public to expose some functionality from the type. I try to avoid making any of these members protected or internal, because this would be exposing my type to some potential vulnerability. However, I would sooner make a member protected or internal than I would make a member virtual because a virtual member gives up a lot of control and really relies on the proper behavior of the derived class.</p></li><li><p>There is an old OOP adage that goes like this: when things get too complicated, make more types. When an implementation of some algorithm starts to get complicated, I define helper types that encapsulate discrete pieces of functionality. If Iâ€™m defining these helper types for use by a single super-type, Iâ€™ll define the helper types nested within the super-type. This allows for scoping and also allows the code in the nested, helper type to reference the private members defined in the super-type. However, there is a design guideline rule, enforced by the Code Analysis tool (FxCopCmd.exe) in Visual Studio, which indicates that publicly exposed nested types should be defined at file or assembly scope and not be defined within another type. This rule exists because some developers find the syntax for referencing nested types cumbersome. I appreciate this rule, and I never define public nested types.</p></li></ul></blockquote><h3 id="dealing-with-virtual-methods-when-versioning-types"><a class="anchor" href="#dealing-with-virtual-methods-when-versioning-types">#</a> Dealing with Virtual Methods When Versioning Types</h3><blockquote><p>As was stated earlier, in a Component Software Programming environment, versioning is a very important issue. I talked about some of these versioning issues in Chapter 3, â€œShared Assemblies and Strongly Named Assemblies,â€ when I explained strongly named assemblies and discussed how an administrator can ensure that an application binds to the assemblies that it was built and tested with. However, other versioning issues cause source code compatibility problems. For example, you must be very careful when adding or modifying members of a type if that type is used as a base type. Letâ€™s look at some examples.</p></blockquote><blockquote><p>CompanyA has designed the following type, Phone.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">namespace</span> <span class="token namespace">CompanyA</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Phone</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dial</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Phone.Dial"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// Do work to dial the phone here. </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Now imagine that CompanyB defines another type, BetterPhone, which uses CompanyAâ€™s Phone type as its base.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">namespace</span> <span class="token namespace">CompanyB</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BetterPhone</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">CompanyA<span class="token punctuation">.</span>Phone</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dial</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"BetterPhone.Dial"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token function">EstablishConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">protected</span> <span class="token keyword">virtual</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">EstablishConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"BetterPhone.EstablishConnection"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// Do work to establish the connection. </span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When CompanyB attempts to compile its code, the C# compiler issues the following message.</p></blockquote><pre><code>warning CS0108: 'CompanyB.BetterPhone.Dial()' hides inherited member 'CompanyA.Phone.Dial()'.
</code></pre><blockquote><p>Use the new keyword if hiding was intended.â€ This warning is notifying the developer that BetterPhone is defining a Dial method, which will hide the Dial method defined in Phone. This new method could change the semantic meaning of Dial (as defined by CompanyA when it originally created the Dial method).</p></blockquote><blockquote><p>Itâ€™s a very nice feature of the compiler to warn you of this potential semantic mismatch. The compiler also tells you how to remove the warning by adding the new keyword before the definition of Dial in the BetterPhone class. Hereâ€™s the fixed BetterPhone class.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">namespace</span> <span class="token namespace">CompanyB</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BetterPhone</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">CompanyA<span class="token punctuation">.</span>Phone</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// This Dial method has nothing to do with Phone's Dial method. </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">new</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dial</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"BetterPhone.Dial"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token function">EstablishConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">protected</span> <span class="token keyword">virtual</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">EstablishConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"BetterPhone.EstablishConnection"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// Do work to establish the connection. </span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>At this point, CompanyB can use BetterPhone.Dial in its application. Hereâ€™s some sample code that CompanyB might write.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">CompanyB<span class="token punctuation">.</span>BetterPhone</span> phone <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">CompanyB<span class="token punctuation">.</span>BetterPhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> phone<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When this code runs, the following output is displayed.</p></blockquote><pre><code>BetterPhone.Dial
BetterPhone.EstablishConnection
Phone.Dial
</code></pre><blockquote><p>This output shows that CompanyB is getting the behavior it desires. The call to Dial is calling the new Dial method defined by BetterPhone, which calls the virtual <code>EstablishConnection</code> method and then calls the Phone base typeâ€™s Dial method.</p></blockquote><blockquote><p>Now letâ€™s imagine that several companies have decided to use CompanyAâ€™s Phone type. Letâ€™s further imagine that these other companies have decided that the ability to establish a connection in the Dial method is a really useful feature. This feedback is given to CompanyA, which now revises its Phone class.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">namespace</span> <span class="token namespace">CompanyA</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Phone</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dial</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Phone.Dial"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token function">EstablishConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Do work to dial the phone here. </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">protected</span> <span class="token keyword">virtual</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">EstablishConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Phone.EstablishConnection"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// Do work to establish the connection. </span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Now when CompanyB compiles its BetterPhone type (derived from this new version of CompanyAâ€™s Phone), the compiler issues this message.</p></blockquote><pre><code>warning CS0114: 'CompanyB.BetterPhone.EstablishConnection()' hides inherited member 'CompanyA.
Phone.EstablishConnection()'. To make the current member override that implementation, add the 
override keyword. Otherwise, add the new keyword.
</code></pre><blockquote><p>The compiler is alerting you to the fact that both Phone and BetterPhone offer an EstablishConnection method and that the semantics of both might not be identical; simply recompiling BetterPhone can no longer give the same behavior as it did when using the first version of the Phone type.</p></blockquote><blockquote><p>If CompanyB decides that the EstablishConnection methods are not semantically identical in both types, CompanyB can tell the compiler that the Dial and EstablishConnection method defined in BetterPhone is the correct method to use and that it has no relationship with the EstablishConnection method defined in the Phone base type. CompanyB informs the compiler of this by adding the new keyword to the EstablishConnection method.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">namespace</span> <span class="token namespace">CompanyB</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BetterPhone</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">CompanyA<span class="token punctuation">.</span>Phone</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// Keep 'new' to mark this method as having no </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// relationship to the base type's Dial method. </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">new</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dial</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"BetterPhone.Dial"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token function">EstablishConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// Add 'new' to mark this method as having no </span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// relationship to the base type's EstablishConnection method. </span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">protected</span> <span class="token keyword">new</span> <span class="token keyword">virtual</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">EstablishConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"BetterPhone.EstablishConnection"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token comment">// Do work to establish the connection. </span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In this code, the new keyword tells the compiler to emit metadata, making it clear to the CLR that BetterPhoneâ€™s EstablishConnection method is intended to be treated as a new function that is introduced by the BetterPhone type. The CLR will know that there is no relationship between Phoneâ€™s and BetterPhoneâ€™s methods.</p></blockquote><blockquote><p>When the same application code (in the Main method) executes, the output is as follows.</p></blockquote><pre><code>BetterPhone.Dial
BetterPhone.EstablishConnection
Phone.Dial
Phone.EstablishConnection
</code></pre><blockquote><p>This output shows that Mainâ€™s call to Dial calls the new Dial method defined by BetterPhone.Dial, which in turn calls the virtual <code>EstablishConnection</code> method that is also defined by BetterPhone. When BetterPhoneâ€™s <code>EstablishConnection</code> method returns, Phoneâ€™s Dial method is called. Phoneâ€™s Dial method calls <code>EstablishConnection</code> , but because BetterPhoneâ€™s <code>EstablishConnection</code> is marked with new, BetterPhoneâ€™s <code>EstablishConnection</code> method isnâ€™t considered an override of Phoneâ€™s virtual <code>EstablishConnection</code> method. As a result, Phoneâ€™s Dial method calls Phoneâ€™s <code>EstablishConnection</code> methodâ€”this is the expected behavior.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šå¦‚æœç¼–è¯‘å™¨åƒåŸç”Ÿ C++ ç¼–è¯‘å™¨é‚£æ ·é»˜è®¤å°†æ–¹æ³•è§†ä¸ºé‡å†™ï¼Œ <code>BetterPhone</code> çš„å¼€å‘è€…å°±ä¸èƒ½ä½¿ç”¨ <code>Dial</code> å’Œ <code>EstablishConnection</code> æ–¹æ³•åäº†ã€‚è¿™ææœ‰å¯èƒ½é€ æˆæ•´ä¸ªæºä»£ç  base çš„è¿é”ååº”ï¼Œç ´åæºä»£ç å’ŒäºŒè¿›åˆ¶å…¼å®¹æ€§ã€‚è¿™ç§æ³¢åŠé¢å¤ªå¤§çš„æ”¹å˜æ˜¯æˆ‘ä»¬ä¸å¸Œæœ›çš„ï¼Œå°¤å…¶æ˜¯ä¸­å¤§å‹çš„é¡¹ç›®ã€‚ä½†æ˜¯ï¼Œå¦‚æœæ›´æ”¹æ–¹æ³•ååªä¼šé€ æˆæºä»£ç å‘ç”Ÿé€‚åº¦æ›´æ–°ï¼Œå°±åº”è¯¥æ›´æ”¹æ–¹æ³•åï¼Œé¿å… <code>Dial</code> å’Œ <code>EstablishConnection</code> æ–¹æ³•çš„ä¸¤ç§ä¸åŒçš„å«ä¹‰ä½¿å¼€å‘äººå‘˜äº§ç”Ÿæ··æ·†ã€‚</p><blockquote><p>Alternatively, CompanyB could have gotten the new version of CompanyAâ€™s Phone type and decided that Phoneâ€™s semantics of Dial and EstablishConnection are exactly what itâ€™s been looking for. In this case, CompanyB would modify its BetterPhone type by removing its Dial method entirely. In addition, because CompanyB now wants to tell the compiler that BetterPhoneâ€™s EstablishConnection method is related to Phoneâ€™s EstablishConnection method, the new keyword must be removed. Simply removing the new keyword isnâ€™t enough, though, because now the compiler canâ€™t tell exactly what the intention is of BetterPhoneâ€™s EstablishConnection method. To express his intent exactly, the CompanyB developer must also change BetterPhoneâ€™s EstablishConnection method from virtual to override. The following code shows the new version of BetterPhone.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">namespace</span> <span class="token namespace">CompanyB</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BetterPhone</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">CompanyA<span class="token punctuation">.</span>Phone</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// Delete the Dial method (inherit Dial from base). </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// Remove 'new' and change 'virtual' to 'override' to </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// mark this method as having a relationship to the base </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// type's EstablishConnection method. </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">protected</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">EstablishConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"BetterPhone.EstablishConnection"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// Do work to establish the connection. </span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Now when the same application code (in the Main method) executes, the output is as follows.</p></blockquote><pre><code>Phone.Dial
BetterPhone.EstablishConnection
</code></pre><blockquote><p>This output shows that Mainâ€™s call to Dial calls the Dial method defined by Phone and inherited by BetterPhone. Then when Phoneâ€™s Dial method calls the virtual EstablishConnection method, BetterPhoneâ€™s EstablishConnection method is called because it overrides the virtual EstablishConnection method defined by Phone.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šç»„ä»¶è½¯ä»¶ç¼–ç¨‹ï¼ˆComponent Software Programmingï¼ŒCSPï¼‰æ˜¯ OOP å‘å±•åˆ°æè‡´çš„æˆæœã€‚ç‰ˆæœ¬æ§åˆ¶ä½¿ CSP çš„å¤æ‚æ€§ä¸Šå‡åˆ°äº† OOP æ— æ³•ä¼åŠçš„é«˜åº¦ã€‚.NET Framework å°†ç‰ˆæœ¬å·åˆ†ä¸ºäº† 4 ä¸ªéƒ¨åˆ†ï¼šä¸»ç‰ˆæœ¬å·ï¼ˆmajor versionï¼‰ã€æ¬¡ç‰ˆæœ¬å·ï¼ˆminor versionï¼‰ã€å†…éƒ¨ç‰ˆæœ¬å·ï¼ˆbuild numberï¼‰å’Œä¿®è®¢å·ï¼ˆrevisionï¼‰ã€‚major/minor éƒ¨åˆ†é€šå¸¸ä»£è¡¨ç¨‹åºé›†çš„ä¸€ä¸ªè¿ç»­çš„ã€ç¨³å®šçš„åŠŸèƒ½é›†ï¼Œè€Œ build/revision éƒ¨åˆ†é€šå¸¸ä»£è¡¨å¯¹è¿™ä¸ªåŠŸèƒ½é›†çš„ä¸€æ¬¡ç»´æŠ¤ã€‚å°†ä¸€ä¸ªç»„ä»¶ï¼ˆç¨‹åºé›†ï¼‰ä¸­å®šä¹‰çš„ç±»å‹ä½œä¸ºå¦ä¸€ä¸ªç»„ä»¶ï¼ˆç¨‹åºé›†ï¼‰ä¸­çš„ä¸€ä¸ªç±»å‹çš„åŸºç±»ä½¿ç”¨æ—¶ï¼Œä¾¿ä¼šå‘ç”Ÿç‰ˆæœ¬æ§åˆ¶é—®é¢˜ã€‚å¦‚æœåŸºç±»çš„ç‰ˆæœ¬ï¼ˆè¢«ä¿®æ”¹å¾—ï¼‰ä½äºæ´¾ç”Ÿç±»ï¼Œæ´¾ç”Ÿç±»çš„è¡Œä¸ºä¹Ÿä¼šæ”¹å˜ï¼Œè¿™å¯èƒ½é€ æˆç±»çš„è¡Œä¸ºå¤±å¸¸ã€‚åœ¨å¤šæ€æƒ…å½¢ä¸­ï¼Œç”±äºæ´¾ç”Ÿç±»å‹ä¼šé‡å†™åŸºç±»å‹å®šä¹‰çš„è™šæ–¹æ³•ï¼Œæ‰€ä»¥è¿™ä¸ªé—®é¢˜æ˜¾å¾—å°¤å…¶çªå‡ºã€‚CLR å…è®¸ç±»å‹å®šä¹‰å¤šä¸ªåŒåæ–¹æ³•ï¼Œåªè¦æ¯ä¸ªæ–¹æ³•éƒ½æœ‰ä¸€ç»„ä¸åŒçš„å‚æ•°æˆ–è€…ä¸€ä¸ªä¸åŒçš„è¿”å›ç±»å‹ã€‚ä½†é™¤äº† IL æ±‡ç¼–è¯­è¨€ï¼Œå¤§å¤šæ•°è¯­è¨€ï¼ˆåŒ…æ‹¬ C#ï¼‰åœ¨åˆ¤æ–­æ–¹æ³•çš„å”¯ä¸€æ€§æ—¶ï¼Œé™¤äº†æ–¹æ³•åä¹‹å¤–ï¼Œéƒ½åªä»¥å‚æ•°ä¸ºå‡†ï¼Œæ–¹æ³•è¿”å›ç±»å‹ä¼šè¢«å¿½ç•¥ã€‚CLR æä¾›äº†ä¸¤ä¸ªæ–¹æ³•è°ƒç”¨æŒ‡ä»¤ï¼Œåˆ†åˆ«æ˜¯ <code>call</code> å’Œ <code>callvirt</code> ã€‚å…¶ä¸­ <code>call</code> å¯è°ƒç”¨é™æ€æ–¹æ³•ã€å®ä¾‹æ–¹æ³•å’Œè™šæ–¹æ³•ï¼Œç”¨ <code>call</code> æŒ‡ä»¤è°ƒç”¨é™æ€æ–¹æ³•æ—¶æŒ‡å®šæ–¹æ³•å®šä¹‰çš„ç±»å‹ï¼Œè°ƒç”¨å®ä¾‹æ–¹æ³•æˆ–è™šæ–¹æ³•æ—¶ä¼šå‡è®¾å˜é‡ä¸ä¸º nullã€‚ <code>callvirt</code> å¯è°ƒç”¨å®ä¾‹æ–¹æ³•å’Œè™šæ–¹æ³•ï¼Œä¸èƒ½è°ƒç”¨é™æ€æ–¹æ³•ã€‚ <code>callvirt</code> æ— è®ºæ—¶è°ƒç”¨å®ä¾‹æ–¹æ³•è¿˜æ˜¯è™šæ–¹æ³•éƒ½ä¼šæ£€æŸ¥å˜é‡æ˜¯ä¸æ˜¯ nullï¼Œæ­£æ˜¯ç”±äºæœ‰è¿™ç§é¢å¤–çš„æ£€æŸ¥ï¼Œæ‰€ä»¥ <code>callvirt</code> æŒ‡ä»¤çš„æ‰§è¡Œé€Ÿåº¦æ¯” <code>call</code> æŒ‡ä»¤ç¨æ…¢ã€‚è°ƒç”¨å®ä¾‹æ–¹æ³•æˆ–è€…è™šæ–¹æ³•æ—¶ï¼ŒJIT ç¼–è¯‘å™¨æ€»æ˜¯ä¼šè°ƒç”¨ <code>callvirt</code> æ¥éªŒè¯å‘å‡ºè°ƒç”¨çš„å¯¹è±¡ä¸ä¸º nullï¼Œé™¤éç¼–è¯‘å™¨è¦ç¡®ä¿ä»¥éè™šæ–¹å¼è°ƒç”¨åŸºç±»æ–¹æ³•çš„æ—¶å€™ã€‚ç¼–è¯‘å™¨è°ƒç”¨å€¼ç±»å‹å®šä¹‰çš„æ–¹æ³•æ—¶å€¾å‘äºä½¿ç”¨ <code>call</code> æŒ‡ä»¤ï¼Œå› ä¸ºå€¼ç±»å‹æ—¶å¯†å°çš„ã€‚è¿™æ„å‘³ç€å³ä½¿å€¼ç±»å‹å«æœ‰è™šæ–¹æ³•ä¹Ÿä¸ç”¨è€ƒè™‘å¤šæ€æ€§ï¼Œè¿™ä½¿è°ƒç”¨æ›´å¿«ã€‚æ­¤å¤–ï¼Œå€¼ç±»å‹å®ä¾‹çš„æœ¬è´¨ä¿è¯å®ƒæ°¸ä¸ä¸º nullï¼Œæ‰€ä»¥æ°¸è¿œä¸æŠ›å‡º <code>NullReferenceException</code> å¼‚å¸¸ã€‚æœ€åï¼Œå¦‚æœä»¥è™šæ–¹å¼è°ƒç”¨å€¼ç±»å‹ä¸­çš„è™šæ–¹æ³•ï¼ŒCLR è¦è·å–å¯¹å€¼ç±»å‹çš„ç±»å‹å¯¹è±¡çš„å¼•ç”¨ï¼Œä»¥ä¾¿å¼•ç”¨ï¼ˆç±»å‹å¯¹è±¡ä¸­çš„ï¼‰æ–¹æ³•è¡¨ï¼Œè¿™è¦æ±‚å¯¹å€¼ç±»å‹è£…ç®±ã€‚æ— è®ºç”¨ <code>call</code> è¿˜æ˜¯ <code>callvirt</code> è°ƒç”¨å®ä¾‹æ–¹æ³•æˆ–è™šæ–¹æ³•ï¼Œè¿™äº›æ–¹æ³•é€šå¸¸æ¥æ”¶éšè—çš„ <code>this</code> å®å‚ä½œä¸ºæ–¹æ³•ç¬¬ä¸€ä¸ªå‚æ•°ã€‚ <code>this</code> å®å‚å¼•ç”¨è¦æ“ä½œçš„å¯¹è±¡ã€‚è®¾è®¡ç±»å‹æ—¶åº”å°½é‡å‡å°‘è™šæ–¹æ³•çš„æ•°é‡ã€‚å¦‚æœå¸Œæœ›è¿™äº›æ–¹æ³•æ˜¯å¤šæ€çš„ï¼Œæœ€å¥½çš„åŠæ³•å°±æ˜¯ä½¿æœ€å¤æ‚çš„æ–¹æ³•æˆä¸ºè™šæ–¹æ³•ï¼Œä½¿æ‰€æœ‰é‡è½½çš„ç®€ä¾¿æ–¹æ³•æˆä¸ºéè™šæ–¹æ³•ã€‚</p><div class="tags"><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> è¯»ä¹¦ç¬”è®°</a> <a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C#</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2022-12-02 19:56:21" itemprop="dateModified" datetime="2022-12-02T19:56:21+08:00">2022-12-02</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(ï¿£â–½ï¿£)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Sakupinera WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Sakupinera Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Sakupinera PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Sakupinera <i class="ic i-at"><em>@</em></i>Sakupinera</li><li class="link"><strong>Post link: </strong><a href="http://sakupinera.github.io/2022/10/21/csharp/clr-via-csharp/Chapter%206%20Type%20and%20Member%20Basics/" title="CLR via C# - Chapter 6 Type and Member Basics">http://sakupinera.github.io/2022/10/21/csharp/clr-via-csharp/Chapter 6 Type and Member Basics/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giph4baakhj20zk0m8h5q.jpg" title="CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals</h3></a></div><div class="item right"><a href="/2022/10/21/computer-graphics/games101/%E6%B8%B2%E6%9F%93%E4%B8%AD%E7%9A%84%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclx6phq6j20zk0m8e36.jpg" title="GAMES101 - Advanced Topics in Renderingï¼ˆæ¸²æŸ“ä¸­çš„é«˜çº§ä¸»é¢˜ï¼‰"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i> GAMES101</span><h3>GAMES101 - Advanced Topics in Renderingï¼ˆæ¸²æŸ“ä¸­çš„é«˜çº§ä¸»é¢˜ï¼‰</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-6-type-and-member-basics"><span class="toc-number">1.</span> <span class="toc-text">Chapter 6 Type and Member Basics</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#the-different-kinds-of-type-members"><span class="toc-number">1.1.</span> <span class="toc-text">The Different Kinds of Type Members</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-visibility"><span class="toc-number">1.2.</span> <span class="toc-text">Type Visibility</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#friend-assemblies"><span class="toc-number">1.2.1.</span> <span class="toc-text">Friend Assemblies</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#member-accessibility"><span class="toc-number">1.3.</span> <span class="toc-text">Member Accessibility</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static-classes"><span class="toc-number">1.4.</span> <span class="toc-text">Static Classes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#partial-classes-structures-and-interfaces"><span class="toc-number">1.5.</span> <span class="toc-text">Partial Classes, Structures, and Interfaces</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#components-polymorphism-and-versioning"><span class="toc-number">1.6.</span> <span class="toc-text">Components, Polymorphism, and Versioning</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#how-the-clr-calls-virtual-methods-properties-and-events"><span class="toc-number">1.6.1.</span> <span class="toc-text">How the CLR Calls Virtual Methods, Properties, and Events</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#using-type-visibility-and-member-accessibility-intelligently"><span class="toc-number">1.6.2.</span> <span class="toc-text">Using Type Visibility and Member Accessibility Intelligently</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dealing-with-virtual-methods-when-versioning-types"><span class="toc-number">1.6.3.</span> <span class="toc-text">Dealing with Virtual Methods When Versioning Types</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"><ul><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/" rel="bookmark" title="CLR via C# - Chapter 1 The CLRâ€™s Execution Model">CLR via C# - Chapter 1 The CLRâ€™s Execution Model</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/" rel="bookmark" title="CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types">CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%203%20Shared%20Assemblies%20and%20Strongly%20Named%20Assemblies/" rel="bookmark" title="CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies">CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies</a></li><li><a href="/2022/09/27/csharp/clr-via-csharp/Chapter%204%20Type%20Fundamentals/" rel="bookmark" title="CLR via C# - Chapter 4 Type Fundamentals">CLR via C# - Chapter 4 Type Fundamentals</a></li><li><a href="/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/" rel="bookmark" title="CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals">CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals</a></li><li class="active"><a href="/2022/10/21/csharp/clr-via-csharp/Chapter%206%20Type%20and%20Member%20Basics/" rel="bookmark" title="CLR via C# - Chapter 6 Type and Member Basics">CLR via C# - Chapter 6 Type and Member Basics</a></li><li><a href="/2022/10/24/csharp/clr-via-csharp/Chapter%207%20Constants%20and%20Fields/" rel="bookmark" title="CLR via C# - Chapter 7 Constants and Fields">CLR via C# - Chapter 7 Constants and Fields</a></li><li><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" rel="bookmark" title="CLR via C# - Chapter 8 Methods">CLR via C# - Chapter 8 Methods</a></li><li><a href="/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/" rel="bookmark" title="CLR via C# - Chapter 9 Parameters">CLR via C# - Chapter 9 Parameters</a></li><li><a href="/2022/10/28/csharp/clr-via-csharp/Chapter%2010%20Properties/" rel="bookmark" title="CLR via C# - Chapter 10 Properties">CLR via C# - Chapter 10 Properties</a></li><li><a href="/2022/10/29/csharp/clr-via-csharp/Chapter%2011%20Events/" rel="bookmark" title="CLR via C# - Chapter 11 Events">CLR via C# - Chapter 11 Events</a></li><li><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" rel="bookmark" title="CLR via C# - Chapter 12 Generics">CLR via C# - Chapter 12 Generics</a></li><li><a href="/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/" rel="bookmark" title="CLR via C# - Chapter 13 Interfaces">CLR via C# - Chapter 13 Interfaces</a></li><li><a href="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/" rel="bookmark" title="CLR via C# - Chapter 14 Chars, Strings, and Working with Text">CLR via C# - Chapter 14 Chars, Strings, and Working with Text</a></li><li><a href="/2022/11/17/csharp/clr-via-csharp/Chapter%2015%20Enumerated%20Types%20and%20Bit%20Flags/" rel="bookmark" title="CLR via C# - Chapter 15 Enumerated Types and Bit Flags">CLR via C# - Chapter 15 Enumerated Types and Bit Flags</a></li><li><a href="/2022/11/19/csharp/clr-via-csharp/Chapter%2016%20Arrays/" rel="bookmark" title="CLR via C# - Chapter 16 Arrays">CLR via C# - Chapter 16 Arrays</a></li><li><a href="/2022/11/21/csharp/clr-via-csharp/Chapter%2017%20Delegates/" rel="bookmark" title="CLR via C# - Chapter 17 Delegates">CLR via C# - Chapter 17 Delegates</a></li><li><a href="/2022/11/22/csharp/clr-via-csharp/Chapter%2018%20Custom%20Attributes/" rel="bookmark" title="CLR via C# - Chapter 18 Custom Attributes">CLR via C# - Chapter 18 Custom Attributes</a></li><li><a href="/2022/11/23/csharp/clr-via-csharp/Chapter%2019%20Nullable%20Value%20Types/" rel="bookmark" title="CLR via C# - Chapter 19 Nullable Value Types">CLR via C# - Chapter 19 Nullable Value Types</a></li><li><a href="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/" rel="bookmark" title="CLR via C# - Chapter 20 Exceptions and State Management">CLR via C# - Chapter 20 Exceptions and State Management</a></li><li><a href="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/" rel="bookmark" title="CLR via C# - Chapter 21 The Managed Heap and Garbage  Collection">CLR via C# - Chapter 21 The Managed Heap and Garbage Collection</a></li><li><a href="/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/" rel="bookmark" title="CLR via C# - Chapter 22 CLR Hosting and AppDomains">CLR via C# - Chapter 22 CLR Hosting and AppDomains</a></li><li><a href="/2022/11/29/csharp/clr-via-csharp/Chapter%2023%20Assembly%20Loading%20and%20Reflection/" rel="bookmark" title="CLR via C# - Chapter 23 Assembly Loading and Reflection">CLR via C# - Chapter 23 Assembly Loading and Reflection</a></li><li><a href="/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/" rel="bookmark" title="CLR via C# - Chapter 24 Runtime Serialization">CLR via C# - Chapter 24 Runtime Serialization</a></li><li><a href="/2022/12/06/csharp/clr-via-csharp/Chapter%2025%20Interoperating%20with%20WinRT%20%20Components/" rel="bookmark" title="CLR via C# - Chapter 25 Interoperating with WinRT Components">CLR via C# - Chapter 25 Interoperating with WinRT Components</a></li><li><a href="/2023/02/06/csharp/clr-via-csharp/Chapter%2026%20Thread%20Basics/" rel="bookmark" title="CLR via C# - Chapter 26 Thread Basics">CLR via C# - Chapter 26 Thread Basics</a></li><li><a href="/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations">CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations</a></li><li><a href="/2023/02/08/csharp/clr-via-csharp/Chapter%2028%20IO-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 28 IO-Bound Asynchronous Operations">CLR via C# - Chapter 28 IO-Bound Asynchronous Operations</a></li><li><a href="/2023/02/09/csharp/clr-via-csharp/Chapter%2029%20Primitive%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 29 Primitive Thread Synchronization">CLR via C# - Chapter 29 Primitive Thread Synchronization</a></li><li><a href="/2023/02/10/csharp/clr-via-csharp/Chapter%2030%20Hybrid%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 30 Hybrid Thread Synchronization">CLR via C# - Chapter 30 Hybrid Thread Synchronization</a></li></ul></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sakupinera" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Sakupinera</p><div class="description" itemprop="description">ä¿æŒä½ çš„å†³å¿ƒï¼</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">89</span> <span class="name">posts</span></a></div><div class="item categories"><a href="/categories/"><span class="count">17</span> <span class="name">categories</span></a></div><div class="item tags"><a href="/tags/"><span class="count">8</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nha3VwaW5lcmE=" title="https:&#x2F;&#x2F;github.com&#x2F;sakupinera"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9zYWt1cGluZXJh" title="https:&#x2F;&#x2F;twitter.com&#x2F;sakupinera"><i class="ic i-twitter"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQwNzIyOTA3MQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;407229071"><i class="ic i-cloud-music"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMjIzMDczOTg/c3BtX2lkX2Zyb209MzMzLjEwMDcuMC4w" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;22307398?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li><li class="item"><a href="/games/" rel="section"><i class="ic i-flag"></i>games</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-person"></i>About</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/10/21/computer-graphics/games101/%E6%B8%B2%E6%9F%93%E4%B8%AD%E7%9A%84%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2022/12/11/cpp/cpp-primer/Chapter%203%20Strings,%20Vectors,%20and%20Arrays/" title="C++ Primer - Chapter 3 Strings, Vectors, and Arrays">C++ Primer - Chapter 3 Strings, Vectors, and Arrays</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/09/05/linux/learn-linux/%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/" title="LearnLinux - æ—¥å¿—ç®¡ç†">LearnLinux - æ—¥å¿—ç®¡ç†</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/" title="CLR via C# - Chapter 21 The Managed Heap and Garbage  Collection">CLR via C# - Chapter 21 The Managed Heap and Garbage Collection</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/08/28/linux/learn-linux/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="LearnLinux - Linuxå¸¸ç”¨å‘½ä»¤">LearnLinux - Linuxå¸¸ç”¨å‘½ä»¤</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/" title="CLR via C# - Chapter 24 Runtime Serialization">CLR via C# - Chapter 24 Runtime Serialization</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CSharp-in-a-Nutshell/" title="In CSharp-in-a-Nutshell">CSharp-in-a-Nutshell</a></div><span><a href="/2022/08/29/csharp/csharp-in-a-nutshell/%E7%AC%AC2%E7%AB%A0%20%E5%9C%A8CSharp%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%9E%8B/" title="C# in a Nutshell - ç¬¬2ç«  C#è¯­è¨€åŸºç¡€">C# in a Nutshell - ç¬¬2ç«  C#è¯­è¨€åŸºç¡€</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2023/02/09/csharp/clr-via-csharp/Chapter%2029%20Primitive%20Thread%20Synchronization%20Constructs/" title="CLR via C# - Chapter 29 Primitive Thread Synchronization">CLR via C# - Chapter 29 Primitive Thread Synchronization</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" title="CLR via C# - Chapter 8 Methods">CLR via C# - Chapter 8 Methods</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2023/08/20/computer-graphics/games101/%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/" title="GAMES101 - Color and Perceptionï¼ˆé¢œè‰²ä¸æ„ŸçŸ¥ï¼‰">GAMES101 - Color and Perceptionï¼ˆé¢œè‰²ä¸æ„ŸçŸ¥ï¼‰</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/09/02/linux/learn-linux/Shell%E5%9F%BA%E7%A1%80/" title="LearnLinux - ShellåŸºç¡€">LearnLinux - ShellåŸºç¡€</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 â€“ <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Sakupinera @ Hanamai Sora</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="Symbols count total">2.2m words</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="Reading time total">34:05</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/10/21/csharp/clr-via-csharp/Chapter 6 Type and Member Basics/",favicon:{show:"ï¼ˆâ—Â´3ï½€â—ï¼‰Goooood",hide:"(Â´Ğ”ï½€)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/shifuku.model.json"},display:{position:"left",width:250,height:500},mobile:{show:!1},react:{opacity:.9},log:!1})</script></body></html>