<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sakupinera" href="http://sakupinera.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sakupinera" href="http://sakupinera.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sakupinera" href="http://sakupinera.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="è¯»ä¹¦ç¬”è®°,C#"><link rel="canonical" href="http://sakupinera.github.io/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/"><title>CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals - CLR-via-CSharp - CSharp | Hanamai Sora = Sakupinera</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals</h1><div class="meta"><span class="item" title="Created: 2022-10-15 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2022-10-15T00:00:00+08:00">2022-10-15</time> </span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">Symbols count in article</span> <span>80k</span> <span class="text">words</span> </span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">Reading time</span> <span>1:13</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hanamai Sora</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gicit31ffoj20zk0m8naf.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipeudstjqj20zk0m8k3r.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclx29mstj20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclhnx9glj20zk0m8npd.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipetfk5zwj20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipexw3o58j20zk0m8e81.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/" itemprop="item" rel="index" title="In CSharp"><span itemprop="name">CSharp</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/CLR-via-CSharp/" itemprop="item" rel="index" title="In CLR-via-CSharp"><span itemprop="name">CLR-via-CSharp</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://sakupinera.github.io/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Sakupinera"><meta itemprop="description" content=", ä¿æŒä½ çš„å†³å¿ƒï¼"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakupinera"></span><div class="body md" itemprop="articleBody"><h1 id="chapter-5-primitive-reference-and-value-types"><a class="anchor" href="#chapter-5-primitive-reference-and-value-types">#</a> Chapter 5 Primitive, Reference, and Value Types</h1><h2 id="programming-language-primitive-types"><a class="anchor" href="#programming-language-primitive-types">#</a> Programming Language Primitive Types</h2><blockquote><p>Certain data types are so commonly used that many compilers allow code to manipulate them using simplified syntax. For example, you could allocate an integer by using the following syntax.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">System<span class="token punctuation">.</span>Int32</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">System<span class="token punctuation">.</span>Int32</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>But Iâ€™m sure youâ€™d agree that declaring and initializing an integer by using this syntax is rather cumbersome. Fortunately, many compilers (including C#) allow you to use syntax similar to the following instead.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token keyword">int</span></span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>This syntax certainly makes the code more readable and generates identical Intermediate Language (IL) to that which is generated when System.Int32 is used. Any data types the compiler directly supports are called primitive types. Primitive types map directly to types existing in the Framework Class Library (FCL). For example, in C#, an int maps directly to the System.Int32 type. Because of this, the following four lines of code all compile correctly and produce exactly the same IL.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token keyword">int</span></span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// Most convenient syntax </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">System<span class="token punctuation">.</span>Int32</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// Convenient syntax </span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name"><span class="token keyword">int</span></span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name"><span class="token keyword">int</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Inconvenient syntax </span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token class-name">System<span class="token punctuation">.</span>Int32</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">System<span class="token punctuation">.</span>Int32</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Most inconvenient syntax</span></pre></td></tr></table></figure><blockquote><p>Table 5-1 shows the FCL types that have corresponding primitives in C#. For the types that are compliant with the Common Language Specification (CLS), other languages will offer similar primitive types. However, languages arenâ€™t required to offer any support for the nonâ€“CLS-compliant types.</p></blockquote><p><img data-src="/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/image-20220928112238217.png" alt="image-20220928112238217"></p><blockquote><p>Another way to think of this is that the C# compiler automatically assumes that you have the following using directives (as discussed in Chapter 4, â€œType Fundamentalsâ€) in all of your source code files.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token class-name">sbyte</span> <span class="token operator">=</span> <span class="token class-name">System<span class="token punctuation">.</span>SByte</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token class-name">byte</span> <span class="token operator">=</span> <span class="token class-name">System<span class="token punctuation">.</span>Byte</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token class-name">short</span> <span class="token operator">=</span> <span class="token class-name">System<span class="token punctuation">.</span>Int16</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">using</span> <span class="token class-name">ushort</span> <span class="token operator">=</span> <span class="token class-name">System<span class="token punctuation">.</span>UInt16</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">using</span> <span class="token class-name">int</span> <span class="token operator">=</span> <span class="token class-name">System<span class="token punctuation">.</span>Int32</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">using</span> <span class="token class-name">uint</span> <span class="token operator">=</span> <span class="token class-name">System<span class="token punctuation">.</span>UInt32</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr></table></figure><blockquote><p>The C# language specification states, â€œAs a matter of style, use of the keyword is favored over use of the complete system type name.â€ I disagree with the language specification; I prefer to use the FCL type names and completely avoid the primitive type names. In fact, I wish that compilers didnâ€™t even offer the primitive type names and forced developers to use the FCL type names instead. Here are my reasons:</p></blockquote><blockquote><p>â–  Iâ€™ve seen a number of developers confused, not knowing whether to use string or String in their code. Because in C# string (a keyword) maps exactly to System.String (an FCL type), there is no difference and either can be used. Similarly, Iâ€™ve heard some developers say that int represents a 32-bit integer when the application is running on a 32-bit operating system and that it represents a 64-bit integer when the application is running on a 64-bit operating system. This statement is absolutely false: in C#, an int always maps to System.Int32, and therefore it represents a 32-bit integer regardless of the operating system the code is running on. If programmers would use Int32 in their code, then this potential confusion is also eliminated.</p><p>â–  In C#, long maps to System.Int64, but in a different programming language, long could map to an Int16 or Int32. In fact, C++/CLI does treat long as an Int32. Someone reading source code in one language could easily misinterpret the codeâ€™s intention if he or she were used to programming in a different programming language. In fact, most languages wonâ€™t even treat long as a keyword and wonâ€™t compile code that uses it.</p><p>â–  The FCL has many methods that have type names as part of their method names. For example, the BinaryReader type offers methods such as ReadBoolean, ReadInt32, ReadSingle, and so on, and the System.Convert type offers methods such as ToBoolean, ToInt32, ToSingle, and so on. Although itâ€™s legal to write the following code, the line with float feels very unnatural to me, and itâ€™s not obvious that the line is correct.</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">BinaryReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">BinaryReader</span><span class="token punctuation">(</span><span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name"><span class="token keyword">float</span></span> val <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">ReadSingle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK, but feels unnatural </span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">Single</span> val <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">ReadSingle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK and feels good</span></pre></td></tr></table></figure><p>â–  Many programmers that use C# exclusively tend to forget that other programming languages can be used against the CLR, and because of this, C#-isms creep into the class library code. For example, Microsoftâ€™s FCL is almost exclusively written in C# and developers on the FCL team have now introduced methods into the library such as Arrayâ€™s GetLongLength, which returns an Int64 value that is a long in C# but not in other languages (like C++/CLI). Another example is System.Linq.Enumerableâ€™s LongCount method.</p></blockquote><blockquote><p>In many programming languages, you would expect the following code to compile and execute correctly.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Int32</span> i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// A 32-bit value </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Int64</span> l <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// Implicit cast to a 64-bit value</span></pre></td></tr></table></figure><blockquote><p>However, based on the casting discussion presented in Chapter 4, you wouldnâ€™t expect this code to compile. After all, System.Int32 and System.Int64 are different types, and neither one is derived from the other. Well, youâ€™ll be happy to know that the C# compiler does compile this code correctly, and it runs as expected. Why? The reason is that the C# compiler has intimate knowledge of primitive types and applies its own special rules when compiling the code. In other words, the compiler recognizes common programming patterns and produces the necessary IL to make the written code work as expected. Specifically, the C# compiler supports patterns related to casting, literals, and operators, as shown in the following examples.</p></blockquote><blockquote><p>First, the compiler is able to perform implicit or explicit casts between primitive types such as the following.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Int32</span> i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// Implicit cast from Int32 to Int32 </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Int64</span> l <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// Implicit cast from Int32 to Int64 </span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">Single</span> s <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// Implicit cast from Int32 to Single </span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token class-name">Byte</span> b <span class="token operator">=</span> <span class="token punctuation">(</span>Byte<span class="token punctuation">)</span> i<span class="token punctuation">;</span> <span class="token comment">// Explicit cast from Int32 to Byte </span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token class-name">Int16</span> v <span class="token operator">=</span> <span class="token punctuation">(</span>Int16<span class="token punctuation">)</span> s<span class="token punctuation">;</span> <span class="token comment">// Explicit cast from Single to Int16</span></pre></td></tr></table></figure><blockquote><p>C# allows implicit casts if the conversion is â€œsafe,â€ that is, no loss of data is possible, such as converting an Int32 to an Int64. But C# requires explicit casts if the conversion is potentially unsafe. For numeric types, â€œunsafeâ€ means that you could lose precision or magnitude as a result of the conversion. For example, converting from Int32 to Byte requires an explicit cast because precision might be lost from large Int32 numbers; converting from Single to Int16 requires a cast because Single can represent numbers of a larger magnitude than Int16 can.</p></blockquote><blockquote><p>Be aware that different compilers can generate different code to handle these cast operations. For example, when casting a Single with a value of 6.8 to an Int32, some compilers could generate code to put a 6 in the Int32, and others could perform the cast by rounding the result up to 7. By the way, C# always truncates the result. For the exact rules that C# follows for casting primitive types, see the â€œConversionsâ€ section in the C# language specification.</p></blockquote><blockquote><p>In addition to casting, primitive types can be written as literals. A literal is considered to be an instance of the type itself, and therefore, you can call instance methods by using the instance as shown here.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">456</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "123456"</span></pre></td></tr></table></figure><blockquote><p>Also, if you have an expression consisting of literals, the compiler is able to evaluate the expression at compile time, improving the applicationâ€™s performance.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Boolean</span> found <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// Generated code sets found to 0 </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token number">100</span> <span class="token operator">+</span> <span class="token number">20</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// Generated code sets x to 123 </span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"a "</span> <span class="token operator">+</span> <span class="token string">"bc"</span><span class="token punctuation">;</span> <span class="token comment">// Generated code sets s to "a bc"</span></pre></td></tr></table></figure><blockquote><p>Finally, the compiler automatically knows how and in what order to interpret operators (such as +, -, *, /, %, &amp;, ^, |, ==, !=, &gt;, &lt;, &gt;=, &lt;=, &lt;&lt;, &gt;&gt;, ~, !, ++, --, and so on) when used in code.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// Assignment operator </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Int32</span> y <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">23</span><span class="token punctuation">;</span> <span class="token comment">// Addition and assignment operators </span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">Boolean</span> lessThanFifty <span class="token operator">=</span> <span class="token punctuation">(</span>y <span class="token operator">&lt;</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Less-than and assignment operators</span></pre></td></tr></table></figure><h3 id="checked-and-unchecked-primitive-type-operations"><a class="anchor" href="#checked-and-unchecked-primitive-type-operations">#</a> Checked and Unchecked Primitive Type Operations</h3><blockquote><p>Programmers are well aware that many arithmetic operations on primitives could result in an overflow.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Byte</span> b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre>b <span class="token operator">=</span> <span class="token punctuation">(</span>Byte<span class="token punctuation">)</span> <span class="token punctuation">(</span>b <span class="token operator">+</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// b now contains 44 (or 2C in Hex).</span></pre></td></tr></table></figure><p>ğŸ’¡é‡è¦æç¤ºï¼šæ‰§è¡Œä¸Šè¿°ç®—æœ¯è¿ç®—æ—¶ï¼Œç¬¬ä¸€æ­¥è¦æ±‚æ‰€æœ‰æ“ä½œæ•°éƒ½æ‰©å¤§ä¸º 32 ä½å€¼ (æˆ–è€… 64 ä½å€¼ï¼Œå¦‚æœä»»ä½•æ“ä½œæ•°éœ€è¦è¶…è¿‡ 32 ä½æ¥è¡¨ç¤ºçš„è¯)ã€‚æ‰€ä»¥ b å’Œ 200 (ä¸¤ä¸ªéƒ½ä¸è¶…è¿‡ 32 ä½) é¦–å…ˆè½¬æ¢æˆ 32 ä½å€¼ï¼Œç„¶ååŠ åˆ°ä¸€èµ·ã€‚ç»“æœæ˜¯ä¸€ä¸ª 32 ä½å€¼ (åè¿›åˆ¶ 300ï¼Œæˆ–åå…­è¿›åˆ¶ 12C)ã€‚è¯¥å€¼åœ¨å¯„å›å˜é‡ b å‰å¿…é¡»è½¬å‹ä¸º <code>Byte</code> ã€‚C# ä¸éšå¼æ‰§è¡Œè¿™ä¸ªè½¬å‹æ“ä½œï¼Œè¿™æ­£æ˜¯ç¬¬äºŒè¡Œä»£ç éœ€è¦å¼ºåˆ¶è½¬å‹ <code>Byte</code> çš„åŸå› ã€‚</p><blockquote><p>In most programming scenarios, this silent overflow is undesirable and if not detected causes the application to behave in strange and unusual ways. In some rare programming scenarios (such as calculating a hash value or a checksum), however, this overflow is not only acceptable but is also desired.</p></blockquote><blockquote><p>Different languages handle overflows in different ways. C and C++ donâ€™t consider overflows to be an error and allow the value to wrap; the application continues running. Microsoft Visual Basic, on the other hand, always considers overflows to be errors and throws an exception when it detects one.</p></blockquote><blockquote><p>The CLR offers IL instructions that allow the compiler to choose the desired behavior. The CLR has an instruction called add that adds two values together. The add instruction performs no overflow checking. The CLR also has an instruction called add.ovf that also adds two values together. However, add.ovf throws a System.OverflowException if an overflow occurs. In addition to these two IL instructions for the add operation, the CLR also has similar IL instructions for subtraction (sub/ sub.ovf), multiplication (mul/mul.ovf), and data conversions (conv/conv.ovf).</p></blockquote><blockquote><p>C# allows the programmer to decide how overflows should be handled. By default, overflow checking is turned off. This means that the compiler generates IL code by using the versions of the add, subtract, multiply, and conversion instructions that donâ€™t include overflow checking. As a result, the code runs fasterâ€”but developers must be assured that overflows wonâ€™t occur or that their code is designed to anticipate these overflows.</p></blockquote><blockquote><p>One way to get the C# compiler to control overflows is to use the /checked+ compiler switch. This switch tells the compiler to generate code that has the overflow-checking versions of the add, subtract, multiply, and conversion IL instructions. The code executes a little slower because the CLR is checking these operations to determine whether an overflow occurred. If an overflow occurs, the CLR throws an OverflowException.</p></blockquote><blockquote><p>In addition to having overflow checking turned on or off globally, programmers can control overflow checking in specific regions of their code. C# allows this flexibility by offering checked and unchecked operators. Hereâ€™s an example that uses the unchecked operator.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">UInt32</span> invalid <span class="token operator">=</span> <span class="token keyword">unchecked</span><span class="token punctuation">(</span><span class="token punctuation">(</span>UInt32<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK</span></pre></td></tr></table></figure><blockquote><p>And here is an example that uses the checked operator.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Byte</span> b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre>b <span class="token operator">=</span> <span class="token keyword">checked</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Byte<span class="token punctuation">)</span> <span class="token punctuation">(</span>b <span class="token operator">+</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OverflowException is thrown</span></pre></td></tr></table></figure><blockquote><p>In this example, b and 200 are first converted to 32-bit values and are then added together; the result is 300. Then 300 is converted to a Byte due to the explicit cast; this generates the OverflowException. If the Byte were cast outside the checked operator, the exception wouldnâ€™t occur.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>b <span class="token operator">=</span> <span class="token punctuation">(</span>Byte<span class="token punctuation">)</span> <span class="token keyword">checked</span><span class="token punctuation">(</span>b <span class="token operator">+</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// b contains 44; no OverflowException</span></pre></td></tr></table></figure><blockquote><p>In addition to the checked and unchecked operators, C# also offers checked and unchecked statements. The statements cause all expressions within a block to be checked or unchecked.</p></blockquote><blockquote><p>In fact, if you use a checked statement block, you can now use the += operator with the Byte, which simplifies the code a bit.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">checked</span> <span class="token punctuation">&#123;</span> <span class="token comment">// Start of checked block </span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Byte</span> b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> b <span class="token operator">+=</span> <span class="token number">200</span><span class="token punctuation">;</span> <span class="token comment">// This expression is checked for overflow. </span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>ğŸ’¡é‡è¦æç¤ºï¼šç”±äº <code>checked</code> æ“ä½œç¬¦å’Œ <code>checked</code> è¯­å¥å”¯ä¸€çš„ä½œç”¨å°±æ˜¯å†³å®šç”Ÿæˆå“ªä¸ªç‰ˆæœ¬çš„åŠ ã€å‡ã€ä¹˜å’Œæ•°æ®è½¬æ¢ IL æŒ‡ä»¤ï¼Œæ‰€ä»¥åœ¨ <code>checked</code> æ“ä½œç¬¦æˆ–è¯­å¥ä¸­è°ƒç”¨æ–¹æ³•ï¼Œä¸ä¼šå¯¹è¯¥æ–¹æ³•é€ æˆä»»ä½•å½±å“ï¼Œå¦‚ä¸‹ä¾‹æ‰€ç¤ºï¼š:</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">checked</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Assume SomeMethod tries to load 400 into a Byte. </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token function">SomeMethod</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// SomeMethod might or might not throw an OverflowException. </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// It would if SomeMethod were compiled with checked instructions. </span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In my experience, I've seen a lot of calculations produce surprising results. Typically, this is due to invalid user input, but it can also be due to values returned from parts of the system that a programmer just doesn't expect. And so, I now recommend that programmers do the following:</p></blockquote><blockquote><p>â–  Use signed data types (such as Int32 and Int64) instead of unsigned numeric types (such as UInt32 and UInt64) wherever possible. This allows the compiler to detect more overflow/ underflow errors. In addition, various parts of the class library (such as Array's and String's Length properties) are hard-coded to return signed values, and less casting is required as you move these values around in your code. Fewer casts make source code cleaner and easier to maintain. In addition, unsigned numeric types are not CLS-compliant.</p><p>â–  As you write your code, explicitly use checked around blocks where an unwanted overflow might occur due to invalid input data, such as processing a request with data supplied from an end user or a client machine. You might want to catch OverflowException as well, so that your application can gracefully recover from these failures.</p><p>â–  As you write your code, explicitly use unchecked around blocks where an overflow is OK, such as calculating a checksum.</p><p>â–  For any code that doesnâ€™t use checked or unchecked, the assumption is that you do want an exception to occur on overflow, for example, calculating something (such as prime numbers) where the inputs are known, and overflows are bugs.</p></blockquote><blockquote><p>Now, as you develop your application, turn on the compilerâ€™s /checked+ switch for debug builds. Your application will run more slowly because the system will be checking for overflows on any code that you didnâ€™t explicitly mark as checked or unchecked. If an exception occurs, youâ€™ll easily detect it and be able to fix the bug in your code. For the release build of your application, use the compilerâ€™s /checked-switch so that the code runs faster and overflow exceptions wonâ€™t be generated. To change the Checked setting in Microsoft Visual Studio, display the properties for your project, select the Build tab, click Advanced, and then select the Check For Arithmetic Overflow/Underflow option, as shown in Figure 5-1.</p></blockquote><p><img data-src="/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/image-20220928121251436.png" alt="image-20220928121251436"></p><blockquote><p>If your application can tolerate the slight performance hit of always doing checked operations, then I recommend that you compile with the /checked command-line option even for a release build because this can prevent your application from continuing to run with corrupted data and possible security holes. For example, you might perform a multiplication to calculate an index into an array; it is much better to get an OverflowException as opposed to accessing an incorrect array element due to the math wrapping around.</p></blockquote><p>ğŸ’¡é‡è¦æç¤ºï¼š <code>System.Decimal</code> æ˜¯éå¸¸ç‰¹æ®Šçš„ç±»å‹ã€‚è™½ç„¶è®¸å¤šç¼–ç¨‹è¯­è¨€ (åŒ…æ‹¬ C# å’Œ Visual Basic) å°† <code>Decimal</code> è§†ä¸ºåŸºå…ƒç±»å‹ï¼Œä½† CLR ä¸ç„¶ã€‚è¿™æ„å‘³ç€ CLR æ²¡æœ‰çŸ¥é“å¦‚ä½•å¤„ç† <code>Decimal</code> å€¼çš„ IL æŒ‡ä»¤ã€‚åœ¨æ–‡æ¡£ä¸­æŸ¥çœ‹ <code>Decimal</code> ç±»å‹ï¼Œå¯ä»¥çœ‹åˆ°å®ƒæä¾›äº†ä¸€ç³»åˆ— <code>pulbic static</code> æ–¹æ³•ï¼ŒåŒ…æ‹¬ <code>Add</code> ï¼Œ <code>Subtract</code> ï¼Œ <code>Multiply</code> ï¼Œ <code>Divide</code> ç­‰ã€‚æ­¤å¤–ï¼Œ <code>Decimal</code> ç±»å‹è¿˜ä¸º <code>+</code> ï¼Œ <code>-</code> ï¼Œ <code>\*</code> ï¼Œ <code>/</code> ç­‰æä¾›äº†æ“ä½œé‡è½½æ–¹æ³•ã€‚</p><p>ç¼–è¯‘ä½¿ç”¨äº† <code>Decimal</code> å€¼çš„ç¨‹åºæ—¶ï¼Œç¼–è¯‘å™¨ä¼šç”Ÿæˆä»£ç æ¥è°ƒç”¨ <code>Decimal</code> çš„æˆå‘˜ï¼Œå¹¶é€šè¿‡è¿™äº›æˆå‘˜æ¥æ‰§è¡Œå®é™…è¿ç®—ã€‚è¿™æ„å‘³ç€ <code>Decimal</code> å€¼çš„å¤„ç†é€Ÿåº¦æ…¢äº CLR åŸºå…ƒç±»å‹çš„å€¼ã€‚å¦å¤–ï¼Œç”±äºæ²¡æœ‰ç›¸åº”çš„ IL æŒ‡ä»¤æ¥å¤„ç† <code>Decimal</code> å€¼ï¼Œæ‰€ä»¥ <code>checked</code> å’Œ <code>unchecked</code> æ“ä½œç¬¦ã€è¯­å¥ä»¥åŠç¼–è¯‘å™¨å¼€å…³éƒ½å¤±å»äº†ä½œç”¨ã€‚å¦‚æœå¯¹ <code>Decimal</code> å€¼æ‰§è¡Œçš„è¿ç®—æ˜¯ä¸å®‰å…¨çš„ï¼Œè‚¯å®šä¼šæŠ›å‡º <code>OverflowException</code> å¼‚å¸¸ã€‚</p><p>ç±»ä¼¼åœ°ï¼Œ <code>System.Numerics.BigInteger</code> ç±»å‹ä¹Ÿåœ¨å†…éƒ¨ä½¿ç”¨ <code>UInt32</code> æ•°ç»„æ¥è¡¨ç¤ºä»»æ„å¤§çš„æ•´æ•°ï¼Œå®ƒçš„å€¼æ²¡æœ‰ä¸Šé™å’Œä¸‹é™ã€‚å› æ­¤ï¼Œå¯¹ <code>BigInteger</code> æ‰§è¡Œçš„è¿ç®—æ°¸è¿œä¸ä¼šé€ æˆ <code>OverflowException</code> å¼‚å¸¸ã€‚ä½†å¦‚æœå€¼å¤ªå¤§ï¼Œæ²¡æœ‰è¶³å¤Ÿå¤šçš„å†…å­˜æ¥æ”¹å˜æ•°ç»„å¤§å°ï¼Œå¯¹ <code>BigInteger</code> çš„è¿ç®—å¯èƒ½æŠ›å‡º <code>OutOfMemoryException</code> å¼‚å¸¸ã€‚â€‹</p><p>ğŸ’¡å°ç»“ï¼šåŸºå…ƒç±»å‹æŒ‡çš„æ˜¯ç¼–è¯‘å™¨èƒ½ç›´æ¥æ”¯æŒçš„æ•°æ®ç±»å‹ï¼Œå®ƒä»¬ç›´æ¥æ˜ å°„åˆ° Framework ç±»åº“ï¼ˆFCLï¼‰ä¸­å­˜åœ¨çš„ç±»å‹ã€‚å¹¶ä¸”è¿™ä¸¤ç§å†™æ³•ä¼šç”Ÿæˆå®Œå…¨ç›¸åŒçš„ IL ä»£ç ã€‚åªè¦æ˜¯ç¬¦åˆå…¬å…±è¯­è¨€è§„èŒƒï¼ˆCLSï¼‰çš„ç±»å‹ï¼Œå…¶ä»–è¯­è¨€éƒ½æä¾›äº†ç±»ä¼¼çš„åŸºå…ƒç±»å‹ã€‚ä½†æ˜¯ï¼Œä¸ç¬¦åˆ CLS çš„ç±»å‹è¯­è¨€å°±ä¸ä¸€å®šè¦æ”¯æŒäº†ã€‚æœ¬ä¹¦ä½œè€… Jeffrey Richter æ¨èä½¿ç”¨ FCL ç±»å‹åç§°ï¼Œè€Œä¸å»ç”¨åŸºå…ƒç±»å‹åç§°ï¼Œä¸»è¦æœ‰ä»¥ä¸‹å‡ ç‚¹ï¼š1.Int32 èƒ½æ¸…æ¥šçš„è¡¨æ˜è¿™æ˜¯ä¸€ä¸ª 32 ä½çš„æ•´æ•°ã€‚2. ä½¿ç”¨å…³é”®å­—å®¹æ˜“å¼•èµ·ä¸åŒè¯­è¨€ä½¿ç”¨è€…é”™è¯¯ç†è§£ä»£ç æ„å›¾ã€‚ä¾‹å¦‚ C# å’Œ C++ å¯¹ long å‹æ•´æ•°çš„é•¿åº¦å®šä¹‰å°±ä¸ä¸€æ ·ã€‚3.FCL çš„è®¸å¤šæ–¹æ³•éƒ½å°†ç±»å‹åä½œä¸ºæ–¹æ³•åçš„ä¸€éƒ¨åˆ†ã€‚ä¾‹å¦‚ BinaryReader ç±»å‹çš„æ–¹æ³•å°±åŒ…æ‹¬ ReadInt32ï¼ŒReadSingle ç­‰ã€‚C# ç¼–è¯‘å™¨éå¸¸ç†Ÿæ‚‰åŸºå…ƒç±»å‹ï¼Œä¼šåœ¨ç¼–è¯‘ä»£ç æ—¶åº”ç”¨è‡ªå·±çš„ç‰¹æ®Šè§„åˆ™ã€‚å› æ­¤ä¾‹å¦‚åƒ Int64 å’Œ Int32 ä¹‹é—´äº’ç›¸çš„è½¬æ¢ç¼–è¯‘å™¨ä¼šç”Ÿæˆå¿…è¦çš„ ILï¼Œä½¿å†™å¥½çš„ä»£ç èƒ½åƒé¢„æœŸçš„é‚£æ ·å·¥ä½œã€‚åªæœ‰åœ¨è½¬æ¢ â€œå®‰å…¨â€ çš„æ—¶å€™ï¼ŒC# æ‰å…è®¸éšå¼è½¬å‹ã€‚æ‰€è°“ â€œå®‰å…¨â€ï¼Œæ˜¯æŒ‡ä¸ä¼šå‘ç”Ÿæ•°æ®ä¸¢å¤±çš„æƒ…å†µï¼Œæ¯”å¦‚ä» Int32 è½¬æ¢ä¸º Int64ã€‚ä½†å¦‚æœå¯èƒ½ä¸å®‰å…¨ï¼ŒC# å°±è¦æ±‚æ˜¾å¼è½¬å‹ã€‚å¯¹äºæ˜¾å¼è½¬å‹ï¼ŒC# æ€»æ˜¯å¯¹ç»“æœè¿›è¡Œæˆªæ–­ï¼Œè€Œä¸è¿›è¡Œå‘ä¸Šå–æ•´ã€‚åŸºæœ¬ç±»å‹è¿˜å¯ä»¥å†™æˆå­—é¢å€¼ï¼ˆliteralï¼‰ï¼Œå­—é¢å€¼å¯è¢«çœ‹æˆæ˜¯ç±»å‹æœ¬èº«çš„å®ä¾‹ï¼Œå¹¶ä¸”å¯ä»¥åœ¨å®ä¾‹ä¸Šè°ƒç”¨å®ä¾‹æ–¹æ³•ã€‚ä¸åŒè¯­è¨€å¤„ç†æº¢å‡ºçš„æ–¹å¼ä¸åŒã€‚C/C++ ä¸å°†æº¢å‡ºè§†ä¸ºé”™è¯¯ï¼Œå…è®¸å€¼å›æ»šï¼ˆwrapï¼‰ã€‚CLR æä¾›äº†ä¸€äº›ç‰¹æ®Šçš„ IL æŒ‡ä»¤ï¼Œå…è®¸ç¼–è¯‘å™¨é€‰æ‹©å®ƒè®¤ä¸ºæœ€æ°å½“çš„è¡Œä¸ºã€‚CLR æä¾›äº†åŠ ã€å‡ã€ä¹˜å’Œæ•°æ®è½¬æ¢çš„ä¸æ‰§è¡Œæº¢å‡ºæ£€æŸ¥å’Œæ‰§è¡Œæº¢å‡ºæ£€æŸ¥çš„ IL æŒ‡ä»¤ï¼Œåˆ†åˆ«æ˜¯ add/add.ovf,sub/sub.ovf,mul/mul.ovf å’Œ conv/conv.ovfã€‚C# å…è®¸ç¨‹åºå‘˜è‡ªå·±å†³å®šå¦‚ä½•å¤„ç†æº¢å‡ºã€‚æº¢å‡ºæ£€æŸ¥é»˜è®¤å…³é—­ï¼Œç¼–è¯‘å™¨ç”Ÿæˆ IL ä»£ç æ—¶ï¼Œå°†è‡ªåŠ¨ä½¿ç”¨æŒ‡ä»¤çš„æ— æº¢å‡ºæ£€æŸ¥ç‰ˆæœ¬ã€‚è®© C# ç¼–è¯‘å™¨æ§åˆ¶æº¢å‡ºçš„ä¸€ä¸ªæ–¹æ³•æ˜¯ä½¿ç”¨ /checked + ç¼–è¯‘å™¨å¼€å…³ã€‚è¯¥å¼€å…³åªæ˜¯ç¼–è¯‘å™¨åœ¨ç”Ÿæˆä»£ç æ—¶ä½¿ç”¨æŒ‡ä»¤çš„æº¢å‡ºæ£€æŸ¥ç‰ˆæœ¬ã€‚é™¤äº†å…¨å±€æ€§åœ°æ‰“å¼€æˆ–å…³é—­æº¢å‡ºæ£€æŸ¥ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥åœ¨ä»£ç çš„ç‰¹å®šåŒºåŸŸæ§åˆ¶æº¢å‡ºæ£€æŸ¥ã€‚C# é€šè¿‡ checked å’Œ unchecked æ“ä½œç¬¦æ¥æä¾›è¿™ç§çµæ´»æ€§ã€‚C# è¿˜æ”¯æŒ checked å’Œ unchecked è¯­å¥å—ï¼Œåœ¨è¯­å¥å—ä¸­çš„æ‰€æœ‰è¡¨è¾¾å¼éƒ½è¿›è¡Œæˆ–ä¸è¿›è¡Œæº¢å‡ºæ£€æŸ¥ã€‚</p><h2 id="reference-types-and-value-types"><a class="anchor" href="#reference-types-and-value-types">#</a> Reference Types and Value Types</h2><blockquote><p>The CLR supports two kinds of types: reference types and value types. Although most types in the FCL are reference types, the types that programmers use most often are value types. Reference types are always allocated from the managed heap, and the C# new operator returns the memory address of the objectâ€”the memory address refers to the objectâ€™s bits. You need to bear in mind some performance considerations when youâ€™re working with reference types. First, consider these facts:</p><p>â–  The memory must be allocated from the managed heap.</p><p>â–  Each object allocated on the heap has some additional overhead members associated with it that must be initialized.</p><p>â–  The other bytes in the object (for the fields) are always set to zero.</p><p>â–  Allocating an object from the managed heap could force a garbage collection to occur.</p></blockquote><blockquote><p>If every type were a reference type, an applicationâ€™s performance would suffer greatly. Imagine how poor performance would be if every time you used an Int32 value, a memory allocation occurred! To improve performance for simple, frequently used types, the CLR offers lightweight types called value types. Value type instances are usually allocated on a threadâ€™s stack (although they can also be embedded as a field in a reference type object). The variable representing the instance doesnâ€™t contain a pointer to an instance; the variable contains the fields of the instance itself. Because the variable contains the instanceâ€™s fields, a pointer doesnâ€™t have to be dereferenced to manipulate the instanceâ€™s fields. Value type instances donâ€™t come under the control of the garbage collector, so their use reduces pressure in the managed heap and reduces the number of collections an application requires over its lifetime.</p></blockquote><blockquote><p>The .NET Framework SDK documentation clearly indicates which types are reference types and which are value types. When looking up a type in the documentation, any type called a class is a reference type. For example, the System.Exception class, the System.IO.FileStream class, and the System.Random class are all reference types. On the other hand, the documentation refers to each value type as a structure or an enumeration. For example, the System.Int32 structure, the System.Boolean structure, the System.Decimal structure, the System.TimeSpan structure, the System.DayOfWeek enumeration, the System.IO.FileAttributes enumeration, and the System.Drawing.FontStyle enumeration are all value types.</p></blockquote><blockquote><p>All of the structures are immediately derived from the System.ValueType abstract type. System.ValueType is itself immediately derived from the System.Object type. By definition, all value types must be derived from System.ValueType. All enumerations are derived from the System.Enum abstract type, which is itself derived from System.ValueType. The CLR and all programming languages give enumerations special treatment. For more information about enumerated types, refer to Chapter 15, â€œEnumerated Types and Bit Flags.â€</p></blockquote><blockquote><p>Even though you canâ€™t choose a base type when defining your own value type, a value type can implement one or more interfaces if you choose. In addition, all value types are sealed, which prevents a value type from being used as a base type for any other reference type or value type. So, for example, itâ€™s not possible to define any new types using Boolean, Char, Int32, UInt64, Single, Double, Decimal, and so on as base types.</p></blockquote><p>ğŸ’¡é‡è¦æç¤ºï¼šå¯¹äºè®¸å¤šå¼€å‘äººå‘˜ (æ¯”å¦‚éæ‰˜ç®¡ C/C++ å¼€å‘äººå‘˜)ï¼Œæœ€åˆæ¥è§¦å¼•ç”¨ç±»å‹å’Œå€¼ç±»å‹æ—¶éƒ½è§‰å¾—æœ‰äº›ä¸è§£ã€‚åœ¨éæ‰˜ç®¡ C/C++ ä¸­å£°æ˜ç±»å‹åï¼Œä½¿ç”¨è¯¥ç±»å‹çš„ä»£ç ä¼šå†³å®šæ˜¯åœ¨çº¿ç¨‹æ ˆä¸Šè¿˜æ˜¯åœ¨åº”ç”¨ç¨‹åºçš„å †ä¸­åˆ†é…ç±»å‹çš„å®ä¾‹ã€‚ä½†åœ¨æ‰˜ç®¡ä»£ç ä¸­ï¼Œè¦ç”±å®šä¹‰ç±»å‹çš„å¼€å‘äººå‘˜å†³å®šåœ¨ä»€ä¹ˆåœ°æ–¹åˆ†é…ç±»å‹çš„å®ä¾‹ï¼Œä½¿ç”¨ç±»å‹çš„äººå¯¹æ­¤å¹¶æ— æ§åˆ¶æƒã€‚</p><blockquote><p>The following code and Figure 5-2 demonstrate how reference types and value types differ.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Reference type (because of 'class') </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">SomeRef</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span> <span class="token class-name">Int32</span> x<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// Value type (because of 'struct') </span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">SomeVal</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span> <span class="token class-name">Int32</span> x<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ValueTypeDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token class-name">SomeRef</span> r1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SomeRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Allocated in heap </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token class-name">SomeVal</span> v1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SomeVal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Allocated on stack </span></pre></td></tr><tr><td data-num="8"></td><td><pre> r1<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// Pointer dereference </span></pre></td></tr><tr><td data-num="9"></td><td><pre> v1<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// Changed on stack </span></pre></td></tr><tr><td data-num="10"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>r1<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "5" </span></pre></td></tr><tr><td data-num="11"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Also displays "5" </span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// The left side of Figure 5-2 reflects the situation </span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token comment">// after the lines above have executed. </span></pre></td></tr><tr><td data-num="14"></td><td><pre> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token class-name">SomeRef</span> r2 <span class="token operator">=</span> r1<span class="token punctuation">;</span> <span class="token comment">// Copies reference (pointer) only </span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token class-name">SomeVal</span> v2 <span class="token operator">=</span> v1<span class="token punctuation">;</span> <span class="token comment">// Allocate on stack &amp; copies members </span></pre></td></tr><tr><td data-num="17"></td><td><pre> r1<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token comment">// Changes r1.x and r2.x </span></pre></td></tr><tr><td data-num="18"></td><td><pre> v1<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span> <span class="token comment">// Changes v1.x, not v2.x </span></pre></td></tr><tr><td data-num="19"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>r1<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "8" </span></pre></td></tr><tr><td data-num="20"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>r2<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "8" </span></pre></td></tr><tr><td data-num="21"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "9" </span></pre></td></tr><tr><td data-num="22"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>v2<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "5" </span></pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token comment">// The right side of Figure 5-2 reflects the situation </span></pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token comment">// after ALL of the lines above have executed. </span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In this code, the SomeVal type is declared using struct instead of the more common class. In C#, types declared using struct are value types, and types declared using class are reference types. As you can see, the behavior of reference types and value types differs quite a bit. As you use types in your code, you must be aware of whether the type is a reference type or a value type because it can greatly affect how you express your intentions in the code.</p></blockquote><p><img data-src="/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/image-20221006155203566.png" alt="image-20221006155203566"></p><blockquote><p>In the preceding code, you saw this line.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">SomeVal</span> v1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SomeVal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Allocated on stack</span></pre></td></tr></table></figure><blockquote><p>The way this line is written makes it look as if a SomeVal instance will be allocated on the managed heap. However, the C# compiler knows that SomeVal is a value type and produces code that allocates the SomeVal instance on the threadâ€™s stack. C# also ensures that all of the fields in the value type instance are zeroed.</p></blockquote><blockquote><p>The preceding line could have been written like this instead.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">SomeVal</span> v1<span class="token punctuation">;</span> <span class="token comment">// Allocated on stack</span></pre></td></tr></table></figure><blockquote><p>This line also produces IL that allocates the instance on the threadâ€™s stack and zeroes the fields. The only difference is that C# â€œthinksâ€ that the instance is initialized if you use the new operator. The following code will make this point clear</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// These two lines compile because C# thinks that </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// v1's fields have been initialized to 0. </span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">SomeVal</span> v1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SomeVal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token class-name">Int32</span> a <span class="token operator">=</span> v1<span class="token punctuation">.</span>x<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// These two lines don't compile because C# doesn't think that </span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// v1's fields have been initialized to 0. </span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token class-name">SomeVal</span> v1<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token class-name">Int32</span> a <span class="token operator">=</span> v1<span class="token punctuation">.</span>x<span class="token punctuation">;</span> <span class="token comment">// error CS0170: Use of possibly unassigned field 'x'</span></pre></td></tr></table></figure><blockquote><p>When designing your own types, consider carefully whether to define your types as value types instead of reference types. In some situations, value types can give better performance. In particular, you should declare a type as a value type if all the following statements are true:</p><p>â–  The type acts as a primitive type. Specifically, this means that it is a fairly simple type that has no members that modify any of its instance fields. When a type offers no members that alter its fields, we say that the type is immutable. In fact, it is recommended that many value types mark all their fields as readonly (discussed in Chapter 7, &quot;Constants and Fields&quot;).</p><p>â–  The type doesnâ€™t need to inherit from any other type.</p><p>â–  The type wonâ€™t have any other types derived from it.</p></blockquote><blockquote><p>The size of instances of your type is also a condition to take into account because by default, arguments are passed by value, which causes the fields in value type instances to be copied, hurting performance. Again, a method that returns a value type causes the fields in the instance to be copied into the memory allocated by the caller when the method returns, hurting performance. So, in addition to the previous conditions, you should declare a type as a value type if one of the following statements is true:</p><p>â–  Instances of the type are small (approximately 16 bytes or less).</p><p>â–  Instances of the type are large (greater than 16 bytes) and are not passed as method parameters or returned from methods.</p></blockquote><blockquote><p>The main advantage of value types is that theyâ€™re not allocated as objects in the managed heap. Of course, value types have several limitations of their own when compared to reference types. Here are some of the ways in which value types and reference types differ:</p><p>â–  Value type objects have two representations: an unboxed form and a boxed form (discussed in the next section). Reference types are always in a boxed form.</p><p>â–  Value types are derived from System.ValueType. This type offers the same methods as defined by System.Object. However, System.ValueType overrides the Equals method so that it returns true if the values of the two objectsâ€™ fields match. In addition, System.ValueType overrides the GetHashCode method to produce a hash code value by using an algorithm that takes into account the values in the objectâ€™s instance fields. Due to performance issues with this default implementation, when defining your own value types, you should override and provide explicit implementations for the Equals and GetHashCode methods. Iâ€™ll cover the Equals and GetHashCode methods at the end of this chapter.</p><p>â–  Because you canâ€™t define a new value type or a new reference type by using a value type as a base class, you shouldnâ€™t introduce any new virtual methods into a value type. No methods can be abstract, and all methods are implicitly sealed (canâ€™t be overridden).</p><p>â–  Reference type variables contain the memory address of objects in the heap. By default, when a reference type variable is created, it is initialized to null, indicating that the reference type variable doesnâ€™t currently point to a valid object. Attempting to use a null reference type variable causes a NullReferenceException to be thrown. By contrast, value type variables always contain a value of the underlying type, and all members of the value type are initialized to 0. Because a value type variable isnâ€™t a pointer, itâ€™s not possible to generate a NullReferenceException when accessing a value type. The CLR does offer a special feature that adds the notion of nullability to a value type. This feature, called nullable types, is discussed in Chapter 19, â€œNullable Value Types.â€</p><p>â–  When you assign a value type variable to another value type variable, a field-by-field copy is made. When you assign a reference type variable to another reference type variable, only the memory address is copied.</p><p>â–  Because of the previous point, two or more reference type variables can refer to a single object in the heap, allowing operations on one variable to affect the object referenced by the other variable. On the other hand, value type variables are distinct objects, and itâ€™s not possible for operations on one value type variable to affect another.</p><p>â–  Because unboxed value types arenâ€™t allocated on the heap, the storage allocated for them is freed as soon as the method that defines an instance of the type is no longer active as opposed to waiting for a garbage collection.</p></blockquote><p><strong>CLR å¦‚ä½•æ§åˆ¶ç±»å‹ä¸­çš„å­—æ®µå¸ƒå±€</strong></p><p>ä¸ºäº†æé«˜æ€§èƒ½ï¼ŒCLR èƒ½æŒ‰ç…§å®ƒæ‰€é€‰æ‹©çš„ä»»ä½•æ–¹å¼æ’åˆ—ç±»å‹çš„å­—æ®µã€‚ä¾‹å¦‚ï¼ŒCLR å¯ä»¥åœ¨å†…å­˜ä¸­é‡æ–°å®‰æ’å­—æ®µçš„é¡ºåºï¼Œå°†å¯¹è±¡å¼•ç”¨åˆ†ä¸ºä¸€ç»„ï¼ŒåŒæ—¶æ­£ç¡®æ’åˆ—å’Œå¡«å……æ•°æ®å­—æ®µã€‚ä½†åœ¨å®šä¹‰ç±»å‹æ—¶ï¼Œé’ˆå¯¹ç±»å‹çš„å„ä¸ªå­—æ®µï¼Œä½ å¯ä»¥å‘Šè¯‰ CLR æ˜¯ä¸¥æ ¼æŒ‰ç…§è‡ªå·±åˆ¶å®šçš„é¡ºåºæ’åˆ—ï¼Œè¿˜æ˜¯æŒ‰ç…§ CLR è‡ªå·±è®¤ä¸ºåˆé€‚çš„æ–¹å¼é‡æ–°æ’åˆ—ã€‚</p><p>ä¸ºäº†å‘Šè¯‰ CLR åº”è¯¥æ€æ ·åšï¼Œè¦ä¸ºè‡ªå·±å®šä¹‰çš„ç±»æˆ–ç»“æ„åº”ç”¨ <code>System.Runtime.InteropServices.StructLayoutAttribute</code> ç‰¹æ€§ã€‚å¯å‘è¯¥ç‰¹æ€§çš„æ„é€ å™¨ä¼ é€’ <code>LayoutKind.Auto</code> ï¼Œè®© CLR è‡ªåŠ¨æ’åˆ—å­—æ®µï¼›ä¹Ÿå¯ä¼ é€’ <code>LayoutKind.Sequential</code> ï¼Œè®© CLR ä¿æŒä½ çš„å­—æ®µå¸ƒå±€ï¼›ä¹Ÿå¯ä¼ é€’ <code>LayoutKind.Explicit</code> ï¼Œåˆ©ç”¨åç§»é‡åœ¨å†…å­˜ä¸­æ˜¾å¼æ’åˆ—å­—æ®µã€‚å¦‚æœä¸ä¸ºè‡ªå·±å®šä¹‰çš„ç±»å‹æ˜¾å¼æŒ‡å®š <code>StructLayoutAttribute</code> ï¼Œç¼–è¯‘å™¨ä¼šé€‰æ‹©å®ƒè‡ªè®¤ä¸ºæœ€å¥½çš„å¸ƒå±€ã€‚</p><p>æ³¨æ„ï¼ŒMicrosoft C# ç¼–è¯‘å™¨é»˜è®¤ä¸ºå¼•ç”¨ç±»å‹ (ç±») é€‰æ‹© <code>LayoutKind.Auto</code> ï¼Œä¸ºå€¼ç±»å‹ (ç»“æ„) é€‰æ‹© <code>LayoutKind.Sequential</code> ã€‚æ˜¾ç„¶ï¼ŒC# ç¼–è¯‘å™¨å›¢é˜Ÿè®¤ä¸ºå’Œéæ‰˜ç®¡ä»£ç äº’æ“ä½œæ—¶ä¼šç»å¸¸ç”¨åˆ°ç»“æ„ã€‚ä¸ºæ­¤ï¼Œå­—æ®µå¿…é¡»ä¿æŒç¨‹åºå‘˜å®šä¹‰çš„é¡ºåºã€‚ç„¶è€Œï¼Œå‡å¦‚åˆ›å»ºçš„å€¼ç±»å‹ä¸ä¸éæ‰˜ç®¡ä»£ç äº’æ“ä½œï¼Œå°±åº”è¯¥è¦†ç›– C# ç¼–è¯‘å™¨çš„é»˜è®¤è®¾å®šï¼Œä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼š</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>InteropServices</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// è®© CLR è‡ªåŠ¨æ’åˆ—å­—æ®µä»¥å¢å¼ºè¿™ä¸ªå€¼ç±»å‹çš„æ€§èƒ½</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">StructLayout</span><span class="token attribute-arguments"><span class="token punctuation">(</span>LayoutKind<span class="token punctuation">.</span>Auto<span class="token punctuation">)</span></span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">struct</span> <span class="token class-name">SomeValType</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">Byte</span> m_b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">Int16</span> m_x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>StructLayoutAttribute</code> è¿˜å…è®¸æ˜¾å¼æŒ‡å®šæ¯ä¸ªå­—æ®µçš„åç§»é‡ï¼Œè¿™è¦æ±‚å‘å…¶æ„é€ å™¨ä¼ é€’ <code>LayoutKind.Explicit</code> ã€‚ ç„¶åå‘å€¼ç±»å‹ä¸­çš„æ¯ä¸ªå­—æ®µéƒ½åº”ç”¨ <code>System.Runtime.InteropServices.FieldOffsetAttribute</code> ç‰¹æ€§çš„å®ä¾‹ï¼Œå‘è¯¥ç‰¹æ€§çš„æ„é€ å™¨ä¼ é€’ <code>Int32</code> å€¼æ¥æŒ‡å‡ºå­—æ®µç¬¬ä¸€ä¸ªå­—èŠ‚è·ç¦»å®ä¾‹èµ·å§‹å¤„çš„åç§»é‡ (ä»¥å­—èŠ‚ä¸ºå•ä½)ã€‚æ˜¾å¼å¸ƒå±€å¸¸ç”¨äºæ¨¡æ‹Ÿéæ‰˜ç®¡ C/C++ ä¸­çš„ <em><code>union</code> </em>ï¼Œå› ä¸ºå¤šä¸ªå­—æ®µå¯èµ·å§‹äºå†…å­˜çš„ç›¸åŒåç§»ä½ç½®ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼š</p><p>union æ˜¯ç‰¹æ®Šçš„ç±»ï¼Œunion ä¸­çš„æ•°æ®æˆå‘˜åœ¨å†…å­˜ä¸­çš„å­˜å‚¨ç›¸äº’é‡å ã€‚æ¯ä¸ªæ•°æ®æˆå‘˜éƒ½ä»ç›¸åŒå†…å­˜åœ°å€å¼€å§‹ã€‚åˆ†é…ç»™ union çš„å­˜å‚¨åŒºæ•°é‡æ˜¯åŒ…å«å®ƒæœ€å¤§æ•°æ®æˆå‘˜æ‰€éœ€çš„å†…å­˜æ•°ã€‚åŒä¸€æ—¶åˆ»åªæœ‰ä¸€ä¸ªæˆå‘˜å¯ä»¥è¢«èµ‹å€¼ã€‚ â€”â€” è¯‘æ³¨</p><pre><code class="language-C#">using System;
using System.Runtime.InteropServices;

// å¼€å‘äººå‘˜æ˜¾å¼æ’åˆ—è¿™ä¸ªå€¼ç±»å‹çš„å­—æ®µ
[StructLayout(LayoutKind.Explicit)]
internal struct SomeValType &#123;
  [FiledOffset(0)]
  private readonly Byte m_b;     // m_b å’Œ m_x å­—æ®µåœ¨è¯¥ç±»å‹çš„å®ä¾‹ä¸­ç›¸äº’é‡å 

  [FiledOffset(0)]
  private readonly Int16 m_x;    // m_b å’Œ m_x å­—æ®µåœ¨è¯¥ç±»å‹çš„å®ä¾‹ä¸­ç›¸äº’é‡å 
  ...
&#125;
</code></pre><p>æ³¨æ„åœ¨ç±»å‹ä¸­ï¼Œä¸€ä¸ªå¼•ç”¨ç±»å‹å’Œä¸€ä¸ªå€¼ç±»å‹ç›¸äº’é‡å æ˜¯ä¸åˆæ³•çš„ã€‚è™½ç„¶å…è®¸å¤šä¸ªå¼•ç”¨ç±»å‹åœ¨åŒä¸€ä¸ªèµ·å§‹åç§»ä½ç½®ç›¸äº’é‡å ï¼Œä½†è¿™æ— æ³•éªŒè¯ (unverifiable)ã€‚å®šä¹‰ç±»å‹ï¼Œåœ¨å…¶ä¸­è®©å¤šä¸ªå€¼ç±»å‹ç›¸äº’é‡å åˆ™æ˜¯åˆæ³•çš„ã€‚ä½†æ˜¯ï¼Œä¸ºäº†ä½¿è¿™æ ·çš„ç±»å‹èƒ½å¤ŸéªŒè¯ (verifiable)ï¼Œæ‰€æœ‰é‡å å­—èŠ‚éƒ½å¿…é¡»èƒ½é€šè¿‡å…¬å…±å­—æ®µè®¿é—®ã€‚</p><p>ğŸ’¡å°ç»“ï¼šCLR æ”¯æŒå¼•ç”¨ç±»å‹å’Œå€¼ç±»å‹ã€‚å¼•ç”¨ç±»å‹æ€»æ˜¯ä»æ‰˜ç®¡å †åˆ†é…ï¼ŒC# çš„ new æ“ä½œç¬¦è¿”å›å¯¹è±¡å†…å­˜åœ°å€ï¼ˆå³æŒ‡å‘å¯¹è±¡æ•°æ®çš„å†…å­˜åœ°å€ï¼‰ã€‚å¯¹äºå¼•ç”¨ç±»å‹å¿…é¡»è®¤æ¸…ä»¥ä¸‹å››ä¸ªäº‹å®ï¼š1. å†…å­˜æ€»æ˜¯åœ¨æ‰˜ç®¡å †åˆ†é…ã€‚2. å †ä¸Šåˆ†é…çš„å¯¹è±¡éƒ½æœ‰ä¸€äº›é¢å¤–æˆå‘˜ï¼ˆç±»å‹å¯¹è±¡æŒ‡é’ˆå’ŒåŒæ­¥å—ç´¢å¼•ï¼‰ï¼Œè¿™äº›æˆå‘˜å¿…é¡»åˆå§‹åŒ–ã€‚3. å¯¹è±¡ä¸­çš„å…¶å®ƒå­—èŠ‚ï¼ˆä¸ºå­—æ®µè€Œè®¾ï¼‰æ€»æ˜¯è®¾ä¸ºé›¶ã€‚4. ä»æ‰˜ç®¡å †åˆ†é…å¯¹è±¡æ—¶ï¼Œå¯èƒ½å¼ºåˆ¶æ‰§è¡Œä¸€æ¬¡åƒåœ¾å›æ”¶ã€‚ä½œä¸º â€œè½»é‡çº§ç±»å‹â€ çš„å€¼ç±»å‹ä¸€èˆ¬åœ¨çº¿ç¨‹æ ˆä¸Šåˆ†é…ï¼ˆä¹Ÿå¯ä½œä¸ºå­—æ®µåµŒå…¥å¼•ç”¨ç±»å‹çš„å¯¹è±¡ä¸­ï¼‰ã€‚ç”±äºå˜é‡å·²åŒ…å«äº†å®ä¾‹çš„å­—æ®µï¼Œæ‰€ä»¥æ“ä½œå®ä¾‹ä¸­çš„å­—æ®µä¸éœ€è¦æé¢†æŒ‡é’ˆã€‚å€¼ç±»å‹çš„å®ä¾‹ä¸å—åƒåœ¾å›æ”¶å™¨çš„æ§åˆ¶ã€‚å› æ­¤ï¼Œå€¼ç±»å‹çš„ä½¿ç”¨ç¼“è§£äº†æ‰˜ç®¡å †çš„å‹åŠ›ï¼Œå¹¶å‡å°‘äº†åº”ç”¨ç¨‹åºç”Ÿå­˜æœŸå†…çš„åƒåœ¾å›æ”¶æ¬¡æ•°ã€‚ä»»ä½•è¢«ç§°ä¸ºç±»çš„ç±»å‹éƒ½æ˜¯å¼•ç”¨ç±»å‹ã€‚ç›¸åï¼Œæ‰€æœ‰å€¼ç±»å‹éƒ½ç§°ä¸ºç»“æ„æˆ–æšä¸¾ã€‚æ‰€æœ‰çš„ç»“æ„éƒ½æ˜¯æŠ½è±¡ç±»å‹ System.ValueType çš„ç›´æ¥æ´¾ç”Ÿç±»ã€‚System.ValueType åˆç›´æ¥ä» System.Object æ´¾ç”Ÿã€‚æ‰€æœ‰æšä¸¾éƒ½ä» System.Enum æŠ½è±¡ç±»å‹æ´¾ç”Ÿï¼Œåè€…åˆä» System.ValueType æ´¾ç”Ÿã€‚è™½ç„¶ä¸èƒ½åœ¨å®šä¹‰å€¼ç±»å‹æ—¶ä¸ºå®ƒé€‰æ‹©åŸºç±»å‹ï¼Œä½†å¦‚æœæ„¿æ„ï¼Œå€¼ç±»å‹å¯ä»¥å®ç°ä¸€ä¸ªæˆ–å¤šä¸ªæ¥å£ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œæ‰€æœ‰å€¼ç±»å‹éƒ½éšå¼å¯†å°ï¼Œç›®çš„æ˜¯é˜²æ­¢å°†å€¼ç±»å‹ç”¨ä½œå…¶å®ƒå¼•ç”¨ç±»å‹æˆ–å€¼ç±»å‹çš„åŸºç±»å‹ã€‚åœ¨ C# ä¸­ï¼Œç”¨ struct å£°æ˜çš„ç±»å‹æ˜¯å€¼ç±»å‹ï¼Œç”¨ class å£°æ˜çš„ç±»å‹æ˜¯å¼•ç”¨ç±»å‹ã€‚å¯¹äºå€¼ç±»å‹æ¥è¯´å³ä½¿ç”¨ new å…³é”®å­—å£°æ˜å˜é‡ï¼Œä»ç„¶ä¼šåœ¨çº¿ç¨‹æ ˆä¸Šåˆ†é…å†…å­˜ï¼Œå› ä¸º C# ç¼–è¯‘å™¨çŸ¥é“è¿™æ˜¯å€¼ç±»å‹ï¼Œæ‰€ä»¥ä¼šç»™å®ƒç”Ÿæˆæ­£ç¡®çš„ IL ä»£ç ï¼Œè¿™ç§æ–¹å¼ C# è¿˜ä¼šç¡®ä¿å€¼ç±»å‹ä¸­çš„æ‰€æœ‰å­—æ®µéƒ½åˆå§‹åŒ–ä¸ºé›¶ã€‚å€¼ç±»å‹å¯¹è±¡æœ‰ä¸¤ç§è¡¨ç¤ºå½¢å¼ï¼šæœªè£…ç®±å’Œå·²è£…ç®±ã€‚ç›¸åï¼Œå¼•ç”¨ç±»å‹æ€»æ˜¯å¤„äºå·²è£…ç®±å½¢å¼ã€‚å®šä¹‰è‡ªå·±çš„å€¼ç±»å‹æ—¶åº”é‡å†™ Equals å’Œ GetHashCode æ–¹æ³•ï¼Œå¹¶æä¾›å®ƒä»¬çš„æ˜¾å¼å®ç°ï¼Œå› ä¸ºé»˜è®¤å®ç°ä¼šå­˜åœ¨æ€§èƒ½é—®é¢˜ã€‚æ­¤å¤–ï¼Œå€¼ç±»å‹çš„æ‰€æœ‰æ–¹æ³•éƒ½ä¸èƒ½æ—¶æŠ½è±¡çš„ï¼Œæ‰€æœ‰æ–¹æ³•éƒ½éšå¼å¯†å°ï¼ˆä¸å¯é‡å†™ï¼‰ã€‚</p><h2 id="boxing-and-unboxing-value-types"><a class="anchor" href="#boxing-and-unboxing-value-types">#</a> Boxing and Unboxing Value Types</h2><blockquote><p>Value types are lighter weight than reference types because they are not allocated as objects in the managed heap, not garbage collected, and not referred to by pointers. However, in many cases, you must get a reference to an instance of a value type. For example, letâ€™s say that you wanted to create an ArrayList object (a type defined in the System.Collections namespace) to hold a set of Point structures. The code might look like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Declare a value type. </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name">Int32</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token class-name">ArrayList</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token class-name">Point</span> p<span class="token punctuation">;</span> <span class="token comment">// Allocate a Point (not in the heap). </span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> p<span class="token punctuation">.</span>x <span class="token operator">=</span> p<span class="token punctuation">.</span>y <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// Initialize the members in the value type. </span></pre></td></tr><tr><td data-num="11"></td><td><pre> a<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Box the value type and add the </span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// reference to the Arraylist. </span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token range operator">..</span><span class="token punctuation">.</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>With each iteration of the loop, a Pointâ€™s value type fields are initialized. Then the Point is stored in the ArrayList. But letâ€™s think about this for a moment. What is actually being stored in the ArrayList? Is it the Point structure, the address of the Point structure, or something else entirely? To get the answer, you must look up ArrayListâ€™s Add method and see what type its parameter is defined as. In this case, the Add method is prototyped as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token return-type class-name">Int32</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token class-name">Object</span> <span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>From this, you can plainly see that Add takes an Object as a parameter, indicating that Add requires a reference (or pointer) to an object on the managed heap as a parameter. But in the preceding code, Iâ€™m passing p, a Point, which is a value type. For this code to work, the Point value type must be converted into a true heap-managed object, and a reference to this object must be obtained.</p></blockquote><blockquote><p>Itâ€™s possible to convert a value type to a reference type by using a mechanism called boxing. Internally, hereâ€™s what happens when an instance of a value type is boxed.</p><ol><li>Memory is allocated from the managed heap. The amount of memory allocated is the size required by the value typeâ€™s fields plus the two additional overhead members (the type object pointer and the sync block index) required by all objects on the managed heap.</li><li>The value typeâ€™s fields are copied to the newly allocated heap memory.</li><li>The address of the object is returned. This address is now a reference to an object; the value type is now a reference type.</li></ol></blockquote><blockquote><p>The C# compiler automatically produces the IL code necessary to box a value type instance, but you still need to understand whatâ€™s going on internally so that youâ€™re aware of code size and performance issues.</p></blockquote><blockquote><p>In the preceding code, the C# compiler detected that I was passing a value type to a method that requires a reference type, and it automatically emitted code to box the object. So at run time, the fields currently residing in the Point value type instance p are copied into the newly allocated Point object. The address of the boxed Point object (now a reference type) is returned and is then passed to the Add method. The Point object will remain in the heap until it is garbage collected. The Point value type variable (p) can be reused because the ArrayList never knows anything about it. Note that the lifetime of the boxed value type extends beyond the lifetime of the unboxed value type.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šFCL ç°åœ¨åŒ…å«ä¸€ç»„æ–°çš„æ³›å‹é›†åˆç±»ï¼Œéæ³›å‹é›†åˆç±»å·²æˆä¸º â€œæ˜¨æ—¥é»„èŠ±â€ã€‚ä¾‹å¦‚ï¼Œåº”è¯¥ä½¿ç”¨ <code>System.Collections.Generic.List&lt;T&gt;</code> ç±»è€Œä¸æ˜¯ <code>System.Collections.ArrayList</code> ç±»ã€‚æ³›å‹é›†åˆç±»å¯¹éæ³›å‹é›†åˆç±»è¿›è¡Œäº†å¤§é‡æ”¹è¿›ã€‚ä¾‹å¦‚ï¼Œ API å¾—åˆ°ç®€åŒ–å’Œå¢å¼ºï¼Œé›†åˆç±»çš„æ€§èƒ½ä¹Ÿå¾—åˆ°æ˜¾è‘—æå‡ã€‚ä½†æœ€å¤§çš„æ”¹è¿›å°±æ˜¯æ³›å‹é›†åˆç±»å…è®¸å¼€å‘äººå‘˜åœ¨æ“ä½œå€¼ç±»å‹çš„é›†åˆæ—¶ä¸éœ€è¦å¯¹é›†åˆä¸­çš„é¡¹è¿›è¡Œè£…ç®± / æ‹†ç®±ã€‚å•è¿™ä¸€é¡¹æ”¹è¿›ï¼Œå°±ä½¿æ€§èƒ½æå‡äº†ä¸å°‘ã€‚è¿™æ˜¯å› ä¸ºæ‰˜ç®¡å †ä¸­éœ€è¦åˆ›å»ºçš„å¯¹è±¡å‡å°‘äº†ï¼Œè¿›è€Œå‡å°‘äº†åº”ç”¨ç¨‹åºéœ€è¦æ‰§è¡Œçš„åƒåœ¾å›æ”¶çš„æ¬¡æ•°ã€‚å¦å¤–ï¼Œå¼€å‘äººå‘˜è¿˜è·å¾—äº†ç¼–è¯‘æ—¶çš„ç±»å‹å®‰å…¨æ€§ï¼Œæºä»£ç ä¹Ÿå› ä¸ºå¼ºåˆ¶ç±»å‹è½¬æ¢çš„æ¬¡æ•°å‡å°‘è€Œå˜å¾—æ›´æ¸…æ™°ã€‚æ‰€æœ‰è¿™ä¸€åˆ‡éƒ½å°†åœ¨ç¬¬ 12 ç«  â€œæ³›å‹â€ è¯¦ç»†è§£é‡Šã€‚</p><blockquote><p>Now that you know how boxing works, letâ€™s talk about unboxing. Letâ€™s say that you want to grab the first element out of the ArrayList by using the following code.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Point</span> p <span class="token operator">=</span> <span class="token punctuation">(</span>Point<span class="token punctuation">)</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>Here youâ€™re taking the reference (or pointer) contained in element 0 of the ArrayList and trying to put it into a Point value type instance, p. For this to work, all of the fields contained in the boxed Point object must be copied into the value type variable, p, which is on the threadâ€™s stack. The CLR accomplishes this copying in two steps. First, the address of the Point fields in the boxed Point object is obtained. This process is called unboxing. Then, the values of these fields are copied from the heap to the stack-based value type instance.</p></blockquote><blockquote><p>Unboxing is not the exact opposite of boxing. The unboxing operation is much less costly than boxing. Unboxing is really just the operation of obtaining a pointer to the raw value type (data fields) contained within an object. In effect, the pointer refers to the unboxed portion in the boxed instance. So, unlike boxing, unboxing doesnâ€™t involve the copying of any bytes in memory. Having made this important clarification, it is important to note that an unboxing operation is typically followed by copying the fields.</p></blockquote><blockquote><p>Obviously, boxing and unboxing/copy operations hurt your applicationâ€™s performance in terms of both speed and memory, so you should be aware of when the compiler generates code to perform these operations automatically and try to write code that minimizes this code generation.</p></blockquote><blockquote><p>Internally, hereâ€™s exactly what happens when a boxed value type instance is unboxed:</p><ol><li>If the variable containing the reference to the boxed value type instance is null, a NullReferenceException is thrown.</li><li>If the reference doesnâ€™t refer to an object that is a boxed instance of the desired value type, an InvalidCastException is thrown.</li></ol></blockquote><blockquote><p>The second item in the preceding list means that the following code will not work as you might expect.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Object</span> o <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// Box x; o refers to the boxed object </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">Int16</span> y <span class="token operator">=</span> <span class="token punctuation">(</span>Int16<span class="token punctuation">)</span> o<span class="token punctuation">;</span> <span class="token comment">// Throws an InvalidCastException </span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Logically, it makes sense to take the boxed Int32 that o refers to and cast it to an Int16. However, when unboxing an object, the cast must be to the exact unboxed value typeâ€”Int32 in this case. Hereâ€™s the correct way to write this code.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Object</span> o <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// Box x; o refers to the boxed object </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">Int16</span> y <span class="token operator">=</span> <span class="token punctuation">(</span>Int16<span class="token punctuation">)</span><span class="token punctuation">(</span>Int32<span class="token punctuation">)</span> o<span class="token punctuation">;</span> <span class="token comment">// Unbox to the correct type and cast </span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>I mentioned earlier that an unboxing operation is frequently followed immediately by a field copy. Letâ€™s take a look at some C# code demonstrating that unbox and copy operations work together.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Point</span> p<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> p<span class="token punctuation">.</span>x <span class="token operator">=</span> p<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">Object</span> o <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">// Boxes p; o refers to the boxed instance </span></pre></td></tr><tr><td data-num="5"></td><td><pre> p <span class="token operator">=</span> <span class="token punctuation">(</span>Point<span class="token punctuation">)</span> o<span class="token punctuation">;</span> <span class="token comment">// Unboxes o AND copies fields from boxed </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// instance to stack variable </span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>On the last line, the C# compiler emits an IL instruction to unbox o (get the address of the fields in the boxed instance) and another IL instruction to copy the fields from the heap to the stack-based variable p.</p></blockquote><blockquote><p>Now look at this code.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Point</span> p<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> p<span class="token punctuation">.</span>x <span class="token operator">=</span> p<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">Object</span> o <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">// Boxes p; o refers to the boxed instance </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// Change Point's x field to 2 </span></pre></td></tr><tr><td data-num="6"></td><td><pre> p <span class="token operator">=</span> <span class="token punctuation">(</span>Point<span class="token punctuation">)</span> o<span class="token punctuation">;</span> <span class="token comment">// Unboxes o AND copies fields from boxed </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// instance to stack variable </span></pre></td></tr><tr><td data-num="8"></td><td><pre> p<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// Changes the state of the stack variable </span></pre></td></tr><tr><td data-num="9"></td><td><pre> o <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">// Boxes p; o refers to a new boxed instance </span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The code at the bottom of this fragment is intended only to change Pointâ€™s x field from 1 to 2. To do this, an unbox operation must be performed, followed by a field copy, followed by changing the field (on the stack), followed by a boxing operation (which creates a whole new boxed instance in the managed heap). Hopefully, you see the impact that boxing and unboxing/copying operations have on your applicationâ€™s performance.</p></blockquote><blockquote><p>Some languages, such as C++/CLI, allow you to unbox a boxed value type without copying the fields. Unboxing returns the address of the unboxed portion of a boxed object (ignoring the objectâ€™s type object pointer and sync block index overhead). You can now use this pointer to manipulate the unboxed instanceâ€™s fields (which happen to be in a boxed object on the heap). For example, the previous code would be much more efficient if written in C++/CLI, because you could change the value of Pointâ€™s x field within the already boxed Point instance. This would avoid both allocating a new object on the heap and copying all of the fields twice!</p></blockquote><p>ğŸ’¡é‡è¦æç¤ºï¼šå¦‚æœå…³å¿ƒåº”ç”¨ç¨‹åºçš„æ€§èƒ½ï¼Œå°±åº”æ¸…æ¥šç¼–è¯‘å™¨ä½•æ—¶ç”Ÿæˆä»£ç æ‰§è¡Œè¿™äº›æ“ä½œã€‚é—æ†¾çš„æ˜¯ï¼Œè®¸å¤šç¼–è¯‘å™¨éƒ½éšå¼ç”Ÿæˆä»£ç æ¥è£…ç®±å¯¹è±¡ï¼Œæ‰€ä»¥æœ‰æ—¶å¹¶ä¸çŸ¥é“è‡ªå·±çš„ä»£ç ä¼šé€ æˆè£…ç®±ã€‚å¦‚æœå…³å¿ƒç‰¹å®šç®—æ³•çš„æ€§èƒ½ï¼Œå¯ç”¨ ILDasm.exe è¿™æ ·çš„å·¥å…·æŸ¥çœ‹æ–¹æ³•çš„ IL ä»£ç ï¼Œè§‚å¯Ÿ IL æŒ‡ä»¤ box éƒ½åœ¨å“ªäº›åœ°æ–¹å‡ºç°ã€‚</p><blockquote><p>Letâ€™s look at a few more examples that demonstrate boxing and unboxing.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Int32</span> v <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// Create an unboxed value type variable. </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Object</span> o <span class="token operator">=</span> v<span class="token punctuation">;</span> <span class="token comment">// o refers to a boxed Int32 containing 5. </span></pre></td></tr><tr><td data-num="4"></td><td><pre> v <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment">// Changes the unboxed value to 123 </span></pre></td></tr><tr><td data-num="5"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>v <span class="token operator">+</span> <span class="token string">", "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>Int32<span class="token punctuation">)</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "123, 5" </span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In this code, can you guess how many boxing operations occur? You might be surprised to discover that the answer is three! Letâ€™s analyze the code carefully to really understand whatâ€™s going on. To help you understand, Iâ€™ve included the IL code generated for the Main method shown in the preceding code. Iâ€™ve commented the code so that you can easily see the individual operations.</p></blockquote><figure class="highlight clike"><figcaption data-lang="C-like"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">.</span>method public hidebysig static void <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> cil managed </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token punctuation">.</span>entrypoint </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// Code size 45 (0x2d) </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">.</span>maxstack <span class="token number">3</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">.</span>locals init <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>int32 v<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> object o<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Load 5 into v. </span></pre></td></tr><tr><td data-num="9"></td><td><pre> IL_0000<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span><span class="token number">5</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> IL_0001<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">0</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// Box v and store the reference pointer in o. </span></pre></td></tr><tr><td data-num="12"></td><td><pre> IL_0002<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> IL_0003<span class="token punctuation">:</span> box <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Int32 </pre></td></tr><tr><td data-num="14"></td><td><pre> IL_0008<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">1</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// Load 123 into v. </span></pre></td></tr><tr><td data-num="16"></td><td><pre> IL_0009<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span>s <span class="token number">123</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> IL_000b<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">0</span> </pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token comment">// Box v and leave the pointer on the stack for Concat. </span></pre></td></tr><tr><td data-num="19"></td><td><pre> IL_000c<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span> </pre></td></tr><tr><td data-num="20"></td><td><pre> IL_000d<span class="token punctuation">:</span> box <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Int32 </pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token comment">// Load the string on the stack for Concat. </span></pre></td></tr><tr><td data-num="22"></td><td><pre> IL_0012<span class="token punctuation">:</span> ldstr <span class="token string">", "</span> </pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token comment">// Unbox o: Get the pointer to the In32's field on the stack. </span></pre></td></tr><tr><td data-num="24"></td><td><pre> IL_0017<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">1</span> </pre></td></tr><tr><td data-num="25"></td><td><pre> IL_0018<span class="token punctuation">:</span> unbox<span class="token punctuation">.</span>any <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Int32 </pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token comment">// Box the Int32 and leave the pointer on the stack for Concat. </span></pre></td></tr><tr><td data-num="27"></td><td><pre> IL_001d<span class="token punctuation">:</span> box <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Int32 </pre></td></tr><tr><td data-num="28"></td><td><pre> <span class="token comment">// Call Concat. </span></pre></td></tr><tr><td data-num="29"></td><td><pre> IL_0022<span class="token punctuation">:</span> call string <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>String<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">Concat</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="30"></td><td><pre> object<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="31"></td><td><pre> object<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="32"></td><td><pre> <span class="token comment">// The string returned from Concat is passed to WriteLine. </span></pre></td></tr><tr><td data-num="33"></td><td><pre> IL_0027<span class="token punctuation">:</span> call void <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Console<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="34"></td><td><pre> <span class="token comment">// Return from Main terminating this application. </span></pre></td></tr><tr><td data-num="35"></td><td><pre> IL_002c<span class="token punctuation">:</span> ret </pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of method App::Main</span></pre></td></tr></table></figure><blockquote><p>First, an Int32 unboxed value type instance (v) is created on the stack and initialized to 5. Then a variable (o) typed as Object is created, and is initialized to point to v. But because reference type variables must always point to objects in the heap, C# generated the proper IL code to box and store the address of the boxed copy of v in o. Now the value 123 is placed into the unboxed value type instance v; this has no effect on the boxed Int32 value, which keeps its value of 5.</p></blockquote><blockquote><p>Next is the call to the WriteLine method. WriteLine wants a String object passed to it, but there is no string object. Instead, these three items are available: an unboxed Int32 value type instance (v), a String (which is a reference type), and a reference to a boxed Int32 value type instance (o) that is being cast to an unboxed Int32. These must somehow be combined to create a String.</p></blockquote><blockquote><p>To create a String, the C# compiler generates code that calls Stringâ€™s static Concat method. There are several overloaded versions of the Concat method, all of which perform identicallyâ€”the only difference is in the number of parameters. Because a string is being created from the concatenation of three items, the compiler chooses the following version of the Concat method.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">String</span> <span class="token function">Concat</span><span class="token punctuation">(</span><span class="token class-name">Object</span> arg0<span class="token punctuation">,</span> <span class="token class-name">Object</span> arg1<span class="token punctuation">,</span> <span class="token class-name">Object</span> arg2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>For the first parameter, arg0, v is passed. But v is an unboxed value parameter and arg0 is an Object, so v must be boxed and the address to the boxed v is passed for arg0. For the arg1 pasrameter, the &quot;,&quot; string is passed as a reference to a String object. Finally, for the arg2 parameter, o (a reference to an Object) is cast to an Int32. This requires an unboxing operation (but no copy operation), which retrieves the address of the unboxed Int32 contained inside the boxed Int32. This unboxed Int32 instance must be boxed again and the new boxed instanceâ€™s memory address passed for Concatâ€™s arg2 parameter.</p></blockquote><blockquote><p>The Concat method calls each of the specified objectsâ€™ ToString method and concatenates each objectâ€™s string representation. The String object returned from Concat is then passed to WriteLine to show the final result.</p></blockquote><blockquote><p>I should point out that the generated IL code is more efficient if the call to WriteLine is written as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>v <span class="token operator">+</span> <span class="token string">", "</span> <span class="token operator">+</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Displays "123, 5"</span></pre></td></tr></table></figure><blockquote><p>This line is identical to the earlier version except that Iâ€™ve removed the (Int32) cast that preceded the variable o. This code is more efficient because o is already a reference type to an Object and its address can simply be passed to the Concat method. So, removing the cast saved two operations: an unbox and a box. You can easily see this savings by rebuilding the application and examining the generated IL code, as shown in the following code.</p></blockquote><figure class="highlight clike"><figcaption data-lang="C-like"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">.</span>method public hidebysig static void <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> cil managed </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token punctuation">.</span>entrypoint </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// Code size 35 (0x23) </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">.</span>maxstack <span class="token number">3</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">.</span>locals init <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> int32 v<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> object o<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Load 5 into v. </span></pre></td></tr><tr><td data-num="9"></td><td><pre> IL_0000<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span><span class="token number">5</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> IL_0001<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">0</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// Box v and store the reference pointer in o. </span></pre></td></tr><tr><td data-num="12"></td><td><pre> IL_0002<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> IL_0003<span class="token punctuation">:</span> box <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Int32 </pre></td></tr><tr><td data-num="14"></td><td><pre> IL_0008<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">1</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// Load 123 into v. </span></pre></td></tr><tr><td data-num="16"></td><td><pre> IL_0009<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span>s <span class="token number">123</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> IL_000b<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">0</span> </pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token comment">// Box v and leave the pointer on the stack for Concat. </span></pre></td></tr><tr><td data-num="19"></td><td><pre> IL_000c<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span> </pre></td></tr><tr><td data-num="20"></td><td><pre> IL_000d<span class="token punctuation">:</span> box <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Int32 </pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token comment">// Load the string on the stack for Concat. </span></pre></td></tr><tr><td data-num="22"></td><td><pre> IL_0012<span class="token punctuation">:</span> ldstr <span class="token string">", "</span> </pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token comment">// Load the address of the boxed Int32 on the stack for Concat. </span></pre></td></tr><tr><td data-num="24"></td><td><pre> IL_0017<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">1</span> </pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token comment">// Call Concat. </span></pre></td></tr><tr><td data-num="26"></td><td><pre> IL_0018<span class="token punctuation">:</span> call string <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>String<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">Concat</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="27"></td><td><pre> object<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="28"></td><td><pre> object<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="29"></td><td><pre> <span class="token comment">// The string returned from Concat is passed to WriteLine. </span></pre></td></tr><tr><td data-num="30"></td><td><pre> IL_001d<span class="token punctuation">:</span> call void <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Console<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="31"></td><td><pre> <span class="token comment">// Return from Main terminating this application. </span></pre></td></tr><tr><td data-num="32"></td><td><pre> IL_0022<span class="token punctuation">:</span> ret </pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of method App::Main</span></pre></td></tr></table></figure><blockquote><p>A quick comparison of the IL for these two versions of the Main method shows that the version without the (Int32) cast is 10 bytes smaller than the version with the cast. The extra unbox/box steps in the first version are obviously generating more code. An even bigger concern, however, is that the extra boxing step allocates an additional object from the managed heap that must be garbage collected in the future. Certainly, both versions give identical results, and the difference in speed isnâ€™t noticeable, but extra, unnecessary boxing operations occurring in a loop cause the performance and memory usage of your application to be seriously degraded.</p></blockquote><blockquote><p>You can improve the previous code even more by calling WriteLine like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", "</span> <span class="token operator">+</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "123, 5"</span></pre></td></tr></table></figure><blockquote><p>Now ToString is called on the unboxed value type instance v, and a String is returned. String objects are already reference types and can simply be passed to the Concat method without requiring any boxing.</p></blockquote><blockquote><p>Letâ€™s look at yet another example that demonstrates boxing and unboxing.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Int32</span> v <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// Create an unboxed value type variable. </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Object</span> o <span class="token operator">=</span> v<span class="token punctuation">;</span> <span class="token comment">// o refers to the boxed version of v. </span></pre></td></tr><tr><td data-num="4"></td><td><pre> v <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment">// Changes the unboxed value type to 123 </span></pre></td></tr><tr><td data-num="5"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "123" </span></pre></td></tr><tr><td data-num="6"></td><td><pre> v <span class="token operator">=</span> <span class="token punctuation">(</span>Int32<span class="token punctuation">)</span> o<span class="token punctuation">;</span> <span class="token comment">// Unboxes and copies o into v </span></pre></td></tr><tr><td data-num="7"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "5" </span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>How many boxing operations do you count in this code? The answer is one. The reason that there is only one boxing operation is that the System.Console class defines a WriteLine method that accepts an Int32 as a parameter.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> <span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>In the two preceding calls to WriteLine, the variable v, an Int32 unboxed value type instance, is passed by value. Now it may be that WriteLine will box this Int32 internally, but you have no control over that. The important thing is that youâ€™ve done the best you could and have eliminated the boxing from your own code.</p></blockquote><blockquote><p>If you take a close look at the FCL, youâ€™ll notice many overloaded methods that differ based on their value type parameters. For example, the System.Console type offers several overloaded versions of the WriteLine method.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">WriteLine</span><span class="token punctuation">(</span>Boolean<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">WriteLine</span><span class="token punctuation">(</span>Char<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">WriteLine</span><span class="token punctuation">(</span>Char<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">WriteLine</span><span class="token punctuation">(</span>Int32<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">WriteLine</span><span class="token punctuation">(</span>UInt32<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">WriteLine</span><span class="token punctuation">(</span>Int64<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">WriteLine</span><span class="token punctuation">(</span>UInt64<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">WriteLine</span><span class="token punctuation">(</span>Single<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">WriteLine</span><span class="token punctuation">(</span>Double<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">WriteLine</span><span class="token punctuation">(</span>Decimal<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">WriteLine</span><span class="token punctuation">(</span>Object<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">WriteLine</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>Youâ€™ll also find a similar set of overloaded methods for System.Consoleâ€™s Write method, System.IO.BinaryWriterâ€™s Write method, System.IO.TextWriterâ€™s Write and WriteLine methods, System.Runtime.Serialization.SerializationInfoâ€™s AddValue method, System.Text.StringBuilderâ€™s Append and Insert methods, and so on. Most of these methods offer overloaded versions for the sole purpose of reducing the number of boxing operations for the common value types.</p></blockquote><blockquote><p>If you define your own value type, these FCL classes will not have overloads of these methods that accept your value type. Furthermore, there are a bunch of value types already defined in the FCL for which overloads of these methods do not exist. If you call a method that does not have an overload for the specific value type that you are passing to it, you will always end up calling the overload that takes an Object. Passing a value type instance as an Object will cause boxing to occur, which will adversely affect performance. If you are defining your own class, you can define the methods in the class to be generic (possibly constraining the type parameters to be value types). Generics give you a way to define a method that can take any kind of value type without having to box it. Generics are discussed in Chapter 12.</p></blockquote><blockquote><p>One last point about boxing: if you know that the code that youâ€™re writing is going to cause the compiler to box a single value type repeatedly, your code will be smaller and faster if you manually box the value type. Hereâ€™s an example.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">Int32</span> v <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// Create an unboxed value type variable. </span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token preprocessor property">#<span class="token directive keyword">if</span> INEFFICIENT </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// When compiling the following line, v is boxed </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// three times, wasting time and memory. </span></pre></td></tr><tr><td data-num="8"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"&#123;0&#125;, &#123;1&#125;, &#123;2&#125;"</span><span class="token punctuation">,</span> v<span class="token punctuation">,</span> v<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token preprocessor property">#<span class="token directive keyword">else</span> </span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// The lines below have the same result, execute </span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// much faster, and use less memory. </span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token class-name">Object</span> o <span class="token operator">=</span> v<span class="token punctuation">;</span> <span class="token comment">// Manually box v (just once). </span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token comment">// No boxing occurs to compile the following line. </span></pre></td></tr><tr><td data-num="14"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"&#123;0&#125;, &#123;1&#125;, &#123;2&#125;"</span><span class="token punctuation">,</span> o<span class="token punctuation">,</span> o<span class="token punctuation">,</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token preprocessor property">#<span class="token directive keyword">endif</span> </span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>If this code is compiled with the INEFFICIENT symbol defined, the compiler will generate code to box v three times, causing three objects to be allocated from the heap! This is extremely wasteful because each object will have exactly the same contents: 5. If the code is compiled without the INEFFICIENT symbol defined, v is boxed just once, so only one object is allocated from the heap. Then, in the call to Console.WriteLine, the reference to the single boxed object is passed three times. This second version executes much faster and allocates less memory from the heap.</p></blockquote><blockquote><p>In these examples, itâ€™s fairly easy to recognize when an instance of a value type requires boxing. Basically, if you want a reference to an instance of a value type, the instance must be boxed. Usually this happens because you have a value type instance and you want to pass it to a method that requires a reference type. However, this situation isnâ€™t the only one in which youâ€™ll need to box an instance of a value type.</p></blockquote><blockquote><p>Recall that unboxed value types are lighter-weight types than reference types for two reasons:</p><p>â–  They are not allocated on the managed heap.</p><p>â–  They donâ€™t have the additional overhead members that every object on the heap has: a type object pointer and a sync block index</p></blockquote><blockquote><p>Because unboxed value types donâ€™t have a sync block index, you canâ€™t have multiple threads synchronize their access to the instance by using the methods of the System.Threading.Monitor type (or by using C#â€™s lock statement).</p></blockquote><blockquote><p>Even though unboxed value types donâ€™t have a type object pointer, you can still call virtual methods (such as Equals, GetHashCode, or ToString) inherited or overridden by the type. If your value type overrides one of these virtual methods, then the CLR can invoke the method nonvirtually because value types are implicitly sealed and cannot have any types derived from them. In addition, the value type instance being used to invoke the virtual method is not boxed. However, if your override of the virtual method calls into the base type's implementation of the method, then the value type instance does get boxed when calling the base type's implementation so that a reference to a heap object gets passed to the this pointer into the base method.</p></blockquote><blockquote><p>However, calling a nonvirtual inherited method (such as GetType or MemberwiseClone) always requires the value type to be boxed because these methods are defined by System.Object, so the methods expect the this argument to be a pointer that refers to an object on the heap.</p></blockquote><blockquote><p>In addition, casting an unboxed instance of a value type to one of the typeâ€™s interfaces requires the instance to be boxed, because interface variables must always contain a reference to an object on the heap. (Iâ€™ll talk about interfaces in Chapter 13, â€œInterfaces.â€) The following code demonstrates.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">struct</span> <span class="token class-name">Point</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IComparable</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">Int32</span> m_x<span class="token punctuation">,</span> m_y<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// Constructor to easily initialize the fields </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> x<span class="token punctuation">,</span> <span class="token class-name">Int32</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> m_x <span class="token operator">=</span> x<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> m_y <span class="token operator">=</span> y<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// Override ToString method inherited from System.ValueType </span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name">String</span> <span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// Return the point as a string. Note: calling ToString prevents boxing</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">return</span> String<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"(&#123;0&#125;, &#123;1&#125;)"</span><span class="token punctuation">,</span> m_x<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m_y<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token comment">// Implementation of type-safe CompareTo method </span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token class-name">Point</span> other<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token comment">// Use the Pythagorean Theorem to calculate </span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token comment">// which point is farther from the origin (0, 0) </span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">Sign</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">Sqrt</span><span class="token punctuation">(</span>m_x <span class="token operator">*</span> m_x <span class="token operator">+</span> m_y <span class="token operator">*</span> m_y<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token operator">-</span> Math<span class="token punctuation">.</span><span class="token function">Sqrt</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>m_x <span class="token operator">*</span> other<span class="token punctuation">.</span>m_x <span class="token operator">+</span> other<span class="token punctuation">.</span>m_y <span class="token operator">*</span> other<span class="token punctuation">.</span>m_y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>  <span class="token comment">// Implementation of IComparable's CompareTo method </span></pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> o<span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ArgumentException</span><span class="token punctuation">(</span><span class="token string">"o is not a Point"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token comment">// Call type-safe CompareTo method </span></pre></td></tr><tr><td data-num="27"></td><td><pre> <span class="token keyword">return</span> <span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Point<span class="token punctuation">)</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="28"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="31"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="32"></td><td><pre> <span class="token comment">// Create two Point instances on the stack. </span></pre></td></tr><tr><td data-num="33"></td><td><pre> <span class="token class-name">Point</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Point</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="34"></td><td><pre> <span class="token class-name">Point</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Point</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="35"></td><td><pre> <span class="token comment">// p1 does NOT get boxed to call ToString (a virtual method). </span></pre></td></tr><tr><td data-num="36"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// "(10, 10)" </span></pre></td></tr><tr><td data-num="37"></td><td><pre> <span class="token comment">// p DOES get boxed to call GetType (a non-virtual method). </span></pre></td></tr><tr><td data-num="38"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// "Point" </span></pre></td></tr><tr><td data-num="39"></td><td><pre> <span class="token comment">// p1 does NOT get boxed to call CompareTo. </span></pre></td></tr><tr><td data-num="40"></td><td><pre> <span class="token comment">// p2 does NOT get boxed because CompareTo(Point) is called. </span></pre></td></tr><tr><td data-num="41"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// "-1" </span></pre></td></tr><tr><td data-num="42"></td><td><pre> <span class="token comment">// p1 DOES get boxed, and the reference is placed in c. </span></pre></td></tr><tr><td data-num="43"></td><td><pre> <span class="token class-name">IComparable</span> c <span class="token operator">=</span> p1<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="44"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// "Point" </span></pre></td></tr><tr><td data-num="45"></td><td><pre> <span class="token comment">// p1 does NOT get boxed to call CompareTo. </span></pre></td></tr><tr><td data-num="46"></td><td><pre> <span class="token comment">// Because CompareTo is not being passed a Point variable, </span></pre></td></tr><tr><td data-num="47"></td><td><pre> <span class="token comment">// CompareTo(Object) is called, which requires a reference to </span></pre></td></tr><tr><td data-num="48"></td><td><pre> <span class="token comment">// a boxed Point. </span></pre></td></tr><tr><td data-num="49"></td><td><pre> <span class="token comment">// c does NOT get boxed because it already refers to a boxed Point. </span></pre></td></tr><tr><td data-num="50"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// "0" </span></pre></td></tr><tr><td data-num="51"></td><td><pre> <span class="token comment">// c does NOT get boxed because it already refers to a boxed Point. </span></pre></td></tr><tr><td data-num="52"></td><td><pre> <span class="token comment">// p2 does get boxed because CompareTo(Object) is called. </span></pre></td></tr><tr><td data-num="53"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// "-1" </span></pre></td></tr><tr><td data-num="54"></td><td><pre> <span class="token comment">// c is unboxed, and fields are copied into p2. </span></pre></td></tr><tr><td data-num="55"></td><td><pre> p2 <span class="token operator">=</span> <span class="token punctuation">(</span>Point<span class="token punctuation">)</span> c<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="56"></td><td><pre> <span class="token comment">// Proves that the fields got copied into p2. </span></pre></td></tr><tr><td data-num="57"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// "(10, 10)" </span></pre></td></tr><tr><td data-num="58"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="59"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>This code demonstrates several scenarios related to boxing and unboxing:</p><p>â–  Calling ToString In the call to ToString, p1 doesnâ€™t have to be boxed. At first, youâ€™d think that p1 would have to be boxed because ToString is a virtual method that is inherited from the base type, System.ValueType. Normally, to call a virtual method, the CLR needs to determine the objectâ€™s type in order to locate the typeâ€™s method table. Because p1 is an unboxed value type, thereâ€™s no type object pointer. However, the just-in-time (JIT) compiler sees that Point overrides the ToString method, and it emits code that calls ToString directly (nonvirtually) without having to do any boxing. The compiler knows that polymorphism canâ€™t come into play here because Point is a value type, and no type can derive from it to provide another implementation of this virtual method. Note that if Point's ToString method internally calls base.ToString(), then the value type instance would be boxed when calling System.ValueType's ToString method.</p><p>â–  Calling GetType In the call to the nonvirtual GetType method, p1 does have to be boxed. The reason is that the Point type inherits GetType from System.Object. So to call GetType, the CLR must use a pointer to a type object, which can be obtained only by boxing p1.</p><p>â–  Calling CompareTo (first time) In the first call to CompareTo, p1 doesnâ€™t have to be boxed because Point implements the CompareTo method, and the compiler can just call it directly. Note that a Point variable (p2) is being passed to CompareTo, and therefore the compiler calls the overload of CompareTo that accepts a Point parameter. This means that p2 will be passed by value to CompareTo and no boxing is necessary.</p><p>â–  Casting to IComparable When casting p1 to a variable (c) that is of an interface type, p1 must be boxed because interfaces are reference types by definition. So p1 is boxed, and the pointer to this boxed object is stored in the variable c. The following call to GetType proves that c does refer to a boxed Point on the heap.</p><p>â–  Calling CompareTo (second time) In the second call to CompareTo, p1 doesnâ€™t have to be boxed because Point implements the CompareTo method, and the compiler can just call it directly. Note that an IComparable variable (c) is being passed to CompareTo, and therefore, the compiler calls the overload of CompareTo that accepts an Object parameter. This means that the argument passed must be a pointer that refers to an object on the heap. Fortunately, c does refer to a boxed Point, and therefore, that memory address in c can be passed to CompareTo, and no additional boxing is necessary.</p><p>â–  Calling CompareTo (third time) In the third call to CompareTo, c already refers to a boxed Point object on the heap. Because c is of the IComparable interface type, you can call only the interfaceâ€™s CompareTo method that requires an Object parameter. This means that the argument passed must be a pointer that refers to an object on the heap. So p2 is boxed, and the pointer to this boxed object is passed to CompareTo.</p><p>â–  Casting to Point When casting c to a Point, the object on the heap referred to by c is unboxed, and its fields are copied from the heap to p2, an instance of the Point type residing on the stack.</p></blockquote><blockquote><p>I realize that all of this information about reference types, value types, and boxing might be overwhelming at first. However, a solid understanding of these concepts is critical to any .NET Framework developerâ€™s long-term success. Trust me: having a solid grasp of these concepts will allow you to build efficient applications faster and easier.</p></blockquote><h3 id="changing-fields-in-a-boxed-value-type-by-using-interfaces-and-why-you-shouldnt-do-this"><a class="anchor" href="#changing-fields-in-a-boxed-value-type-by-using-interfaces-and-why-you-shouldnt-do-this">#</a> Changing Fields in a Boxed Value Type by Using Interfaces (and Why You Shouldnâ€™t Do This)</h3><blockquote><p>Letâ€™s have some fun and see how well you understand value types, boxing, and unboxing. Examine the following code, and see whether you can figure out what it displays on the console.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// Point is a value type. </span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">struct</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_x<span class="token punctuation">,</span> m_y<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> x<span class="token punctuation">,</span> <span class="token class-name">Int32</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> m_x <span class="token operator">=</span> x<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> m_y <span class="token operator">=</span> y<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Change</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> x<span class="token punctuation">,</span> <span class="token class-name">Int32</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> m_x <span class="token operator">=</span> x<span class="token punctuation">;</span> m_y <span class="token operator">=</span> y<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name">String</span> <span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">return</span> String<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"(&#123;0&#125;, &#123;1&#125;)"</span><span class="token punctuation">,</span> m_x<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m_y<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token class-name">Point</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Point</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="20"></td><td><pre> p<span class="token punctuation">.</span><span class="token function">Change</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="21"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token class-name">Object</span> o <span class="token operator">=</span> p<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="23"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token punctuation">(</span><span class="token punctuation">(</span>Point<span class="token punctuation">)</span> o<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Change</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="25"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Very simply, Main creates an instance (p) of a Point value type on the stack and sets its m_x and m_y fields to 1. Then, p is boxed before the first call to WriteLine, which calls ToString on the boxed Point, and (1, 1) is displayed as expected. Then, p is used to call the Change method, which changes the values of pâ€™s m_x and m_y fields on the stack to 2. The second call to WriteLine requires p to be boxed again and displays (2, 2), as expected.</p></blockquote><blockquote><p>Now, p is boxed a third time, and o refers to the boxed Point object. The third call to WriteLine again shows (2, 2), which is also expected. Finally, I want to call the Change method to update the fields in the boxed Point object. However, Object (the type of the variable o) doesnâ€™t know anything about the Change method, so I must first cast o to a Point. Casting o to a Point unboxes o and copies the fields in the boxed Point to a temporary Point on the threadâ€™s stack! The m_x and m_y fields of this temporary point are changed to 3 and 3, but the boxed Point isnâ€™t affected by this call to Change. When WriteLine is called the fourth time, (2, 2) is displayed again. Many developers do not expect this.</p></blockquote><blockquote><p>Some languages, such as C++/CLI, let you change the fields in a boxed value type, but C# does not. However, you can fool C# into allowing this by using an interface. The following code is a modified version of the previous code.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// Interface defining a Change method </span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">interface</span> <span class="token class-name">IChangeBoxedPoint</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Change</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> x<span class="token punctuation">,</span> <span class="token class-name">Int32</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// Point is a value type. </span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">struct</span> <span class="token class-name">Point</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IChangeBoxedPoint</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_x<span class="token punctuation">,</span> m_y<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> x<span class="token punctuation">,</span> <span class="token class-name">Int32</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> m_x <span class="token operator">=</span> x<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> m_y <span class="token operator">=</span> y<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Change</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> x<span class="token punctuation">,</span> <span class="token class-name">Int32</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> m_x <span class="token operator">=</span> x<span class="token punctuation">;</span> m_y <span class="token operator">=</span> y<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name">String</span> <span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token keyword">return</span> String<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"(&#123;0&#125;, &#123;1&#125;)"</span><span class="token punctuation">,</span> m_x<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m_y<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token class-name">Point</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Point</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="23"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="24"></td><td><pre> p<span class="token punctuation">.</span><span class="token function">Change</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="25"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token class-name">Object</span> o <span class="token operator">=</span> p<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="27"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="28"></td><td><pre> <span class="token punctuation">(</span><span class="token punctuation">(</span>Point<span class="token punctuation">)</span> o<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Change</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="29"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="30"></td><td><pre> <span class="token comment">// Boxes p, changes the boxed object and discards it </span></pre></td></tr><tr><td data-num="31"></td><td><pre> <span class="token punctuation">(</span><span class="token punctuation">(</span>IChangeBoxedPoint<span class="token punctuation">)</span> p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Change</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="32"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="33"></td><td><pre> <span class="token comment">// Changes the boxed object and shows it </span></pre></td></tr><tr><td data-num="34"></td><td><pre> <span class="token punctuation">(</span><span class="token punctuation">(</span>IChangeBoxedPoint<span class="token punctuation">)</span> o<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Change</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="35"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="36"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>This code is almost identical to the previous version. The main difference is that the Change method is defined by the IChangeBoxedPoint interface, and the Point type now implements this interface. Inside Main, the first four calls to WriteLine are the same and produce the same results I had before (as expected). However, Iâ€™ve added two more examples at the end of Main.</p></blockquote><blockquote><p>In the first example, the unboxed Point, p, is cast to an IChangeBoxedPoint. This cast causes the value in p to be boxed. Change is called on the boxed value, which does change its m_x and m_y fields to 4 and 4, but after Change returns, the boxed object is immediately ready to be garbage collected. So the fifth call to WriteLine displays (2, 2). Many developers wonâ€™t expect this result.</p></blockquote><blockquote><p>In the last example, the boxed Point referred to by o is cast to an IChangeBoxedPoint. No boxing is necessary here because o is already a boxed Point. Then Change is called, which does change the boxed Pointâ€™s m_x and m_y fields. The interface method Change has allowed me to change the fields in a boxed Point object! Now, when WriteLine is called, it displays (5, 5) as expected. The purpose of this whole example is to demonstrate how an interface method is able to modify the fields of a boxed value type. In C#, this isnâ€™t possible without using an interface method.</p></blockquote><p>ğŸ’¡é‡è¦æç¤ºï¼šæœ¬ç« å‰é¢æåˆ°ï¼Œå€¼ç±»å‹åº”è¯¥ â€œä¸å¯å˜â€(immutable)ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬ä¸åº”è¯¥å®šä¹‰ä»»ä½•ä¼šä¿®æ”¹å®ä¾‹å­—æ®µçš„æˆå‘˜ã€‚äº‹å®ä¸Šï¼Œæˆ‘å»ºè®®å°†å€¼ç±»å‹çš„å­—æ®µéƒ½æ ‡è®°ä¸º <code>readonly</code> ã€‚è¿™æ ·ï¼Œä¸€æ—¦ä¸ç•™ç¥å†™ä¸€ä¸ªè§†å›¾æ›´æ”¹å­—æ®µçš„æ–¹æ³•ï¼Œç¼–è¯‘æ—¶å°±ä¼šæŠ¥é”™ã€‚å‰é¢çš„ä¾‹å­æ¸…æ¥šæ­ç¤ºäº†æˆ‘ä»¬ä¸ºä»€ä¹ˆåº”è¯¥è¿™æ ·åšã€‚å‡å¦‚æ–¹æ³•è¯•å›¾ä¿®æ”¹å€¼ç±»å‹çš„å®ä¾‹å­—æ®µï¼Œè°ƒç”¨è¿™ä¸ªæ–¹æ³•å°±ä¼šäº§ç”Ÿéé¢„æœŸçš„è¡Œä¸ºã€‚æ„é€ å¥½å€¼ç±»å‹åï¼Œå¦‚æœä¸è°ƒç”¨ä»»ä½•ä¼šä¿®æ”¹å…¶çŠ¶æ€çš„æ–¹æ³• (æˆ–è€…å¦‚æœæ ¹æœ¬ä¸å­˜åœ¨è¿™æ ·çš„æ–¹æ³•)ï¼Œå°±ç”¨ä¸ç€æ“å¿ƒä»€ä¹ˆæ—¶å€™å‘ç”Ÿè£…ç®±å’Œæ‹†ç®± / å­—æ®µå¤åˆ¶ã€‚å¦‚æœå€¼ç±»å‹ä¸å¯å˜ï¼Œç®€å•å¤åˆ¶ç›¸åŒçš„çŠ¶æ€å°±å¯ä»¥äº† (ä¸ç”¨æ‹…å¿ƒæœ‰æ–¹æ³•ä¼šä¿®æ”¹è¿™äº›çŠ¶æ€)ï¼Œä»£ç çš„ä»»ä½•è¡Œä¸ºéƒ½åœ¨ä½ çš„æŒæ§ä¹‹ä¸­ã€‚</p><p>æœ‰è®¸å¤šå¼€å‘äººå‘˜å®¡é˜…äº†æœ¬ä¹¦å†…å®¹ã€‚åœ¨é˜…è¯»æˆ‘çš„éƒ¨åˆ†ç¤ºä¾‹ä»£ç ä¹‹å (æ¯”å¦‚å‰é¢çš„ä»£ç )ï¼Œä»–ä»¬å‘Šè¯‰æˆ‘ä»¥åå†ä¹Ÿä¸æ•¢ä½¿ç”¨å€¼ç±»å‹äº†ã€‚æˆ‘å¿…é¡»å£°æ˜ï¼Œå€¼ç±»å‹çš„è¿™äº›ç„å¦™ä¹‹å¤„ç€å®èŠ±äº†æˆ‘å¥½å‡ å¤©åŠŸå¤«è¿›è¡Œè°ƒè¯•ï¼Œç—›å®šæ€ç—›ä¹‹ä½™ï¼Œæˆ‘å¿…é¡»åœ¨ä¹‹é‡Œç€é‡å¼ºè°ƒï¼Œæé†’å¤§å®¶æ³¨æ„ï¼Œå¸Œæœ›å¤§å®¶è®°ä½æˆ‘æè¿°çš„é—®é¢˜ã€‚è¿™æ ·ï¼Œå½“ä»£ç çœŸæ­£å‡ºç°è¿™äº›é—®é¢˜çš„æ—¶å€™ï¼Œæˆ‘ä»¬å°±èƒ½å¤Ÿåšåˆ°å¿ƒä¸­æœ‰æ•°ã€‚è™½ç„¶å¦‚æ­¤ï¼Œä½†ä¹Ÿä¸è¦å› å™åºŸé£Ÿè€Œæƒ§æ€•å€¼ç±»å‹ã€‚å®ƒä»¬å¾ˆæœ‰ç”¨ï¼Œæœ‰è‡ªå·±çš„é€‚ç”¨åœºæ™¯ã€‚æ¯•ç«Ÿï¼Œç¨‹åºå¶å°”è¿˜æ˜¯éœ€è¦ <code>Int32</code> çš„ã€‚åªæ˜¯è¦æ³¨æ„ï¼Œå€¼ç±»å‹å’Œå¼•ç”¨ç±»å‹çš„è¡Œä¸ºä¼šå› ä¸ºä½¿ç”¨æ–¹å¼çš„ä¸åŒè€Œæœ‰æ˜æ˜¾å·®å¼‚ã€‚äº‹å®ä¸Šï¼Œå‰ä¾‹å°† <code>Point</code> å£°æ˜ä¸º <code>class</code> è€Œä¸æ˜¯ <code>struct</code> ï¼Œå³å¯è·å¾—ä»¤äººæ»¡æ„çš„ç»“æœã€‚æœ€åè¿˜è¦å‘Šè¯‰ä½ ä¸€ä¸ªå¥½æ¶ˆæ¯ï¼ŒFCL çš„æ ¸å¿ƒå€¼ç±»å‹ ( <code>Byte</code> ï¼Œ <code>Int32</code> ï¼Œ <code>UInt32</code> ï¼Œ <code>Int64</code> ï¼Œ <code>UInt64</code> ï¼Œ <code>Single</code> , <code>Double</code> , <code>Decimal</code> , <code>BigInteger</code> , <code>Complex</code> ä»¥åŠæ‰€æœ‰æšä¸¾) éƒ½æ˜¯ â€œä¸å¯å˜â€ çš„ï¼Œæ‰€ä»¥åœ¨ä½¿ç”¨è¿™äº›ç±»å‹æ—¶ï¼Œä¸ä¼šå‘ç”Ÿä»»ä½•ç¨€å¥‡å¤æ€ªçš„äº‹æƒ…ã€‚</p><h3 id="object-equality-and-identity"><a class="anchor" href="#object-equality-and-identity">#</a> Object Equality and Identity</h3><blockquote><p>Frequently, developers write code to compare objects with one another. This is particularly true when placing objects in a collection and youâ€™re writing code to sort, search, or compare items in a collection. In this section, I'll discuss object equality and identity, and Iâ€™ll also discuss how to define a type that properly implements object equality.</p></blockquote><blockquote><p>The System.Object type offers a virtual method named Equals, whose purpose is to return true if two objects contain the same value. The implementation of Objectâ€™s Equals method looks like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Object</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token return-type class-name">Boolean</span> <span class="token function">Equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// If both references point to the same object, </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// they must have the same value. </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> obj<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Assume that the objects do not have the same value. </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>At first, this seems like a reasonable default implementation of Equals: it returns true if the this and obj arguments refer to the same exact object. This seems reasonable because Equals knows that an object must have the same value as itself. However, if the arguments refer to different objects, Equals canâ€™t be certain if the objects contain the same values, and therefore, false is returned. In other words, the default implementation of Objectâ€™s Equals method really implements identity, not value equality.</p></blockquote><blockquote><p>Unfortunately, as it turns out, Objectâ€™s Equals method is not a reasonable default, and it should have never been implemented this way. You immediately see the problem when you start thinking about class inheritance hierarchies and how to properly override Equals. Here is how to properly implement an Equals method internally:</p><ol><li>If the obj argument is null, return false because the current object identified by this is obviously not null when the nonstatic Equals method is called.</li><li>If the this and obj arguments refer to the same object, return true. This step can improve performance when comparing objects with many fields.</li><li>If the this and obj arguments refer to objects of different types, return false. Obviously, checking if a String object is equal to a FileStream object should result in a false result.</li><li>For each instance field defined by the type, compare the value in the this object with the value in the obj object. If any fields are not equal, return false.</li><li>Call the base classâ€™s Equals method so it can compare any fields defined by it. If the base classâ€™s Equals method returns false, return false; otherwise, return true.</li></ol></blockquote><blockquote><p>So Microsoft should have implemented Objectâ€™s Equals like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Object</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token return-type class-name">Boolean</span> <span class="token function">Equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// The given object to compare to can't be null </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// If objects are different types, they can't be equal. </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> obj<span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// If objects are same type, return true if all of their fields match </span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Because System.Object defines no fields, the fields match </span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>But, because Microsoft didnâ€™t implement Equals this way, the rules for how to implement Equals are significantly more complicated than you would think. When a type overrides Equals, the override should call its base classâ€™s implementation of Equals unless it would be calling Objectâ€™s implementation. This also means that because a type can override Objectâ€™s Equals method, this Equals method can no longer be called to test for identity. To fix this, Object offers a static ReferenceEquals method, which is implemented like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Object</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Boolean</span> <span class="token function">ReferenceEquals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> objA<span class="token punctuation">,</span> <span class="token class-name">Object</span> objB<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">return</span> <span class="token punctuation">(</span>objA <span class="token operator">==</span> objB<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>You should always call ReferenceEquals if you want to check for identity (if two references point to the same object). You shouldnâ€™t use the C# == operator (unless you cast both operands to Object first) because one of the operandsâ€™ types could overload the == operator, giving it semantics other than identity.</p></blockquote><blockquote><p>As you can see, the .NET Framework has a very confusing story when it comes to object equality and identity. By the way, System.ValueType (the base class of all value types) does override Objectâ€™s Equals method and is correctly implemented to perform a value equality check (not an identity check). Internally, ValueTypeâ€™s Equals is implemented this way:</p><ol><li>If the obj argument is null, return false.</li><li>If the this and obj arguments refer to objects of different types, return false.</li><li>For each instance field defined by the type, compare the value in the this object with the value in the obj object by calling the fieldâ€™s Equals method. If any fields are not equal, return false.</li><li>Return true. Objectâ€™s Equals method is not called by ValueTypeâ€™s Equals method.</li></ol></blockquote><blockquote><p>Internally, ValueTypeâ€™s Equals method uses reflection (covered in Chapter 23, â€œAssembly Loading and Reflectionâ€) to accomplish step 3. Because the CLRâ€™s reflection mechanism is slow, when defining your own value type, you should override Equals and provide your own implementation to improve the performance of value equality comparisons that use instances of your type. Of course, in your own implementation, do not call base.Equals.</p></blockquote><blockquote><p>When defining your own type, if you decide to override Equals, you must ensure that it adheres to the four properties of equality:</p><p>â–  Equals must be reflexive; that is, x.Equals(x) must return true.</p><p>â–  Equals must be symmetric; that is, x.Equals(y) must return the same value as y.Equals(x).</p><p>â–  Equals must be transitive; that is, if x.Equals(y) returns true and y.Equals(z) returns true, then x.Equals(z) must also return true.</p><p>â–  Equals must be consistent. Provided that there are no changes in the two values being compared, Equals should consistently return true or false.</p></blockquote><blockquote><p>If your implementation of Equals fails to adhere to all of these rules, your application will behave in strange and unpredictable ways.</p></blockquote><blockquote><p>When overriding the Equals method, there are a couple more things that youâ€™ll probably want to do:</p><p>â–  Have the type implement the System.IEquatable interfaceâ€™s Equals method This generic interface allows you to define a type-safe Equals method. Usually, youâ€™ll implement the Equals method that takes an Object parameter to internally call the type-safe Equals method.</p><p>â–  Overload the == and != operator methods Usually, youâ€™ll implement these operator methods to internally call the type-safe Equals method.</p></blockquote><blockquote><p>Furthermore, if you think that instances of your type will be compared for the purposes of sorting, youâ€™ll want your type to also implement System.IComparableâ€™s CompareTo method and System.IComparableâ€™s type-safe CompareTo method. If you implement these methods, youâ€™ll also want to overload the various comparison operator methods (&lt;, &lt;=, &gt;, &gt;=) and implement these methods internally to call the type-safe CompareTo method.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šå°†å€¼ç±»å‹è½¬æ¢æˆå¼•ç”¨ç±»å‹è¦ä½¿ç”¨è£…ç®±æœºåˆ¶ï¼Œè¿™ä¼šåœ¨æ‰˜ç®¡å †ä¸­åˆ†é…å†…å­˜å¹¶ä¸”å€¼ç±»å‹çš„å­—æ®µä¼šå¤åˆ¶åˆ°æ–°åˆ†é…çš„å †å†…å­˜ï¼Œç„¶åè¿”å›å¯¹è±¡åœ°å€ã€‚æœ‰è£…ç®±è‡ªç„¶ä¼šæœ‰æ‹†ç®±ï¼Œæ‹†ç®±ä¸æ˜¯ç›´æ¥æŠŠè£…ç®±è¿‡ç¨‹å€’è¿‡æ¥ï¼Œæ‹†ç®±çš„ä»£ä»·ä¼šæ¯”è£…ç®±ä½å¾ˆå¤šï¼Œå› ä¸ºæ‹†ç®±åªæ˜¯è·å–å·²è£…ç®±å®ä¾‹ä¸­æœªè£…ç®±éƒ¨åˆ†çš„æŒ‡é’ˆï¼Œä¸ä¼šå­˜åœ¨ä»»ä½•å†…å­˜ä¸­çš„å¤åˆ¶ï¼Œåªä¸è¿‡è¿™ä¸ªåé¢å¾€å¾€æ¥ç€è¿›è¡Œäº†ä¸€æ¬¡å­—æ®µå¤åˆ¶çš„æ“ä½œï¼Œè¿™æ—¶æ‰å°†å€¼ä»å †å¤åˆ¶åˆ°åŸºäºæ ˆçš„å€¼ç±»å‹å®ä¾‹ä¸­ï¼ˆå¿½ç•¥å¯¹è±¡çš„ â€œç±»å‹å¯¹è±¡æŒ‡é’ˆâ€ å’ŒåŒæ­¥å—ç´¢å¼• â€œè¿™ä¸¤ä¸ªé¢å¤–çš„æˆå‘˜ï¼‰ã€‚åœ¨å¯¹å¯¹è±¡è¿›è¡Œæ‹†ç®±æ—¶ï¼Œåªèƒ½å°†å…¶è½¬å‹ä¸ºæœ€åˆæœªè£…ç®±çš„å€¼ç±»å‹ï¼Œå¦åˆ™ä¼šæŠ›å‡º <code>InvalidCastException</code> å¼‚å¸¸ã€‚æœ‰çš„è¯­è¨€ï¼ˆæ¯”å¦‚ C++/CLIï¼‰å…è®¸åœ¨ä¸å¤åˆ¶å­—æ®µçš„å‰æä¸‹å¯¹å·²è£…ç®±çš„å€¼ç±»å‹è¿›è¡Œæ‹†ç®±ã€‚æˆ‘ä»¬åº”å½“å‡å°‘ç¨‹åºä¸­çš„è£…ç®± / æ‹†ç®±æ¬¡æ•°ï¼Œå› ä¸ºé¢å¤–çš„è£…ç®±æ­¥éª¤ä¼šä»æ‰˜ç®¡å †ä¸­åˆ†é…ä¸€ä¸ªé¢å¤–çš„å¯¹è±¡ï¼Œå°†æ¥å¿…é¡»å¯¹å…¶è¿›è¡Œåƒåœ¾å›æ”¶ã€‚FCL çš„è®¸å¤šæ–¹æ³•éƒ½é’ˆå¯¹ä¸åŒçš„å€¼ç±»å‹å‚æ•°è¿›è¡Œäº†é‡è½½ï¼Œå¤§å¤šæ•°æ–¹æ³•è¿›è¡Œé‡è½½å”¯ä¸€çš„ç›®çš„å°±æ˜¯å‡å°‘å¸¸ç”¨å€¼ç±»å‹çš„è£…ç®±æ¬¡æ•°ã€‚å®šä¹‰è‡ªå·±çš„ç±»æ—¶ï¼Œå¯ä»¥å°†ç±»ä¸­çš„æ–¹æ³•å®šä¹‰ä¸ºæ³›å‹ï¼ˆé€šè¿‡ç±»å‹çº¦æŸå°†ç±»å‹å‚æ•°é™åˆ¶ä¸ºå€¼ç±»å‹ï¼‰ã€‚è¿™æ ·æ–¹æ³•å°±å¯ä»¥è·å–ä»»ä½•å€¼ç±»å‹è€Œä¸å¿…è£…ç®±ã€‚ç”±äºæœªè£…ç®±å€¼ç±»å‹æ²¡æœ‰åŒæ­¥å—ç´¢å¼•ï¼Œæ‰€ä»¥ä¸èƒ½ä½¿ç”¨ <code>System.Threading.Monitor</code> ç±»å‹çš„æ–¹æ³•ï¼ˆæˆ–è€… C#lock è¯­å¥ï¼‰è®©å¤šä¸ªçº¿ç¨‹åŒæ­¥å¯¹å®ä¾‹çš„è®¿é—®ã€‚è™½ç„¶æœªè£…ç®±å€¼ç±»å‹æ²¡æœ‰ç±»å‹å¯¹è±¡æŒ‡é’ˆï¼Œä½†ä»å¯è°ƒç”¨ç”±ç±»å‹ç»§æ‰¿æˆ–é‡å†™çš„è™šæ–¹æ³•ï¼ˆæ¯”å¦‚ <code>Equals</code> ï¼Œ <code>GetHashCode</code> æˆ–è€… <code>ToString</code> ï¼‰ã€‚å¦‚æœå€¼ç±»å‹é‡å†™äº†å…¶ä¸­ä»»ä½•è™šæ–¹æ³•ï¼Œé‚£ä¹ˆ CLR å¯ä»¥éè™šåœ°è°ƒç”¨è¯¥æ–¹æ³•ï¼Œå› ä¸ºå€¼ç±»å‹åº”è¯•å¯†å°ï¼Œä¸å¯èƒ½æœ‰ç±»å‹ä»å®ƒä»¬æ´¾ç”Ÿï¼Œè€Œä¸”è°ƒç”¨è™šæ–¹æ³•çš„å€¼ç±»å‹å®ä¾‹æ²¡æœ‰è£…ç®±ã€‚ç„¶è€Œï¼Œå¦‚æœé‡å†™çš„è™šæ–¹æ³•è¦è°ƒç”¨æ–¹æ³•åœ¨åŸºç±»ä¸­çš„å®ç°ï¼Œé‚£ä¹ˆåœ¨è°ƒç”¨åŸºç±»çš„å®ç°æ—¶ï¼Œå€¼ç±»å‹å®ä¾‹ä¼šè£…ç®±ï¼Œä»¥ä¾¿èƒ½å¤Ÿé€šè¿‡ this æŒ‡é’ˆå°†å¯¹ä¸€ä¸ªå †å¯¹è±¡çš„å¼•ç”¨ä¼ ç»™åŸºæ–¹æ³•ã€‚æ­¤å¤–ï¼Œå°†å€¼ç±»å‹çš„æœªè£…ç®±å®ä¾‹è½¬å‹æœªç±»å‹çš„æŸä¸ªæ¥å£æ—¶è¦å¯¹å®ä¾‹è¿›è¡Œè£…ç®±ã€‚è¿™æ˜¯å› ä¸ºæ¥å£å˜é‡å¿…é¡»åŒ…å«å¯¹å †å¯¹è±¡çš„å¼•ç”¨ã€‚æœ‰çš„è¯­è¨€ï¼ˆæ¯”å¦‚ C++/CLIï¼‰å…è®¸æ›´æ”¹å·²è£…ç®±å€¼ç±»å‹ä¸­çš„å­—æ®µï¼Œä½† C# ä¸å…è®¸ã€‚ä¸è¿‡ï¼Œå¯ä»¥ç”¨æ¥å£æ¬ºéª— C#ï¼Œè®©å®ƒå…è®¸è¿™ä¸ªæ“ä½œã€‚æ­£å¸¸æ¥è¯´å€¼ç±»å‹åº”è¯¥å®šä¹‰æˆ â€œä¸å¯å˜â€ï¼ˆimmutableï¼‰ï¼Œä»¥ä¾¿åœ¨ä½¿ç”¨ç±»å‹æ—¶ä¸ä¼šå‘ç”Ÿä»»ä½•ç¨€å¥‡å¤æ€ªçš„äº‹æƒ…ã€‚å¯¹è±¡è¿˜æœ‰ç›¸ç­‰æ€§å’ŒåŒä¸€æ€§çš„æ¦‚å¿µã€‚å¯¹äº Object çš„ <code>Equals</code> æ–¹æ³•çš„é»˜è®¤å®ç°çš„å®é™…æ—¶åŒä¸€æ€§ï¼Œè€Œéç›¸ç­‰æ€§ã€‚åŒä¸€æ€§æŒ‡çš„æ˜¯æ˜¯å¦æ˜¯ç›¸åŒçš„å¯¹è±¡ã€‚ç›¸ç­‰æ€§æŒ‡çš„æ˜¯ä¸¤ä¸ªå¯¹è±¡æ˜¯å¦åŒ…å«ç›¸ç­‰çš„å€¼ã€‚ç”±äºç±»å‹èƒ½é‡å†™ Object çš„ <code>Equals</code> æ–¹æ³•ï¼Œæ‰€ä»¥ä¸èƒ½å†ç”¨å®ƒæµ‹è¯•åŒä¸€æ€§ã€‚è¦æƒ³æ£€æŸ¥åŒä¸€æ€§åŠ¡å¿…è°ƒç”¨ <code>ReferenceEquals</code> ï¼Œä¸åº”ä½¿ç”¨ C# çš„ == æ“ä½œç¬¦ï¼ˆé™¤éå…ˆæŠŠä¸¤ä¸ªæ“ä½œæ•°éƒ½è½¬å‹ä¸º Objectï¼‰ï¼Œå› ä¸ºæŸä¸ªæ“ä½œæ•°çš„ç±»å‹å¯èƒ½é‡è½½äº† == æ“ä½œç¬¦ï¼Œä¸ºå…¶èµ‹äºˆä¸åŒäº â€œåŒä¸€æ€§â€ çš„è¯­ä¹‰ã€‚ <code>System.ValueType</code> ä»å†™äº† Object çš„ <code>Equals</code> æ–¹æ³•ï¼Œå¹¶è¿›è¡Œäº†æ­£ç¡®çš„å®ç°æ¥æ‰§è¡Œå€¼çš„ç›¸ç­‰æ€§æ£€æŸ¥ã€‚åœ¨å†…éƒ¨ï¼Œ <code>ValueType</code> çš„ <code>Equals</code> æ–¹æ³•åˆ©ç”¨åå°„å°†ç±»å‹å®šä¹‰çš„æ¯ä¸ªå®ä¾‹å­—æ®µè¿›è¡Œæ¯”è¾ƒã€‚ç”±äº CLR åå°„æœºåˆ¶æ…¢ï¼Œå®šä¹‰è‡ªå·±çš„å€¼ç±»å‹æ—¶åº”é‡å†™ Equals æ–¹æ³•æ¥æä¾›è‡ªå·±çš„å®ç°ï¼Œä»è€Œæé«˜è‡ªå·±ç±»å‹çš„å®ä¾‹è¿›è¡Œå€¼ç›¸ç­‰æ¯”è¾ƒçš„æ€§èƒ½ã€‚é‡å†™ <code>Equals</code> æ–¹æ³•æ—¶ï¼Œå¯èƒ½è¿˜ä¼šå®ç° <code>System.IEquatable&lt;T&gt;æ¥å£çš„Equalsæ–¹æ³•</code> ï¼Œè¿™ä¸ªæ³›å‹æ¥å£å…è®¸å®šä¹‰ç±»å‹å®‰å…¨çš„ <code>Equals</code> æ–¹æ³•ï¼Œåœ¨è·å–ä¸€ä¸ª Object å‚æ•°çš„ <code>Equals</code> æ–¹æ³•æˆ–è€…é‡è½½çš„ == å’Œï¼= æ“ä½œç¬¦æ–¹æ³•ä¸­å°±å¯ä»¥è°ƒç”¨ç±»å‹å®‰å…¨çš„ <code>Equals</code> æ–¹æ³•ã€‚</p><h2 id="object-hash-codes"><a class="anchor" href="#object-hash-codes">#</a> Object Hash Codes</h2><blockquote><p>The designers of the FCL decided that it would be incredibly useful if any instance of any object could be placed into a hash table collection. To this end, System.Object provides a virtual GetHashCode method so that an Int32 hash code can be obtained for any and all objects.</p></blockquote><blockquote><p>If you define a type and override the Equals method, you should also override the GetHashCode method. In fact, Microsoftâ€™s C# compiler emits a warning if you define a type that overrides Equals without also overriding GetHashCode. For example, compiling the following type yields this warning: warning CS0659: 'Program' overrides Object.Equals(object o) but does not override Object.GetHashCode().</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name">Boolean</span> <span class="token function">Equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The reason a type that defines Equals must also define GetHashCode is that the implementation of the System.Collections.Hashtable type, the System.Collections.Generic.Dictionary type, and some other collections require that any two objects that are equal must have the same hash code value. So if you override Equals, you should override GetHashCode to ensure that the algorithm you use for calculating equality corresponds to the algorithm you use for calculating the objectâ€™s hash code.</p></blockquote><blockquote><p>Basically, when you add a key/value pair to a collection, a hash code for the key object is obtained first. This hash code indicates which â€œbucketâ€ the key/value pair should be stored in. When the collection needs to look up a key, it gets the hash code for the specified key object. This code identifies the â€œbucketâ€ that is now searched sequentially, looking for a stored key object that is equal to the specified key object. Using this algorithm of storing and looking up keys means that if you change a key object that is in a collection, the collection will no longer be able to find the object. If you intend to change a key object in a hash table, you should remove the original key/value pair, modify the key object, and then add the new key/value pair back into the hash table.</p></blockquote><blockquote><p>Defining a GetHashCode method can be easy and straightforward. But depending on your data types and the distribution of data, it can be tricky to come up with a hashing algorithm that returns a well-distributed range of values. Hereâ€™s a simple example that will probably work just fine for Point objects.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">Int32</span> m_x<span class="token punctuation">,</span> m_y<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name">Int32</span> <span class="token function">GetHashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">return</span> m_x <span class="token operator">^</span> m_y<span class="token punctuation">;</span> <span class="token comment">// m_x XOR'd with m_y </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token range operator">..</span><span class="token punctuation">.</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When selecting an algorithm for calculating hash codes for instances of your type, try to follow these guidelines:</p><p>â–  Use an algorithm that gives a good random distribution for the best performance of the hash table.</p><p>â–  Your algorithm can also call the base typeâ€™s GetHashCode method, including its return value. However, you donâ€™t generally want to call Objectâ€™s or ValueTypeâ€™s GetHashCode method, because the implementation in either method doesnâ€™t lend itself to high-performance hashing algorithms.</p><p>â–  Your algorithm should use at least one instance field.</p><p>â–  Ideally, the fields you use in your algorithm should be immutable; that is, the fields should be initialized when the object is constructed, and they should never again change during the objectâ€™s lifetime.</p><p>â–  Your algorithm should execute as quickly as possible.</p><p>â–  Objects with the same value should return the same code. For example, two String objects with the same text should return the same hash code value.</p></blockquote><blockquote><p>System.Objectâ€™s implementation of the GetHashCode method doesnâ€™t know anything about its derived type and any fields that are in the type. For this reason, Objectâ€™s GetHashCode method returns a number that is guaranteed not to change for the lifetime of the object.</p></blockquote><p>ğŸ’¡é‡è¦æç¤ºï¼šå‡å¦‚å› ä¸ºæŸäº›åŸå› è¦å®ç°è‡ªå·±çš„å“ˆå¸Œè¡¨é›†åˆï¼Œæˆ–è€…è¦åœ¨å®ç°çš„ä»£ç ä¸­è°ƒç”¨ <code>GetHashCode</code> ï¼Œè®°ä½åƒä¸‡ä¸è¦å¯¹å“ˆå¸Œç è¿›è¡ŒæŒä¹…åŒ–ï¼Œå› ä¸ºå“ˆå¸Œç å¾ˆå®¹æ˜“æ”¹å˜ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªç±»å‹æœªæ¥çš„ç‰ˆæœ¬å¯èƒ½ä½¿ç”¨ä¸åŒçš„ç®—æ³•è®¡ç®—å¯¹è±¡å“ˆå¸Œç ã€‚æœ‰ä¸ªå…¬å¸æ²¡æœ‰æŠŠè¿™ä¸ªè­¦å‘Šæ”¾åœ¨å¿ƒä¸Šã€‚åœ¨ä»–ä»¬çš„ç½‘ç«™ä¸Šï¼Œç”¨æˆ·å¯é€‰æ‹©ç”¨æˆ·åå’Œå¯†ç æ¥åˆ›å»ºè´¦å·ã€‚ç„¶åï¼Œç½‘ç«™è·å–å¯†ç  <code>String</code> ï¼Œè°ƒç”¨ <code>GetHashCode</code> ï¼Œå°†å“ˆå¸Œç æŒä¹…æ€§å­˜å‚¨åˆ°æ•°æ®åº“ã€‚ç”¨æˆ·é‡æ–°ç™»å½•ç½‘ç«™ï¼Œè¾“å…¥è‡ªå·±çš„å¯†ç ã€‚ç½‘ç«™å†æ¬¡è°ƒç”¨ <code>GetHashCode</code> ï¼Œå¹¶å°†å“ˆå¸Œç ä¸æ•°æ®åº“ä¸­å­˜å‚¨çš„å€¼æ¯”è¾ƒï¼ŒåŒ¹é…å°±å…è®¸è®¿é—®ã€‚ä¸å¹¸çš„æ˜¯ï¼Œå…¬å¸å‡çº§åˆ°æ–°ç‰ˆæœ¬ CLR åï¼Œ <code>String</code> çš„ <code>GetHashCode</code> æ–¹æ³•å‘ç”Ÿäº†æ”¹å˜ï¼Œç°åœ¨è¿”å›ä¸åŒçš„å“ˆå¸Œç ã€‚ç»“æœæ˜¯æ‰€æœ‰ç”¨æˆ·éƒ½æ— æ³•ç™»å½•ï¼</p><p>ğŸ’¡å°ç»“ï¼š <code>System.Object</code> æä¾›äº†è™šæ–¹æ³• <code>GetHashCode</code> ï¼Œå®ƒèƒ½è·å–ä»»æ„å¯¹è±¡çš„ Int32 å“ˆå¸Œç ã€‚å¦‚æœé‡å†™äº† <code>Equals</code> æ–¹æ³•ï¼Œè¿˜åº”è¯¥é‡å†™ <code>GetHashCode</code> æ–¹æ³•ï¼Œå¦è€…ä¼šæ”¶åˆ° Microsoft C# ç¼–è¯‘å™¨çš„è­¦å‘Šï¼Œè¿™æ˜¯ç”±äºåœ¨ <code>System.Collections.Hashtable</code> ç±»å‹ã€ <code>System.Collections.Generic.Dictionary</code> ç±»å‹ä»¥åŠå…¶å®ƒä¸€äº›é›†åˆçš„å®ç°ä¸­ï¼Œè¦æ±‚ä¸¤ä¸ªå¯¹è±¡å¿…é¡»å…·æœ‰ç›¸åŒå“ˆå¸Œç æ‰è¢«è§†ä¸ºç›¸ç­‰ã€‚æ‰€ä»¥ï¼Œé‡å†™ <code>Equals</code> å°±å¿…é¡»é‡å†™ <code>GetHashdCode</code> ï¼Œç¡®ä¿ç›¸ç­‰æ€§ç®—æ³•å’Œå¯¹è±¡å“ˆå¸Œç ç®—æ³•ä¸€è‡´ã€‚åœ¨å‘é›†åˆä¸­æ·»åŠ é”®å€¼å¯¹æ˜¯ï¼Œé¦–å…ˆè¦è·å–é”®å¯¹è±¡çš„å“ˆå¸Œç ï¼Œè¯¥å“ˆå¸Œç ä¹‹å¤„é”®å€¼å¯¹å­˜å‚¨åˆ°å“ªä¸ªå“ˆå¸Œæ¡¶ï¼ˆbucketï¼‰ä¸­ï¼Œå“ˆå¸Œç æ ‡è¯†äº†ä¹‹åè¦æœç´¢çš„å“ˆå¸Œæ¡¶ï¼Œå¹¶åœ¨å…¶ä¸­æŸ¥æ‰¾ä¸æŒ‡å®šé”®å¯¹è±¡ç›¸ç­‰çš„é”®å¯¹è±¡ã€‚ç”±äºå“ˆå¸Œè¡¨é‡‡ç”¨è¿™ä¸ªç®—æ³•æ¥å­˜å‚¨å’ŒæŸ¥æ‰¾é”®ï¼Œæ„å‘³ç€ä¸€æ—¦ä¿®æ”¹äº†é›†åˆä¸­çš„ä¸€ä¸ªé”®å¯¹è±¡ï¼Œé›†åˆå°±å†ä¹Ÿæ‰¾ä¸åˆ°è¯¥å¯¹è±¡ã€‚æ‰€ä»¥ï¼Œéœ€è¦ä¿®æ”¹å“ˆå¸Œè¡¨ä¸­é”®å¯¹è±¡æ—¶ï¼Œæ­£ç¡®åšæ³•æ˜¯æº¢å‡ºåŸæ¥çš„é”®å€¼å¯¹ï¼Œä¿®æ”¹é”®å¯¹è±¡ï¼Œå†å°†æ–°çš„é”®å€¼å¯¹æ·»åŠ å›å“ˆå¸Œè¡¨ã€‚åœ¨é€‰æ‹©ç®—æ³•æ¥è®¡ç®—ç±»å‹å®ä¾‹çš„å“ˆå¸Œç æ—¶ï¼Œè¿˜åº”è¯¥å­˜å¯¿ä¸€äº›è§„åˆ™ã€‚ä¾‹å¦‚ç®—æ³•è¦æä¾›è‰¯å¥½çš„éšæœºåˆ†å¸ƒã€ä¸€èˆ¬ä¸è°ƒç”¨ <code>Object</code> æˆ– <code>ValueType</code> çš„ <code>GetHashCode</code> æ–¹æ³•ï¼ˆå› ä¸ºä¸¤è€…çš„å®ç°éƒ½å’Œé«˜æ€§èƒ½å“ˆå¸Œç®—æ³• â€œä¸æ²¾è¾¹â€ï¼‰ã€‚ <code>System.Object</code> å®ç°çš„ <code>GetHashCode</code> æ–¹æ³•å¯¹æ´¾ç”Ÿç±»å‹å’Œå…¶ä¸­çš„å­—æ®µä¸€æ— æ‰€çŸ¥ï¼Œæ‰€ä»¥è¿”å›ä¸€ä¸ªåœ¨å¯¹è±¡ç”Ÿå­˜æœŸä¿è¯ä¸å˜çš„ç¼–å·ã€‚</p><h2 id="the-dynamic-primitive-type"><a class="anchor" href="#the-dynamic-primitive-type">#</a> The dynamic Primitive Type</h2><blockquote><p>C# is a type-safe programming language. This means that all expressions resolve into an instance of a type and the compiler will generate only code that is attempting to perform an operation that is valid for this type. The benefit of a type-safe programming language over a nonâ€“type-safe programming language is that many programmer errors are detected at compile time, helping to ensure that the code is correct before you attempt to execute it. In addition, compile-time languages can typically produce smaller and faster code because they make more assumptions at compile time and bake those assumptions into the resulting IL and metadata.</p></blockquote><blockquote><p>However, there are also many occasions when a program has to act on information that it doesnâ€™t know about until it is running. Although you can use type-safe programming languages (like C#) to interact with this information, the syntax tends to be clumsy, especially because you tend to work a lot with strings, and performance is hampered as well. If you are writing a pure C# application, then the only occasion you have for working with runtime-determined information is when you are using reflection (discussed in Chapter 23). However, many developers also use C# to communicate with components that are not implemented in C#. Some of these components could be .NET-dynamic languages such as Python or Ruby, or COM objects that support the IDispatch interface (possibly implemented in native C or C++), or HTML Document Object Model (DOM) objects (implemented using various languages and technologies). Communicating with HTML DOM objects is particularly useful when building a Microsoft Silverlight application.</p></blockquote><blockquote><p>To make it easier for developers using reflection or communicating with other components, the C# compiler offers you a way to mark an expressionâ€™s type as dynamic. You can also put the result of an expression into a variable and you can mark a variableâ€™s type as dynamic. This dynamic expression/ variable can then be used to invoke a member such as a field, a property/indexer, a method, delegate, and unary/binary/conversion operators. When your code invokes a member by using a dynamic expression/variable, the compiler generates special IL code that describes the desired operation. This special code is referred to as the payload. At run time, the payload code determines the exact operation to execute based on the actual type of the object now referenced by the dynamic expression/ variable.</p></blockquote><blockquote><p>Here is some code to demonstrate what Iâ€™m talking about.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DynamicDemo</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name"><span class="token keyword">dynamic</span></span> <span class="token keyword">value</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> demo <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> demo <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> demo<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">value</span> <span class="token operator">=</span> <span class="token punctuation">(</span>demo <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">?</span> <span class="token punctuation">(</span><span class="token keyword">dynamic</span><span class="token punctuation">)</span> <span class="token number">5</span> <span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token keyword">dynamic</span><span class="token punctuation">)</span> <span class="token string">"A"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">value</span> <span class="token operator">=</span> <span class="token keyword">value</span> <span class="token operator">+</span> <span class="token keyword">value</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token function">M</span><span class="token punctuation">(</span><span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">M</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"M(Int32): "</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">M</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"M(String): "</span> <span class="token operator">+</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When I execute Main, I get the following output.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">M</span><span class="token punctuation">(</span>Int32<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token number">10</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">M</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span><span class="token punctuation">:</span> AA</pre></td></tr></table></figure><blockquote><p>To understand whatâ€™s happening, letâ€™s start by looking at the + operator. This operator has operands of the dynamic type. Because value is dynamic, the C# compiler emits payload code that will examine the actual type of value at run time and determine what the + operator should actually do.</p></blockquote><blockquote><p>The first time the + operator evaluates, value contains 5 (an Int32) and the result is 10 (also an Int32). This puts this result in the value variable. Then, the M method is called, passing it value. For the call to M, the compiler will emit payload code that will, at run time, examine the actual type of the argument being passed to M and determine which overload of the M method to call. When value contains an Int32, the overload of M that takes an Int32 parameter is called.</p></blockquote><blockquote><p>The second time the + operator evaluates, value contains â€œAâ€ (a String) and the result is â€œAAâ€ (the result of concatenating â€œAâ€ with itself). Then, the M method is called again, passing it value. This time, the payload code determines that the actual type being passed to M is a String and calls the overload of M that takes a String parameter.</p></blockquote><blockquote><p>When the type of a field, method parameter, or method return type is specified as dynamic, the compiler converts this type to the System.Object type and applies an instance of System.Runtime.CompilerServices.DynamicAttribute to the field, parameter, or return type in metadata. If a local variable is specified as dynamic, then the variableâ€™s type will also be of type Object, but the DynamicAttribute is not applied to the local variable because its usage is self-contained within the method. Because dynamic is really the same as Object, you cannot write methods whose signature differs only by dynamic and Object.</p></blockquote><blockquote><p>It is also possible to use dynamic when specifying generic type arguments to a generic class (reference type), a structure (value type), an interface, a delegate, or a method. When you do this, the compiler converts dynamic to Object and applies DynamicAttribute to the various pieces of metadata where it makes sense. Note that the generic code that you are using has already been compiled and will consider the type to be Object; no dynamic dispatch will be performed because the compiler did not produce any payload code in the generic code.</p></blockquote><blockquote><p>Any expression can implicitly be cast to dynamic because all expressions result in a type that is derived from Object.2 Normally, the compiler does not allow you to write code that implicitly casts an expression from Object to another type; you must use explicit cast syntax. However, the compiler does allow you to cast an expression from dynamic to another type by using implicit cast syntax.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Object</span> o1 <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment">// OK: Implicit cast from Int32 to Object (boxing)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Int32</span> n1 <span class="token operator">=</span> o<span class="token punctuation">;</span> <span class="token comment">// Error: No implicit cast from Object to Int32</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">Int32</span> n2 <span class="token operator">=</span> <span class="token punctuation">(</span>Int32<span class="token punctuation">)</span> o<span class="token punctuation">;</span> <span class="token comment">// OK: Explicit cast from Object to Int32 (unboxing)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token class-name"><span class="token keyword">dynamic</span></span> d1 <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment">// OK: Implicit cast from Int32 to dynamic (boxing)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token class-name">Int32</span> n3 <span class="token operator">=</span> d1<span class="token punctuation">;</span> <span class="token comment">// OK: Implicit cast from dynamic to Int32 (unboxing)</span></pre></td></tr></table></figure><blockquote><p>Although the compiler allows you to omit the explicit cast when casting from dynamic to some other type, the CLR will validate the cast at run time to ensure that type safety is maintained. If the objectâ€™s type is not compatible with the cast, the CLR will throw an InvalidCastException exception.</p></blockquote><blockquote><p>Note that the result of evaluating a dynamic expression is a dynamic expression. Examine this code.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token keyword">dynamic</span></span> d <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name"><span class="token keyword">var</span></span> result <span class="token operator">=</span> <span class="token function">M</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Note: 'var result' is the same as 'dynamic result'</span></pre></td></tr></table></figure><blockquote><p>Here, the compiler allows the code to compile because it doesnâ€™t know at compile time which M method it will call. Therefore, it also does not know what type of result M will return. And so, the compiler assumes that the result variable is of type dynamic itself. You can verify this by placing your mouse over var in the Visual Studio editor; the IntelliSense window will indicate 'dynamic: Represents an object whose operations will be resolved at runtime.' If the M method invoked at run time has a return type of void, a Microsoft.CSharp.RuntimeBinder.RuntimeBinderException exception is thrown.</p></blockquote><p>ğŸ’¡é‡è¦æç¤ºï¼šä¸è¦æ··æ·† <code>dynamic</code> å’Œ <code>var</code> ã€‚ç”¨ <code>var</code> å£°æ˜å±€éƒ¨å˜é‡åªæ˜¯ä¸€ç§ç®€åŒ–è¯­æ³•ï¼Œå®ƒè¦æ±‚ç¼–è¯‘å™¨æ ¹æ®è¡¨è¾¾å¼æ¨æ–­å…·ä½“æ•°æ®ç±»å‹ã€‚ <code>var</code> å…³é”®å­—åªèƒ½åœ¨æ–¹æ³•å†…éƒ¨å£°æ˜å±€éƒ¨å˜é‡ï¼Œè€Œ <code>dynamic</code> å…³é”®å­—å¯ç”¨äºå±€éƒ¨å˜é‡ã€å­—æ®µå’Œå‚æ•°ã€‚è¡¨è¾¾å¼ä¸èƒ½è½¬å‹ä¸º <code>var</code> ï¼Œä½†èƒ½è½¬å‹ä¸º <code>dynamic</code> ã€‚å¿…é¡»æ˜¾ç¤ºåˆå§‹åŒ–ç”¨ <code>var</code> å£°æ˜çš„å˜é‡ï¼Œä½†æ— éœ€åˆå§‹åŒ–ç”¨ <code>dynamic</code> å£°æ˜çš„å˜é‡ã€‚æ¬²çŸ¥ C# çš„ <code>var</code> å…³é”®å­—çš„è¯¦æƒ…ï¼Œè¯·å‚è§ 9.2 èŠ‚ â€œéšå¼ç±»å‹çš„å±€éƒ¨å˜é‡â€ã€‚</p><blockquote><p>However, when converting from dynamic to another static type, the resultâ€™s type is, of course, the static type. Similarly, when constructing a type by passing one or more dynamic arguments to its constructor, the result is the type of object you are constructing.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token keyword">dynamic</span></span> d <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name"><span class="token keyword">var</span></span> x <span class="token operator">=</span> <span class="token punctuation">(</span>Int32<span class="token punctuation">)</span> d<span class="token punctuation">;</span> <span class="token comment">// Conversion: 'var x' is the same as 'Int32 x'</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name"><span class="token keyword">var</span></span> dt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">DateTime</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Construction: 'var dt' is the same as 'DateTime dt'</span></pre></td></tr></table></figure><blockquote><p>If a dynamic expression is specified as the collection in a foreach statement or as a resource in a using statement, the compiler will generate code that attempts to cast the expression to the non-generic System.IEnumerable interface or to the System.IDisposable interface, respectively. If the cast succeeds, the expression is used and the code runs just fine. If the cast fails, a Microsoft.CSharp.RuntimeBinder.RuntimeBinderException exception is thrown.</p></blockquote><p>ğŸ’¡é‡è¦æç¤ºï¼š <code>dynamic</code> è¡¨è¾¾å¼å…¶å®æ˜¯å’Œ <code>System.Object</code> ä¸€æ ·çš„ç±»å‹ï¼Œç¼–è¯‘å™¨å‡å®šä½ åœ¨è¡¨è¾¾å¼ä¸Šè¿›è¡Œçš„ä»»ä½•æ“ä½œéƒ½æ˜¯åˆæ³•çš„ï¼Œæ‰€ä»¥ä¸ä¼šç”Ÿæˆä»»ä½•è­¦å‘Šæˆ–é”™è¯¯ã€‚ä½†å¦‚æœè¯•å›¾åœ¨è¿è¡Œæ—¶æ‰§è¡Œæ— æ•ˆçš„æ“ä½œï¼Œå°±ä¼šæŠ›å‡ºå¼‚å¸¸ã€‚æ­¤å¤–ï¼Œ Visual Studio æ— æ³•æä¾›ä»»ä½• â€œæ™ºèƒ½æ„ŸçŸ¥â€ æ”¯æŒæ¥å¸®åŠ©ä½ å†™é’ˆå¯¹ <code>dynamic</code> è¡¨è¾¾å¼çš„ä»£ç ã€‚è™½ç„¶èƒ½å®šä¹‰å¯¹ <code>Object</code> è¿›è¡Œæ‰©å±•æ–¹æ³• (è¯¦æƒ…å‚è§ç¬¬ 8 ç«  â€œæ–¹æ³•â€)ï¼Œä½†ä¸èƒ½å®šä¹‰å¯¹ <code>dynamic</code> è¿›è¡Œæ‰©å±•çš„æ‰©å±•æ–¹æ³•ã€‚å¦å¤–ï¼Œä¸èƒ½å°† lambda è¡¨è¾¾å¼æˆ–åŒ¿åæ–¹æ³• (éƒ½åœ¨ç¬¬ 17 ç«  â€œå§”æ‰˜â€ ä¸­è®¨è®º) ä½œä¸ºå®å‚ä¼ ç»™ <code>dynamic</code> æ–¹æ³•è°ƒç”¨ï¼Œå› ä¸ºç¼–è¯‘å™¨æ¨æ–­ä¸äº†è¦ä½¿ç”¨çš„ç±»å‹ã€‚</p><blockquote><p>Here is an example of some C# code that uses COM IDispatch to create a Microsoft Excel workbook and places a string in cell A1.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">Microsoft<span class="token punctuation">.</span>Office<span class="token punctuation">.</span>Interop<span class="token punctuation">.</span>Excel</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">Application</span> excel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Application</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> excel<span class="token punctuation">.</span>Visible <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> excel<span class="token punctuation">.</span>Workbooks<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>Type<span class="token punctuation">.</span>Missing<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">(</span><span class="token punctuation">(</span>Range<span class="token punctuation">)</span>excel<span class="token punctuation">.</span>Cells<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Value <span class="token operator">=</span> <span class="token string">"Text in cell A1"</span><span class="token punctuation">;</span> <span class="token comment">// Put this string in cell A1</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Without the dynamic type, the value returned from excel.Cells[1, 1] is of type Object, which must be cast to the Range type before its Value property can be accessed. However, when producing a runtime callable wrapper assembly for a COM object, any use of VARIANT in the COM method is really converted to dynamic; this is called dynamification. Therefore, because excel.Cells[1, 1] is of type dynamic, you do not have to explicitly cast it to the Range type before its Value property can be accessed. Dynamification can greatly simplify code that interoperates with COM objects. Here is the simpler code.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">Microsoft<span class="token punctuation">.</span>Office<span class="token punctuation">.</span>Interop<span class="token punctuation">.</span>Excel</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">Application</span> excel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Application</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> excel<span class="token punctuation">.</span>Visible <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> excel<span class="token punctuation">.</span>Workbooks<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>Type<span class="token punctuation">.</span>Missing<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> excel<span class="token punctuation">.</span>Cells<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Value <span class="token operator">=</span> <span class="token string">"Text in cell A1"</span><span class="token punctuation">;</span> <span class="token comment">// Put this string in cell A1</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The following code shows how to use reflection to call a method (â€œContainsâ€) on a String target (â€œJeffrey Richterâ€) passing it a String argument (â€œffâ€) and storing the Boolean result in a local variable (result).</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Object</span> target <span class="token operator">=</span> <span class="token string">"Jeffrey Richter"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Object</span> arg <span class="token operator">=</span> <span class="token string">"ff"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// Find a method on the target that matches the desired argument types</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token class-name">Type<span class="token punctuation">[</span><span class="token punctuation">]</span></span> argTypes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Type<span class="token punctuation">[</span><span class="token punctuation">]</span></span> <span class="token punctuation">&#123;</span> arg<span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token class-name">MethodInfo</span> method <span class="token operator">=</span> target<span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetMethod</span><span class="token punctuation">(</span><span class="token string">"Contains"</span><span class="token punctuation">,</span> argTypes<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// Invoke the method on the target passing the desired arguments</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token class-name">Object<span class="token punctuation">[</span><span class="token punctuation">]</span></span> arguments <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Object<span class="token punctuation">[</span><span class="token punctuation">]</span></span> <span class="token punctuation">&#123;</span> arg <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token class-name">Boolean</span> result <span class="token operator">=</span> Convert<span class="token punctuation">.</span><span class="token function">ToBoolean</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">Invoke</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>Using C#â€™s dynamic type, this code can be rewritten with greatly improved syntax.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token keyword">dynamic</span></span> target <span class="token operator">=</span> <span class="token string">"Jeffrey Richter"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name"><span class="token keyword">dynamic</span></span> arg <span class="token operator">=</span> <span class="token string">"ff"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">Boolean</span> result <span class="token operator">=</span> target<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>Earlier, I mentioned that the C# compiler emits payload code that, at run time, figures out what operation to perform based on the actual type of an object. This payload code uses a class known as a runtime binder. Different programming languages define their own runtime binders that encapsulate the rules of that language. The code for the C# runtime binder is in the Microsoft.CSharp.dll assembly, and you must reference this assembly when you build projects that use the dynamic keyword. This assembly is referenced in the compilerâ€™s default response file, CSC.rsp. It is the code in this assembly that knows to produce code (at run time) that performs addition when the + operator is applied to two Int32 objects and concatenation when applied to two String objects.</p></blockquote><blockquote><p>At run time, the Microsoft.CSharp.dll assembly will have to load into the AppDomain, which hurts your applicationâ€™s performance and increases memory consumption. Microsoft.CSharp.dll also loads System.dll and System.Core.dll. If you are using dynamic to help you interoperate with COM components, then System.Dynamic.dll will also load. And when the payload code executes, it generates dynamic code at run time; this code will be in an in-memory assembly called â€œAnonymously Hosted DynamicMethods Assembly.â€ The purpose of this code is to improve the performance of dynamic dispatch in scenarios where a particular call site is making many invocations using dynamic arguments that have the same runtime type.</p></blockquote><blockquote><p>Due to all the overhead associated with C#â€™s built-in dynamic evaluation feature, you should consciously decide that you are getting sufficient syntax simplification from the dynamic feature to make it worth the extra performance hit of loading all these assemblies and the extra memory that they consume. If you have only a couple places in your program where you need dynamic behavior, it might be more efficient to just do it the old-fashioned way, by calling reflection methods (for managed objects) or with manual casting (for COM objects).</p></blockquote><blockquote><p>At run time, the C# runtime binder resolves a dynamic operation according to the runtime type of the object. The binder first checks to see if the type implements the IDynamicMetaObjectProvider interface. If the object does implement this interface, then the interfaceâ€™s GetMetaObject method is called, which returns a DynamicMetaObject-derived type. This type can process all of the member, method, and operator bindings for the object. Both the IDynamicMetaObjectProvider interface and the DynamicMetaObject base class are defined in the System.Dynamic namespace, and both are in the System.Core.dll assembly.</p></blockquote><blockquote><p>Dynamic languages, such as Python and Ruby, endow their types with DynamicMetaObjectderived types so that they can be accessed in a way appropriate for them when manipulated from other programming languages (like C#). Similarly, when accessing a COM component, the C# runtime binder will use a DynamicMetaObject-derived type that knows how to communicate with a COM component. The COM DynamicMetaObject-derived type is defined in the System.Dynamic.dll assembly.</p></blockquote><blockquote><p>If the type of the object being used in the dynamic expression does not implement the IDynamicMetaObjectProvider interface, then the C# compiler treats the object like an instance of an ordinary C#-defined type and performs operations on the object using reflection.</p></blockquote><blockquote><p>One of the limitations of dynamic is that you can only use it to access an objectâ€™s instance members because the dynamic variable must refer to an object. But, there are occasions when it would be useful to dynamically invoke static members of a type where the type is determined at run time. To accomplish this, I have created a StaticMemberDynamicWrapper class that derives from System.Dynamic.DynamicObject, which implements the IDynamicMetaObjectProvider interface. The class internally uses quite a bit of reflection (covered in Chapter 23, â€œAssembly Loading and Reflectionâ€). Here is the code for my StaticMemberDynamicWrapper class.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">StaticMemberDynamicWrapper</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">DynamicObject</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">TypeInfo</span> m_type<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token function">StaticMemberDynamicWrapper</span><span class="token punctuation">(</span><span class="token class-name">Type</span> type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> m_type <span class="token operator">=</span> type<span class="token punctuation">.</span><span class="token function">GetTypeInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name">IEnumerable<span class="token punctuation">&lt;</span>String<span class="token punctuation">></span></span> <span class="token function">GetDynamicMemberNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">return</span> m_type<span class="token punctuation">.</span>DeclaredMembers<span class="token punctuation">.</span><span class="token function">Select</span><span class="token punctuation">(</span>mi <span class="token operator">=></span> mi<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name">Boolean</span> <span class="token function">TryGetMember</span><span class="token punctuation">(</span><span class="token class-name">GetMemberBinder</span> binder<span class="token punctuation">,</span> <span class="token keyword">out</span> <span class="token class-name"><span class="token keyword">object</span></span> result<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> field <span class="token operator">=</span> <span class="token function">FindField</span><span class="token punctuation">(</span>binder<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>field <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> result <span class="token operator">=</span> field<span class="token punctuation">.</span><span class="token function">GetValue</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> prop <span class="token operator">=</span> <span class="token function">FindProperty</span><span class="token punctuation">(</span>binder<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>prop <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> result <span class="token operator">=</span> prop<span class="token punctuation">.</span><span class="token function">GetValue</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name">Boolean</span> <span class="token function">TrySetMember</span><span class="token punctuation">(</span><span class="token class-name">SetMemberBinder</span> binder<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">object</span></span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> field <span class="token operator">=</span> <span class="token function">FindField</span><span class="token punctuation">(</span>binder<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>field <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> field<span class="token punctuation">.</span><span class="token function">SetValue</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> prop <span class="token operator">=</span> <span class="token function">FindProperty</span><span class="token punctuation">(</span>binder<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>prop <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> prop<span class="token punctuation">.</span><span class="token function">SetValue</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">value</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name">Boolean</span> <span class="token function">TryInvokeMember</span><span class="token punctuation">(</span><span class="token class-name">InvokeMemberBinder</span> binder<span class="token punctuation">,</span> <span class="token class-name">Object<span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token keyword">out</span> <span class="token class-name">Object</span> result<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token class-name">MethodInfo</span> method <span class="token operator">=</span> <span class="token function">FindMethod</span><span class="token punctuation">(</span>binder<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>method <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre> result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre> <span class="token keyword">private</span> <span class="token return-type class-name">MethodInfo</span> <span class="token function">FindMethod</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">Type<span class="token punctuation">[</span><span class="token punctuation">]</span></span> paramTypes<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre> <span class="token keyword">return</span> m_type<span class="token punctuation">.</span>DeclaredMethods<span class="token punctuation">.</span><span class="token function">FirstOrDefault</span><span class="token punctuation">(</span>mi <span class="token operator">=></span> mi<span class="token punctuation">.</span>IsPublic <span class="token operator">&amp;&amp;</span> mi<span class="token punctuation">.</span>IsStatic </pre></td></tr><tr><td data-num="31"></td><td><pre> <span class="token operator">&amp;&amp;</span> mi<span class="token punctuation">.</span>Name <span class="token operator">==</span> name</pre></td></tr><tr><td data-num="32"></td><td><pre> <span class="token operator">&amp;&amp;</span> <span class="token function">ParametersMatch</span><span class="token punctuation">(</span>mi<span class="token punctuation">.</span><span class="token function">GetParameters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> paramTypes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre> <span class="token keyword">private</span> <span class="token return-type class-name">Boolean</span> <span class="token function">ParametersMatch</span><span class="token punctuation">(</span><span class="token class-name">ParameterInfo<span class="token punctuation">[</span><span class="token punctuation">]</span></span> parameters<span class="token punctuation">,</span> <span class="token class-name">Type<span class="token punctuation">[</span><span class="token punctuation">]</span></span> paramTypes<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="35"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>parameters<span class="token punctuation">.</span>Length <span class="token operator">!=</span> paramTypes<span class="token punctuation">.</span>Length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> parameters<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="37"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>parameters<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>ParameterType <span class="token operator">!=</span> paramTypes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="40"></td><td><pre> <span class="token keyword">private</span> <span class="token return-type class-name">FieldInfo</span> <span class="token function">FindField</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="41"></td><td><pre> <span class="token keyword">return</span> m_type<span class="token punctuation">.</span>DeclaredFields<span class="token punctuation">.</span><span class="token function">FirstOrDefault</span><span class="token punctuation">(</span>fi <span class="token operator">=></span> fi<span class="token punctuation">.</span>IsPublic <span class="token operator">&amp;&amp;</span> fi<span class="token punctuation">.</span>IsStatic </pre></td></tr><tr><td data-num="42"></td><td><pre> <span class="token operator">&amp;&amp;</span> fi<span class="token punctuation">.</span>Name <span class="token operator">==</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="44"></td><td><pre> <span class="token keyword">private</span> <span class="token return-type class-name">PropertyInfo</span> <span class="token function">FindProperty</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">Boolean</span> <span class="token keyword">get</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="45"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">get</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="46"></td><td><pre> <span class="token keyword">return</span> m_type<span class="token punctuation">.</span>DeclaredProperties<span class="token punctuation">.</span><span class="token function">FirstOrDefault</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="47"></td><td><pre> pi <span class="token operator">=></span> pi<span class="token punctuation">.</span>Name <span class="token operator">==</span> name <span class="token operator">&amp;&amp;</span> pi<span class="token punctuation">.</span>GetMethod <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="48"></td><td><pre> pi<span class="token punctuation">.</span>GetMethod<span class="token punctuation">.</span>IsPublic <span class="token operator">&amp;&amp;</span> pi<span class="token punctuation">.</span>GetMethod<span class="token punctuation">.</span>IsStatic<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="49"></td><td><pre> <span class="token keyword">return</span> m_type<span class="token punctuation">.</span>DeclaredProperties<span class="token punctuation">.</span><span class="token function">FirstOrDefault</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="50"></td><td><pre> pi <span class="token operator">=></span> pi<span class="token punctuation">.</span>Name <span class="token operator">==</span> name <span class="token operator">&amp;&amp;</span> pi<span class="token punctuation">.</span>SetMethod <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="51"></td><td><pre> pi<span class="token punctuation">.</span>SetMethod<span class="token punctuation">.</span>IsPublic <span class="token operator">&amp;&amp;</span> pi<span class="token punctuation">.</span>SetMethod<span class="token punctuation">.</span>IsStatic<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="52"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="53"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>To invoke a static member dynamically, construct an instance of this class by passing in the Type you want it to operate on and put the reference in a dynamic variable. Then, invoke the desired static member by using instance member syntax. Here is an example of how to invoke Stringâ€™s static Concat(String, String) method.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token keyword">dynamic</span></span> stringType <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">StaticMemberDynamicWrapper</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name"><span class="token keyword">var</span></span> r <span class="token operator">=</span> stringType<span class="token punctuation">.</span><span class="token function">Concat</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// dynamically invoke Stringâ€™s static Concat method</span></pre></td></tr><tr><td data-num="3"></td><td><pre>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "AB"</span></pre></td></tr></table></figure><p>ğŸ’¡å°ç»“ï¼šC# æ˜¯ç±»å‹å®‰å…¨çš„ç¼–ç¨‹è¯­è¨€ï¼Œè¿™æ„å‘³ç€æ‰€æœ‰è¡¨è¾¾å¼éƒ½è§£ææˆç±»å‹çš„å®ä¾‹ï¼Œç¼–è¯‘å™¨ç”Ÿæˆçš„ä»£ç åªæ‰§è¡Œå¯¹è¯¥ç±»å‹æœ‰æ•ˆçš„æ“ä½œã€‚ä½†ç¨‹åºè®¸å¤šæ—¶å€™ä»éœ€å¤„ç†ä¸€äº›è¿è¡Œæ—¶æ‰ä¼šçŸ¥æ™“çš„ä¿¡æ¯ï¼Œä¾‹å¦‚åœ¨ä½¿ç”¨åå°„æˆ–è€…å’Œä¸€äº›ä¸æ˜¯ç”¨ C# å®ç°çš„ç»„ä»¶è¿›è¡Œé€šä¿¡çš„æ—¶å€™ã€‚ä¸ºäº†æ–¹ä¾¿å¼€å‘äººå‘˜ä½¿ç”¨åå°„æˆ–è€…ä¸å…¶ä»–ç»„ä»¶é€šä¿¡ï¼ŒC# ç¼–è¯‘å™¨å…è®¸å°†è¡¨è¾¾å¼çš„ç±»å‹æ ‡è®°ä¸º <code>dynamic</code> ã€‚ä»£ç ä½¿ç”¨ <code>dynamic</code> è¡¨è¾¾å¼ / å˜é‡è°ƒç”¨æˆå‘˜æ—¶ï¼Œç¼–è¯‘å™¨ç”Ÿæˆç‰¹æ®Š IL ä»£ç æ¥æè¿°æ‰€éœ€çš„æ“ä½œã€‚è¿™ç§ç‰¹æ®Šçš„ä»£ç ç§°ä¸º payloadï¼ˆæœ‰æ•ˆè½½è·ï¼‰ã€‚åœ¨è¿è¡Œæ—¶ï¼Œpayload ä»£ç æ ¹æ® <code>dynamic</code> è¡¨è¾¾å¼ / å˜é‡å¼•ç”¨çš„å¯¹è±¡çš„å®é™…ç±»å‹æ¥å†³å®šå…·ä½“æ‰§è¡Œçš„æ“ä½œã€‚å¦‚æœå­—æ®µã€æ–¹æ³•å‚æ•°æˆ–æ–¹æ³•è¿”å›å€¼ç±»å‹æ˜¯ <code>dynamic</code> ï¼Œç¼–è¯‘å™¨ä¼šå°†è¯¥ç±»å‹è½¬æ¢ä¸º <code>System.Object</code> ï¼Œå¹¶åœ¨å…ƒæ•°æ®ä¸­å‘å­—æ®µã€å‚æ•°æˆ–è¿”å›ç±»å‹åº”ç”¨ <code>System.Runtime.CompilerServices.DynamicAttribute</code> çš„å®ä¾‹ã€‚å¦‚æœå±€éƒ¨å˜é‡è¢«æŒ‡å®šä¸º <code>dynamic</code> ï¼Œåˆ™å˜é‡ç±»å‹ä¹Ÿä¼šæˆä¸º <code>Object</code> ï¼Œä½†ä¸ä¼šå‘å±€éƒ¨å˜é‡åº”ç”¨ <code>DynamicAttribute</code> ï¼Œå› ä¸ºå®ƒé™åˆ¶åœ¨æ–¹æ³•å†…éƒ¨ä½¿ç”¨ã€‚ç”±äº <code>dynamic</code> å…¶å®å°±æ˜¯ <code>Object</code> ï¼Œæ‰€ä»¥æ–¹æ³•ç­¾åä¸èƒ½ä»…é  <code>dynamic</code> å’Œ <code>Object</code> çš„å˜åŒ–æ¥åŒºåˆ†ã€‚æ³›å‹ç±»ã€ç»“æ„ã€æ¥å£ã€å§”æ‰˜æˆ–æ–¹æ³•çš„æ³›å‹ç±»å‹å®å‚ä¹Ÿå¯ä»¥æ˜¯ <code>dynamic</code> ç±»å‹ã€‚æ³¨æ„ï¼Œä½¿ç”¨çš„æ³›å‹ä»£ç æ˜¯å·²ç»ç¼–è¯‘å¥½çš„ï¼Œä¼šå°†ç±»å‹è§†ä¸º <code>Object</code> ï¼›ç¼–è¯‘å™¨ä¸åœ¨æ³›å‹ä»£ç ä¸­ç”Ÿæˆ payload ä»£ç ï¼Œæ‰€ä»¥ä¸ä¼šæ‰§è¡ŒåŠ¨æ€è°ƒåº¦ã€‚ç¼–è¯‘å™¨å…è®¸ä½¿ç”¨éšå¼è½¬å‹è¯­æ³•å°†è¡¨è¾¾å¼ä» <code>dynamic</code> è½¬å‹ä¸ºå…¶ä»–ç±»å‹ã€‚ä» <code>dynamic</code> è½¬å‹ä¸ºå…¶ä»–ç±»å‹æ—¶ï¼Œè™½ç„¶ç¼–è¯‘å™¨å…è®¸çœç•¥æ˜¾ç¤ºè½¬å‹ï¼Œä½† CLR ä¼šåœ¨è¿è¡Œæ—¶éªŒè¯è½¬å‹æ¥ç¡®ä¿ç±»å‹å®‰å…¨æ€§ã€‚C# ä¹‹æ‰€ä»¥èƒ½åœ¨è¿è¡Œæ—¶æ ¹æ®å¯¹è±¡å®é™…ç±»å‹åˆ¤æ–­è¦æ‰§è¡Œä»€ä¹ˆæ“ä½œï¼Œæ˜¯å› ä¸º payload ä»£ç ä½¿ç”¨äº†ç§°ä¸º ** è¿è¡Œæ—¶ç»‘å®šå™¨ï¼ˆruntime binderï¼‰** çš„ç±»ã€‚ä¸åŒç¼–ç¨‹è¯­è¨€å®šä¹‰äº†ä¸åŒçš„è¿è¡Œæ—¶ç»‘å®šå™¨æ¥å°è£…è‡ªå·±çš„è§„åˆ™ã€‚C#â€œè¿è¡Œæ—¶ç»‘å®šå™¨â€ çš„ä»£ç åœ¨ <code>Microsoft.CSharp.dll</code> ç¨‹åºé›†ä¸­ï¼Œç”Ÿæˆä½¿ç”¨ <code>dynamic</code> å…³é”®å­—çš„é¡¹ç›®å¿…é¡»å¼•ç”¨è¯¥ç¨‹åºé›†ã€‚åœ¨è¿è¡Œæ—¶ï¼Œ <code>Microsoft.CSharp.dll</code> ç¨‹åºé›†å¿…é¡»åŠ è½½åˆ° <code>AppDomain</code> ä¸­ï¼Œè¿™ä¼šæŸå®³åº”ç”¨ç¨‹åºçš„æ€§èƒ½ï¼Œå¢å¤§å†…å­˜æ¶ˆè€—ã€‚payload ä»£ç æ‰§è¡Œæ—¶ï¼Œä¼šåœ¨è¿è¡Œæ—¶ç”ŸæˆåŠ¨æ€ä»£ç ï¼Œè¿™äº›ä»£ç è¿›å…¥é©»ç•™äºå†…å­˜çš„ç¨‹åºé›†ï¼Œå³ â€œåŒ¿åå¯„å®¿çš„ <code>DynamicMethods</code> ç¨‹åºé›†â€ï¼ˆAnonymously Hosted DynamicMethods Assemblyï¼‰ï¼Œä½œç”¨æ˜¯å½“ç‰¹å®š call siteï¼ˆå‘å‡ºè°ƒç”¨çš„åœ°æ–¹ï¼Œå¯ä»¥ç†è§£æˆè°ƒç”¨äº†ä¸€ä¸ªç›®æ ‡æ–¹æ³•çš„è¡¨è¾¾å¼æˆ–ä»£ç è¡Œï¼‰ä½¿ç”¨å…·æœ‰ç›¸åŒç±»å‹æ—¶ç±»å‹çš„åŠ¨æ€å®å‚å‘å‡ºå¤§é‡è°ƒç”¨æ—¶å¢å¼ºåŠ¨æ€è°ƒç”¨æ€§èƒ½ã€‚è™½ç„¶èƒ½ç”¨åŠ¨æ€åŠŸèƒ½ç®€åŒ–è¯­æ³•ï¼Œä½†ä¹Ÿè¦çœ‹æ˜¯å¦å€¼å¾—ã€‚æ¯•ç«Ÿï¼ŒåŠ è½½æ‰€æœ‰è¿™äº›ç¨‹åºé›†ä»¥åŠé¢å¤–çš„å†…å­˜æ¶ˆè€—ï¼Œä¼šå¯¹æ€§èƒ½é€ æˆé¢å¤–å½±å“ã€‚åœ¨è¿è¡Œæ—¶ï¼ŒC# çš„ â€œè¿è¡Œæ—¶ç»‘å®šå™¨â€ æ ¹æ®å¯¹è±¡çš„è¿è¡Œæ—¶ç±»å‹åˆ†æåº”é‡‡å–ä»€ä¹ˆåŠ¨æ€æ“ä½œã€‚ç»‘å®šå™¨é¦–å…ˆæ£€æŸ¥ç±»å‹æ˜¯å¦å®ç°äº† <code>IDynamicMetaObjectProvider</code> æ¥å£ã€‚å¦‚æœæ˜¯ï¼Œå°±è°ƒç”¨æ¥å£çš„ <code>GetMetaObject</code> æ–¹æ³•ï¼Œå®ƒè¿”å› <code>DynamicMetaObject</code> çš„ä¸€ä¸ªæ´¾ç”Ÿç±»å‹ã€‚è¯¥ç±»å‹èƒ½å¤„ç†å¯¹è±¡çš„æ‰€æœ‰æˆå‘˜ã€æ–¹æ³•å’Œæ“ä½œç¬¦ç»‘å®šã€‚ <code>IDynamicMetaObjectProvider</code> æ¥å£å’Œ <code>DynamicMetaObject</code> åŸºç±»éƒ½åœ¨ <code>System.Dynamic</code> å‘½åç©ºé—´ä¸­å®šä¹‰ï¼Œéƒ½åœ¨ System.Core.dll ç¨‹åºé›†ä¸­ã€‚å¦‚æœåœ¨åŠ¨æ€è¡¨è¾¾å¼ä¸­ä½¿ç”¨çš„ä¸€ä¸ªå¯¹è±¡çš„ç±»å‹æœªå®ç° <code>IDynamicMetaObjectProvider</code> æ¥å£ï¼ŒC# ç¼–è¯‘å™¨ä¼šå¯¹å¯¹è±¡è§†ä¸ºç”¨ C# å®šä¹‰çš„æ™®é€šç±»å‹çš„å®ä¾‹ï¼Œåˆ©ç”¨åå°„åœ¨å¯¹è±¡ä¸Šæ‰§è¡Œæ“ä½œã€‚</p><div class="tags"><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> è¯»ä¹¦ç¬”è®°</a> <a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C#</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2022-12-02 19:54:42" itemprop="dateModified" datetime="2022-12-02T19:54:42+08:00">2022-12-02</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(ï¿£â–½ï¿£)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Sakupinera WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Sakupinera Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Sakupinera PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Sakupinera <i class="ic i-at"><em>@</em></i>Sakupinera</li><li class="link"><strong>Post link: </strong><a href="http://sakupinera.github.io/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/" title="CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals">http://sakupinera.github.io/2022/10/15/csharp/clr-via-csharp/Chapter 5 Primitive, Reference, and Value Types/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/10/14/computer-graphics/games101/%E6%9D%90%E8%B4%A8%E4%B8%8E%E5%A4%96%E8%A7%82/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giciub8ja1j20zk0m81ky.jpg" title="GAMES101 - Materials and Appearancesï¼ˆæè´¨ä¸å¤–è§‚ï¼‰"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i> GAMES101</span><h3>GAMES101 - Materials and Appearancesï¼ˆæè´¨ä¸å¤–è§‚ï¼‰</h3></a></div><div class="item right"><a href="/2022/10/21/csharp/clr-via-csharp/Chapter%206%20Type%20and%20Member%20Basics/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicljgocqbj20zk0m8e81.jpg" title="CLR via C# - Chapter 6 Type and Member Basics"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 6 Type and Member Basics</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-5-primitive-reference-and-value-types"><span class="toc-number">1.</span> <span class="toc-text">Chapter 5 Primitive, Reference, and Value Types</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#programming-language-primitive-types"><span class="toc-number">1.1.</span> <span class="toc-text">Programming Language Primitive Types</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#checked-and-unchecked-primitive-type-operations"><span class="toc-number">1.1.1.</span> <span class="toc-text">Checked and Unchecked Primitive Type Operations</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reference-types-and-value-types"><span class="toc-number">1.2.</span> <span class="toc-text">Reference Types and Value Types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#boxing-and-unboxing-value-types"><span class="toc-number">1.3.</span> <span class="toc-text">Boxing and Unboxing Value Types</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#changing-fields-in-a-boxed-value-type-by-using-interfaces-and-why-you-shouldnt-do-this"><span class="toc-number">1.3.1.</span> <span class="toc-text">Changing Fields in a Boxed Value Type by Using Interfaces (and Why You Shouldnâ€™t Do This)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#object-equality-and-identity"><span class="toc-number">1.3.2.</span> <span class="toc-text">Object Equality and Identity</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#object-hash-codes"><span class="toc-number">1.4.</span> <span class="toc-text">Object Hash Codes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#the-dynamic-primitive-type"><span class="toc-number">1.5.</span> <span class="toc-text">The dynamic Primitive Type</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"><ul><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/" rel="bookmark" title="CLR via C# - Chapter 1 The CLRâ€™s Execution Model">CLR via C# - Chapter 1 The CLRâ€™s Execution Model</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/" rel="bookmark" title="CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types">CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%203%20Shared%20Assemblies%20and%20Strongly%20Named%20Assemblies/" rel="bookmark" title="CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies">CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies</a></li><li><a href="/2022/09/27/csharp/clr-via-csharp/Chapter%204%20Type%20Fundamentals/" rel="bookmark" title="CLR via C# - Chapter 4 Type Fundamentals">CLR via C# - Chapter 4 Type Fundamentals</a></li><li class="active"><a href="/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/" rel="bookmark" title="CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals">CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals</a></li><li><a href="/2022/10/21/csharp/clr-via-csharp/Chapter%206%20Type%20and%20Member%20Basics/" rel="bookmark" title="CLR via C# - Chapter 6 Type and Member Basics">CLR via C# - Chapter 6 Type and Member Basics</a></li><li><a href="/2022/10/24/csharp/clr-via-csharp/Chapter%207%20Constants%20and%20Fields/" rel="bookmark" title="CLR via C# - Chapter 7 Constants and Fields">CLR via C# - Chapter 7 Constants and Fields</a></li><li><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" rel="bookmark" title="CLR via C# - Chapter 8 Methods">CLR via C# - Chapter 8 Methods</a></li><li><a href="/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/" rel="bookmark" title="CLR via C# - Chapter 9 Parameters">CLR via C# - Chapter 9 Parameters</a></li><li><a href="/2022/10/28/csharp/clr-via-csharp/Chapter%2010%20Properties/" rel="bookmark" title="CLR via C# - Chapter 10 Properties">CLR via C# - Chapter 10 Properties</a></li><li><a href="/2022/10/29/csharp/clr-via-csharp/Chapter%2011%20Events/" rel="bookmark" title="CLR via C# - Chapter 11 Events">CLR via C# - Chapter 11 Events</a></li><li><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" rel="bookmark" title="CLR via C# - Chapter 12 Generics">CLR via C# - Chapter 12 Generics</a></li><li><a href="/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/" rel="bookmark" title="CLR via C# - Chapter 13 Interfaces">CLR via C# - Chapter 13 Interfaces</a></li><li><a href="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/" rel="bookmark" title="CLR via C# - Chapter 14 Chars, Strings, and Working with Text">CLR via C# - Chapter 14 Chars, Strings, and Working with Text</a></li><li><a href="/2022/11/17/csharp/clr-via-csharp/Chapter%2015%20Enumerated%20Types%20and%20Bit%20Flags/" rel="bookmark" title="CLR via C# - Chapter 15 Enumerated Types and Bit Flags">CLR via C# - Chapter 15 Enumerated Types and Bit Flags</a></li><li><a href="/2022/11/19/csharp/clr-via-csharp/Chapter%2016%20Arrays/" rel="bookmark" title="CLR via C# - Chapter 16 Arrays">CLR via C# - Chapter 16 Arrays</a></li><li><a href="/2022/11/21/csharp/clr-via-csharp/Chapter%2017%20Delegates/" rel="bookmark" title="CLR via C# - Chapter 17 Delegates">CLR via C# - Chapter 17 Delegates</a></li><li><a href="/2022/11/22/csharp/clr-via-csharp/Chapter%2018%20Custom%20Attributes/" rel="bookmark" title="CLR via C# - Chapter 18 Custom Attributes">CLR via C# - Chapter 18 Custom Attributes</a></li><li><a href="/2022/11/23/csharp/clr-via-csharp/Chapter%2019%20Nullable%20Value%20Types/" rel="bookmark" title="CLR via C# - Chapter 19 Nullable Value Types">CLR via C# - Chapter 19 Nullable Value Types</a></li><li><a href="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/" rel="bookmark" title="CLR via C# - Chapter 20 Exceptions and State Management">CLR via C# - Chapter 20 Exceptions and State Management</a></li><li><a href="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/" rel="bookmark" title="CLR via C# - Chapter 21 The Managed Heap and Garbage  Collection">CLR via C# - Chapter 21 The Managed Heap and Garbage Collection</a></li><li><a href="/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/" rel="bookmark" title="CLR via C# - Chapter 22 CLR Hosting and AppDomains">CLR via C# - Chapter 22 CLR Hosting and AppDomains</a></li><li><a href="/2022/11/29/csharp/clr-via-csharp/Chapter%2023%20Assembly%20Loading%20and%20Reflection/" rel="bookmark" title="CLR via C# - Chapter 23 Assembly Loading and Reflection">CLR via C# - Chapter 23 Assembly Loading and Reflection</a></li><li><a href="/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/" rel="bookmark" title="CLR via C# - Chapter 24 Runtime Serialization">CLR via C# - Chapter 24 Runtime Serialization</a></li><li><a href="/2022/12/06/csharp/clr-via-csharp/Chapter%2025%20Interoperating%20with%20WinRT%20%20Components/" rel="bookmark" title="CLR via C# - Chapter 25 Interoperating with WinRT Components">CLR via C# - Chapter 25 Interoperating with WinRT Components</a></li><li><a href="/2023/02/06/csharp/clr-via-csharp/Chapter%2026%20Thread%20Basics/" rel="bookmark" title="CLR via C# - Chapter 26 Thread Basics">CLR via C# - Chapter 26 Thread Basics</a></li><li><a href="/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations">CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations</a></li><li><a href="/2023/02/08/csharp/clr-via-csharp/Chapter%2028%20IO-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 28 IO-Bound Asynchronous Operations">CLR via C# - Chapter 28 IO-Bound Asynchronous Operations</a></li><li><a href="/2023/02/09/csharp/clr-via-csharp/Chapter%2029%20Primitive%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 29 Primitive Thread Synchronization">CLR via C# - Chapter 29 Primitive Thread Synchronization</a></li><li><a href="/2023/02/10/csharp/clr-via-csharp/Chapter%2030%20Hybrid%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 30 Hybrid Thread Synchronization">CLR via C# - Chapter 30 Hybrid Thread Synchronization</a></li></ul></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sakupinera" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Sakupinera</p><div class="description" itemprop="description">ä¿æŒä½ çš„å†³å¿ƒï¼</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">89</span> <span class="name">posts</span></a></div><div class="item categories"><a href="/categories/"><span class="count">17</span> <span class="name">categories</span></a></div><div class="item tags"><a href="/tags/"><span class="count">8</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nha3VwaW5lcmE=" title="https:&#x2F;&#x2F;github.com&#x2F;sakupinera"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQwNzIyOTA3MQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;407229071"><i class="ic i-cloud-music"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMjIzMDczOTg/c3BtX2lkX2Zyb209MzMzLjEwMDcuMC4w" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;22307398?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li><li class="item"><a href="/games/" rel="section"><i class="ic i-flag"></i>games</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-person"></i>About</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/10/14/computer-graphics/games101/%E6%9D%90%E8%B4%A8%E4%B8%8E%E5%A4%96%E8%A7%82/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/10/21/csharp/clr-via-csharp/Chapter%206%20Type%20and%20Member%20Basics/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/" title="CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations">CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CSharp-in-a-Nutshell/" title="In CSharp-in-a-Nutshell">CSharp-in-a-Nutshell</a></div><span><a href="/2022/08/30/csharp/csharp-in-a-nutshell/%E7%AC%AC8%E7%AB%A0%20LINQ%E6%9F%A5%E8%AF%A2/" title="C# in a Nutshell - ç¬¬8ç«  LINQæŸ¥è¯¢">C# in a Nutshell - ç¬¬8ç«  LINQæŸ¥è¯¢</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/" title="CLR via C# - Chapter 1 The CLRâ€™s Execution Model">CLR via C# - Chapter 1 The CLRâ€™s Execution Model</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2022/12/17/cpp/cpp-primer/Chapter%209%20Sequential%20Containers/" title="C++ Primer - Chapter 9 Sequential Containers">C++ Primer - Chapter 9 Sequential Containers</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" title="CLR via C# - Chapter 8 Methods">CLR via C# - Chapter 8 Methods</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2023/01/08/cpp/cpp-primer/Chapter%2016%20Templates%20and%20Generic%20Programming/" title="C++ Primer - Chapter 16 Templates and Generic Programming">C++ Primer - Chapter 16 Templates and Generic Programming</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/09/05/linux/learn-linux/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/" title="LearnLinux - Linuxç³»ç»Ÿç®¡ç†">LearnLinux - Linuxç³»ç»Ÿç®¡ç†</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CSharp-in-a-Nutshell/" title="In CSharp-in-a-Nutshell">CSharp-in-a-Nutshell</a></div><span><a href="/2022/09/04/csharp/csharp-in-a-nutshell/%E7%AC%AC14%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%BC%82%E6%AD%A5/" title="C# in a Nutshell - ç¬¬14ç«  å¹¶å‘ä¸å¼‚æ­¥">C# in a Nutshell - ç¬¬14ç«  å¹¶å‘ä¸å¼‚æ­¥</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2022/12/09/cpp/cpp-primer/Chapter%201%20Getting%20Started/" title="C++ Primer - Chapter 1 Getting Started">C++ Primer - Chapter 1 Getting Started</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/09/22/computer-graphics/games101/%E5%85%89%E6%A0%85%E5%8C%96/" title="GAMES101 - Rasterizationï¼ˆå…‰æ …åŒ–ï¼‰">GAMES101 - Rasterizationï¼ˆå…‰æ …åŒ–ï¼‰</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 â€“ <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Sakupinera @ Hanamai Sora</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="Symbols count total">2.2m words</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="Reading time total">34:05</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/10/15/csharp/clr-via-csharp/Chapter 5 Primitive, Reference, and Value  Types/",favicon:{show:"ï¼ˆâ—Â´3ï½€â—ï¼‰Goooood",hide:"(Â´Ğ”ï½€)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/shifuku.model.json"},display:{position:"left",width:250,height:500},mobile:{show:!1},react:{opacity:.9},log:!1})</script></body></html>