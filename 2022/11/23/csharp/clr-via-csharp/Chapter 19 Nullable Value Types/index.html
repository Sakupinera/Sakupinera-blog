<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sakupinera" href="http://sakupinera.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sakupinera" href="http://sakupinera.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sakupinera" href="http://sakupinera.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="读书笔记,C#"><link rel="canonical" href="http://sakupinera.github.io/2022/11/23/csharp/clr-via-csharp/Chapter%2019%20Nullable%20Value%20Types/"><title>CLR via C# - Chapter 19 Nullable Value Types - CLR-via-CSharp - CSharp | Hanamai Sora = Sakupinera</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">CLR via C# - Chapter 19 Nullable Value Types</h1><div class="meta"><span class="item" title="Created: 2022-11-23 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2022-11-23T00:00:00+08:00">2022-11-23</time> </span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">Symbols count in article</span> <span>13k</span> <span class="text">words</span> </span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">Reading time</span> <span>12 mins.</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hanamai Sora</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s2.loli.net/2023/03/08/IFz2iyDlkbhZKqV.png"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/OQq9sc7VlKfnvGL.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/KFwBz5WDl3HNyXq.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/y7LRpQIrAdzbUek.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/qSxQEJk41eog52I.png"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/Jxa8Trdmc4uFsqW.png"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/" itemprop="item" rel="index" title="In CSharp"><span itemprop="name">CSharp</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/CLR-via-CSharp/" itemprop="item" rel="index" title="In CLR-via-CSharp"><span itemprop="name">CLR-via-CSharp</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://sakupinera.github.io/2022/11/23/csharp/clr-via-csharp/Chapter%2019%20Nullable%20Value%20Types/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Sakupinera"><meta itemprop="description" content=", 保持你的决心！"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakupinera"></span><div class="body md" itemprop="articleBody"><h1 id="chapter-19-nullable-value-types"><a class="anchor" href="#chapter-19-nullable-value-types">#</a> Chapter 19 Nullable Value Types</h1><blockquote><p>As you know, a variable of a value type can never be null; it always contains the value type’s value itself. In fact, this is why they call these types value types. Unfortunately, there are some scenarios in which this is a problem. For example, when designing a database, it’s possible to define a column’s data type to be a 32-bit integer that would map to the Int32 data type of the Framework Class Library (FCL). But a column in a database can indicate that the value is nullable. That is, it is OK to have no value in the row’s column. Working with database data by using the Microsoft .NET Framework can be quite difficult because in the common language runtime (CLR), there is no way to represent an Int32 value as null.</p></blockquote><p>💡注意：Microsoft <span class="exturl" data-url="aHR0cDovL0FETy5ORVQ=">ADO.NET</span> 的表适配器 (table adapter) 确实支持可空类型。遗憾的是 <code>System.Data.SqlTypes</code> 命名空间中的类型没有用可空类型替换，部分原因是类型之间没有 “一对一” 的对应关系。例如， <code>SqlDecimal</code> 类型最大允许 38 位数，而普通的 <code>Decimal</code> 类型最大允许 38 位数，而普通的 <code>Decimal</code> 类型最大只允许 29 位数。此外， <code>SqlString</code> 类型支持它自己的本地化和比较选项，而普通的 <code>String</code> 类型并不支持这些。</p><blockquote><p>Here is another example. In Java, the java.util.Date class is a reference type, and therefore, a variable of this type can be set to null. However, in the CLR, a <code>System.DateTime</code> is a value type, and a <code>DateTime</code> variable can never be null. If an application written in Java wants to communicate a date/time to a web service running the CLR, there is a problem if the Java application sends null because the CLR has no way to represent this and operate on it.</p></blockquote><blockquote><p>To improve this situation, Microsoft added the concept of nullable value types to the CLR. To understand how they work, we first need to look at the <code>System.Nullable</code> structure, which is defined in the FCL.</p></blockquote><blockquote><p>Here is the logical representation of how the <code>System.Nullable</code> type is defined.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Serializable</span><span class="token punctuation">,</span> <span class="token class-name">StructLayout</span><span class="token attribute-arguments"><span class="token punctuation">(</span>LayoutKind<span class="token punctuation">.</span>Sequential<span class="token punctuation">)</span></span></span><span class="token punctuation">]</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">struct</span> <span class="token class-name">Nullable<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token keyword">where</span> <span class="token class-name">T</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token keyword">struct</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// These 2 fields represent the state </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Boolean</span> hasValue <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// Assume null </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">internal</span> <span class="token class-name">T</span> <span class="token keyword">value</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">(</span><span class="token type-expression class-name">T</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Assume all bits zero </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Nullable</span><span class="token punctuation">(</span><span class="token class-name">T</span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">value</span> <span class="token operator">=</span> <span class="token keyword">value</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">this</span><span class="token punctuation">.</span>hasValue <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Boolean</span> HasValue <span class="token punctuation">&#123;</span> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> hasValue<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">T</span> Value <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>hasValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">InvalidOperationException</span><span class="token punctuation">(</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token string">"Nullable object must have a value."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token keyword">return</span> <span class="token keyword">value</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">T</span> <span class="token function">GetValueOrDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">value</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">T</span> <span class="token function">GetValueOrDefault</span><span class="token punctuation">(</span><span class="token class-name">T</span> defaultValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>HasValue<span class="token punctuation">)</span> <span class="token keyword">return</span> defaultValue<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token keyword">return</span> <span class="token keyword">value</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name">Boolean</span> <span class="token function">Equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> other<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>HasValue<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>other <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="27"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>other <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="28"></td><td><pre> <span class="token keyword">return</span> <span class="token keyword">value</span><span class="token punctuation">.</span><span class="token function">Equals</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="29"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="30"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">GetHashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="31"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>HasValue<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="32"></td><td><pre> <span class="token keyword">return</span> <span class="token keyword">value</span><span class="token punctuation">.</span><span class="token function">GetHashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="33"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="34"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> <span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="35"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>HasValue<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="36"></td><td><pre> <span class="token keyword">return</span> <span class="token keyword">value</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="37"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="38"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">implicit</span> <span class="token keyword">operator</span> <span class="token generic-method"><span class="token function">Nullable</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">T</span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="39"></td><td><pre> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Nullable<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="40"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="41"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">explicit</span> <span class="token keyword">operator</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token class-name">Nullable<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="42"></td><td><pre> <span class="token keyword">return</span> <span class="token keyword">value</span><span class="token punctuation">.</span>Value<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="43"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="44"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>As you can see, this class encapsulates the notion of a value type that can also be null. Because Nullable is itself a value type, instances of it are still fairly lightweight. That is, instances can still be on the stack, and an instance is the same size as the original value type plus the size of a Boolean field. Notice that <code>Nullable</code> ’s type parameter, T, is constrained to struct. This was done because reference type variables can already be null.</p></blockquote><blockquote><p>So now, if you want to use a nullable Int32 in your code, you can write something like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Nullable<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">></span></span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Nullable<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">></span></span> y <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"x: HasValue=&#123;0&#125;, Value=&#123;1&#125;"</span><span class="token punctuation">,</span> x<span class="token punctuation">.</span>HasValue<span class="token punctuation">,</span> x<span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"y: HasValue=&#123;0&#125;, Value=&#123;1&#125;"</span><span class="token punctuation">,</span> y<span class="token punctuation">.</span>HasValue<span class="token punctuation">,</span> y<span class="token punctuation">.</span><span class="token function">GetValueOrDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>When I compile and run this code, I get the following output.</p></blockquote><pre><code class="language-cmd">x: HasValue=True, Value=5 
y: HasValue=False, Value=0
</code></pre><p>💡小结：为了解决 C# 与数据库数据交互的问题，Microsoft 在 CLR 中引入了可空值类型的概念。该结构能表示可为 null 的值类型。由于 <code>Nullable&lt;T&gt;</code> 本身是值类型，所以它的实例仍然是 “轻量级” 的。也就是说，实例仍然可能在栈上，而且实例的大小和原始值类型基本一样，只是多了一个 <code>Boolean</code> 字段。 <code>Nullable</code> 的类型参数 T 被约束为 struct。这是由于引用类型的变量本来就可以为 null，所以没必要再去照顾它。</p><h2 id="cs-support-for-nullable-value-types"><a class="anchor" href="#cs-support-for-nullable-value-types">#</a> C#’s Support for Nullable Value Types</h2><blockquote><p>Notice in the code that C# allows you to use fairly simple syntax to initialize the two Nullable variables, x and y. In fact, the C# team wants to integrate nullable value types into the C# language, making them first-class citizens. To that end, C# offers a cleaner syntax for working with nullable value types. C# allows the code to declare and initialize the x and y variables to be written using question mark notation.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Int32<span class="token punctuation">?</span></span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Int32<span class="token punctuation">?</span></span> y <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>In C#, Int32? is a synonym notation for Nullable. But C# takes this further. C# allows you to perform conversions and casts on nullable instances. And C# also supports applying operators to nullable instances. The following code shows examples of these.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ConversionsAndCasting</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Implicit conversion from non-nullable Int32 to Nullable&lt;Int32></span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Int32<span class="token punctuation">?</span></span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// Implicit conversion from 'null' to Nullable&lt;Int32></span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token class-name">Int32<span class="token punctuation">?</span></span> b <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// Same as "Int32? b = new Int32?();" which sets HasValue to false </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Explicit conversion from Nullable&lt;Int32> to non-nullable Int32 </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token class-name">Int32</span> c <span class="token operator">=</span> <span class="token punctuation">(</span>Int32<span class="token punctuation">)</span> a<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Casting between nullable primitive types </span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token class-name">Double<span class="token punctuation">?</span></span> d <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// Int32->Double? (d is 5.0 as a double) </span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token class-name">Double<span class="token punctuation">?</span></span> e <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token comment">// Int32?->Double? (e is null) </span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>C# also allows you to apply operators to nullable instances. The following code shows examples of this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Operators</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Int32<span class="token punctuation">?</span></span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Int32<span class="token punctuation">?</span></span> b <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// Unary operators (+ ++ - -- ! ~) </span></pre></td></tr><tr><td data-num="6"></td><td><pre> a<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// a = 6 </span></pre></td></tr><tr><td data-num="7"></td><td><pre> b <span class="token operator">=</span> <span class="token operator">-</span>b<span class="token punctuation">;</span> <span class="token comment">// b = null </span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Binary operators (+ - * / % &amp; | ^ &lt;&lt; >>) </span></pre></td></tr><tr><td data-num="9"></td><td><pre> a <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// a = 9 </span></pre></td></tr><tr><td data-num="10"></td><td><pre> b <span class="token operator">=</span> b <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// b = null; </span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// Equality operators (== !=) </span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* no */</span> <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* yes */</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* yes */</span> <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* no */</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* yes */</span> <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* no */</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// Comparison operators (&lt;> &lt;= >=) </span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* no */</span> <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* yes */</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Here is how C# interprets the operators:</p><ul><li><p>Unary operators (+, ++, -, --, ! , ~) If the operand is null, the result is null.</p></li><li><p>Binary operators (+, -, *, /, %, &amp;, |, ^, &lt;&lt;, &gt;&gt;) If either operand is null, the result is null. However, an exception is made when the &amp; and | operators are operating on Boolean? operands, so that the behavior of these two operators gives the same behavior as demonstrated by SQL’s three-valued logic. For these two operators, if neither operand is null, the operator performs as expected, and if both operands are null, the result is null. The special behavior comes into play when just one of the operands is null. The following table lists the results produced by these two operators for all combinations of true, false, and null.</p></li></ul><p><img data-src="/2022/11/23/csharp/clr-via-csharp/Chapter%2019%20Nullable%20Value%20Types/image-20221123114540314.png" alt="image-20221123114540314"></p><ul><li><p>Equality operators (==, !=) If both operands are null, they are equal. If one operand is null, they are not equal. If neither operand is null, compare the values to determine if they are equal.</p></li><li><p>Relational operators (&lt;, &gt;, &lt;=, &gt;=) If either operand is null, the result is false. If neither operand is null, compare the values.</p></li></ul></blockquote><blockquote><p>You should be aware that manipulating nullable instances does generate a lot of code. For example, see the following method.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name">Int32<span class="token punctuation">?</span></span> <span class="token function">NullableCodeSize</span><span class="token punctuation">(</span><span class="token class-name">Int32<span class="token punctuation">?</span></span> a<span class="token punctuation">,</span> <span class="token class-name">Int32<span class="token punctuation">?</span></span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When I compile this method, there is quite a bit of resulting Intermediate Language (IL) code, which also makes performing operations on nullable types slower than performing the same operation on non-nullable types. Here is the C# equivalent of the compiler-produced IL code.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name">Nullable<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">></span></span> <span class="token function">NullableCodeSize</span><span class="token punctuation">(</span><span class="token class-name">Nullable<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">></span></span> a<span class="token punctuation">,</span> <span class="token class-name">Nullable<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">></span></span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Nullable<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">></span></span> nullable1 <span class="token operator">=</span> a<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Nullable<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">></span></span> nullable2 <span class="token operator">=</span> b<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>nullable1<span class="token punctuation">.</span>HasValue <span class="token operator">&amp;</span> nullable2<span class="token punctuation">.</span>HasValue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Nullable<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Nullable<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">></span></span><span class="token punctuation">(</span>nullable1<span class="token punctuation">.</span><span class="token function">GetValueOrDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> nullable2<span class="token punctuation">.</span><span class="token function">GetValueOrDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Finally, let me point out that you can define your own value types that overload the various operators previously mentioned. I discuss how to do this in the “Operator Overload Methods” section in Chapter 8, “Methods.” If you then use a nullable instance of your own value type, the compiler does the right thing and invokes your overloaded operator. For example, suppose that you have a Point value type that defines overloads for the == and != operators as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">struct</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_x<span class="token punctuation">,</span> m_y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> x<span class="token punctuation">,</span> <span class="token class-name">Int32</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> m_x <span class="token operator">=</span> x<span class="token punctuation">;</span> m_y <span class="token operator">=</span> y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> Boolean <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token class-name">Point</span> p1<span class="token punctuation">,</span> <span class="token class-name">Point</span> p2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">return</span> <span class="token punctuation">(</span>p1<span class="token punctuation">.</span>m_x <span class="token operator">==</span> p2<span class="token punctuation">.</span>m_x<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>p1<span class="token punctuation">.</span>m_y <span class="token operator">==</span> p2<span class="token punctuation">.</span>m_y<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> Boolean <span class="token keyword">operator</span><span class="token operator">!=</span><span class="token punctuation">(</span><span class="token class-name">Point</span> p1<span class="token punctuation">,</span> <span class="token class-name">Point</span> p2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span>p1 <span class="token operator">==</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>At this point, you can use nullable instances of the Point type and the compiler will invoke your overloaded operators.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Point<span class="token punctuation">?</span></span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Point</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">Point<span class="token punctuation">?</span></span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Point</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Are points equal? "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>p1 <span class="token operator">==</span> p2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Are points not equal? "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>p1 <span class="token operator">!=</span> p2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When I build and run the preceding code, I get the following output.</p></blockquote><pre><code class="language-cmd">Are points equal? False
Are points not equal? True
</code></pre><p>💡小结：事实上，C# 开发团队的目的是将可空值类型集成到 C# 语言中，使之成为 “一等公民”。为此，C# 提供了更清晰的语法来处理可空值类型。在 C# 中， <code>Int32?</code> 等价于 <code>Nullable&lt;Int32&gt;</code> 。但 C# 在此基础上更进一步，允许开发人员在可空实例上执行转换和转型。并且 C# 有自己解析操作符的一套方式。可以定义自己的值类型来重载上述各种操作符。使用自己的值类型的可空实例，编译器能正确识别它并调用你重载的操作符方法。</p><h2 id="cs-null-coalescing-operator"><a class="anchor" href="#cs-null-coalescing-operator">#</a> C#’s Null-Coalescing Operator</h2><blockquote><p>C# has an operator called the null-coalescing operator (??), which takes two operands. If the operand on the left is not null, the operand’s value is returned. If the operand on the left is null, the value of the right operand is returned. The null-coalescing operator offers a very convenient way to set a variable’s default value.</p></blockquote><blockquote><p>A cool feature of the null-coalescing operator is that it can be used with reference types as well as nullable value types. Here is some code that demonstrates the use of the null-coalescing operator.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">NullCoalescingOperator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Int32<span class="token punctuation">?</span></span> b <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// The following line is equivalent to: </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// x = (b.HasValue) ? b.Value : 123 </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token class-name">Int32</span> x <span class="token operator">=</span> b <span class="token operator">??</span> <span class="token number">123</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "123" </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// The following line is equivalent to: </span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// String temp = GetFilename(); </span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// filename = (temp != null) ? temp : "Untitled"; </span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token class-name">String</span> filename <span class="token operator">=</span> <span class="token function">GetFilename</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">??</span> <span class="token string">"Untitled"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Some people argue that the null-coalescing operator is simply syntactic sugar for the ?: operator, and that the C# compiler team should not have added this operator to the language. However, the null-coalescing operator offers two significant syntactic improvements. The first is that the ?? operator works better with expressions.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Func<span class="token punctuation">&lt;</span>String<span class="token punctuation">></span></span> f <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">SomeMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">??</span> <span class="token string">"Untitled"</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>This code is much easier to read and understand than the following line, which requires variable assignments and multiple statements.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Func<span class="token punctuation">&lt;</span>String<span class="token punctuation">></span></span> f <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span> <span class="token class-name"><span class="token keyword">var</span></span> temp <span class="token operator">=</span> <span class="token function">SomeMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">return</span> temp <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token punctuation">?</span> temp <span class="token punctuation">:</span> <span class="token string">"Untitled"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>The second improvement is that ?? works better in composition scenarios. For example, the following single line:</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token function">SomeMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">??</span> <span class="token function">SomeMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">??</span> <span class="token string">"Untitled"</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>is far easier to read and understand than this chunk of code.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">String</span> s<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name"><span class="token keyword">var</span></span> sm1 <span class="token operator">=</span> <span class="token function">SomeMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>sm1 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> s <span class="token operator">=</span> sm1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> sm2 <span class="token operator">=</span> <span class="token function">SomeMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>sm2 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> s <span class="token operator">=</span> sm2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">else</span> s <span class="token operator">=</span> <span class="token string">"Untitled"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>💡小结：C# 提供了一个 “空结合操作符”（null-coalescing operator），即？？操作符，它要获取两个操作数。假如左边的操作数不为 null，就返回这个操作数的值。如果左边的操作数为 null，就返回右边的操作数的值。空结合操作符的一个好处在于，它既能用于引用类型，也能用于可空值类型。</p><h2 id="the-clr-has-special-support-for-nullable-value-types"><a class="anchor" href="#the-clr-has-special-support-for-nullable-value-types">#</a> The CLR Has Special Support for Nullable Value Types</h2><blockquote><p>The CLR has built-in support for nullable value types. This special support is provided for boxing, unboxing, calling <code>GetType</code> , calling interface methods, and it is given to nullable types to make them fit more seamlessly into the CLR. This also makes them behave more naturally and as most developers would expect. Let’s take a closer look at the CLR’s special support for nullable types.</p></blockquote><h3 id="boxing-nullable-value-types"><a class="anchor" href="#boxing-nullable-value-types">#</a> Boxing Nullable Value Types</h3><blockquote><p>Imagine a Nullable variable that is logically set to null. If this variable is passed to a method prototyped as expecting an Object, the variable must be boxed, and a reference to the boxed Nullable is passed to the method. This is not ideal because the method is now being passed a non-null value even though the Nullable variable logically contained the value of null. To fix this, the CLR executes some special code when boxing a nullable variable to keep up the illusion that nullable types are first-class citizens in the environment.</p></blockquote><blockquote><p>Specifically, when the CLR is boxing a Nullable instance, it checks to see if it is null, and if so, the CLR doesn’t actually box anything, and null is returned. If the nullable instance is not null, the CLR takes the value out of the nullable instance and boxes it. In other words, a Nullable with a value of 5 is boxed into a boxed-Int32 with a value of 5. Here is some code that demonstrates this behavior.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Boxing Nullable&lt;T> is null or boxed T </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Int32<span class="token punctuation">?</span></span> n <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">Object</span> o <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment">// o is null </span></pre></td></tr><tr><td data-num="4"></td><td><pre>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"o is null=&#123;0&#125;"</span><span class="token punctuation">,</span> o <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "True" </span></pre></td></tr><tr><td data-num="5"></td><td><pre>n <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre>o <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment">// o refers to a boxed Int32 </span></pre></td></tr><tr><td data-num="7"></td><td><pre>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"o's type=&#123;0&#125;"</span><span class="token punctuation">,</span> o<span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "System.Int32"</span></pre></td></tr></table></figure><h3 id="unboxing-nullable-value-types"><a class="anchor" href="#unboxing-nullable-value-types">#</a> Unboxing Nullable Value Types</h3><blockquote><p>The CLR allows a boxed value type T to be unboxed into a T or a Nullable. If the reference to the boxed value type is null, and you are unboxing it to a Nullable, the CLR sets <code>Nullable</code> ’s value to null. Here is some code to demonstrate this behavior.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Create a boxed Int32 </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Object</span> o <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// Unbox it into a Nullable&lt;Int32> and into an Int32 </span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token class-name">Int32<span class="token punctuation">?</span></span> a <span class="token operator">=</span> <span class="token punctuation">(</span>Int32<span class="token punctuation">?</span><span class="token punctuation">)</span> o<span class="token punctuation">;</span> <span class="token comment">// a = 5 </span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token class-name">Int32</span> b <span class="token operator">=</span> <span class="token punctuation">(</span>Int32<span class="token punctuation">)</span> o<span class="token punctuation">;</span> <span class="token comment">// b = 5 </span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// Create a reference initialized to null </span></pre></td></tr><tr><td data-num="7"></td><td><pre>o <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// "Unbox" it into a Nullable&lt;Int32> and into an Int32 </span></pre></td></tr><tr><td data-num="9"></td><td><pre>a <span class="token operator">=</span> <span class="token punctuation">(</span>Int32<span class="token punctuation">?</span><span class="token punctuation">)</span> o<span class="token punctuation">;</span> <span class="token comment">// a = null </span></pre></td></tr><tr><td data-num="10"></td><td><pre>b <span class="token operator">=</span> <span class="token punctuation">(</span>Int32<span class="token punctuation">)</span> o<span class="token punctuation">;</span> <span class="token comment">// NullReferenceException</span></pre></td></tr></table></figure><h3 id="calling-gettype-via-a-nullable-value-type"><a class="anchor" href="#calling-gettype-via-a-nullable-value-type">#</a> Calling GetType via a Nullable Value Type</h3><blockquote><p>When calling <code>GetType</code> on a Nullable object, the CLR actually lies and returns the type T instead of the type Nullable. Here is some code that demonstrates this behavior.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Int32<span class="token punctuation">?</span></span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// The following line displays "System.Int32"; not "System.Nullable&lt;Int32>" </span></pre></td></tr><tr><td data-num="3"></td><td><pre>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="calling-interface-methods-via-a-nullable-value-type"><a class="anchor" href="#calling-interface-methods-via-a-nullable-value-type">#</a> Calling Interface Methods via a Nullable Value Type</h3><blockquote><p>In the following code, I’m casting n, a Nullable, to <code>IComparable</code> , an interface type. However, the Nullable type does not implement the <code>IComparable</code> interface as Int32 does. The C# compiler allows this code to compile anyway, and the CLR’s verifier considers this code verifiable to allow you a more convenient syntax.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Int32<span class="token punctuation">?</span></span> n <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Int32</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>IComparable<span class="token punctuation">)</span> n<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Compiles &amp; runs OK </span></pre></td></tr><tr><td data-num="3"></td><td><pre>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0</span></pre></td></tr></table></figure><blockquote><p>If the CLR didn’t provide this special support, it would be more cumbersome for you to write code to call an interface method on a nullable value type. You’d have to cast the unboxed value type first before casting to the interface to make the call.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Int32</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>IComparable<span class="token punctuation">)</span> <span class="token punctuation">(</span>Int32<span class="token punctuation">)</span> n<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Cumbersome</span></pre></td></tr></table></figure><p>💡小结：CLR 内建对可空值类型的支持。这个特殊的支持是针对装箱、拆箱、调用 <code>GetType</code> 和调用接口方法提供的，它使可空类型能无缝地集成到 CLR 中，而且它使用具有更自然的行为，更符合大多数开发人员的预期。当 CLR 对 <code>Nullable&lt;T&gt;</code> 实例进行装箱时，会检查它是否为 null。如果是，CLR 不装箱任何东西，直接返回 null。如果可空实例不为 null，CLR 从可空实例中取出值并进行装箱。CLR 允许将已装箱的值类型 T 拆箱为一个 T 或者 <code>Nullable&lt;T&gt;</code> 。如果对已装箱类型的引用是 <code>null</code> ，而且要把它拆箱为一个 <code>Nullable&lt;T&gt;</code> ，那么 CLR 会将 <code>Nullable&lt;T&gt;</code> 的值设为 <code>null</code> 。在 <code>Nullable&lt;T&gt;</code> 对象上调用 <code>GetType</code> ，CLR 实际会 “撒谎” 说类型是 <code>T</code> ，而不是 <code>Nullable&lt;T&gt;</code> 。通过可空值类型我们还能调用对应值类型的接口方法。</p><div class="tags"><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 读书笔记</a> <a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C#</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2022-11-23 15:10:20" itemprop="dateModified" datetime="2022-11-23T15:10:20+08:00">2022-11-23</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Sakupinera WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Sakupinera Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Sakupinera PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Sakupinera <i class="ic i-at"><em>@</em></i>Sakupinera</li><li class="link"><strong>Post link: </strong><a href="http://sakupinera.github.io/2022/11/23/csharp/clr-via-csharp/Chapter%2019%20Nullable%20Value%20Types/" title="CLR via C# - Chapter 19 Nullable Value Types">http://sakupinera.github.io/2022/11/23/csharp/clr-via-csharp/Chapter 19 Nullable Value Types/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/11/22/csharp/clr-via-csharp/Chapter%2018%20Custom%20Attributes/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;03&#x2F;08&#x2F;iXZtNJQI2kjGuqS.jpg" title="CLR via C# - Chapter 18 Custom Attributes"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 18 Custom Attributes</h3></a></div><div class="item right"><a href="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;03&#x2F;08&#x2F;XtZcHusj92O56kz.jpg" title="CLR via C# - Chapter 20 Exceptions and State Management"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 20 Exceptions and State Management</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-19-nullable-value-types"><span class="toc-number">1.</span> <span class="toc-text">Chapter 19 Nullable Value Types</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#cs-support-for-nullable-value-types"><span class="toc-number">1.1.</span> <span class="toc-text">C#’s Support for Nullable Value Types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cs-null-coalescing-operator"><span class="toc-number">1.2.</span> <span class="toc-text">C#’s Null-Coalescing Operator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#the-clr-has-special-support-for-nullable-value-types"><span class="toc-number">1.3.</span> <span class="toc-text">The CLR Has Special Support for Nullable Value Types</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#boxing-nullable-value-types"><span class="toc-number">1.3.1.</span> <span class="toc-text">Boxing Nullable Value Types</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unboxing-nullable-value-types"><span class="toc-number">1.3.2.</span> <span class="toc-text">Unboxing Nullable Value Types</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#calling-gettype-via-a-nullable-value-type"><span class="toc-number">1.3.3.</span> <span class="toc-text">Calling GetType via a Nullable Value Type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#calling-interface-methods-via-a-nullable-value-type"><span class="toc-number">1.3.4.</span> <span class="toc-text">Calling Interface Methods via a Nullable Value Type</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"><ul><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/" rel="bookmark" title="CLR via C# - Chapter 1 The CLR’s Execution Model">CLR via C# - Chapter 1 The CLR’s Execution Model</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/" rel="bookmark" title="CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types">CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%203%20Shared%20Assemblies%20and%20Strongly%20Named%20Assemblies/" rel="bookmark" title="CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies">CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies</a></li><li><a href="/2022/09/27/csharp/clr-via-csharp/Chapter%204%20Type%20Fundamentals/" rel="bookmark" title="CLR via C# - Chapter 4 Type Fundamentals">CLR via C# - Chapter 4 Type Fundamentals</a></li><li><a href="/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/" rel="bookmark" title="CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals">CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals</a></li><li><a href="/2022/10/21/csharp/clr-via-csharp/Chapter%206%20Type%20and%20Member%20Basics/" rel="bookmark" title="CLR via C# - Chapter 6 Type and Member Basics">CLR via C# - Chapter 6 Type and Member Basics</a></li><li><a href="/2022/10/24/csharp/clr-via-csharp/Chapter%207%20Constants%20and%20Fields/" rel="bookmark" title="CLR via C# - Chapter 7 Constants and Fields">CLR via C# - Chapter 7 Constants and Fields</a></li><li><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" rel="bookmark" title="CLR via C# - Chapter 8 Methods">CLR via C# - Chapter 8 Methods</a></li><li><a href="/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/" rel="bookmark" title="CLR via C# - Chapter 9 Parameters">CLR via C# - Chapter 9 Parameters</a></li><li><a href="/2022/10/28/csharp/clr-via-csharp/Chapter%2010%20Properties/" rel="bookmark" title="CLR via C# - Chapter 10 Properties">CLR via C# - Chapter 10 Properties</a></li><li><a href="/2022/10/29/csharp/clr-via-csharp/Chapter%2011%20Events/" rel="bookmark" title="CLR via C# - Chapter 11 Events">CLR via C# - Chapter 11 Events</a></li><li><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" rel="bookmark" title="CLR via C# - Chapter 12 Generics">CLR via C# - Chapter 12 Generics</a></li><li><a href="/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/" rel="bookmark" title="CLR via C# - Chapter 13 Interfaces">CLR via C# - Chapter 13 Interfaces</a></li><li><a href="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/" rel="bookmark" title="CLR via C# - Chapter 14 Chars, Strings, and Working with Text">CLR via C# - Chapter 14 Chars, Strings, and Working with Text</a></li><li><a href="/2022/11/17/csharp/clr-via-csharp/Chapter%2015%20Enumerated%20Types%20and%20Bit%20Flags/" rel="bookmark" title="CLR via C# - Chapter 15 Enumerated Types and Bit Flags">CLR via C# - Chapter 15 Enumerated Types and Bit Flags</a></li><li><a href="/2022/11/19/csharp/clr-via-csharp/Chapter%2016%20Arrays/" rel="bookmark" title="CLR via C# - Chapter 16 Arrays">CLR via C# - Chapter 16 Arrays</a></li><li><a href="/2022/11/21/csharp/clr-via-csharp/Chapter%2017%20Delegates/" rel="bookmark" title="CLR via C# - Chapter 17 Delegates">CLR via C# - Chapter 17 Delegates</a></li><li><a href="/2022/11/22/csharp/clr-via-csharp/Chapter%2018%20Custom%20Attributes/" rel="bookmark" title="CLR via C# - Chapter 18 Custom Attributes">CLR via C# - Chapter 18 Custom Attributes</a></li><li class="active"><a href="/2022/11/23/csharp/clr-via-csharp/Chapter%2019%20Nullable%20Value%20Types/" rel="bookmark" title="CLR via C# - Chapter 19 Nullable Value Types">CLR via C# - Chapter 19 Nullable Value Types</a></li><li><a href="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/" rel="bookmark" title="CLR via C# - Chapter 20 Exceptions and State Management">CLR via C# - Chapter 20 Exceptions and State Management</a></li><li><a href="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/" rel="bookmark" title="CLR via C# - Chapter 21 The Managed Heap and Garbage  Collection">CLR via C# - Chapter 21 The Managed Heap and Garbage Collection</a></li><li><a href="/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/" rel="bookmark" title="CLR via C# - Chapter 22 CLR Hosting and AppDomains">CLR via C# - Chapter 22 CLR Hosting and AppDomains</a></li><li><a href="/2022/11/29/csharp/clr-via-csharp/Chapter%2023%20Assembly%20Loading%20and%20Reflection/" rel="bookmark" title="CLR via C# - Chapter 23 Assembly Loading and Reflection">CLR via C# - Chapter 23 Assembly Loading and Reflection</a></li><li><a href="/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/" rel="bookmark" title="CLR via C# - Chapter 24 Runtime Serialization">CLR via C# - Chapter 24 Runtime Serialization</a></li><li><a href="/2022/12/06/csharp/clr-via-csharp/Chapter%2025%20Interoperating%20with%20WinRT%20%20Components/" rel="bookmark" title="CLR via C# - Chapter 25 Interoperating with WinRT Components">CLR via C# - Chapter 25 Interoperating with WinRT Components</a></li><li><a href="/2023/02/06/csharp/clr-via-csharp/Chapter%2026%20Thread%20Basics/" rel="bookmark" title="CLR via C# - Chapter 26 Thread Basics">CLR via C# - Chapter 26 Thread Basics</a></li><li><a href="/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations">CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations</a></li><li><a href="/2023/02/08/csharp/clr-via-csharp/Chapter%2028%20IO-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 28 IO-Bound Asynchronous Operations">CLR via C# - Chapter 28 IO-Bound Asynchronous Operations</a></li><li><a href="/2023/02/09/csharp/clr-via-csharp/Chapter%2029%20Primitive%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 29 Primitive Thread Synchronization">CLR via C# - Chapter 29 Primitive Thread Synchronization</a></li><li><a href="/2023/02/10/csharp/clr-via-csharp/Chapter%2030%20Hybrid%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 30 Hybrid Thread Synchronization">CLR via C# - Chapter 30 Hybrid Thread Synchronization</a></li></ul></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sakupinera" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Sakupinera</p><div class="description" itemprop="description">保持你的决心！</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">86</span> <span class="name">posts</span></a></div><div class="item categories"><a href="/categories/"><span class="count">13</span> <span class="name">categories</span></a></div><div class="item tags"><a href="/tags/"><span class="count">6</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nha3VwaW5lcmE=" title="https:&#x2F;&#x2F;github.com&#x2F;sakupinera"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9zYWt1cGluZXJh" title="https:&#x2F;&#x2F;twitter.com&#x2F;sakupinera"><i class="ic i-twitter"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQwNzIyOTA3MQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;407229071"><i class="ic i-cloud-music"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMjIzMDczOTg/c3BtX2lkX2Zyb209MzMzLjEwMDcuMC4w" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;22307398?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li><li class="item"><a href="/games/" rel="section"><i class="ic i-flag"></i>Games</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-person"></i>About</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/11/22/csharp/clr-via-csharp/Chapter%2018%20Custom%20Attributes/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/" title="CLR via C# - Chapter 13 Interfaces">CLR via C# - Chapter 13 Interfaces</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CSharp-in-a-Nutshell/" title="In CSharp-in-a-Nutshell">CSharp-in-a-Nutshell</a></div><span><a href="/2022/09/01/csharp/csharp-in-a-nutshell/%E7%AC%AC12%E7%AB%A0%20%E5%AF%B9%E8%B1%A1%E9%94%80%E6%AF%81%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" title="C# in a Nutshell - 第12章 对象销毁与垃圾回收">C# in a Nutshell - 第12章 对象销毁与垃圾回收</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/09/22/computer-graphics/games101/%E5%85%89%E6%A0%85%E5%8C%96/" title="GAMES101 - Rasterization（光栅化）">GAMES101 - Rasterization（光栅化）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/" title="CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals">CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2022/12/12/cpp/cpp-primer/Chapter%204%20Expressions/" title="C++ Primer - Chapter 4 Expressions">C++ Primer - Chapter 4 Expressions</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2022/12/15/cpp/cpp-primer/Chapter%207%20Classes/" title="C++ Primer - Chapter 7 Classes">C++ Primer - Chapter 7 Classes</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/08/28/linux/learn-linux/%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/" title="LearnLinux - 软件包管理">LearnLinux - 软件包管理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2023/01/02/cpp/cpp-primer/Chapter%2010%20Generic%20Algorithms/" title="C++ Primer - Chapter 10 Generic Algorithms">C++ Primer - Chapter 10 Generic Algorithms</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2022/12/11/cpp/cpp-primer/Chapter%203%20Strings,%20Vectors,%20and%20Arrays/" title="C++ Primer - Chapter 3 Strings, Vectors, and Arrays">C++ Primer - Chapter 3 Strings, Vectors, and Arrays</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/" title="CLR via C# - Chapter 24 Runtime Serialization">CLR via C# - Chapter 24 Runtime Serialization</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Sakupinera @ Hanamai Sora</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="Symbols count total">2.2m words</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="Reading time total">33:30</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/11/23/csharp/clr-via-csharp/Chapter 19 Nullable Value Types/",favicon:{show:"（●´3｀●）Goooood",hide:"(´Д｀)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/shifuku.model.json"},display:{position:"left",width:250,height:500},mobile:{show:!1},react:{opacity:.9},log:!1})</script></body></html>