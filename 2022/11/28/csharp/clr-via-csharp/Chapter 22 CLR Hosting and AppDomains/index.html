<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sakupinera" href="http://sakupinera.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sakupinera" href="http://sakupinera.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sakupinera" href="http://sakupinera.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="è¯»ä¹¦ç¬”è®°,C#"><link rel="canonical" href="http://sakupinera.github.io/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/"><title>CLR via C# - Chapter 22 CLR Hosting and AppDomains - CLR-via-CSharp - CSharp | Hanamai Sora = Sakupinera</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">CLR via C# - Chapter 22 CLR Hosting and AppDomains</h1><div class="meta"><span class="item" title="Created: 2022-11-28 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2022-11-28T00:00:00+08:00">2022-11-28</time> </span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">Symbols count in article</span> <span>69k</span> <span class="text">words</span> </span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">Reading time</span> <span>1:03</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hanamai Sora</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclimtf7dj20zk0m8qav.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclgi503lj20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclffsa1cj20zk0m811l.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipewr8iypj20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gicm0n457cj20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giph4lm9i7j20zk0m84qp.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/" itemprop="item" rel="index" title="In CSharp"><span itemprop="name">CSharp</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/CLR-via-CSharp/" itemprop="item" rel="index" title="In CLR-via-CSharp"><span itemprop="name">CLR-via-CSharp</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://sakupinera.github.io/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Sakupinera"><meta itemprop="description" content=", ä¿æŒä½ çš„å†³å¿ƒï¼"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakupinera"></span><div class="body md" itemprop="articleBody"><h1 id="chapter-22-clr-hosting-and-appdomains"><a class="anchor" href="#chapter-22-clr-hosting-and-appdomains">#</a> Chapter 22 CLR Hosting and AppDomains</h1><h2 id="clr-hosting"><a class="anchor" href="#clr-hosting">#</a> CLR Hosting</h2><blockquote><p>The .NET Framework runs on top of Windows. This means that the .NET Framework must be built using technologies that Windows can interface with. For starters, all managed module and assembly files must use the Windows portable executable (PE) file format and be either a Windows executable (EXE) file or a DLL.</p></blockquote><blockquote><p>When developing the CLR, Microsoft implemented it as a COM server contained inside a DLL; that is, Microsoft defined a standard COM interface for the CLR and assigned GUIDs to this interface and the COM server. When you install the .NET Framework, the COM server representing the CLR is registered in the Windows registry just as any other COM server would. If you want more information about this topic, refer to the MetaHost.h C++ header file that ships with the .NET Framework SDK. This header file defines the GUIDs and the unmanaged ICLRMetaHost interface definition.</p></blockquote><blockquote><p>Any Windows application can host the CLR. However, you shouldnâ€™t create an instance of the CLR COM server by calling CoCreateInstance; instead, your unmanaged host should call the CLRCreateInstance function declared in MetaHost.h. The CLRCreateInstance function is implemented in the MSCorEE.dll file, which is usually found in the C:\Windows\System32 directory. This DLL is affectionately referred to as the shim, and its job is to determine which version of the CLR to create; the shim DLL doesnâ€™t contain the CLR COM server itself.</p></blockquote><blockquote><p>A single machine may have multiple versions of the CLR installed, but there will be only one version of the MSCorEE.dll file (the shim).1 The version of MSCorEE.dll installed on the machine is the version that shipped with the latest version of the CLR installed on the machine. Therefore, this version of MSCorEE.dll knows how to find any previous versions of the CLR that may be installed.</p></blockquote><blockquote><p>The actual CLR code is contained in a file whose name has changed with different versions of the CLR. For versions 1.0, 1.1, and 2.0, the CLR code is in a file called MSCorWks.dll, and for version 4, the CLR code is in a file called Clr.dll. Because you can have multiple versions of the CLR installed on a single machine, these files are installed into different directories as follows.</p><ul><li><p>Version 1.0 is in C:\Windows\<span class="exturl" data-url="aHR0cDovL01pY3Jvc29mdC5ORVQ=">Microsoft.NET</span>\Framework\v1.0.3705</p></li><li><p>Version 1.1 is in C:\Windows\<span class="exturl" data-url="aHR0cDovL01pY3Jvc29mdC5ORVQ=">Microsoft.NET</span>\Framework\v1.0.4322</p></li><li><p>Version 2.0 is in C:\Windows\<span class="exturl" data-url="aHR0cDovL01pY3Jvc29mdC5ORVQ=">Microsoft.NET</span>\Framework\v2.0.50727</p></li><li><p>Version 4 is in C:\Windows\<span class="exturl" data-url="aHR0cDovL01pY3Jvc29mdC5ORVQ=">Microsoft.NET</span>\Framework\v4.0.21006</p></li></ul></blockquote><blockquote><p>The CLRCreateInstance function can return an ICLRMetaHost interface. A host application can call this interfaceâ€™s GetRuntime function, specifying the version of the CLR that the host would like to create. The shim then loads the desired version of the CLR into the hostâ€™s process.</p></blockquote><blockquote><p>By default, when a managed executable starts, the shim examines the executable file and extracts the information indicating the version of the CLR that the application was built and tested with. However, an application can override this default behavior by placing requiredRuntime and supportedRuntime entries in its XML configuration file (described in Chapter 2, â€œBuilding, Packaging, Deploying, and Administering Applications and Types,â€ and Chapter 3, â€œShared Assemblies and Strongly Named Assembliesâ€).</p></blockquote><blockquote><p>The GetRuntime function returns a pointer to the unmanaged ICLRRuntimeInfo interface from which the ICLRRuntimeHost interface is obtained via the GetInterface method. The hosting application can call methods defined by this interface to:</p><ul><li><p>Set Host managers. Tell the CLR that the host wants to be involved in making decisions related to memory allocations, thread scheduling/synchronization, assembly loading, and more. The host can also state that it wants notifications of garbage collection starts and stops and when certain operations time out.</p></li><li><p>Get CLR managers. Tell the CLR to prevent the use of some classes/members. In addition, the host can tell which code can and canâ€™t be debugged and which methods in the host should be called when a special eventâ€”such as an AppDomain unload, CLR stop, or stack overflow exceptionâ€”occurs.</p></li><li><p>Initialize and start the CLR.</p></li><li><p>Load an assembly and execute code in it.</p></li><li><p>Stop the CLR, thus preventing any more managed code from running in the Windows process.</p></li></ul></blockquote><blockquote><p>There are many reasons why hosting the CLR is useful. Hosting allows any application to offer CLR features and a programmability story and to be at least partially written in managed code. Any application that hosts the runtime offers many benefits to developers who are trying to extend the application. Here are some of the benefits:</p><ul><li><p>Programming can be done in any programming language.</p></li><li><p>Code is just-in-time (JIT)â€“compiled for speed (versus being interpreted).</p></li><li><p>Code uses garbage collection to avoid memory leaks and corruption.</p></li><li><p>Code runs in a secure sandbox.</p></li><li><p>The host doesnâ€™t need to worry about providing a rich development environment. The host makes use of existing technologies: languages, compilers, editors, debuggers, profilers, and more.</p></li></ul></blockquote><blockquote><p>If you are interested in using the CLR for hosting scenarios, I highly recommend that you get Steven Pratschnerâ€™s excellent book, Customizing the Microsoft .NET Framework Common Language Runtime (Microsoft Press 2005), even though it focuses on pre-4 versions of the CLR.</p></blockquote><p>ğŸ’¡æ³¨æ„ Windows è¿›ç¨‹å®Œå…¨å¯ä»¥ä¸åŠ è½½ CLRï¼Œåªæœ‰åœ¨è¿›ç¨‹ä¸­æ‰§è¡Œæ‰˜ç®¡ä»£ç æ—¶æ‰è¿›è¡ŒåŠ è½½ã€‚åœ¨ .NET Framework 4 ä¹‹å‰ï¼ŒCLR åªå…è®¸å®ƒçš„ä¸€ä¸ªå®ä¾‹å¯„å®¿åœ¨ Windows è¿›ç¨‹ä¸­ã€‚æ¢è¨€ä¹‹ï¼Œåœ¨ä¸€ä¸ªè¿›ç¨‹ä¸­ï¼Œè¦ä¹ˆä¸åŒ…å«ä»»ä½• CLRï¼Œè¦ä¹ˆåªèƒ½åŒ…å« CLR v1.0, CLR v1.1 æˆ–è€… CLR 2.0 ä¹‹ä¸€ã€‚æ¯è¿›ç¨‹ä»…ä¸€ä¸ªç‰ˆæœ¬çš„ CLR æ˜¾ç„¶è¿‡äºå±€é™ã€‚ä¾‹å¦‚ï¼Œè¿™æ · Microsoft Office Outlook å°±ä¸èƒ½åŠ è½½ä¸ºä¸åŒç‰ˆæœ¬çš„ .NET Framework ç”Ÿæˆå’Œæµ‹è¯•çš„ä¸¤ä¸ªåŠ è½½é¡¹äº†ã€‚</p><p>ä½†æ˜¯ï¼Œéšç€ .NET Framework 4 çš„å‘å¸ƒï¼ŒMicrosoft æ”¯æŒåœ¨ä¸€ä¸ª Windows è¿›ç¨‹ä¸­åŒæ—¶åŠ è½½ CLR v2.0 å’Œ v4.0ï¼Œä¸º .NET Framework 2.0 å’Œ 4.0 å†™çš„ä¸åŒç»„ä»¶èƒ½åŒæ—¶è¿è¡Œï¼Œä¸ä¼šå‡ºç°ä»»ä½•å…¼å®¹æ€§é—®é¢˜ã€‚è¿™æ˜¯ä¸€ä¸ªä»¤äººæ¿€åŠ¨çš„åŠŸèƒ½ï¼Œå› ä¸ºå®ƒæå¤§æ‰©å±•äº† .NET Framework ç»„ä»¶çš„åº”ç”¨åœºåˆã€‚å¯åˆ©ç”¨ CLrVer.exe å·¥å…·æ£€æŸ¥ç»™å®šçš„è¿›ç¨‹åŠ è½½çš„æ˜¯å“ªä¸ª (å“ªäº›) ç‰ˆæœ¬çš„ CLRã€‚</p><p>ä¸€ä¸ª CLR åŠ è½½åˆ° Windows è¿›ç¨‹ä¹‹åï¼Œä¾¿æ°¸è¿œä¸èƒ½å¸è½½ï¼›åœ¨ <code>ICLRRuntimeHost</code> æ¥å£ä¸Šè°ƒç”¨ <code>AddRef</code> å’Œ <code>Release</code> æ–¹æ³•æ˜¯æ²¡æœ‰ä½œç”¨çš„ã€‚CLR ä»è¿›ç¨‹ä¸­å¸è½½çš„å”¯ä¸€é€”å¾„å°±æ˜¯ç»ˆæ­¢è¿›ç¨‹ï¼Œè¿™ä¼šé€ æˆ Windows æ¸…ç†è¿›ç¨‹ä½¿ç”¨çš„æ‰€æœ‰èµ„æºã€‚</p><p>ğŸ’¡å°ç»“ï¼šå¯„å®¿ï¼ˆhostingï¼‰ä½¿ä»»ä½•åº”ç”¨ç¨‹åºéƒ½èƒ½åˆ©ç”¨ CLR çš„åŠŸèƒ½ã€‚ç‰¹åˆ«è¦æŒ‡å‡ºçš„æ˜¯ï¼Œå®ƒä½¿ç°åœ¨çš„åº”ç”¨ç¨‹åºè‡³å°‘èƒ½éƒ¨åˆ†ä½¿ç”¨æ‰˜ç®¡ä»£ç ç¼–å†™ã€‚å¦å¤–ï¼Œå¯„å®¿è¿˜ä¸ºåº”ç”¨ç¨‹åºæä¾›äº†é€šè¿‡ç¼–è¯‘æ¥è¿›è¡Œè‡ªå®šä¹‰å’Œæ‰©å±•çš„åŠŸèƒ½ã€‚.NET Framework åœ¨ Windows å¹³å°çš„é¡¶éƒ¨è¿è¡Œã€‚<span class="exturl" data-url="aHR0cDovL3huLS1idHI1NjBhOGtydXB3Lk5FVA==">è¿™æ„å‘³ç€.NET</span> Framework å¿…é¡»ç”¨ Windows èƒ½ç†è§£çš„æŠ€æœ¯æ¥æ„å»ºã€‚é¦–å…ˆï¼Œæ‰€æœ‰æ‰˜ç®¡æ¨¡å—å’Œç¨‹åºé›†æ–‡ä»¶å¿…é¡»ä½¿ç”¨ Windows PE æ–‡ä»¶æ ¼å¼ï¼Œè€Œä¸”è¦ä¹ˆæ˜¯ Windows EXE æ–‡ä»¶ï¼Œè¦ä¹ˆæ˜¯ DLL æ–‡ä»¶ã€‚å¼€å‘ CLR æ—¶ï¼ŒMicrosoft å®é™…æ˜¯æŠŠå®ƒå®ç°æˆåŒ…å«åœ¨ä¸€ä¸ª DLL ä¸­çš„ COM æœåŠ¡å™¨ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼ŒMicrosoft ä¸º CLR å®šä¹‰äº†ä¸€ä¸ªæ ‡å‡†çš„ COM æ¥å£ï¼Œå¹¶ä¸ºè¯¥æ¥å£å’Œ COM æœåŠ¡å™¨åˆ†é…äº† GUIDã€‚<span class="exturl" data-url="aHR0cDovL3huLS00OXNxNjZoLk5FVA==">å®‰è£….NET</span> Framework æ—¶ï¼Œä»£è¡¨ CLR çš„ COM æœåŠ¡å™¨å’Œå…¶ä»– COM æœåŠ¡å™¨ä¸€æ ·åœ¨ Windows æ³¨å†Œè¡¨ä¸­æ³¨å†Œã€‚ä»»ä½• Windows åº”ç”¨ç¨‹åºéƒ½èƒ½å¯„å®¿ï¼ˆå®¹çº³ï¼‰CLRã€‚ä½†ä¸è¦é€šè¿‡è°ƒç”¨ <code>CoCreateInstance</code> æ¥åˆ›å»º CLR COM æœåŠ¡å™¨çš„å®ä¾‹ï¼Œç›¸åï¼Œä½ çš„éæ‰˜ç®¡å®¿ä¸»åº”è¯¥è°ƒç”¨ MetaHost.h æ–‡ä»¶ä¸­å£°æ˜çš„ <code>CLRCreateInstance</code> å‡½æ•°ã€‚ <code>CLRCreateInstance</code> å‡½æ•°åœ¨ MSCorEE.dll æ–‡ä»¶ä¸­å®ç°ï¼Œè¯¥æ–‡ä»¶ä¸€èˆ¬åœ¨ C:\WIndows\System32 ç›®å½•ä¸­ã€‚è¿™ä¸ª DLL è¢«äººä»¬äº²åˆ‡åœ°ç§°ä¸º â€œå«ç‰‡â€ï¼ˆshimï¼‰ï¼Œå®ƒçš„å·¥ä½œæ˜¯å†³å®šåˆ›å»ºå“ªä¸ªç‰ˆæœ¬çš„ CLRï¼›å«ç‰‡ DLL æœ¬èº«ä¸åŒ…å« CLR COM æœåŠ¡å™¨ã€‚ä¸€å°æœºå™¨å¯å®‰è£…å¤šä¸ªç‰ˆæœ¬çš„ CLRï¼Œä½†åªæœ‰ä¸€ä¸ªç‰ˆæœ¬çš„ MSCorEE.dll æ–‡ä»¶ï¼ˆå«ç‰‡ï¼‰ã€‚æœºå™¨ä¸Šå®‰è£…çš„ MSCorEE.dll æ˜¯ä¸æœºå™¨ä¸Šå®‰è£…çš„æœ€æ–°ç‰ˆæœ¬çš„ CLR ä¸€èµ·å‘å¸ƒçš„é‚£ä¸ªç‰ˆæœ¬ã€‚æ‰€ä»¥ï¼Œè¯¥ç‰ˆæœ¬çš„ MSCorEE.dll çŸ¥é“å¦‚ä½•æŸ¥æ‰¾æœºå™¨ä¸Šçš„è€ç‰ˆæœ¬ CLRã€‚åŒ…å«å®é™… CLR ä»£ç çš„æ–‡ä»¶çš„åç§°åœ¨ä¸åŒç‰ˆæœ¬çš„ CLR ä¸­æ˜¯ä¸åŒçš„ã€‚ç‰ˆæœ¬ 1.0ï¼Œ1.1 å’Œ 2.0 çš„ CLR ä»£ç åœ¨ MSCorWks.dll æ–‡ä»¶ä¸­ï¼›ç‰ˆæœ¬ 4 åˆ™åœ¨ Clr.dll æ–‡ä»¶ä¸­ã€‚ <code>CLRCreateInstance</code> å‡½æ•°å¯è¿”å›ä¸€ä¸ª <code>ICLRMetaHost</code> æ¥å£ã€‚å®¿ä¸»åº”ç”¨ç¨‹åºå¯è°ƒç”¨è¿™ä¸ªæ¥å£çš„ GetRuntime å‡½æ•°ï¼ŒæŒ‡å®šå®¿ä¸»è¦åˆ›å»ºçš„ CLR çš„ç‰ˆæœ¬ã€‚ç„¶åï¼Œå«ç‰‡å°†æ‰€éœ€ç‰ˆæœ¬çš„ CLR åŠ è½½åˆ°å®¿ä¸»çš„è¿›ç¨‹ä¸­ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œå½“ä¸€ä¸ªæ‰˜ç®¡çš„å¯æ‰§è¡Œæ–‡ä»¶å¯åŠ¨æ—¶ï¼Œå«ç‰‡ä¼šæ£€æŸ¥å¯æ‰§è¡Œæ–‡ä»¶ï¼Œæå–å½“åˆç”Ÿæˆå’Œæµ‹è¯•åº”ç”¨ç¨‹åºæ—¶ä½¿ç”¨çš„ CLR çš„ç‰ˆæœ¬ä¿¡æ¯ã€‚ä½†åº”ç”¨ç¨‹åºå¯ä»¥åœ¨å®ƒçš„ XML é…ç½®æ–‡ä»¶ä¸­è®¾ç½® <code>requiredRuntime</code> å’Œ <code>supportedRuntime</code> è¿™ä¸¤é¡¹æ¥è¦†ç›–è¯¥é»˜è®¤è¡Œä¸ºã€‚ <code>GetRuntime</code> å‡½æ•°è¿”å›æŒ‡å‘éæ‰˜ç®¡ <code>ICLRRuntimeInfo</code> æ¥å£çš„æŒ‡é’ˆã€‚æœ‰äº†è¿™ä¸ªæŒ‡é’ˆåï¼Œå°±å¯åˆ©ç”¨ <code>GetInterface</code> æ–¹æ³•è·å¾— <code>ICLRRuntimeHost</code> æ¥å£ã€‚å®¿ä¸»åº”ç”¨ç¨‹åºå¯è°ƒç”¨è¯¥æ¥å£å®šä¹‰çš„æ–¹æ³•æ¥è®¾ç½®å®¿ä¸»ç®¡ç†å™¨ã€è·å– CLR ç®¡ç†å™¨ã€åˆå§‹åŒ–å¹¶å¯åŠ¨ CLRã€åŠ è½½ç¨‹åºé›†å¹¶æ‰§è¡Œå…¶ä¸­çš„ä»£ç ã€åœæ­¢ CLRï¼Œé˜»æ­¢ä»»ä½•æ›´å¤šçš„æ‰˜ç®¡ä»£ç åœ¨ Windows è¿›ç¨‹ä¸­è¿è¡Œã€‚</p><h2 id="appdomains"><a class="anchor" href="#appdomains">#</a> AppDomains</h2><blockquote><p>When the CLR COM server initializes, it creates an AppDomain. An AppDomain is a logical container for a set of assemblies. The first AppDomain created when the CLR is initialized is called the default AppDomain; this AppDomain is destroyed only when the Windows process terminates.</p></blockquote><blockquote><p>In addition to the default AppDomain, a host using either unmanaged COM interface methods or managed type methods can instruct the CLR to create additional AppDomains. The whole purpose of an AppDomain is to provide isolation. Here are the specific features offered by an AppDomain:</p><ul><li><p><strong>Objects created by code in one AppDomain cannot be accessed directly by code in another AppDomain</strong> When code in an AppDomain creates an object, that object is â€œownedâ€ by that AppDomain. In other words, the object is not allowed to live beyond the lifetime of the AppDomain whose code constructed it. Code in other AppDomains can access another AppDomainâ€™s object only by using marshal-by-reference or marshal-by-value semantics. This enforces a clean separation and boundary because code in one AppDomain canâ€™t have a direct reference to an object created by code in a different AppDomain. This isolation allows AppDomains to be easily unloaded from a process without affecting code running in other AppDomains.</p></li><li><p><strong>AppDomains can be unloaded</strong> The CLR doesnâ€™t support the ability to unload a single assembly from an AppDomain. However, you can tell the CLR to unload an AppDomain, which will cause all of the assemblies currently contained in it to be unloaded as well.</p></li><li><p><strong>AppDomains can be individually secured</strong> When created, an AppDomain can have a permission set applied to it that determines the maximum rights granted to assemblies running in the AppDomain. This allows a host to load some code and be ensured that the code cannot corrupt or read important data structures used by the host itself.</p></li><li><p><strong>AppDomains can be individually configured</strong> When created, an AppDomain can have a bunch of configuration settings associated with it. These settings mostly affect how the CLR loads assemblies into the AppDomain. There are configuration settings related to search paths, version binding redirects, shadow copying, and loader optimizations.</p></li></ul></blockquote><p>ğŸ’¡é‡è¦æç¤ºï¼šWindows çš„ä¸€ä¸ªé‡è¦ç‰¹è‰²æ˜¯è®©æ¯ä¸ªåº”ç”¨ç¨‹åºéƒ½åœ¨è‡ªå·±çš„è¿›ç¨‹åœ°å€ç©ºé—´ä¸­è¿è¡Œã€‚è¿™å°±ä¿è¯äº†ä¸€ä¸ªåº”ç”¨ç¨‹åºçš„ä»£ç ä¸èƒ½è®¿é—®å¦ä¸€ä¸ªåº”ç”¨ç¨‹åºä½¿ç”¨çš„ä»£ç æˆ–æ•°æ®ã€‚è¿›ç¨‹éš”ç¦»å¯é˜²èŒƒå®‰å…¨æ¼æ´ã€æ•°æ®ç ´åå’Œå…¶ä»–ä¸å¯é¢„æµ‹çš„è¡Œä¸ºï¼Œç¡®ä¿äº† Windows ç³»ç»Ÿä»¥åŠåœ¨å®ƒä¸Šé¢è¿è¡Œçš„åº”ç”¨ç¨‹åºçš„å¥å£®æ€§ã€‚é—æ†¾çš„æ˜¯ï¼Œåœ¨ Windows ä¸­åˆ›å»ºè¿›ç¨‹çš„å¼€é”€å¾ˆå¤§ã€‚Win32 CreateProcess å‡½æ•°çš„é€Ÿåº¦å¾ˆæ…¢ï¼Œè€Œä¸” Windows éœ€è¦å¤§é‡å†…å­˜æ¥è™šæ‹ŸåŒ–è¿›ç¨‹çš„åœ°å€ç©ºé—´ã€‚</p><p>ä½†æ˜¯ï¼Œå¦‚æœåº”ç”¨ç¨‹åºå®‰å…¨ç”±æ‰˜ç®¡ä»£ç æ„æˆ (è¿™äº›ä»£ç çš„å®‰å…¨æ€§å¯ä»¥éªŒè¯)ï¼ŒåŒæ—¶è¿™äº›ä»£ç æ²¡æœ‰è°ƒç”¨éæ‰˜ç®¡ä»£ç ï¼Œé‚£ä¹ˆåœ¨ä¸€ä¸ª Windows è¿›ç¨‹ä¸­è¿è¡Œå¤šä¸ªæ‰˜ç®¡åº”ç”¨ç¨‹åºæ˜¯æ²¡æœ‰é—®é¢˜çš„ã€‚AppDomain æä¾›äº†ä¿æŠ¤ã€é…ç½®å’Œç»ˆæ­¢å…¶ä¸­æ¯ä¸€ä¸ªåº”ç”¨ç¨‹åºæ‰€éœ€çš„éš”ç¦»ã€‚</p><blockquote><p>Figure 22-1 shows a single Windows process that has one CLR COM server running in it. This CLR is currently managing two AppDomains (although there is no hard-coded limit to the number of AppDomains that could be running in a single Windows process). Each AppDomain has its own loader heap, each of which maintains a record of which types have been accessed because the AppDomain was created. These type objects were discussed in Chapter 4, â€œType Fundamentals;â€ each type object in the loader heap has a method table, and each entry in the method table points to JIT-compiled native code if the method has been executed at least once.</p></blockquote><blockquote><p>In addition, each AppDomain has some assemblies loaded into it. AppDomain #1 (the default AppDomain) has three assemblies: MyApp.exe, TypeLib.dll, and System.dll. AppDomain #2 has two assemblies loaded into it: Wintellect.dll and System.dll.</p></blockquote><blockquote><p>Youâ€™ll notice that the System.dll assembly has been loaded into both AppDomains. If both AppDomains are using a single type from System.dll, both AppDomains will have a type object for the same type allocated in each loader heap; the memory for the type object is not shared by all of the AppDomains. Furthermore, as code in an AppDomain calls methods defined by a type, the methodâ€™s Intermediate Language (IL) code is JIT-compiled, and the resulting native code is associated with each AppDomain; the code for the method is not shared by all AppDomains that call it.</p></blockquote><blockquote><p>Not sharing the memory for the type objects or native code is wasteful. However, the whole purpose of AppDomains is to provide isolation; the CLR needs to be able to unload an AppDomain and free up all of its resources without adversely affecting any other AppDomain. Replicating the CLR data structures ensures that this is possible. It also ensures that a type used by multiple AppDomains has a set of static fields for each AppDomain.</p></blockquote><p><img data-src="/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/image-20221202183601974.png" alt="image-20221202183601974"></p><blockquote><p>Some assemblies are expected to be used by several AppDomains. MSCorLib.dll is the best example. This assembly contains System.Object, System.Int32, and all of the other types that are so integral to the .NET Framework. This assembly is automatically loaded when the CLR initializes, and all AppDomains share the types in this assembly. To reduce resource usage, MSCorLib.dll is loaded in an AppDomain-neutral fashion; that is, the CLR maintains a special loader heap for assemblies that are loaded in a domain-neutral fashion. All type objects in this loader heap and all native code for methods of these types are shared by all AppDomains in the process. Unfortunately, the benefit gained by sharing these resources does come with a price: assemblies that are loaded domain-neutral can never be unloaded. The only way to reclaim the resources used by them is to terminate the Windows process to cause Windows to reclaim the resources.</p></blockquote><h3 id="accessing-objects-across-appdomain-boundaries"><a class="anchor" href="#accessing-objects-across-appdomain-boundaries">#</a> Accessing Objects Across AppDomain Boundaries</h3><blockquote><p>Code in one AppDomain can communicate with types and objects contained in another AppDomain. However, access to these types and objects is allowed only through well-defined mechanisms. The following Ch22-1-AppDomains sample application demonstrates how to create a new AppDomain, load an assembly into it, and construct an instance of a type defined in that assembly. The code shows the different behaviors when constructing a type that is marshaled by reference, a type that is marshaled by value, and a type that canâ€™t be marshaled at all. The code also shows how these differently marshaled objects behave when the AppDomain that created them is unloaded. The Ch22- 1-AppDomains sample application has very little code in it, but I have added a lot of comments. After the code listing, Iâ€™ll walk through the code, explaining what the CLR is doing.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Marshalling</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Get a reference to the AppDomain that the calling thread is executing in</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">AppDomain</span> adCallingThreadDomain <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">GetDomain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// Every AppDomain is assigned a friendly string name (helpful for debugging)</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// Get this AppDomain's friendly string name and display it</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token class-name">String</span> callingDomainName <span class="token operator">=</span> adCallingThreadDomain<span class="token punctuation">.</span>FriendlyName<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Default AppDomain's friendly name=&#123;0&#125;"</span><span class="token punctuation">,</span> callingDomainName<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Get and display the assembly in our AppDomain that contains the 'Main' method</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token class-name">String</span> exeAssembly <span class="token operator">=</span> Assembly<span class="token punctuation">.</span><span class="token function">GetEntryAssembly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>FullName<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Main assembly=&#123;0&#125;"</span><span class="token punctuation">,</span> exeAssembly<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// Define a local variable that can refer to an AppDomain</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token class-name">AppDomain</span> ad2 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token comment">// *** DEMO 1: Cross-AppDomain Communication Using Marshal-by-Reference ***</span></pre></td></tr><tr><td data-num="14"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"&#123;0&#125;Demo #1"</span><span class="token punctuation">,</span> Environment<span class="token punctuation">.</span>NewLine<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// Create new AppDomain (security and configuration match current AppDomain)</span></pre></td></tr><tr><td data-num="16"></td><td><pre> ad2 <span class="token operator">=</span> AppDomain<span class="token punctuation">.</span><span class="token function">CreateDomain</span><span class="token punctuation">(</span><span class="token string">"AD #2"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token class-name">MarshalByRefType</span> mbrt <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token comment">// Load our assembly into the new AppDomain, construct an object, marshal </span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token comment">// it back to our AD (we really get a reference to a proxy)</span></pre></td></tr><tr><td data-num="20"></td><td><pre> mbrt <span class="token operator">=</span> <span class="token punctuation">(</span>MarshalByRefType<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre> ad2<span class="token punctuation">.</span><span class="token function">CreateInstanceAndUnwrap</span><span class="token punctuation">(</span>exeAssembly<span class="token punctuation">,</span> <span class="token string">"MarshalByRefType"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Type=&#123;0&#125;"</span><span class="token punctuation">,</span> mbrt<span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// The CLR lies about the type</span></pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token comment">// Prove that we got a reference to a proxy object</span></pre></td></tr><tr><td data-num="24"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Is proxy=&#123;0&#125;"</span><span class="token punctuation">,</span> RemotingServices<span class="token punctuation">.</span><span class="token function">IsTransparentProxy</span><span class="token punctuation">(</span>mbrt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token comment">// This looks like we're calling a method on MarshalByRefType but we're not.</span></pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token comment">// We're calling a method on the proxy type. The proxy transitions the thread</span></pre></td></tr><tr><td data-num="27"></td><td><pre> <span class="token comment">// to the AppDomain owning the object and calls this method on the real object.</span></pre></td></tr><tr><td data-num="28"></td><td><pre> mbrt<span class="token punctuation">.</span><span class="token function">SomeMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre> <span class="token comment">// Unload the new AppDomain</span></pre></td></tr><tr><td data-num="30"></td><td><pre> AppDomain<span class="token punctuation">.</span><span class="token function">Unload</span><span class="token punctuation">(</span>ad2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre> <span class="token comment">// mbrt refers to a valid proxy object; the proxy object refers to an invalid AppDomain</span></pre></td></tr><tr><td data-num="32"></td><td><pre> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="33"></td><td><pre> <span class="token comment">// We're calling a method on the proxy type. The AD is invalid, exception is thrown</span></pre></td></tr><tr><td data-num="34"></td><td><pre> mbrt<span class="token punctuation">.</span><span class="token function">SomeMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Successful call."</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="37"></td><td><pre> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">AppDomainUnloadedException</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="38"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Failed call."</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="40"></td><td><pre> <span class="token comment">// *** DEMO 2: Cross-AppDomain Communication Using Marshal-by-Value ***</span></pre></td></tr><tr><td data-num="41"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"&#123;0&#125;Demo #2"</span><span class="token punctuation">,</span> Environment<span class="token punctuation">.</span>NewLine<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="42"></td><td><pre> <span class="token comment">// Create new AppDomain (security and configuration match current AppDomain)</span></pre></td></tr><tr><td data-num="43"></td><td><pre> ad2 <span class="token operator">=</span> AppDomain<span class="token punctuation">.</span><span class="token function">CreateDomain</span><span class="token punctuation">(</span><span class="token string">"AD #2"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre> <span class="token comment">// Load our assembly into the new AppDomain, construct an object, marshal </span></pre></td></tr><tr><td data-num="45"></td><td><pre> <span class="token comment">// it back to our AD (we really get a reference to a proxy)</span></pre></td></tr><tr><td data-num="46"></td><td><pre> mbrt <span class="token operator">=</span> <span class="token punctuation">(</span>MarshalByRefType<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="47"></td><td><pre> ad2<span class="token punctuation">.</span><span class="token function">CreateInstanceAndUnwrap</span><span class="token punctuation">(</span>exeAssembly<span class="token punctuation">,</span> <span class="token string">"MarshalByRefType"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="48"></td><td><pre> <span class="token comment">// The object's method returns a COPY of the returned object; </span></pre></td></tr><tr><td data-num="49"></td><td><pre> <span class="token comment">// the object is marshaled by value (not by reference).</span></pre></td></tr><tr><td data-num="50"></td><td><pre> <span class="token class-name">MarshalByValType</span> mbvt <span class="token operator">=</span> mbrt<span class="token punctuation">.</span><span class="token function">MethodWithReturn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="51"></td><td><pre> <span class="token comment">// Prove that we did NOT get a reference to a proxy object</span></pre></td></tr><tr><td data-num="52"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Is proxy=&#123;0&#125;"</span><span class="token punctuation">,</span> RemotingServices<span class="token punctuation">.</span><span class="token function">IsTransparentProxy</span><span class="token punctuation">(</span>mbvt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="53"></td><td><pre> <span class="token comment">// This looks like we're calling a method on MarshalByValType and we are.</span></pre></td></tr><tr><td data-num="54"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Returned object created "</span> <span class="token operator">+</span> mbvt<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="55"></td><td><pre> <span class="token comment">// Unload the new AppDomain</span></pre></td></tr><tr><td data-num="56"></td><td><pre> AppDomain<span class="token punctuation">.</span><span class="token function">Unload</span><span class="token punctuation">(</span>ad2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="57"></td><td><pre> <span class="token comment">// mbvt refers to valid object; unloading the AppDomain has no impact.</span></pre></td></tr><tr><td data-num="58"></td><td><pre> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="59"></td><td><pre> <span class="token comment">// We're calling a method on an object; no exception is thrown</span></pre></td></tr><tr><td data-num="60"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Returned object created "</span> <span class="token operator">+</span> mbvt<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="61"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Successful call."</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="62"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="63"></td><td><pre> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">AppDomainUnloadedException</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="64"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Failed call."</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="65"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="66"></td><td><pre> <span class="token comment">// DEMO 3: Cross-AppDomain Communication Using non-marshalable type ***</span></pre></td></tr><tr><td data-num="67"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"&#123;0&#125;Demo #3"</span><span class="token punctuation">,</span> Environment<span class="token punctuation">.</span>NewLine<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="68"></td><td><pre> <span class="token comment">// Create new AppDomain (security and configuration match current AppDomain)</span></pre></td></tr><tr><td data-num="69"></td><td><pre> ad2 <span class="token operator">=</span> AppDomain<span class="token punctuation">.</span><span class="token function">CreateDomain</span><span class="token punctuation">(</span><span class="token string">"AD #2"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="70"></td><td><pre> <span class="token comment">// Load our assembly into the new AppDomain, construct an object, marshal </span></pre></td></tr><tr><td data-num="71"></td><td><pre> <span class="token comment">// it back to our AD (we really get a reference to a proxy)</span></pre></td></tr><tr><td data-num="72"></td><td><pre> mbrt <span class="token operator">=</span> <span class="token punctuation">(</span>MarshalByRefType<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="73"></td><td><pre> ad2<span class="token punctuation">.</span><span class="token function">CreateInstanceAndUnwrap</span><span class="token punctuation">(</span>exeAssembly<span class="token punctuation">,</span> <span class="token string">"MarshalByRefType"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="74"></td><td><pre> <span class="token comment">// The object's method returns a non-marshalable object; exception</span></pre></td></tr><tr><td data-num="75"></td><td><pre> <span class="token class-name">NonMarshalableType</span> nmt <span class="token operator">=</span> mbrt<span class="token punctuation">.</span><span class="token function">MethodArgAndReturn</span><span class="token punctuation">(</span>callingDomainName<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="76"></td><td><pre> <span class="token comment">// We won't get here...</span></pre></td></tr><tr><td data-num="77"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="78"></td><td><pre><span class="token comment">// Instances can be marshaled-by-reference across AppDomain boundaries</span></pre></td></tr><tr><td data-num="79"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">MarshalByRefType</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">MarshalByRefObject</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="80"></td><td><pre> <span class="token keyword">public</span> <span class="token function">MarshalByRefType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="81"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"&#123;0&#125; ctor running in &#123;1&#125;"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="82"></td><td><pre> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Thread<span class="token punctuation">.</span><span class="token function">GetDomain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>FriendlyName<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="83"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="84"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SomeMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="85"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Executing in "</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">GetDomain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>FriendlyName<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="86"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="87"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">MarshalByValType</span> <span class="token function">MethodWithReturn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="88"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Executing in "</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">GetDomain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>FriendlyName<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="89"></td><td><pre> <span class="token class-name">MarshalByValType</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">MarshalByValType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="90"></td><td><pre> <span class="token keyword">return</span> t<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="91"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="92"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">NonMarshalableType</span> <span class="token function">MethodArgAndReturn</span><span class="token punctuation">(</span><span class="token class-name">String</span> callingDomainName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="93"></td><td><pre> <span class="token comment">// NOTE: callingDomainName is [Serializable]</span></pre></td></tr><tr><td data-num="94"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Calling from '&#123;0&#125;' to '&#123;1&#125;'."</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="95"></td><td><pre> callingDomainName<span class="token punctuation">,</span> Thread<span class="token punctuation">.</span><span class="token function">GetDomain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>FriendlyName<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="96"></td><td><pre> <span class="token class-name">NonMarshalableType</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">NonMarshalableType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="97"></td><td><pre> <span class="token keyword">return</span> t<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="98"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="99"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="100"></td><td><pre><span class="token comment">// Instances can be marshaled-by-value across AppDomain boundaries</span></pre></td></tr><tr><td data-num="101"></td><td><pre><span class="token punctuation">[</span>Serializable<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="102"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">MarshalByValType</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Object</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="103"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">DateTime</span> m_creationTime <span class="token operator">=</span> DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">;</span> <span class="token comment">// NOTE: DateTime is [Serializable]</span></pre></td></tr><tr><td data-num="104"></td><td><pre> <span class="token keyword">public</span> <span class="token function">MarshalByValType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="105"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"&#123;0&#125; ctor running in &#123;1&#125;, Created on &#123;2:D&#125;"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="106"></td><td><pre> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="107"></td><td><pre> Thread<span class="token punctuation">.</span><span class="token function">GetDomain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>FriendlyName<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="108"></td><td><pre> m_creationTime<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="109"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="110"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name">String</span> <span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="111"></td><td><pre> <span class="token keyword">return</span> m_creationTime<span class="token punctuation">.</span><span class="token function">ToLongDateString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="112"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="113"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="114"></td><td><pre><span class="token comment">// Instances cannot be marshaled across AppDomain boundaries</span></pre></td></tr><tr><td data-num="115"></td><td><pre><span class="token comment">// [Serializable]</span></pre></td></tr><tr><td data-num="116"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">NonMarshalableType</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Object</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="117"></td><td><pre> <span class="token keyword">public</span> <span class="token function">NonMarshalableType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="118"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Executing in "</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">GetDomain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>FriendlyName<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="119"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="120"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>If you build and run the Ch22-1-AppDomains application, you get the following output.</p></blockquote><pre><code class="language-cmd">Default AppDomain's friendly name= Ch22-1-AppDomains.exe
Main assembly=Ch22-1-AppDomains, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
Demo #1
MarshalByRefType ctor running in AD #2
Type=MarshalByRefType
Is proxy=True
Executing in AD #2
Failed call.
Demo #2
MarshalByRefType ctor running in AD #2
Executing in AD #2
MarshalByValType ctor running in AD #2, Created on Friday, August 07, 2009
Is proxy=False
Returned object created Saturday, June 23, 2012
Returned object created Saturday, June 23, 2012
Successful call.
Demo #3
MarshalByRefType ctor running in AD #2
Calling from 'Ch22-1-AppDomains.exe' to 'AD #2'.
Executing in AD #2
Unhandled Exception: System.Runtime.Serialization.SerializationException: 
Type 'NonMarshalableType' in assembly 'Ch22-1-AppDomains, Version=0.0.0.0, 
Culture=neutral, PublicKeyToken=null' is not marked as serializable.
at MarshalByRefType.MethodArgAndReturn(String callingDomainName)
at Program.Marshalling()
at Program.Main() 
</code></pre><blockquote><p>Now, I will discuss what this code and the CLR are doing.</p></blockquote><blockquote><p>Inside the Marshalling method, I first get a reference to an AppDomain object that identifies the AppDomain the calling thread is currently executing in. In Windows, a thread is always created in the context of one process, and the thread lives its entire lifetime in that process. However, a one-to-one correspondence doesnâ€™t exist between threads and AppDomains. AppDomains are a CLR feature; Windows knows nothing about AppDomains. Because multiple AppDomains can be in a single Windows process, a thread can execute code in one AppDomain and then execute code in another AppDomain. From the CLRâ€™s perspective, a thread is executing code in one AppDomain at a time. A thread can ask the CLR what AppDomain it is currently executing in by calling System.Threading. Threadâ€™s static GetDomain method. The thread could also query System.AppDomainâ€™s static, readonly CurrentDomain property to get the same information.</p></blockquote><blockquote><p>When an AppDomain is created, it can be assigned a friendly name. A friendly name is just a String that you can use to identify an AppDomain. This is typically useful in debugging scenarios. Because the CLR creates the default AppDomain before any of our code can run, the CLR uses the executable fileâ€™s file name as the default AppDomainâ€™s friendly name. My Marshalling method queries the default AppDomainâ€™s friendly name by using System.AppDomainâ€™s read-only FriendlyName property.</p></blockquote><blockquote><p>Next, my Marshalling method queries the strong-name identity of the assembly (loaded into the default AppDomain) that defines the entry point method Main that calls Marshalling. This assembly defines several types: Program, MarshalByRefType, MarshalBy ValType, and NonMarshalableType. At this point, weâ€™re ready to look at the three demos that are all pretty similar to each other.</p></blockquote><h3 id="demo-1-cross-appdomain-communication-using-marshal-by-reference"><a class="anchor" href="#demo-1-cross-appdomain-communication-using-marshal-by-reference">#</a> Demo #1: Cross-AppDomain Communication Using Marshal-by-Reference</h3><blockquote><p>In Demo #1, System.AppDomainâ€™s static CreateDomain method is called, instructing the CLR to create a new AppDomain in the same Windows process. The AppDomain type actually offers several overloads of the CreateDomain method; I encourage you to study them and select the version that is most appropriate when you are writing code to create a new AppDomain. The version of CreateDomain that I call accepts three arguments:</p><ul><li><p><strong>A String identifying the friendly name I want assigned to the new AppDomain</strong> Iâ€™m passing in â€œAD #2â€ here.</p></li><li><p><strong>A System.Security.Policy.Evidence identifying the evidence that the CLR should use to calculate the AppDomainâ€™s permission set</strong> Iâ€™m passing null here so that the new AppDomain will inherit the same permission set as the AppDomain creating it. Usually, if you want to create a security boundary around code in an AppDomain, youâ€™d construct a System. Security.PermissionSet object, add the desired permission objects to it (instances of types that implement the IPermission interface), and then pass the resulting PermissionSet object reference to the overloaded version of the CreateDomain method that accepts a PermissionSet.</p></li><li><p><strong>A System.AppDomainSetup identifying the configuration settings the CLR should use for the new AppDomain</strong> Again, Iâ€™m passing null here so that the new AppDomain will inherit the same configuration settings as the AppDomain creating it. If you want the AppDomain to have a special configuration, construct an AppDomainSetup object, set its various properties to whatever you want, such as the name of the configuration file, and then pass the resulting AppDomainSetup object reference to the CreateDomain method.</p></li></ul></blockquote><blockquote><p>Internally, the CreateDomain method creates a new AppDomain in the process. This AppDomain will be assigned the specified friendly name, security, and configuration settings. The new AppDomain will have its very own loader heap, which will be empty because there are currently no assemblies loading into the new AppDomain. When you create an AppDomain, the CLR does not create any threads in this AppDomain; no code runs in the AppDomain unless you explicitly have a thread call code in the AppDomain.</p></blockquote><blockquote><p>Now to create an instance of an object in the new AppDomain, we must first load an assembly into the new AppDomain and then construct an instance of a type defined in this assembly. This is precisely what the call to AppDomainâ€™s public, instance CreateInstanceAndUnwrap method does. When calling CreateInstanceAndUnwrap, I pass two arguments: a String identifying the assembly I want loaded into the new AppDomain (referenced by the ad2 variable) and another String identifying the name of the type that I want to construct an instance of. Internally, CreateInstanceAndUnwrap causes the calling thread to transition from the current AppDomain into the new AppDomain. Now, the thread (which is inside the call to CreateInstanceAndUnwrap) loads the specified assembly into the new AppDomain and then scans the assemblyâ€™s type definition metadata table, looking for the specified type (â€œMarshalByRefTypeâ€). After the type is found, the thread calls the MarshalByRefTypeâ€™s parameterless constructor. Now the thread transitions back to the default AppDomain so that CreateInstanceAndUnwrap can return a reference to the new MarshalByRefType object.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼š <code>CreateInstanceAndUnwrap</code> æ–¹æ³•çš„ä¸€äº›é‡è½½ç‰ˆæœ¬å…è®¸åœ¨è°ƒç”¨ç±»å‹çš„æ„é€ å™¨æ—¶ä¼ é€’å®å‚ã€‚</p><blockquote><p>Although this sounds all fine and good, there is a problem: the CLR cannot allow a variable (root) living in one AppDomain to reference an object created in another AppDomain. If CreateInstanceAndUnwrap simply returned the reference to the object, isolation would be broken, and isolation is the whole purpose of AppDomains! So, just before CreateInstanceAndUnwrap returns the object reference, it performs some additional logic.</p></blockquote><blockquote><p>Youâ€™ll notice that the MarshalByRefType type is derived from a very special base class: System. MarshalByRefObject. When CreateInstanceAndUnwrap sees that it is marshalling an object whose type is derived from MarshalByRefObject, the CLR will marshal the object by reference across the AppDomain boundaries. Here is what it means to marshal an object by reference from one AppDomain (the source AppDomain where the object is really created) to another AppDomain (the destination AppDomain from where CreateInstanceAndUnwrap is called).</p></blockquote><blockquote><p>When a source AppDomain wants to send or return the reference of an object to a destination AppDomain, the CLR defines a proxy type in the destination AppDomainâ€™s loader heap. This proxy type is defined using the original typeâ€™s metadata, and therefore, it looks exactly like the original type; it has all of the same instance members (properties, events, and methods). The instance fields are not part of the type, but Iâ€™ll talk more about this in a moment. This new type does have some instance fields defined inside of it, but these fields are not identical to that of the original data type. Instead, these fields indicate which AppDomain â€œownsâ€ the real object and how to find the real object in the owning AppDomain. (Internally, the proxy object uses a GCHandle instance that refers to the real object. The GCHandle type is discussed in Chapter 21, â€œThe Managed Heap and Garbage Collection.â€)</p></blockquote><blockquote><p>After this type is defined in the destination AppDomain, CreateInstanceAndUnwrap creates an instance of this proxy type, initializes its fields to identify the source AppDomain and the real object, and returns a reference to this proxy object to the destination AppDomain. In my Ch22-1-AppDomains application, the mbrt variable will be set to refer to this proxy. Notice that the object returned from CreateInstanceAndUnwrap is actually not an instance of the MarshalByRefType type. The CLR will usually not allow you to cast an object of one type to an incompatible type. However, in this situation, the CLR does allow the cast, because this new type has the same instance members as defined on the original type. In fact, if you use the proxy object to call GetType, it actually lies to you and says that it is a MarshalByRefType object.</p></blockquote><blockquote><p>However, it is possible to prove that the object returned from CreateInstanceAndUnwrap is actually a reference to a proxy object. To do this, my Ch22-1-AppDomains application calls System. Runtime.Remoting.RemotingServiceâ€™s public, static IsTransparentProxy method passing in the reference returned from CreateInstanceAndUnwrap. As you can see from the output, IsTransparentProxy returns true, indicating that the object is a proxy.</p></blockquote><blockquote><p>Now, my Ch22-1-AppDomains application uses the proxy to call the SomeMethod method. Because the mbrt variable refers to a proxy object, the proxyâ€™s implementation of this method is called. The proxyâ€™s implementation uses the information fields inside the proxy object to transition the calling thread from the default AppDomain to the new AppDomain. Any actions now performed by this thread run under the new AppDomainâ€™s security and configuration settings. Next, the thread uses the proxy objectâ€™s GCHandle field to find the real object in the new AppDomain, and then it uses the real object to call the real SomeMethod method.</p></blockquote><blockquote><p>There are two ways to prove that the calling thread has transitioned from the default AppDomain to the new AppDomain. First, inside the SomeMethod method, I call Thread.GetDomain().FriendlyName. This will return â€œAD #2â€ (as evidenced by the output) because the thread is now running in the new AppDomain created by using AppDomain.CreateDomain with â€œAD #2â€ as the friendly name parameter. Second, if you step through the code in a debugger and display the Call Stack window, the [AppDomain Transition] line marks where a thread has transitioned across an AppDomain boundary. See the Call Stack window near the bottom of Figure 22-2.</p></blockquote><p><img data-src="/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/image-20221130105852421.png" alt="image-20221130105852421"></p><p><strong>FIGURE 22-2</strong> The Debuggerâ€™s Call Stack window showing an AppDomain transition.</p><blockquote><p>When the real SomeMethod method returns, it returns to the proxyâ€™s SomeMethod method, which transitions the thread back to the default AppDomain, and then the thread continues executing code in the default AppDomain.</p></blockquote><p>ğŸ’¡æ³¨æ„ ä¸€ä¸ª AppDomain ä¸­çš„çº¿ç¨‹è°ƒç”¨å¦ä¸€ä¸ª AppDomain ä¸­çš„æ–¹æ³•æ—¶ï¼Œçº¿ç¨‹ä¼šåœ¨è¿™ä¸¤ä¸ª AppDomain ä¹‹é—´åˆ‡æ¢ã€‚è¿™æ„å‘³ç€è·¨ AppDomain è¾¹ç•Œçš„æ–¹æ³•è°ƒç”¨æ˜¯åŒæ­¥æ‰§è¡Œçš„ã€‚ä»»ä½•æ—¶åˆ»ä¸€ä¸ªçº¿ç¨‹åªèƒ½åœ¨ä¸€ä¸ª AppDomain ä¸­ï¼Œè€Œä¸”è¦ç”¨é‚£ä¸ª AppDomain çš„å®‰å…¨å’Œé…ç½®è®¾ç½®æ¥æ‰§è¡Œä»£ç ã€‚å¦‚æœå¸Œæœ›å¤šä¸ª AppDomain ä¸­çš„ä»£ç å¹¶å‘æ‰§è¡Œï¼Œåº”åˆ›å»ºé¢å¤–çš„çº¿ç¨‹ï¼Œè®©è¿™äº›çº¿ç¨‹åœ¨ä½ å¸Œæœ›çš„ AppDomain ä¸­æ‰§è¡Œä½ å¸Œæœ›çš„ä»£ç ã€‚</p><blockquote><p>The next thing that my Ch22-1-AppDomains application does is call AppDomainâ€™s public, static Unload method to force the CLR to unload the specified AppDomain, including all of the assemblies loaded into it. A garbage collection is forced to free up any objects that were created by code in the unloading AppDomain. At this point, the default AppDomainâ€™s mbrt variable still refers to a valid proxy object; however, the proxy object no longer refers to a valid AppDomain (because it has been unloaded).</p></blockquote><blockquote><p>When the default AppDomain attempts to use the proxy object to call the SomeMethod method, the proxyâ€™s implementation of this method is called. The proxyâ€™s implementation determines that the AppDomain that contained the real object has been unloaded, and the proxyâ€™s SomeMethod method throws an AppDomainUnloadedException to let the caller know that the operation cannot complete.</p></blockquote><blockquote><p>Wow! The CLR team at Microsoft had to do a lot of work to ensure AppDomain isolation, but it is important work because these features are used heavily and are being used more and more by developers every day. Obviously, accessing objects across AppDomain boundaries by using marshalby-reference semantics has some performance costs associated with it, so you typically want to keep the use of this feature to a minimum.</p></blockquote><blockquote><p>I promised you that Iâ€™d talk a little more about instance fields. A type derived from MarshalByRefObject can define instance fields. However, these instance fields are not defined as being part of the proxy type and are not contained inside a proxy object. When you write code that reads from or writes to an instance field of a type derived from MarshalByRefObject, the JIT compiler emits code that uses the proxy object (to find the real AppDomain/object) by calling System.Objectâ€™s FieldGetter or FieldSetter methods, respectively. These methods are private and undocumented; they are basically methods that use reflection to get and set the value in a field. So although you can access fields of a type derived from MarshalByRefObject, the performance is particularly bad because the CLR really ends up calling methods to perform the field access. In fact, the performance is bad even if the object that you are accessing is in your own AppDomain.</p></blockquote><p><strong>è®¿é—®å®ä¾‹å­—æ®µæ—¶çš„æ€§èƒ½é—®é¢˜</strong></p><p>æˆ‘ç”¨ä»¥ä¸‹ä»£ç æ¼”ç¤ºæ€§èƒ½æŸå¤±çš„ç¨‹åº¦ï¼š</p><pre><code class="language-C#">private sealed class NonMBRO : Object &#123; public Int32 x; &#125;
private sealed class MBRO    : Object &#123; public Int32 x; &#125;

private static void FieldAccessTiming() &#123;
    const Int32 count = 100000000;
    NonMBRO nonMbro = new NonMBRO();
    MBRO mbro = new MBRO();

    Stopwatch sw = Stopwatch.StartNew();
    for (Int32 c = 0; c &lt; count; c++ ) nonMbro.x++;
    Console.WriteLine(&quot;&#123;0&#125;&quot;, sw.Elapsed);       // 00:00:00.4073560

    sw = Stopwatch.StartNew();
    for (Int32 c = 0; c &lt; count; c++) mbro.x++;
    Console.WriteLine(&quot;&#123;0&#125;&quot;, sw.Elapsed);       // 00:00:02.5388665 
&#125;
</code></pre><p>æˆ‘è¿è¡Œä»¥ä¸Šä»£ç ï¼Œè®¿é—®ä» <code>Object</code> æ´¾ç”Ÿçš„ <code>NonMBRO</code> ç±»çš„å®ä¾‹å­—æ®µåªèŠ±äº†çº¦ 0.4 ç§’ï¼Œä½†è®¿é—®ä» <code>MarshalByRefObject</code> æ´¾ç”Ÿçš„ <code>MBRO</code> ç±»çš„å®ä¾‹å­—æ®µå´èŠ±äº† 2.54 ç§’ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œè®¿é—®ä» <code>MarshalByRefObject</code> æ´¾ç”Ÿçš„ä¸€ä¸ªç±»çš„å®ä¾‹å­—æ®µè¦å¤šèŠ±çº¦ 6 å€çš„æ—¶é—´ï¼</p><blockquote><p>From a usability standpoint, a type derived from MarshalByRefObject should really avoid defining any static members. The reason is that static members are always accessed in the context of the calling AppDomain. No AppDomain transition can occur because a proxy object contains the information identifying which AppDomain to transition to, but there is no proxy object when calling a static member. Having a typeâ€™s static members execute in one AppDomain while instance members execute in another AppDomain would make a very awkward programming model.</p></blockquote><blockquote><p>Because there are no roots in the second AppDomain, the original object referred to by the proxy could be garbage collected. Of course, this is not ideal. On the other hand, if the original object is held in memory indefinitely, then the proxy could go away and the original object would still live; this is also not ideal. The CLR solves this problem by using a lease manager. When a proxy for an object is created, the CLR keeps the object alive for five minutes. If no calls have been made through the proxy after five minutes, then the object is deactivated and will have its memory freed at the next garbage collection. After each call into the object, the lease manager renews the objectâ€™s lease so that it is guaranteed to remain in memory for another two minutes before being deactivated. If an application attempts to call into an object through a proxy after the objectâ€™s lease has expired, the CLR throws a System.Runtime.Remoting.RemotingException.</p></blockquote><blockquote><p>It is possible to override the default lease times of five minutes and two minutes by overriding MarshalByRefObjectâ€™s virtual InitializeLifetimeServices method. For more information, see the section titled â€œLifetime Leasesâ€ in the .NET Framework SDK documentation.</p></blockquote><h3 id="demo-2-cross-appdomain-communication-using-marshal-by-value"><a class="anchor" href="#demo-2-cross-appdomain-communication-using-marshal-by-value">#</a> Demo #2: Cross-AppDomain Communication Using Marshal-by-Value</h3><blockquote><p>Demo #2 is very similar to Demo #1. Again, another AppDomain is created exactly as Demo #1 did it. Then, CreateInstanceAndUnwrap is called to load the same assembly into the new AppDomain and create an instance of a MarshalByRefType object in this new AppDomain. Next, the CLR creates a proxy to the object and the mbrt variable (in the default AppDomain) is initialized referring to the proxy. Now, using the proxy, I call MethodWithReturn. This method, which takes no arguments, will execute in the new AppDomain to create an instance of the MarshalByValType type before returning a reference to the object to the default AppDomain.</p></blockquote><blockquote><p>MarshalByValType is not derived from System.MarshalByRefObject, and therefore, the CLR cannot define a proxy type to create an instance from; the object canâ€™t be marshaled by reference across the AppDomain boundary.</p></blockquote><blockquote><p>However, because MarshalByValType is marked with the [Serializable] custom attribute, MethodWithReturn is allowed to marshal the object by value. The next paragraph describes what it means to marshal an object by value from one AppDomain (the source AppDomain) to another AppDomain (the destination AppDomain). For more information about the CLR's serialization and deserialization mechanisms, see Chapter 24, &quot;Runtime Serialization.â€</p></blockquote><blockquote><p>When a source AppDomain wants to send or return a reference to an object to a destination AppDomain, the CLR serializes the objectâ€™s instance fields into a byte array. This byte array is copied from the source AppDomain to the destination AppDomain. Then, the CLR deserializes the byte array in the destination AppDomain. This forces the CLR to load the assembly that defines the type being deserialized into the destination AppDomain if it is not already loaded. Then, the CLR creates an instance of the type and uses the values in the byte array to initialize the objectâ€™s fields so that they have values identical to those they had in the original object. In other words, the CLR makes an exact duplicate of the source object in the destinationâ€™s AppDomain MethodWithReturn, and then returns a reference to this copy; the object has been marshaled by value across the AppDomainâ€™s boundary.</p></blockquote><p>ğŸ’¡é‡è¦æç¤ºï¼šåŠ è½½ç¨‹åºé›†æ—¶ï¼ŒCLR ä½¿ç”¨ç›®æ ‡ AppDomain çš„ç­–ç•¥å’Œé…ç½®è®¾ç½® (è€Œ AppDomain å¯èƒ½è®¾ç½®äº†ä¸åŒçš„ AppBase ç›®å½•æˆ–è€…ä¸åŒçš„ç‰ˆæœ¬ç»‘å®šé‡å®šå‘)ã€‚ç­–ç•¥ä¸Šçš„å·®å¼‚å¯èƒ½å¦¨ç¢ CLR å®šä½ç¨‹ç¨‹åºé›†ã€‚ç¨‹åºé›†æ— æ³•åŠ è½½æ—¶ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œç›®æ ‡ AppDomain æ¥æ”¶ä¸åˆ°å¯¹è±¡å¼•ç”¨ã€‚</p><blockquote><p>At this point, the object in the source AppDomain and the object in the destination AppDomain live separate lifetimes, and their states can change independently of each other. If there are no roots in the source AppDomain keeping the original object alive (as in my Ch22-1-AppDomains application), its memory will be reclaimed at the next garbage collection.</p></blockquote><blockquote><p>To prove that the object returned from MethodWithReturn is not a reference to a proxy object, my Ch22-1-AppDomains application calls System.Runtime.Remoting.RemotingServiceâ€™s public, static IsTransparentProxy method passing in the reference returned from MethodWithReturn. As you can see from the output, IsTransparentProxy returns false, indicating that the object is a real object, not a proxy.</p></blockquote><blockquote><p>Now, my program uses the real object to call the ToString method. Because the mbvt variable refers to a real object, the real implementation of this method is called, and no AppDomain transition occurs. This can be evidenced by examining the debuggerâ€™s Call Stack window, which will not show an [Appdomain Transition] line.</p></blockquote><blockquote><p>To further prove that no proxy is involved, my Ch22-1-AppDomains application unloads the new AppDomain and then attempts to call the ToString method again. Unlike in Demo #1, the call succeeds this time because unloading the new AppDomain had no impact on objects â€œownedâ€ by the default AppDomain, and this includes the object that was marshaled by value.</p></blockquote><h3 id="demo-3-cross-appdomain-communication-using-non-marshalable-types"><a class="anchor" href="#demo-3-cross-appdomain-communication-using-non-marshalable-types">#</a> Demo #3: Cross-AppDomain Communication Using Non-Marshalable Types</h3><blockquote><p>Demo #3 starts out very similar to Demos #1 and #2. Just as in Demos #1 and #2, an AppDomain is created. Then, CreateInstanceAndUnwrap is called to load the same assembly into the new AppDomain, create a MarshalByRefType object in this new AppDomain, and have the mbrt variable refer to a proxy to this object.</p></blockquote><blockquote><p>Then, using this proxy, I call MethodArgAndReturn, which accepts an argument. Again, the CLR must maintain AppDomain isolation, so it cannot simply pass the reference to the argument into the new AppDomain. If the type of the object is derived from MarshalByRefObject, the CLR will make a proxy for it and marshal it by reference. If the objectâ€™s type is marked as [Serializable], the CLR will serialize the object (and its children) to a byte array, marshal the byte array into the new AppDomain, and then deserialize the byte array into an object graph, passing the root of the object graph into the MethodArgAndReturn method.</p></blockquote><blockquote><p>In this particular demo, I am passing a System.String object across AppDomain boundaries. The System.String type is not derived from MarshalByRefObject, so the CLR cannot create a proxy. Fortunately, System.String is marked as [Serializable], and therefore the CLR can marshal it by value, which allows the code to work. Note that for String objects, the CLR performs a special optimization. When marshaling a String object across an AppDomain boundary, the CLR just passes the reference to the String object across the boundary; it does not make a copy of the String object. The CLR can offer this optimization because String objects are immutable; therefore, it is impossible for code in one AppDomain to corrupt a String objectâ€™s characters.4 For more about String immutability, see Chapter 14, â€œChars, Strings, and Working with Text.â€</p></blockquote><blockquote><p>Inside MethodArgAndReturn, I display the string passed into it to show that the string came across the AppDomain boundary, and then I create an instance of the NonMarshalableType type and return a reference to this object to the default AppDomain. Because NonMarshalableType is not derived from System.MarshalByRefObject and is also not marked with the [Serializable] custom attribute, MethodArgAndReturn is not allowed to marshal the object by reference or by valueâ€”the object cannot be marshaled across an AppDomain boundary at all! To report this, MethodArgAndReturn throws a SerializationException in the default AppDomain. Because my program doesnâ€™t catch this exception, the program just dies.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šCLR COM æœåŠ¡å™¨åˆå§‹åŒ–æ—¶ä¼šåˆ›å»ºä¸€ä¸ª AppDomainã€‚AppDomain æ˜¯ä¸€ç»„ç¨‹åºé›†çš„é€»è¾‘å®¹å™¨ã€‚CLR åˆå§‹åŒ–æ—¶åˆ›å»ºçš„ç¬¬ä¸€ä¸ª AppDomain ç§°ä¸º â€œé»˜è®¤ AppDomainâ€ï¼Œè¿™ä¸ªé»˜è®¤çš„ AppDomain åªæœ‰åœ¨ Windows è¿›ç¨‹ç»ˆæ­¢æ—¶æ‰ä¼šè¢«é”€æ¯ã€‚é™¤äº†é»˜è®¤ AppDomainï¼Œæ­£åœ¨ä½¿ç”¨éæ‰˜ç®¡ COM æ¥å£æ–¹æ³•æˆ–æ‰˜ç®¡ç±»å‹æ–¹æ³•çš„å®¿ä¸»è¿˜å¯è¦æ±‚ CLR åˆ›å»ºé¢å¤–çš„ AppDomainã€‚AppDomain æ˜¯ä¸ºäº†æä¾›éš”ç¦»è€Œè®¾è®¡çš„ã€‚ä¸€ä¸ª AppDomain ä¸­çš„ä»£ç åˆ›å»ºäº†ä¸€ä¸ªå¯¹è±¡åï¼Œè¯¥å¯¹è±¡ä¾¿è¢«è¯¥ AppDomain â€œæ‹¥æœ‰â€ï¼Œæ¢è¨€ä¹‹ï¼Œå®ƒçš„ç”Ÿå­˜æœŸä¸èƒ½è¶…è¿‡åˆ›å»ºå®ƒçš„ä»£ç æ‰€åœ¨çš„ AppDomainã€‚ä¸€ä¸ª AppDomain ä¸­çš„ä»£ç è¦è®¿é—®å¦ä¸€ä¸ª AppDomain ä¸­çš„å¯¹è±¡ï¼Œåªèƒ½ä½¿ç”¨ â€œæŒ‰å¼•ç”¨å°é€â€ï¼ˆmarshal-by-referenceï¼‰æˆ–è€… â€œæŒ‰å€¼å°é€â€ï¼ˆmarshal-by-valueï¼‰çš„è¯­ä¹‰ã€‚è¿™å°±å¼ºåˆ¶å»ºç«‹äº†æ¸…æ™°çš„åˆ†éš”å’Œè¾¹ç•Œï¼Œå› ä¸ºä¸€ä¸ª AppDomain ä¸­çš„ä»£ç ä¸èƒ½ç›´æ¥å¼•ç”¨å¦ä¸€ä¸ª AppDomain ä¸­çš„ä»£ç åˆ›å»ºçš„å¯¹è±¡ã€‚CLR ä¸æ”¯æŒä» AppDomain ä¸­å¸è½½ç‰¹å®šçš„ç¨‹åºé›†ã€‚ä½†å¯ä»¥å‘Šè¯‰ CLR å¸è½½ä¸€ä¸ª AppDomainï¼Œä»è€Œå¸è½½è¯¥ AppDomain å½“å‰åŒ…å«çš„æ‰€æœ‰ç¨‹åºé›†ã€‚AppDomain åˆ›å»ºåä¼šåº”ç”¨ä¸€ä¸ªæƒé™é›†ï¼Œå®ƒå†³å®šäº†å‘è¿™ä¸ª AppDomain ä¸­è¿è¡Œçš„ç¨‹åºé›†æˆäºˆçš„æœ€å¤§æƒé™ã€‚æ­£æ˜¯ç”±äºå­˜åœ¨è¿™äº›æƒé™ï¼Œæ‰€ä»¥å½“å®¿ä¸»åŠ è½½ä¸€äº›ä»£ç åï¼Œå¯ä»¥ä¿è¯è¿™äº›ä»£ç ä¸ä¼šç ´åï¼ˆæˆ–è¯»å–ï¼‰å®¿ä¸»æœ¬èº«ä½¿ç”¨çš„ä¸€äº›é‡è¦æ•°æ®ç»“æ„ã€‚AppDomain åˆ›å»ºåä¼šå…³è”ä¸€ç»„é…ç½®è®¾ç½®ã€‚è¿™äº›è®¾ç½®ä¸»è¦å½±å“ CLR åœ¨ AppDomain ä¸­åŠ è½½ç¨‹åºé›†çš„æ–¹å¼ã€‚æ¯ä¸ª AppDomain éƒ½æœ‰è‡ªå·±çš„ Loader å †ï¼Œæ¯ä¸ª Loader å †éƒ½è®°å½•äº†è‡ª AppDomain åˆ›å»ºä»¥æ¥å·²è®¿é—®è¿‡å“ªäº›ç±»å‹ã€‚è¿™äº›ç±»å‹å¯¹è±¡å·²åœ¨ç¬¬ 4 ç« è®¨è®ºè¿‡ï¼ŒLoader å †ä¸­çš„æ¯ä¸ªç±»å‹å¯¹è±¡éƒ½æœ‰ä¸€ä¸ªæ–¹æ³•è¡¨ï¼Œæ–¹æ³•è¡¨ä¸­çš„æ¯ä¸ªè®°å½•é¡¹éƒ½æŒ‡å‘ JIT ç¼–è¯‘çš„æœ¬æœºä»£ç ï¼ˆå‰ææ˜¯æ–¹æ³•è‡³å°‘æ‰§è¡Œè¿‡ä¸€æ¬¡ï¼‰ã€‚å¦‚æœä¸¤ä¸ª AppDomain éƒ½ä½¿ç”¨äº†åŒä¸€ä¸ªç¨‹åºé›†çš„ä¸€ä¸ªç±»å‹ï¼Œé‚£ä¹ˆä¸¤ä¸ª AppDomain çš„ Loader å †ä¼šä¸ºç›¸åŒçš„ç±»å‹åˆ†åˆ«åˆ†é…ä¸€ä¸ªç±»å‹å¯¹è±¡ï¼›ç±»å‹å¯¹è±¡çš„å†…å­˜ä¸ä¼šç”±ä¸¤ä¸ª AppDomain å…±äº«ã€‚å¦å¤–ï¼Œä¸€ä¸ª AppDomain ä¸­çš„ä»£ç è°ƒç”¨ä¸€ä¸ªç±»å‹å®šä¹‰çš„æ–¹æ³•æ—¶ï¼Œæ–¹æ³•çš„ IL ä»£ç ä¼šè¿›è¡Œ JIT ç¼–è¯‘ï¼Œç”Ÿæˆçš„æœ¬æœºä»£ç å•ç‹¬ä¸æ¯ä¸ª AppDomain å…³è”ï¼Œè€Œä¸æ˜¯ç”±è°ƒç”¨å®ƒçš„æ‰€æœ‰ AppDomain å…±äº«ã€‚ä¸å…±äº«ç±»å‹å¯¹è±¡çš„å†…å­˜æˆ–æœ¬æœºä»£ç æ˜¾å¾—æœ‰äº›æµªè´¹ã€‚ä½† AppDomain çš„è®¾è®¡å®—æ—¨å°±æ˜¯æä¾›éš”ç¦»ï¼›CLR è¦æ±‚åœ¨å¸è½½æŸä¸ª AppDomain å¹¶é‡Šæ”¾å…¶æ‰€æœ‰èµ„æºæ—¶ä¸ä¼šå½±å“åˆ°å…¶ä»–ä»»ä½• AppDomainã€‚CLR åˆå§‹åŒ–æ—¶ï¼ŒMSCorLib.dll ç¨‹åºé›†ä¼šè‡ªåŠ¨åŠ è½½ï¼Œè€Œä¸”æ‰€æœ‰ AppDomain éƒ½å…±äº«è¯¥ç¨‹åºé›†ä¸­çš„ç±»å‹ã€‚ä¸ºäº†å‡å°‘èµ„æºæ¶ˆè€—ï¼ŒMSCorLib.dll ç¨‹åºé›†ä»¥ä¸€ç§ â€œAppDomain ä¸­ç«‹â€ çš„æ–¹å¼åŠ è½½ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œé’ˆå¯¹ä»¥ â€œAppDomain ä¸­ç«‹â€ çš„æ–¹å¼åŠ è½½çš„ç¨‹åºé›†ï¼ŒCLR ä¼šä¸ºå®ƒä»¬ç»´æŠ¤ä¸€ä¸ªç‰¹æ®Šçš„ Loader å †ã€‚è¯¥ Loader å †ä¸­çš„æ‰€æœ‰ç±»å‹å¯¹è±¡ï¼Œä»¥åŠä¸ºè¿™äº›ç±»å‹å®šä¹‰çš„æ–¹æ³• JIT ç¼–è¯‘å™¨ç”Ÿæˆçš„æ‰€æœ‰æœ¬æœºä»£ç ï¼Œéƒ½ä¼šç”±è¿›ç¨‹ä¸­çš„æ‰€æœ‰ AppDomain å…±äº«ã€‚ä»¥ â€œAppDomain ä¸­ç«‹â€ çš„æ–¹å¼åŠ è½½çš„æ‰€æœ‰ç¨‹åºé›†æ°¸è¿œä¸èƒ½å¸è½½ã€‚è¦å›æ”¶å®ƒä»¬å ç”¨çš„èµ„æºï¼Œå”¯ä¸€çš„åŠæ³•å°±æ˜¯ç»ˆæ­¢ Windows è¿›ç¨‹ï¼Œè®© Windows å»å›æ”¶èµ„æºã€‚åœ¨ Windows ä¸­ï¼Œçº¿ç¨‹æ€»æ˜¯åœ¨ä¸€ä¸ªè¿›ç¨‹ä¸­çš„ä¸Šä¸‹æ–‡ä¸­åˆ›å»ºï¼Œè€Œä¸”çº¿ç¨‹çš„æ•´ä¸ªç”Ÿå­˜æœŸéƒ½åœ¨è¯¥è¿›ç¨‹çš„ç”Ÿå­˜æœŸå†…ã€‚ä½†çº¿ç¨‹å’Œ AppDomain æ²¡æœ‰ä¸€å¯¹ä¸€å…³ç³»ã€‚AppDomain æ˜¯ä¸€é¡¹ CLR åŠŸèƒ½ï¼›Windows å¯¹ AppDomain ä¸€æ— æ‰€çŸ¥ã€‚ç”±äºä¸€ä¸ª Windows è¿›ç¨‹å¯åŒ…å«å¤šä¸ª AppDomainï¼Œæ‰€ä»¥çº¿ç¨‹èƒ½æ‰§è¡Œä¸€ä¸ª AppDomain ä¸­çš„ä»£ç ï¼Œå†æ‰§è¡Œå¦ä¸€ä¸ª AppDomain ä¸­çš„ä»£ç ã€‚ä» CLR çš„è§’åº¦çœ‹ï¼Œçº¿ç¨‹ä¸€æ¬¡åªèƒ½æ‰§è¡Œä¸€ä¸ª AppDomain ä¸­çš„ä»£ç ã€‚AppDomain åˆ›å»ºåå¯è¢«èµ‹äºˆä¸€ä¸ªå‹å¥½åç§°ã€‚å®ƒæ˜¯ç”¨äºæ ‡è¯† AppDomain çš„ä¸€ä¸ª Stringã€‚å‹å¥½åç§°ä¸»è¦æ˜¯ä¸ºäº†æ–¹ä¾¿è°ƒè¯•ã€‚ <code>CreateDomain</code> æ–¹æ³•å†…éƒ¨ä¼šåœ¨è¿›ç¨‹ä¸­åˆ›å»ºä¸€ä¸ª AppDomainï¼Œè¯¥ AppDomain å°†è¢«èµ‹äºˆæŒ‡å®šçš„å‹å¥½åç§°ã€å®‰å…¨æ€§å’Œé…ç½®è®¾ç½®ã€‚åˆ›å»º AppDomain æ—¶ï¼ŒCLR ä¸åœ¨è¿™ä¸ª AppDomain ä¸­åˆ›å»ºä»»ä½•çº¿ç¨‹ï¼›AppDomain ä¸­ä¹Ÿä¸ä¼šè¿è¡Œä»£ç ï¼Œé™¤éæ˜¾å¼åœ°è®©ä¸€ä¸ªçº¿ç¨‹è°ƒç”¨ AppDomain ä¸­çš„ä»£ç ã€‚CLR ä¸å…è®¸ä¸€ä¸ª AppDomain ä¸­çš„å˜é‡ï¼ˆæ ¹ï¼‰å¼•ç”¨å¦ä¸€ä¸ª AppDomain ä¸­åˆ›å»ºçš„å¯¹è±¡ã€‚å¯ä»¥ä½¿ç”¨ä¸¤ç§æ–¹å¼è¿›è¡Œè·¨ AppDomain è¿›è¡Œé€šä¿¡ï¼Œä¸€ç§æ˜¯ä½¿ç”¨ â€œæŒ‰å¼•ç”¨å°é€â€ï¼Œå¦ä¸€ç§æ˜¯ä½¿ç”¨ â€œæŒ‰å€¼å°é€â€ã€‚å½“ <code>CreateInstanceAndUnwrap</code> å‘ç°å®ƒå°é€çš„ä¸€ä¸ªå¯¹è±¡çš„ç±»å‹æ´¾ç”Ÿè‡ª <code>MarshalByRefObject</code> æ—¶ï¼ŒCLR å°±ä¼šè·¨ AppDomain è¾¹ç•ŒæŒ‰å¼•ç”¨å°é€å¯¹è±¡ã€‚æº AppDomain æƒ³å‘ç›®æ ‡ AppDomain å‘é€æˆ–è¿”å›å¯¹è±¡å¼•ç”¨æ—¶ï¼ŒCLR ä¼šåœ¨ç›®æ ‡ AppDomain çš„ Loader å †ä¸­å®šä¹‰ä¸€ä¸ªä»£ç†ç±»å‹ã€‚ä»£ç†ç±»å‹æ˜¯ç”¨åŸå§‹ç±»å‹å®Œå…¨ä¸€æ ·ï¼›æœ‰å®Œå…¨ä¸€æ ·çš„å®ä¾‹æˆå‘˜ (å±æ€§ã€äº‹ä»¶å’Œæ–¹æ³•)ã€‚ä½†æ˜¯ï¼Œå®ä¾‹å­—æ®µä¸ä¼šæˆä¸º (ä»£ç†) ç±»å‹çš„ä¸€éƒ¨åˆ†ï¼Œæˆ‘ç¨åä¼šå…·ä½“è§£é‡Šè¿™ä¸€ç‚¹ã€‚ä»£ç†ç±»å‹ç¡®å®å®šä¹‰äº†å‡ ä¸ª (è‡ªå·±çš„) å®ä¾‹å­—æ®µï¼Œä½†è¿™äº›å­—æ®µå’ŒåŸå§‹ç±»å‹çš„ä¸ä¸€è‡´ã€‚ç›¸åï¼Œè¿™äº›å­—æ®µåªæ˜¯æŒ‡å‡ºå“ªä¸ª AppDomain â€œæ‹¥æœ‰â€ çœŸå®çš„å¯¹è±¡ï¼Œä»¥åŠå¦‚ä½•åœ¨æ‹¥æœ‰ (å¯¹è±¡çš„) AppDomain ä¸­æ‰¾åˆ°çœŸå®çš„å¯¹è±¡ (åœ¨å†…éƒ¨ï¼Œä»£ç†å¯¹è±¡ç”¨ä¸€ä¸ª <code>GCHandle</code> å®ä¾‹å¼•ç”¨çœŸå®çš„å¯¹è±¡)ã€‚åœ¨ç›®æ ‡ AppDomain ä¸­å®šä¹‰å¥½è¿™ä¸ªä»£ç†ç±»å‹ä¹‹åï¼Œ <code>CreateInstanceAndUnwrap</code> æ–¹æ³•å°±ä¼šåˆ›å»ºä»£ç†ç±»å‹çš„å®ä¾‹ï¼Œåˆå§‹åŒ–å®ƒçš„å­—æ®µæ¥æ ‡è¯†æº AppDomain å’ŒçœŸå®å¯¹è±¡ï¼Œç„¶åå°†å¯¹è¿™ä¸ªä»£ç†å¯¹è±¡çš„å¼•ç”¨è¿”å›ç»™ç›®æ ‡ AppDomainã€‚ä» <code>MarshalByRefObject</code> æ´¾ç”Ÿçš„ç±»å‹å¯å®šä¹‰å®ä¾‹å­—æ®µã€‚ä½†è¿™äº›å®ä¾‹å­—æ®µä¸ä¼šæˆä¸ºä»£ç†ç±»å‹çš„ä¸€éƒ¨åˆ†ï¼Œä¹Ÿä¸ä¼šåŒ…å«åœ¨ä»£ç†å¯¹è±¡ä¸­ã€‚å†™ä»£ç å¯¹æ´¾ç”Ÿè‡ª <code>MarshalByRefObject</code> çš„ç±»å‹çš„å®ä¾‹å­—æ®µè¿›è¡Œè¯»å†™æ—¶ï¼ŒJIT ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨ç”Ÿæˆä»£ç ï¼Œåˆ†åˆ«è°ƒç”¨ <code>System.Object</code> çš„ <code>FieldGetter</code> æ–¹æ³• (ç”¨äºè¯») æˆ– <code>FieldSetter</code> æ–¹æ³• (ç”¨äºå†™) æ¥ä½¿ç”¨ä»£ç†å¯¹è±¡ (ä»¥æ‰¾åˆ°çœŸæ­£çš„ AppDomain / å¯¹è±¡)ã€‚è¿™äº›æ–¹æ³•æ˜¯ç§æœ‰çš„ï¼Œè€Œä¸”æ²¡æœ‰åœ¨æ–‡æ¡£ä¸­è®°å½•ã€‚ç®€å•åœ°è¯´ï¼Œè¿™äº›æ–¹æ³•åˆ©ç”¨åå°„æœºåˆ¶è·å–æˆ–è®¾ç½®å­—æ®µå€¼ã€‚å› æ­¤ï¼Œè™½ç„¶èƒ½è®¿é—®æ´¾ç”Ÿè‡ª <code>MarshalByRefObject</code> çš„ä¸€ä¸ªç±»å‹ä¸­çš„å­—æ®µï¼Œä½†æ€§èƒ½å¾ˆå·®ï¼Œå› ä¸º CLR æœ€ç»ˆè¦è°ƒç”¨æ–¹æ³•æ¥æ‰§è¡Œå­—æ®µè®¿é—®ã€‚äº‹å®ä¸Šï¼Œå³ä½¿è¦è®¿é—®çš„å­—æ®µåœ¨ä½ è‡ªå·±çš„ AppDomain ä¸­ï¼Œæ€§èƒ½ä¹Ÿå¥½ä¸åˆ°å“ªé‡Œå»ã€‚ä»å¥½ä¸å¥½ç”¨ (usability) çš„è§’åº¦è¯´ï¼Œæ´¾ç”Ÿè‡ª <code>MarshalByRefObject</code> çš„ç±»å‹çœŸçš„åº”è¯¥é¿å…å®šä¹‰ä»»ä½•é™æ€æˆå‘˜ã€‚è¿™æ˜¯å› ä¸ºé™æ€æˆå‘˜æ€»æ˜¯åœ¨è°ƒç”¨ AppDomain çš„ä¸Šä¸‹æ–‡ä¸­è®¿é—®ã€‚è¦åˆ‡æ¢åˆ°å“ªä¸ª AppDomain çš„ä¿¡æ¯åŒ…å«åœ¨ä»£ç†å¯¹è±¡ä¸­ï¼Œä½†è°ƒç”¨é™æ€æˆå‘˜æ—¶æ²¡æœ‰ä»£ç†å¯¹è±¡ï¼Œæ‰€ä»¥ä¸ä¼šå‘ç”Ÿ AppDomain çš„åˆ‡æ¢ã€‚ç”±äºç¬¬äºŒä¸ª AppDomain ä¸­æ²¡æœ‰æ ¹ï¼Œæ‰€ä»¥ä»£ç†å¼•ç”¨çš„åŸå§‹å¯¹è±¡å¯ä»¥è¢«åƒåœ¾å›æ”¶ã€‚è¿™å½“ç„¶ä¸ç†æƒ³ã€‚ä½†å¦ä¸€æ–¹é¢ï¼Œå‡å¦‚å°†åŸå§‹å¯¹è±¡ä¸ç¡®å®šåœ° (indefinitely) ç•™åœ¨å†…å­˜ä¸­ï¼Œä»£ç†å¯èƒ½ä¸å†å¼•ç”¨å®ƒï¼Œè€ŒåŸå§‹å¯¹è±¡ä¾ç„¶å­˜æ´»ï¼›è¿™åŒæ ·ä¸ç†æƒ³ã€‚CLR è§£å†³è¿™ä¸ªé—®é¢˜çš„åŠæ³•æ˜¯ä½¿ç”¨ä¸€ä¸ª â€œç§Ÿçº¦ç®¡ç†å™¨â€(lease manager)ã€‚ä¸€ä¸ªå¯¹è±¡çš„ä»£ç†åˆ›å»ºå¥½ä¹‹åï¼ŒCLR ä¿æŒå¯¹è±¡å­˜æ´» 5 åˆ†é’Ÿã€‚5 åˆ†é’Ÿå†…æ²¡æœ‰é€šè¿‡ä»£ç†å‘å‡ºè°ƒç”¨ï¼Œå¯¹è±¡å°±ä¼šå¤±æ•ˆï¼Œä¸‹æ¬¡åƒåœ¾å›æ”¶ä¼šé‡Šæ”¾å®ƒçš„å†…å­˜ã€‚æ¯å‘å‡ºä¸€æ¬¡å¯¹å¯¹è±¡çš„è°ƒç”¨ï¼Œâ€œç§Ÿçº¦ç®¡ç†å™¨â€ éƒ½ä¼šç»­è®¢å¯¹è±¡çš„ç§ŸæœŸï¼Œä¿è¯å®ƒåœ¨æ¥ä¸‹æ¥çš„ 2 åˆ†é’Ÿå†…åœ¨å†…å­˜ä¸­ä¿æŒå­˜æ´»ã€‚åœ¨å¯¹è±¡è¿‡æœŸåè¯•å›¾é€šè¿‡ä»£ç†è°ƒç”¨å®ƒï¼ŒCLR ä¼šæŠ›å‡º <code>System.Runtime.Remoting.RemotingException</code> å¼‚å¸¸ã€‚é»˜è®¤çš„ 5 åˆ†é’Ÿå’Œ 2 åˆ†é’Ÿç§ŸæœŸè®¾å®šæ˜¯å¯ä»¥ä¿®æ”¹çš„ï¼Œé‡å†™ <code>MarshalByRefObject</code> çš„è™šæ–¹æ³• <code>InitializeLifetimeService</code> å³å¯ã€‚å¯¹äºæ ‡è®°äº†è‡ªå®šä¹‰ç‰¹æ€§ [Serializable] çš„å¯¹è±¡èƒ½æŒ‰å€¼è¿›è¡Œå°é€ã€‚æº AppDomain æƒ³å‘ç›®æ ‡ AppDomain å‘é€æˆ–è¿”å›ä¸€ä¸ªå¯¹è±¡å¼•ç”¨æ—¶ï¼ŒCLR å°†å¯¹è±¡çš„å®ä¾‹å­—æ®µåºåˆ—åŒ–æˆä¸€ä¸ªå­—èŠ‚æ•°ç»„ã€‚å­—èŠ‚æ•°ç»„ä»æº AppDomain å¤åˆ¶åˆ°ç›®æ ‡ AppDomainã€‚ç„¶åï¼ŒCLR åœ¨ç›®æ ‡ AppDomain ä¸­ååºåˆ—åŒ–å­—èŠ‚æ•°ç»„ï¼Œè¿™ä¼šå¼ºåˆ¶ CLR å°†å®šä¹‰äº† â€œè¢«ååºåˆ—åŒ–çš„ç±»å‹â€ çš„ç¨‹åºé›†åŠ è½½åˆ°ç›®æ ‡ AppDomain ä¸­ (å¦‚æœå°šæœªåŠ è½½çš„è¯)ã€‚æ¥ç€ï¼ŒCLR åˆ›å»ºç±»å‹çš„å®ä¾‹ï¼Œå¹¶åˆ©ç”¨å­—èŠ‚æ•°ç»„ä¸­çš„å€¼åˆå§‹åŒ–å¯¹è±¡çš„å­—æ®µï¼Œä½¿ä¹‹ä¸æºå¯¹è±¡ä¸­çš„å€¼ç›¸åŒã€‚æ¢è¨€ä¹‹ï¼ŒCLR åœ¨ç›®æ ‡ AppDomain ä¸­ç²¾ç¡®å¤åˆ¶äº†æºå¯¹è±¡ã€‚ç„¶åè¿”å›å¯¹è¿™ä¸ªå‰¯æœ¬çš„å¼•ç”¨ï¼›è¿™æ ·ä¸€æ¥ï¼Œå¯¹è±¡å°±è·¨ AppDomain çš„è¾¹ç•ŒæŒ‰å€¼å°é€äº†ã€‚è‡³æ­¤ï¼Œæº AppDomain ä¸­çš„å¯¹è±¡å’Œç›®æ ‡ AppDomain ä¸­çš„å¯¹è±¡å°±æœ‰äº†ç‹¬ç«‹çš„ç”Ÿå­˜æœŸï¼Œå®ƒä»¬çš„çŠ¶æ€ä¹Ÿå¯ä»¥ç‹¬ç«‹åœ°æ›´æ”¹ã€‚æ³¨æ„ï¼Œå¯¹äº <code>String</code> å¯¹è±¡ï¼ŒCLR ä¼šé‡‡å–ç‰¹æ®Šçš„ä¼˜åŒ–æªæ–½ã€‚è·¨è¶Š AppDomain è¾¹ç•Œå°é€ä¸€ä¸ª <code>String</code> å¯¹è±¡æ—¶ï¼Œ CLR åªæ˜¯è·¨è¶Šè¾¹ç•Œä¼ é€’å¯¹ <code>String</code> å¯¹è±¡çš„å¼•ç”¨ï¼›ä¸ä¼šçœŸçš„ç”Ÿæˆ <code>String</code> å¯¹è±¡çš„å‰¯æœ¬ã€‚ä¹‹æ‰€ä»¥èƒ½æä¾›è¿™ä¸ªä¼˜åŒ–ï¼Œæ˜¯å› ä¸º <code>String</code> å¯¹è±¡æ˜¯ä¸å¯å˜çš„ï¼›æ‰€ä»¥ï¼Œä¸€ä¸ª AppDomain ä¸­çš„ä»£ç ä¸å¯èƒ½ç ´å <code>String</code> å¯¹è±¡çš„å­—æ®µã€‚</p><h2 id="appdomain-unloading"><a class="anchor" href="#appdomain-unloading">#</a> AppDomain Unloading</h2><blockquote><p>One of the great features of AppDomains is that you can unload them. Unloading an AppDomain causes the CLR to unload all of the assemblies in the AppDomain, and the CLR frees the AppDomainâ€™s loader heap as well. To unload an AppDomain, you call AppDomainâ€™s Unload static method (as the Ch22-1-AppDomains application does). This call causes the CLR to perform a lot of actions to gracefully unload the specified AppDomain:</p><ol><li>The CLR suspends all threads in the process that have ever executed managed code.</li><li>The CLR examines all of the threadsâ€™ stacks to see which threads are currently executing code in the AppDomain being unloaded, or which threads might return at some point to code in the AppDomain that is being unloaded. The CLR forces any threads that have the unloading AppDomain on their stack to throw a ThreadAbortException (resuming the threadâ€™s execution). This causes the threads to unwind, executing any finally blocks on their way out so that cleanup code executes. If no code catches the ThreadAbortException, it will eventually become an unhandled exception that the CLR swallows; the thread dies, but the process is allowed to continue running. This is unusual, because for all other unhandled exceptions, the CLR kills the process.</li></ol></blockquote><p>ğŸ’¡é‡è¦æç¤ºï¼šå¦‚æœçº¿ç¨‹å½“å‰æ­£åœ¨ <code>finally</code> å—ã€ <code>catch</code> å—ã€ç±»æ„é€ å™¨ã€ä¸´ç•Œæ‰§è¡ŒåŒºåŸŸæˆ–éæ‰˜ç®¡ä»£ç ä¸­æ‰§è¡Œï¼Œé‚£ä¹ˆ CLR ä¸ä¼šç«‹å³ç»ˆæ­¢è¯¥çº¿ç¨‹ã€‚å¦åˆ™ã€èµ„æºæ¸…ç†ä»£ç ã€é”™è¯¯æ¢å¤ä»£ç ã€ç±»å‹åˆå§‹åŒ–ä»£ç ã€å…³é”® (critical) ä»£ç æˆ–è€…å…¶ä»–ä»»ä½• CLR ä¸äº†è§£çš„ä»£ç éƒ½å°†æ— æ³•å®Œæˆï¼Œå¯¼è‡´åº”ç”¨ç¨‹åºçš„è¡Œä¸ºæ— æ³•é¢„æµ‹ï¼Œç”šè‡³å¯èƒ½é€ æˆå®‰å…¨æ¼æ´ã€‚çº¿ç¨‹ç»ˆæ­¢æ—¶ä¼šç­‰å¾…è¿™äº›ä»£ç å—æ‰§è¡Œå®Œæ¯•ã€‚ç„¶åï¼Œå½“ä»£ç å—ç»“æŸæ—¶ï¼ŒCLR å†å¼ºåˆ¶çº¿ç¨‹æŠ›å‡ºä¸€ä¸ª <code>ThreadAbortException</code> å¼‚å¸¸ã€‚</p><blockquote><ol start="3"><li>After all threads discovered in step 2 have left the AppDomain, the CLR then walks the heap and sets a flag in each proxy object that referred to an object created by the unloaded AppDomain. These proxy objects now know that the real object they referred to is gone. If any code now calls a method on an invalid proxy object, the method will throw an AppDomainUnloadedException.</li><li>The CLR forces a garbage collection to occur, reclaiming the memory used by any objects that were created by the now unloaded AppDomain. The Finalize methods for these objects are called, giving the objects a chance to clean themselves up properly.</li><li>The CLR resumes all of the remaining threads. The thread that called AppDomain.Unload will now continue running; calls to AppDomain.Unload occur synchronously.</li></ol></blockquote><blockquote><p>My Ch22-1-AppDomains application uses just one thread to do all of the work. Whenever my code calls AppDomain.Unload, there are no threads in the unloading AppDomain, and therefore, the CLR doesnâ€™t have to throw any ThreadAbortException exceptions. Iâ€™ll talk more about ThreadAbortException later in this chapter.</p></blockquote><blockquote><p>By the way, when a thread calls AppDomain.Unload, the CLR waits 10 seconds for the threads in the unloading AppDomain to leave it. If after 10 seconds, the thread that called AppDomain.Unload doesnâ€™t return, it will throw a CannotUnloadAppDomainException, and the AppDomain may or may not be unloaded in the future.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šå¦‚æœè°ƒç”¨ <code>AppDomain.Unload</code> æ–¹æ³•çš„çº¿ç¨‹ä¸å·§åœ¨è¦å¸è½½çš„ AppDomain ä¸­ï¼ŒCLR ä¼šåˆ›å»ºå¦ä¸€ä¸ªçº¿ç¨‹æ¥å°è¯•å¸è½½ AppDomainã€‚ç¬¬ä¸€ä¸ªçº¿ç¨‹è¢«å¼ºåˆ¶æŠ›å‡º <code>ThreadAbortException</code> å¹¶å±•å¼€ (unwind)ã€‚æ–°çº¿ç¨‹å°†ç­‰å¾… AppDomain å¸è½½ï¼Œç„¶åæ–°çº¿ç¨‹ä¼šç»ˆæ­¢ã€‚å¦‚æœ AppDomain å¸è½½å¤±è´¥ï¼Œæ–°çº¿ç¨‹å°†æŠ›å‡º <code>CannotUnloadAppDomainException</code> å¼‚å¸¸ã€‚ä½†æ˜¯ï¼Œç”±äºæˆ‘ä»¬æ²¡æœ‰å†™ç”±æ–°çº¿ç¨‹æ‰§è¡Œçš„ä»£ç ï¼Œæ‰€ä»¥æ— æ³•æ•æ‰è¿™å¼‚å¸¸ã€‚</p><p>ğŸ’¡å°ç»“ï¼šAppDomain å¾ˆå¼ºå¤§çš„ä¸€ä¸ªåœ°æ–¹å°±æ˜¯å¯ä»¥å¸è½½å®ƒã€‚å¸è½½ AppDomain ä¼šå¯¼è‡´ CLR å¸è½½ AppDomain ä¸­çš„æ‰€æœ‰ç¨‹åºé›†ï¼Œè¿˜ä¼šé‡Šæ”¾ AppDomain çš„ Loader å †ã€‚å¸è½½ AppDomain çš„åŠæ³•æ˜¯è°ƒç”¨ <code>AppDomain</code> çš„é™æ€ <code>Unload</code> æ–¹æ³•ã€‚è¿™å¯¼è‡´ CLR æ‰§è¡Œä¸€ç³»åˆ—æ“ä½œæ¥å¾—ä½“åœ°å¸è½½æŒ‡å®šçš„ AppDomainã€‚CLR ä¼šæŒ‚èµ·è¿›ç¨‹ä¸­æ‰§è¡Œè¿‡æ‰˜ç®¡ä»£ç çš„æ‰€æœ‰çº¿ç¨‹ã€‚ç„¶å CLR æ£€æŸ¥æ‰€æœ‰çº¿ç¨‹æ ˆï¼ŒæŸ¥çœ‹å“ªäº›çº¿ç¨‹æ­£åœ¨æ‰§è¡Œè¦å¸è½½çš„ AppDomain ä¸­çš„ä»£ç ï¼Œæˆ–è€…å“ªäº›çº¿ç¨‹ä¼šåœ¨æŸä¸ªæ—¶å€™è¿”å›è‡³è¦å¸è½½çš„ AppDomainã€‚ä»»ä½•æ ˆä¸Šæœ‰è¦å¸è½½çš„ AppDomainï¼ŒCLR éƒ½ä¼šå¼ºè¿«å¯¹åº”çš„çº¿ç¨‹æŠ›å‡ºä¸€ä¸ª <code>ThreadAbortException</code> (åŒæ—¶æ¢å¤çº¿ç¨‹çš„æ‰§è¡Œ)ã€‚è¿™å°†å¯¼è‡´çº¿ç¨‹å±•å¼€ (unwind)ï¼Œå¹¶æ‰§è¡Œé‡åˆ°çš„æ‰€æœ‰ <code>finally</code> å—ä»¥æ¸…ç†èµ„æºã€‚å¦‚æœæ²¡æœ‰ä»£ç æ•æ‰ <code>ThreadAbortException</code> ï¼Œå®ƒæœ€ç»ˆä¼šæˆä¸ºæœªå¤„ç†çš„å¼‚å¸¸ï¼ŒCLR ä¼š â€œåå™¬â€ è¿™ä¸ªå¼‚å¸¸ï¼šçº¿ç¨‹ä¼šç»ˆæ­¢ï¼Œä½†è¿›ç¨‹å¯ç»§ç»­è¿è¡Œã€‚è¿™æ˜¯å¾ˆç‰¹åˆ«çš„ä¸€ç‚¹ï¼Œå› ä¸ºå¯¹äºå…¶ä»–æ‰€æœ‰æœªç»å¤„ç†çš„å¼‚å¸¸ï¼ŒCLR éƒ½ä¼šç»ˆæ­¢è¿›ç¨‹ã€‚å½“ç¬¬ 2 æ­¥å‘ç°çš„æ‰€æœ‰çº¿ç¨‹éƒ½ç¦»å¼€ AppDomain åï¼ŒCLR éå†å †ï¼Œä¸ºå¼•ç”¨äº† â€œç”±å·²å¸è½½çš„ AppDomain åˆ›å»ºçš„å¯¹è±¡â€ çš„æ¯ä¸ªä»£ç†å¯¹è±¡éƒ½è®¾ç½®ä¸€ä¸ªæ ‡å¿— (flag)ã€‚è¿™äº›ä»£ç†å¯¹è±¡ç°åœ¨çŸ¥é“å®ƒä»¬å¼•ç”¨çš„çœŸå®å¯¹è±¡å·²ç»ä¸åœ¨äº†ã€‚ç°åœ¨ï¼Œä»»ä½•ä»£ç åœ¨æ— æ•ˆçš„ä»£ç†å¯¹è±¡ä¸Šè°ƒç”¨æ–¹æ³•éƒ½ä¼šæŠ›å‡ºä¸€ä¸ª <code>AppDomainUnloadedException</code> å¼‚å¸¸ã€‚CLR å¼ºåˆ¶åƒåœ¾å›æ”¶ï¼Œå›æ”¶ç”±å·²å¸è½½çš„ AppDomain åˆ›å»ºçš„ä»»ä½•å¯¹è±¡çš„å†…å­˜ã€‚è¿™äº›å¯¹è±¡çš„ <code>Finalize</code> æ–¹æ³•è¢«è°ƒç”¨ï¼Œä½¿å¯¹è±¡æœ‰æœºä¼šæ­£ç¡®æ¸…ç†å®ƒä»¬å ç”¨çš„èµ„æºã€‚CLR æ¢å¤å‰©ä½™æ‰€æœ‰çº¿ç¨‹çš„æ‰§è¡Œã€‚è°ƒç”¨ <code>AppDomain.Unload</code> æ–¹æ³•çš„çº¿ç¨‹å°†ç»§ç»­è¿è¡Œï¼›å¯¹ <code>AppDomain.Unload</code> çš„è°ƒç”¨æ˜¯åŒæ­¥è¿›è¡Œçš„ã€‚æ¢è¨€ä¹‹ï¼Œä¸€æ—¦è°ƒç”¨ Unloadï¼Œåªæœ‰åœ¨å®ƒè¿”å›ä¹‹åï¼Œçº¿ç¨‹æ‰èƒ½æ¢å¤è¿è¡Œã€‚é¡ºä¾¿è¯´ä¸€å¥ï¼Œå½“ä¸€ä¸ªçº¿ç¨‹è°ƒç”¨ <code>AppDomain.Unload</code> æ–¹æ³•æ—¶ï¼Œé’ˆå¯¹è¦å¸è½½çš„ AppDomain ä¸­çš„çº¿ç¨‹ï¼Œ CLR ä¼šç»™å®ƒä»¬ 10 ç§’é’Ÿçš„æ—¶é—´ç¦»å¼€ã€‚10 ç§’é’Ÿåï¼Œå¦‚æœè°ƒç”¨ <code>AppDomain.Unload</code> æ–¹æ³•çš„çº¿ç¨‹è¿˜æ²¡æœ‰è¿”å›ï¼ŒCLR å°†æŠ›å‡ºä¸€ä¸ª <code>CannotUnloadAppDomainException</code> å¼‚å¸¸ï¼ŒAppDomain å°†æ¥å¯èƒ½ä¼šã€ä¹Ÿå¯èƒ½ä¸ä¼šå¸è½½ã€‚</p><h2 id="appdomain-monitoring"><a class="anchor" href="#appdomain-monitoring">#</a> AppDomain Monitoring</h2><blockquote><p>A host application can monitor the resources that an AppDomain consumes. Some hosts will use this information to decide when to forcibly unload an AppDomain should its memory or CPU consumption rise above what the host considers reasonable. Monitoring can also be used to compare the resource consumption of different algorithms to determine which uses fewer resources. Because AppDomain monitoring incurs additional overhead, hosts must explicitly turn the monitoring on by setting AppDomainâ€™s static MonitoringEnabled property to true. This turns on monitoring for all AppDomains. After monitoring is turned on, it cannot be turned off; attempting to set the MonitoringEnabled property to false causes an ArgumentException to be thrown.</p></blockquote><blockquote><p>After monitoring is turned on, your code can query the following four read-only properties offered by the AppDomain class:</p><ul><li><p><strong>MonitoringSurvivedProcessMemorySize</strong> This static Int64 property returns the number of bytes that are currently in use by all AppDomains controlled by the current CLR instance. The number is accurate as of the last garbage collection.</p></li><li><p><strong>MonitoringTotalAllocatedMemorySize</strong> This instance Int64 property returns the number of bytes that have been allocated by a specific AppDomain. The number is accurate as of the last garbage collection.</p></li><li><p><strong>MonitoringSurvivedMemorySize</strong> This instance Int64 property returns the number of bytes that are currently in use by a specific AppDomain. The number is accurate as of the last garbage collection.</p></li><li><p><strong>MonitoringTotalProcessorTime</strong> This instance TimeSpan property returns the amount of CPU usage incurred by a specific AppDomain.</p></li></ul></blockquote><blockquote><p>The following class shows how to use three of these properties to see what has changed within an AppDomain between two points in time.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">AppDomainMonitorDelta</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IDisposable</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">AppDomain</span> m_appDomain<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">TimeSpan</span> m_thisADCpu<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int64</span> m_thisADMemoryInUse<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int64</span> m_thisADMemoryAllocated<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">static</span> <span class="token function">AppDomainMonitorDelta</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// Make sure that AppDomain monitoring is turned on</span></pre></td></tr><tr><td data-num="8"></td><td><pre> AppDomain<span class="token punctuation">.</span>MonitoringIsEnabled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">public</span> <span class="token function">AppDomainMonitorDelta</span><span class="token punctuation">(</span><span class="token class-name">AppDomain</span> ad<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> m_appDomain <span class="token operator">=</span> ad <span class="token operator">??</span> AppDomain<span class="token punctuation">.</span>CurrentDomain<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> m_thisADCpu <span class="token operator">=</span> m_appDomain<span class="token punctuation">.</span>MonitoringTotalProcessorTime<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> m_thisADMemoryInUse <span class="token operator">=</span> m_appDomain<span class="token punctuation">.</span>MonitoringSurvivedMemorySize<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> m_thisADMemoryAllocated <span class="token operator">=</span> m_appDomain<span class="token punctuation">.</span>MonitoringTotalAllocatedMemorySize<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre> GC<span class="token punctuation">.</span><span class="token function">Collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>â€œFriendlyName<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> CPU<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">&#125;</span>msâ€<span class="token punctuation">,</span> m_appDomain<span class="token punctuation">.</span>FriendlyName<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token punctuation">(</span>m_appDomain<span class="token punctuation">.</span>MonitoringTotalProcessorTime <span class="token operator">-</span> m_thisADCpu<span class="token punctuation">)</span><span class="token punctuation">.</span>TotalMilliseconds<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>â€œ Allocated <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">:</span>N0<span class="token punctuation">&#125;</span> bytes <span class="token return-type class-name">of</span> which <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">:</span>N0<span class="token punctuation">&#125;</span> survived GCsâ€<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="21"></td><td><pre> m_appDomain<span class="token punctuation">.</span>MonitoringTotalAllocatedMemorySize <span class="token operator">-</span> m_thisADMemoryAllocated<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="22"></td><td><pre> m_appDomain<span class="token punctuation">.</span>MonitoringSurvivedMemorySize <span class="token operator">-</span> m_thisADMemoryInUse<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The following code shows how to use the AppDomainMonitorDelta class.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">AppDomainResourceMonitoring</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">AppDomainMonitorDelta</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// Allocate about 10 million bytes that will survive collections</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">List<span class="token punctuation">&lt;</span>Object<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span> list<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">Byte</span><span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Allocate about 20 million bytes that will NOT survive collections</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> <span class="token number">2000</span><span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Byte</span><span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Spin the CPU for about 5 seconds</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token class-name">Int64</span> stop <span class="token operator">=</span> Environment<span class="token punctuation">.</span>TickCount <span class="token operator">+</span> <span class="token number">5000</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">while</span> <span class="token punctuation">(</span>Environment<span class="token punctuation">.</span>TickCount <span class="token operator">&lt;</span> stop<span class="token punctuation">)</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When I execute this code, I get the following output.</p></blockquote><pre><code class="language-cmd">FriendlyName=03-Ch22-1-AppDomains.exe, CPU=5031.25ms
 Allocated 30,159,496 bytes of which 10,085,080 survived GCs
</code></pre><p>ğŸ’¡å°ç»“ï¼šå®¿ä¸»åº”ç”¨ç¨‹åºå¯ç›‘è§† AppDomain æ¶ˆè€—çš„èµ„æºã€‚æœ‰çš„å®¿ä¸»æ ¹æ®è¿™ç§ä¿¡æ¯åˆ¤æ–­ä¸€ä¸ª AppDomain çš„å†…å­˜æˆ– CPU æ¶ˆè€—æ˜¯å¦è¶…è¿‡äº†åº”æœ‰çš„æ°´å‡†ï¼Œå¹¶å¼ºåˆ¶å¸è½½ä¸€ä¸ª AppDomainã€‚è¿˜å¯åˆ©ç”¨ç›‘è§†æ¥æ¯”è¾ƒä¸åŒç®—æ³•çš„èµ„æºæ¶ˆè€—æƒ…å†µï¼Œåˆ¤æ–­å“ªä¸€ç§ç®—æ³•ç”¨çš„èµ„æºè¾ƒå°‘ã€‚ç”±äº AppDomain ç›‘è§†æœ¬èº«ä¹Ÿä¼šäº§ç”Ÿå¼€é”€ï¼Œæ‰€ä»¥å®¿ä¸»å¿…é¡»å°† <code>AppDomain</code> çš„é™æ€ <code>MonitoringEnabled</code> å±æ€§è®¾ä¸º <code>true</code> ï¼Œä»è€Œæ˜¾å¼åœ°æ‰“å¼€ç›‘è§†ã€‚ç›‘è§†ä¸€æ—¦æ‰“å¼€ä¾¿ä¸èƒ½å…³é—­ï¼›å°† <code>MonitoringEnabled</code> å±æ€§è®¾ä¸º <code>false</code> ä¼šæŠ›å‡ºä¸€ä¸ª <code>ArgumentException</code> å¼‚å¸¸ã€‚</p><h2 id="appdomain-first-chance-exception-notifications"><a class="anchor" href="#appdomain-first-chance-exception-notifications">#</a> AppDomain First-Chance Exception Notifications</h2><blockquote><p>Each AppDomain can have associated with it a series of callback methods that get invoked when the CLR begins looking for catch blocks within an AppDomain. These methods can perform logging, or a host can use this mechanism to monitor exceptions being thrown within an AppDomain. The callbacks cannot handle the exception or swallow it in any way; they are just receiving a notification that the exception has occurred. To register a callback method, just add a delegate to AppDomainâ€™s instance FirstChanceException event.</p></blockquote><blockquote><p>Here is how the CLR processes an exception: when the exception is first thrown, the CLR invokes any FirstChanceException callback methods registered with the AppDomain that are throwing the exception. Then, the CLR looks for any catch blocks on the stack that are within the same AppDomain. If a catch block handles the exception, then processing of the exception is complete and execution continues as normal. If the AppDomain has no catch block to handle the exception, then the CLR walks up the stack to the calling AppDomain and throws the same exception object again (after serializing and deserializing it). At this point, it is as if a brand new exception is being thrown, and the CLR invokes any FirstChanceException callback methods registered with the now current AppDomain. This continues until the top of the threadâ€™s stack is reached. At that point, if the exception is not handled by any code, the CLR terminates the whole process.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šæ¯ä¸ª AppDomain éƒ½å¯å…³è”ä¸€ç»„å›è°ƒæ–¹æ³•ï¼›CLR å¼€å§‹æŸ¥æ‰¾ AppDomain ä¸­çš„ <code>catch</code> å—æ—¶ï¼Œè¿™äº›å›è°ƒæ–¹æ³•å°†å¾—ä»¥è°ƒç”¨ã€‚å¯ç”¨è¿™äº›æ–¹æ³•æ‰§è¡Œæ—¥å¿—è®°å½•æ“ä½œã€‚å¦å¤–ï¼Œå®¿ä¸»å¯åˆ©ç”¨è¿™ä¸ªæœºåˆ¶ç›‘è§† AppDomain ä¸­æŠ›å‡ºçš„å¼‚å¸¸ã€‚å›è°ƒæ–¹æ³•ä¸èƒ½å¤„ç†å¼‚å¸¸ï¼Œä¹Ÿä¸èƒ½ä»¥ä»»ä½•æ–¹å¼ â€œåå™¬â€ å¼‚å¸¸ (è£…ä½œå¼‚å¸¸æ²¡æœ‰å‘ç”Ÿ)ï¼›å®ƒä»¬åªæ˜¯æ¥æ”¶å…³äºå¼‚å¸¸å‘ç”Ÿçš„é€šçŸ¥ã€‚è¦ç™»è®°å›è°ƒæ–¹æ³•ï¼Œä¸º AppDomain çš„å®ä¾‹äº‹ä»¶ <code>FirstChanceException</code> æ·»åŠ ä¸€ä¸ªå§”æ‰˜å°±å¯ä»¥äº†ã€‚å¼‚å¸¸é¦–æ¬¡æŠ›å‡ºæ—¶ï¼ŒCLR è°ƒç”¨å‘æŠ›å‡ºå¼‚å¸¸çš„ AppDomain ç™»è®°çš„æ‰€æœ‰ <code>FirstChanceException</code> å›è°ƒæ–¹æ³•ã€‚ç„¶åï¼ŒCLR æŸ¥æ‰¾æ ˆä¸Šåœ¨åŒä¸€ä¸ª AppDomain ä¸­çš„ä»»ä½• <code>catch</code> å—ã€‚æœ‰ä¸€ä¸ª <code>catch</code> å—èƒ½å¤„ç†å¼‚å¸¸ï¼Œåˆ™å¼‚å¸¸å¤„ç†å®Œæˆï¼Œå°†ç»§ç»­æ­£å¸¸æ‰§è¡Œã€‚å¦‚æœ AppDomain ä¸­æ²¡æœ‰ä¸€ä¸ª <code>catch</code> å—èƒ½å¤„ç†å¼‚å¸¸ï¼Œåˆ™ CLR æ²¿ç€æ ˆå‘ä¸Šæ¥åˆ°è°ƒç”¨ AppDomainï¼Œå†æ¬¡æŠ›å‡ºåŒä¸€ä¸ªå¼‚å¸¸å¯¹è±¡ (åºåˆ—åŒ–å’Œååºåˆ—åŒ–ä¹‹å)ã€‚è¿™æ—¶æ„Ÿè§‰å°±åƒæ˜¯æŠ›å‡ºäº†ä¸€ä¸ªå…¨æ–°çš„å¼‚å¸¸ï¼ŒCLR è°ƒç”¨å‘å½“å‰ AppDomain ç™»è®°çš„æ‰€æœ‰ <code>FirstChanceException</code> å›è°ƒæ–¹æ³•ã€‚è¿™ä¸ªè¿‡ç¨‹ä¼šä¸€ç›´æŒç»­ï¼Œç›´åˆ°æŠµè¾¾çº¿ç¨‹æ ˆé¡¶éƒ¨ã€‚å±Šæ—¶å¦‚æœå¼‚å¸¸è¿˜æœªè¢«ä»»ä½•ä»£ç†å¤„ç†ï¼ŒCLR åªå¥½ç»ˆæ­¢æ•´ä¸ªè¿›ç¨‹ã€‚</p><h2 id="how-hosts-use-appdomains"><a class="anchor" href="#how-hosts-use-appdomains">#</a> How Hosts Use AppDomains</h2><blockquote><p>So far, Iâ€™ve talked about hosts and how they load the CLR. Iâ€™ve also talked about how the hosts tell the CLR to create and unload AppDomains. To make the discussion more concrete, Iâ€™ll describe some common hosting and AppDomain scenarios. In particular, Iâ€™ll explain how different application types host the CLR and how they manage AppDomains.</p></blockquote><h3 id="executable-applications"><a class="anchor" href="#executable-applications">#</a> Executable Applications</h3><blockquote><p>Console UI applications, NT Service applications, Windows Forms applications, and Windows Presentation Foundation (WPF) applications are all examples of self-hosted applications that have managed EXE files. When Windows initializes a process by using a managed EXE file, Windows loads the shim, and the shim examines the CLR header information contained in the applicationâ€™s assembly (the EXE file). The header information indicates the version of the CLR that was used to build and test the application. The shim uses this information to determine which version of the CLR to load into the process. After the CLR loads and initializes, it again examines the assemblyâ€™s CLR header to determine which method is the applicationâ€™s entry point (Main). The CLR invokes this method, and the application is now up and running.</p></blockquote><blockquote><p>As the code runs, it accesses other types. When referencing a type contained in another assembly, the CLR locates the necessary assembly and loads it into the same AppDomain. Any additionally referenced assemblies also load into the same AppDomain. When the applicationâ€™s Main method returns, the Windows process terminates (destroying the default AppDomain and all other AppDomains).</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šé¡ºä¾¿è¯´ä¸€å¥ï¼Œè¦å…³é—­ Windows è¿›ç¨‹ (åŒ…æ‹¬å®ƒçš„æ‰€æœ‰ AppDomain)ï¼Œå¯è°ƒç”¨ <code>System.Enviroment</code> çš„é™æ€æ–¹æ³• <code>Exit</code> ã€‚ <code>Exit</code> æ˜¯ç»ˆæ­¢è¿›ç¨‹æœ€å¾—ä½“çš„æ–¹å¼ï¼Œå› ä¸ºå®ƒé¦–å…ˆè°ƒç”¨æ‰˜ç®¡å †ä¸Šçš„æ‰€æœ‰å¯¹è±¡çš„ <code>Finalize</code> æ–¹æ³•ï¼Œå†é‡Šæ”¾ CLR å®¹çº³çš„æ‰€æœ‰éæ‰˜ç®¡ COM å¯¹è±¡ï¼Œæœ€åï¼Œ <code>Exit</code> è°ƒç”¨ Win32 <code>ExitProcess</code> å‡½æ•°ã€‚</p><blockquote><p>Itâ€™s possible for the application to tell the CLR to create additional AppDomains in the processâ€™s address space. In fact, this is what my Ch22-1-AppDomains application did.</p></blockquote><h3 id="microsoft-silverlight-rich-internet-applications"><a class="anchor" href="#microsoft-silverlight-rich-internet-applications">#</a> Microsoft Silverlight Rich Internet Applications</h3><blockquote><p>Microsoftâ€™s Silverlight runtime technology uses a special CLR that is different from the normal desktop version of the .NET Framework. After the Silverlight runtime is installed, navigating to a website that uses Silverlight causes the Silverlight CLR (CoreClr.dll) to load in your browser (which may or may not be Windows Internet Explorerâ€”you may not even be using a Windows machine). Each Silverlight control on the page runs in its own AppDomain. When the user closes a tab or navigates to another website, any Silverlight controls no longer in use have their AppDomains unloaded. The Silverlight code running in the AppDomain runs in a limited-security sandbox so that it cannot harm the user or the machine in any way.</p></blockquote><h3 id="microsoft-aspnet-and-xml-web-services-applications"><a class="anchor" href="#microsoft-aspnet-and-xml-web-services-applications">#</a> Microsoft <span class="exturl" data-url="aHR0cDovL0FTUC5ORVQ=">ASP.NET</span> and XML Web Services Applications</h3><blockquote><p><span class="exturl" data-url="aHR0cDovL0FTUC5ORVQ=">ASP.NET</span> is implemented as an ISAPI DLL (implemented in ASPNet_ISAPI.dll). The first time a client requests a URL handled by the <span class="exturl" data-url="aHR0cDovL0FTUC5ORVQ=">ASP.NET</span> ISAPI DLL, <span class="exturl" data-url="aHR0cDovL0FTUC5ORVQ=">ASP.NET</span> loads the CLR. When a client makes a request of a web application, <span class="exturl" data-url="aHR0cDovL0FTUC5ORVQ=">ASP.NET</span> determines if this is the first time a request has been made. If it is, <span class="exturl" data-url="aHR0cDovL0FTUC5ORVQ=">ASP.NET</span> tells the CLR to create a new AppDomain for this web application; each web application is identified by its virtual root directory. <span class="exturl" data-url="aHR0cDovL0FTUC5ORVQ=">ASP.NET</span> then tells the CLR to load the assembly that contains the type exposed by the web application into this new AppDomain, creates an instance of this type, and starts calling methods in it to satisfy the clientâ€™s web request. If the code references more types, the CLR will load the required assemblies into the web applicationâ€™s AppDomain.</p></blockquote><blockquote><p>When future clients make requests of an already running web application, <span class="exturl" data-url="aHR0cDovL0FTUC5ORVQ=">ASP.NET</span> doesnâ€™t create a new AppDomain; instead, it uses the existing AppDomain, creates a new instance of the web applicationâ€™s type, and starts calling methods. The methods will already be JIT-compiled into native code, so the performance of processing all subsequent client requests is excellent.</p></blockquote><blockquote><p>If a client makes a request of a different web application, <span class="exturl" data-url="aHR0cDovL0FTUC5ORVQ=">ASP.NET</span> tells the CLR to create a new AppDomain. This new AppDomain is typically created inside the same worker process as the other AppDomains. This means that many web applications run in a single Windows process, which improves the efficiency of the system overall. Again, the assemblies required by each web application are loaded into an AppDomain created for the sole purpose of isolating that web applicationâ€™s code and objects from other web applications.</p></blockquote><blockquote><p>A fantastic feature of <span class="exturl" data-url="aHR0cDovL0FTUC5ORVQ=">ASP.NET</span> is that the code for a website can be changed on the fly without shutting down the web server. When a websiteâ€™s file is changed on the hard disk, <span class="exturl" data-url="aHR0cDovL0FTUC5ORVQ=">ASP.NET</span> detects this, unloads the AppDomain that contains the old version of the files (when the last currently running request finishes), and then creates a new AppDomain, loading into it the new versions of the files. To make this happen, <span class="exturl" data-url="aHR0cDovL0FTUC5ORVQ=">ASP.NET</span> uses an AppDomain feature called shadow copying.</p></blockquote><h3 id="microsoft-sql-server"><a class="anchor" href="#microsoft-sql-server">#</a> Microsoft SQL Server</h3><blockquote><p>Microsoft SQL Server is an unmanaged application because most of its code is still written in unmanaged C++. SQL Server allows developers to create stored procedures by using managed code. The first time a request comes in to the database to run a stored procedure written in managed code, SQL Server loads the CLR. Stored procedures run in their own secured AppDomain, prohibiting the stored procedures from adversely affecting the database server.</p></blockquote><blockquote><p>This functionality is absolutely incredible! It means that developers will be able to write stored procedures in the programming language of their choice. The stored procedure can use strongly typed data objects in its code. The code will also be JIT-compiled into native code when executed instead of being interpreted. And developers can take advantage of any types defined in the Framework Class Library (FCL) or in any other assembly. The result is that our job becomes much easier and our applications perform much better. What more could a developer ask for?!</p></blockquote><h3 id="your-own-imagination"><a class="anchor" href="#your-own-imagination">#</a> Your Own Imagination</h3><blockquote><p>Productivity applications such as word processors and spreadsheets also allow users to write macros in any programming language they choose. These macros will have access to all of the assemblies and types that work with the CLR. They will be compiled, so they will execute fast, and, most important, these macros will run in a secure AppDomain so that users donâ€™t get hit with any unwanted surprises. Your own applications can use this ability, too, in any way you want.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šæ§åˆ¶å° UI åº”ç”¨ç¨‹åºã€NT Service åº”ç”¨ç¨‹åºã€Windows çª—ä½“åº”ç”¨ç¨‹åºå’Œ Windows Presentation Foundation (WPF) åº”ç”¨ç¨‹åºéƒ½ä¼šè‡ªå¯„å®¿ (self-hostedï¼Œå³è‡ªå·±å®¹çº³ CLR) çš„åº”ç”¨ç¨‹åºï¼Œå®ƒä»¬éƒ½æœ‰æ‰˜ç®¡ EXE æ–‡ä»¶ã€‚Windows ç”¨æ‰˜ç®¡ EXE æ–‡ä»¶åˆå§‹åŒ–è¿›ç¨‹æ—¶ï¼Œä¼šåŠ è½½å«ç‰‡ã€‚å«ç‰‡æ£€æŸ¥åº”ç”¨ç¨‹åºçš„ç¨‹åºé›† (EXE æ–‡ä»¶) ä¸­çš„ CLR å¤´ä¿¡æ¯ã€‚å¤´ä¿¡æ¯æŒ‡æ˜äº†ç”Ÿæˆå’Œæµ‹è¯•åº”ç”¨ç¨‹åºæ—¶ä½¿ç”¨çš„ CLR ç‰ˆæœ¬ã€‚å«ç‰‡æ ¹æ®è¿™äº›ä¿¡æ¯å†³å®šå°†å“ªä¸ªç‰ˆæœ¬çš„ CLR åŠ è½½åˆ°è¿›ç¨‹ä¸­ï¼ŒCLR åŠ è½½å¹¶åˆå§‹åŒ–å¥½ä¹‹åï¼Œä¼šå†æ¬¡æ£€æŸ¥ç¨‹åºé›†çš„ CLR å¤´ï¼Œåˆ¤æ–­å“ªä¸ªæ–¹æ³•æ˜¯åº”ç”¨ç¨‹åºçš„å…¥å£æ–¹ ( <code>Main</code> )ã€‚CLR è°ƒç”¨è¯¥æ–¹æ³•ï¼Œæ­¤æ—¶åº”ç”¨ç¨‹åºæ‰çœŸæ­£å¯åŠ¨å¹¶è¿è¡Œèµ·æ¥ã€‚ä»£ç è¿è¡Œæ—¶ä¼šè®¿é—®å…¶ä»–ç±»å‹ã€‚å¼•ç”¨å¦ä¸€ä¸ªç¨‹åºé›†ä¸­çš„ç±»å‹æ—¶ï¼ŒCLR ä¼šå®šä½æ‰€éœ€çš„ç¨‹åºé›†ï¼Œå¹¶å°†å…¶åŠ è½½åˆ°åŒä¸€ä¸ª AppDomain ä¸­ã€‚åº”ç”¨ç¨‹åºçš„ <code>Main</code> æ–¹æ³•è¿”å›åï¼ŒWindows è¿›ç¨‹ç»ˆæ­¢ (é”€æ¯é»˜è®¤ AppDomain å’Œå…¶ä»–æ‰€æœ‰ AppDomain)ã€‚</p><h2 id="advanced-host-control"><a class="anchor" href="#advanced-host-control">#</a> Advanced Host Control</h2><blockquote><p>In this section, Iâ€™ll mention some more advanced topics related to hosting the CLR. My intent is to give you a taste of what is possible, and this will help you to understand more of what the CLR is capable of. I encourage you to seek out other texts if you find this information particularly interesting.</p></blockquote><h3 id="managing-the-clr-by-using-managed-code"><a class="anchor" href="#managing-the-clr-by-using-managed-code">#</a> Managing the CLR by Using Managed Code</h3><blockquote><p>The System.AppDomainManager class allows a host to override CLR default behavior by using managed code instead of using unmanaged code. Of course, using managed code makes implementing a host easier. All you need to do is define your class and derive it from the System.AppDomainManager class, overriding any virtual methods where you want to take over control. Your class should then be built into its very own assembly and installed into the global assembly cache (GAC) because the assembly needs to be granted full-trust, and all assemblies in the GAC are always granted full-trust.</p></blockquote><blockquote><p>Then, you need to tell the CLR to use your AppDomainManager-derived class. In code, the best way to do this is to create an AppDomainSetup object initializing its AppDomainManagerAssembly and AppDomainManagerType properties, both of which are of type String. Set the AppDomainManagerAssembly property to the string identifying the strong-name identity of the assembly that defines your AppDomainManager-derived class, and then set the AppDomainManagerType property to the full name of your AppDomainManager-derived class. Alternatively, AppDomainManager can be set in your applicationâ€™s XML configuration file by using the appDomainManagerAssembly and appDomainManagerType elements. In addition, a native host could query for the ICLRControl interface and call this interfaceâ€™s SetAppDomainManagerType function, passing in the identity of the GAC-installed assembly and the name of the AppDomainManager-derived class.</p></blockquote><blockquote><p>Now, letâ€™s talk about what an AppDomainManager-derived class can do. The purpose of the AppDomainManager-derived class is to allow a host to maintain control even when an add-in tries to create AppDomains of its own. When code in the process tries to create a new AppDomain, the AppDomainManager-derived object in that AppDomain can modify security and configuration settings.</p></blockquote><blockquote><p>It can also decide to fail an AppDomain creation, or it can decide to return a reference to an existing AppDomain instead. When a new AppDomain is created, the CLR creates a new AppDomainManagerderived object in the AppDomain. This object can also modify configuration settings, how execution context is flowed between threads, and permissions granted to an assembly.</p></blockquote><h3 id="writing-a-robust-host-application"><a class="anchor" href="#writing-a-robust-host-application">#</a> Writing a Robust Host Application</h3><blockquote><p>A host can tell the CLR what actions to take when a failure occurs in managed code. Here are some examples (listed from least severe to most severe):</p><ul><li><p>The CLR can abort a thread if the thread is taking too long to execute and return a response. (Iâ€™ll discuss this more in the next section.)</p></li><li><p>The CLR can unload an AppDomain. This aborts all of the threads that are in the AppDomain and causes the problematic code to be unloaded.</p></li><li><p>The CLR can be disabled. This stops any more managed code from executing in the process, but unmanaged code is still allowed to run.</p></li><li><p>The CLR can exit the Windows process. This aborts all of the threads and unloads all of the AppDomains first so that cleanup operations occur, and then the process terminates.</p></li></ul></blockquote><blockquote><p>The CLR can abort a thread or AppDomain gracefully or rudely. A graceful abort means that cleanup code executes. In other words, code in finally blocks runs, and objects have their Finalize methods executed. A rude abort means that cleanup code does not execute. In other words, code in finally blocks may not run, and objects may not have their Finalize methods executed. A graceful abort cannot abort a thread that is in a catch or finally block. However, a rude abort will abort a thread that is in a catch or finally block. Unfortunately, a thread that is in unmanaged code or in a constrained execution region (CER) cannot be aborted at all.</p></blockquote><blockquote><p>A host can set what is called an escalation policy, which tells the CLR how to deal with managed code failures. For example, SQL Server tells the CLR what to do should an unhandled exception be thrown while the CLR is executing managed code. When a thread experiences an unhandled exception, the CLR first attempts to upgrade the exception to a graceful thread abort. If the thread does not abort in a specified time period, the CLR attempts to upgrade the graceful thread abort to a rude thread abort.</p></blockquote><blockquote><p>What I just described is what usually happens. However, if the thread experiencing the unhandled exception is in a critical region, the policy is different. A thread that is in a critical region is a thread that has entered a thread synchronization lock that must be released by the same thread, for example, a thread that has called Monitor.Enter, Mutexâ€™s WaitOne, or one of ReaderWriterLockâ€™s AcquireReaderLock or AcquireWriterLock methods.6 Successfully waiting for an AutoResetEvent, ManualResetEvent, or Semaphore doesnâ€™t cause the thread to be in a critical region because another thread can signal these synchronization objects. When a thread is in a critical region, the CLR believes that the thread is accessing data that is shared by multiple threads in the same AppDomain. After all, this is probably why the thread took the lock. If the thread is accessing shared data, just terminating the thread isnâ€™t good enough, because other threads may then try to access the shared data that is now corrupt, causing the AppDomain to run unpredictably or with possible security vulnerabilities.</p></blockquote><blockquote><p>So, when a thread in a critical region experiences an unhandled exception, the CLR first attempts to upgrade the exception to a graceful AppDomain unload in an effort to get rid of all of the threads and data objects that are currently in use. If the AppDomain doesnâ€™t unload in a specified amount of time, the CLR upgrades the graceful AppDomain unload to a rude AppDomain unload.</p></blockquote><h3 id="how-a-host-gets-its-thread-back"><a class="anchor" href="#how-a-host-gets-its-thread-back">#</a> How a Host Gets Its Thread Back</h3><blockquote><p>Normally, a host application wants to stay in control of its threads. Letâ€™s take a database server as an example. When a request comes into the database server, a thread picks up the request and then dispatches the request to another thread that is to perform the actual work. This other thread may need to execute code that wasnâ€™t created and tested by the team that produced the database server. For example, imagine a request coming into the database server to execute a stored procedure written in managed code by the company running the server. Itâ€™s great that the database server can run the stored procedure code in its own AppDomain, which is locked down with security. This prevents the stored procedure from accessing any objects outside of its own AppDomain, and it also prevents the code from accessing resources that it is not allowed to access, such as disk files or the clipboard.</p></blockquote><blockquote><p>But what if the code in the stored procedure enters an infinite loop? In this case, the database server has dispatched one of its threads into the stored procedure code, and this thread is never coming back. This puts the server in a precarious position; the future behavior of the server is unknown. For example, the performance might be terrible now because a thread is in an infinite loop. Should the server create more threads? Doing so uses more resources (such as stack space), and these threads could also enter an infinite loop themselves.</p></blockquote><blockquote><p>To solve these problems, the host can take advantage of thread aborting. Figure 22-3 shows the typical architecture of a host application trying to solve the runaway thread problem. Hereâ€™s how it works (the numbers correspond to the circled numbers in the figure):</p><ol><li>A client sends a request to the server.</li><li>A server thread picks up this request and dispatches it to a thread pool thread to perform the actual work.</li><li>A thread pool thread picks up the client request and executes trusted code written by the company that built and tested the host application.</li><li>This trusted code then enters a try block, and from within the try block, calls across an AppDomain boundary (via a type derived from MarshalByRefObject). This AppDomain contains the untrusted code (perhaps a stored procedure) that was not built and tested by the company that produced the host application. At this point, the server has given control of its thread to some untrusted code; the server is feeling nervous right now.</li><li>When the host originally received the clientâ€™s request, it recorded the time. If the untrusted code doesnâ€™t respond to the client in some administrator-set amount of time, the host calls Threadâ€™s Abort method, asking the CLR to stop the thread pool thread, forcing it to throw a ThreadAbortException.</li><li>At this point, the thread pool thread starts unwinding, calling finally blocks so that cleanup code executes. Eventually, the thread pool thread crosses back over the AppDomain boundary. Because the hostâ€™s stub code called the untrusted code from inside a try block, the hostâ€™s stub code has a catch block that catches the ThreadAbortException.</li><li>In response to catching the ThreadAbortException, the host calls Threadâ€™s ResetAbort method. Iâ€™ll explain the purpose of this call shortly.</li><li>Now that the hostâ€™s code has caught the ThreadAbortException, the host can return some sort of failure back to the client and allow the thread pool thread to return to the pool so that it can be used for a future client request.</li></ol></blockquote><p><img data-src="/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/image-20221202190540124.png" alt="image-20221202190540124"></p><blockquote><p>Let me now clear up a few loose ends about this architecture. First, Threadâ€™s Abort method is asynchronous. When Abort is called, it sets the target threadâ€™s AbortRequested flag and returns immediately. When the runtime detects that a thread is to be aborted, the runtime tries to get the thread to a safe place. A thread is in a safe place when the runtime feels that it can stop what the thread is doing without causing disastrous effects. A thread is in a safe place if it is performing a managed blocking operation such as sleeping or waiting. A thread can be corralled to a safe place by using hijacking (described in Chapter 21). A thread is not in a safe place if it is executing a typeâ€™s class constructor, code in a catch or finally block, code in a CER, or unmanaged code.</p></blockquote><blockquote><p>After the thread reaches a safe place, the runtime will detect that the AbortRequested flag is set for the thread. This causes the thread to throw a ThreadAbortException. If this exception is not caught, the exception will be unhandled, all pending finally blocks will execute, and the thread will kill itself gracefully. Unlike all other exceptions, an unhandled ThreadAbortException does not cause the application to terminate. The runtime silently eats this exception and the thread dies, but the application and all of its remaining threads continue to run just fine.</p></blockquote><blockquote><p>In my example, the host catches the ThreadAbortException, allowing the host to regain control of the thread and return it to the pool. But there is a problem: What is to stop the untrusted code from catching the ThreadAbortException itself to keep control of the thread? The answer is that the CLR treats the ThreadAbortException in a very special manner. Even when code catches the ThreadAbortException, the CLR doesnâ€™t allow the exception to be swallowed. In other words, at the end of the catch block, the CLR automatically rethrows the ThreadAbortException exception.</p></blockquote><blockquote><p>This CLR feature raises another question: If the CLR rethrows the ThreadAbortException at the end of a catch block, how can the host catch it to regain control of the thread? Inside the hostâ€™s catch block, there is a call to Threadâ€™s ResetAbort method. Calling this method tells the CLR to stop rethrowing the ThreadAbortException at the end of each catch block.</p></blockquote><blockquote><p>This raises yet another question: Whatâ€™s to stop the untrusted code from catching the ThreadAbortException and calling Threadâ€™s ResetAbort method itself to keep control of the thread? The answer is that Threadâ€™s ResetAbort method requires the caller to have the SecurityPermission with the ControlThread flag set to true. When the host creates the AppDomain for the untrusted code, the host will not grant this permission, and now, the untrusted code cannot keep control of the hostâ€™s thread.</p></blockquote><blockquote><p>I should point out that there is still a potential hole in this story: while the thread is unwinding from its ThreadAbortException, the untrusted code can execute catch and finally blocks. Inside these blocks, the untrusted code could enter an infinite loop, preventing the host from regaining control of its thread. A host application fixes this problem by setting an escalation policy (discussed earlier). If an aborting thread doesnâ€™t finish in a reasonable amount of time, the CLR can upgrade the thread abort to a rude thread abort, a rude AppDomain unload, disabling of the CLR, or killing of the process. I should also note that the untrusted code could catch the ThreadAbortException and, inside the catch block, throw some other kind of exception. If this other exception is caught, at the end of the catch block, the CLR automatically rethrows the ThreadAbortException.</p></blockquote><blockquote><p>It should be noted, though, that most untrusted code is not actually intended to be malicious; it is just written in such a way so as to be taking too long by the hostâ€™s standards. Usually, catch and finally blocks contain very little code, and this code usually executes quickly without any infinite loops or long-running tasks. And so it is very unlikely that the escalation policy will have to go into effect for the host to regain control of its thread.</p></blockquote><blockquote><p>By the way, the Thread class actually offers two Abort methods: one takes no parameters, and the other takes an Object parameter allowing you to pass anything. When code catches the ThreadAbortException, it can query its read-only ExceptionState property. This property returns the object that was passed to Abort. This allows the thread calling Abort to specify some additional information that can be examined by code catching the ThreadAbortException. The host can use this to let its own handling code know why it is aborting threads.</p></blockquote><p>ğŸ“ï¼šï¼‰ <code>Thread</code> çš„ <code>Abort</code> æ–¹æ³•æ˜¯å¼‚æ­¥çš„ã€‚è°ƒç”¨ <code>Abort</code> æ–¹æ³•æ—¶ï¼Œä¼šåœ¨è®¾ç½®ç›®æ ‡çº¿ç¨‹çš„ <code>AbortRequsted</code> æ ‡å¿—åç«‹å³è¿”å›ã€‚â€œè¿è¡Œæ—¶â€ æ£€æµ‹åˆ°ä¸€ä¸ªçº¿ç¨‹è¦ä¸­æ­¢æ—¶ï¼Œä¼šå°è¯•å°†è¯¥çº¿ç¨‹å¼„åˆ°ä¸€ä¸ªå®‰å…¨åœ°ç‚¹ (safe place)ã€‚å¦‚æœ â€œè¿è¡Œæ—¶â€ è®¤ä¸ºèƒ½å®‰å…¨åœ°åœæ­¢çº¿ç¨‹æ­£åœ¨åšçš„äº‹æƒ…ï¼Œä¸ä¼šé€ æˆç¾éš¾æ€§åæœï¼Œå°±è¯´çº¿ç¨‹åœ¨å®‰å…¨åœ°ç‚¹ã€‚å¦‚æœçº¿ç¨‹æ­£åœ¨æ‰§è¡Œä¸€ä¸ªæ‰˜ç®¡çš„é˜»å¡æ“ä½œ (æ¯”å¦‚ç¡çœ æˆ–ç­‰å¾…)ï¼Œå®ƒå°±åœ¨ä¸€ä¸ªå®‰å…¨åœ°ç‚¹ã€‚ç›¸åï¼Œå¦‚æœçº¿ç¨‹æ­£åœ¨æ‰§è¡Œç±»å‹çš„ç±»æ„é€ å™¨ã€ <code>catch</code> å—æˆ– <code>finally</code> å—ä¸­çš„ä»£ç ã€CER ä¸­çš„ä»£ç æˆ–è€…éæ‰˜ç®¡ä»£ç ï¼Œçº¿ç¨‹å°±ä¸åœ¨å®‰å…¨åœ°ç‚¹ã€‚</p><p>ğŸ“ï¼šï¼‰çº¿ç¨‹åˆ°è¾¾å®‰å…¨åœ°ç‚¹åï¼Œâ€œè¿è¡Œæ—¶â€ æ£€æµ‹åˆ°çº¿ç¨‹å·²è®¾ç½®äº† <code>AbortRequsted</code> æ ‡å¿—ã€‚è¿™å¯¼è‡´çº¿ç¨‹æŠ›å‡ºä¸€ä¸ª <code>ThreadAbortException</code> ï¼Œå¦‚æœè¯¥å¼‚å¸¸æœªæ•æ‰ï¼Œå¼‚å¸¸å°±ä¼šæˆä¸ºæœªå¤„ç†çš„å¼‚å¸¸ï¼Œæ‰€æœ‰æŒ‚èµ·çš„ <code>finally</code> å—å°†æ‰§è¡Œï¼Œçº¿ç¨‹å¾—ä½“åœ°ä¸­æ­¢ã€‚å’Œå…¶ä»–æ‰€æœ‰å¼‚å¸¸ä¸åŒï¼Œæœªå¤„ç†çš„ <code>ThreadAbortException</code> ä¸ä¼šå¯¼è‡´åº”ç”¨ç¨‹åºç»ˆæ­¢ã€‚â€œè¿è¡Œæ—¶â€ ä¼šæ‚„æ‚„åœ° â€œåå™¬â€ è¿™ä¸ªå¼‚å¸¸ (å‡è£…å®ƒæ²¡æœ‰å‘ç”Ÿ)ï¼Œçº¿ç¨‹å°† â€œæ­»äº¡â€ã€‚ä½†åº”ç”¨ç¨‹åºåŠå…¶å‰©ä½™çš„æ‰€æœ‰çº¿ç¨‹éƒ½å°†ç»§ç»­è¿è¡Œã€‚</p><p>ğŸ“ï¼šï¼‰æœ‰ä¸€ä¸ªé—®é¢˜ï¼šå®¿ä¸»ç”¨ä»€ä¹ˆåŠæ³•é˜»æ­¢ä¸å¯ä¿¡ä»£ç è‡ªå·±æ•æ‰ <code>ThreadAbortException</code> ï¼Œä»è€Œä¿æŒå®¿ä¸»å¯¹çº¿ç¨‹çš„æ§åˆ¶å‘¢ï¼Ÿç­”æ¡ˆæ˜¯ CLR ä»¥ä¸€ç§éå¸¸ç‰¹æ®Šçš„æ–¹å¼å¯¹å¾… <code>ThreadAbortException</code> ã€‚å³ä½¿ä»£ç æ•æ‰äº† <code>ThreadAbortException</code> ã€‚å³ä½¿ä»£ç æ•æ‰äº† <code>ThreadAbortException</code> ï¼ŒCLR ä¹Ÿä¸å…è®¸ä»£ç æ‚„æ‚„åœ° â€œåå™¬â€ è¯¥å¼‚å¸¸ã€‚æ¢è¨€ä¹‹ï¼Œåœ¨ <code>catch</code> å—çš„å°¾éƒ¨ï¼ŒCLR ä¼šè‡ªåŠ¨é‡æ–°æŠ›å‡º <code>ThreadAbortException</code> å¼‚å¸¸ã€‚</p><p>ğŸ“ï¼šï¼‰CLR çš„è¿™ä¸ªåŠŸèƒ½åˆå¼•èµ·å¦ä¸€ä¸ªé—®é¢˜ï¼šå¦‚æœ CLR åœ¨ <code>catch</code> å—çš„å°¾éƒ¨é‡æ–°æŠ›å‡ºäº† <code>ThreadAbortException</code> å¼‚å¸¸ï¼Œå®¿ä¸»å¦‚ä½•æ•æ‰å®ƒå¹¶é‡æ–°è·å–çº¿ç¨‹çš„æ§åˆ¶æƒå‘¢ï¼Ÿå®¿ä¸»çš„ <code>catch</code> å—ä¸­æœ‰ä¸€ä¸ªå¯¹ <code>Thread</code> çš„ <code>ResetAbort</code> æ–¹æ³•çš„è°ƒç”¨ã€‚è°ƒç”¨è¯¥æ–¹æ³•ä¼šå‘Šè¯‰ CLR åœ¨ <code>catch</code> å—çš„å°¾éƒ¨ä¸è¦é‡æ–°æŠ›å‡º <code>ThreadAbortException</code> å¼‚å¸¸ã€‚</p><p>ğŸ“ï¼šï¼‰è¿™åˆå¼•èµ·äº†å¦ä¸€ä¸ªé—®é¢˜ï¼šå®¿ä¸»æ€ä¹ˆé˜»æ­¢ä¸å¯ä¿¡ä»£ç è‡ªå·±æ•æ‰ <code>ThreadAbortException</code> å¹¶è°ƒç”¨ <code>Thread</code> çš„ <code>ResetAbort</code> æ–¹æ³•ï¼Œä»è€Œä¿æŒå®¿ä¸»å¯¹çº¿ç¨‹çš„æ§åˆ¶å‘¢ï¼Ÿç­”æ¡ˆæ˜¯ <code>Thread</code> çš„ <code>ResetAbort</code> æ–¹æ³•è¦æ±‚è°ƒç”¨è€…è¢«æˆäºˆäº† <code>SecurityPermission</code> æƒé™ï¼Œè€Œä¸”å…¶ <code>ControlThread</code> æ ‡å¿—å·²è¢«è®¾ä¸º <code>true</code> ã€‚å®¿ä¸»ä¸ºä¸å¯ä¿¡ä»£ç åˆ›å»º AppDomain æ—¶ï¼Œä¸ä¼šå‘å…¶æˆäºˆè¿™ä¸ªæƒé™ï¼Œæ‰€ä»¥ä¸å¯ä¿¡ä»£ç ä¸èƒ½ä¿æŒå¯¹å®¿ä¸»çš„çº¿ç¨‹çš„æ§åˆ¶æƒã€‚</p><p>ğŸ“ï¼šï¼‰éœ€è¦æŒ‡å‡ºçš„æ˜¯ï¼Œè¿™é‡Œä»ç„¶å­˜åœ¨ä¸€ä¸ªæ½œåœ¨çš„æ¼æ´ï¼šå½“çº¿ç¨‹ä»å®ƒçš„ <code>ThreadAbortException</code> å±•å¼€æ—¶ï¼Œä¸å¯ä¿¡ä»£ç å¯æ‰§è¡Œ <code>catch</code> å—å’Œ <code>finally</code> å—ã€‚åœ¨è¿™äº›å—ä¸­ï¼Œä¸å¯ä¿¡ä»£ç å¯èƒ½è¿›å…¥æ­»å¾ªç¯ï¼Œé˜»æ­¢å®¿ä¸»é‡æ–°è·å–çº¿ç¨‹çš„æ§åˆ¶æƒã€‚å®¿ä¸»åº”ç”¨ç¨‹åºé€šè¿‡è®¾ç½®ä¸€ä¸ªå‡çº§ç­–ç•¥ (å‰é¢å·²è¿›è¡Œäº†è®¨è®º) æ¥ä¿®æ­£è¿™ä¸ªé—®é¢˜ã€‚è¦ç»ˆæ­¢çš„çº¿ç¨‹åœ¨åˆç†çš„æ—¶é—´å†…æ²¡æœ‰å®Œæˆï¼ŒCLR å¯å°†çº¿ç¨‹çš„ç»ˆæ­¢æ–¹å¼å‡çº§æˆ â€œç²—é²â€ çš„çº¿ç¨‹ç»ˆæ­¢ã€â€œç²—é²â€ çš„ AppDomain å¸è½½ã€ç¦ç”¨ CLR æˆ–è€…å¹²è„†æ€æ­»æ•´ä¸ªè¿›ç¨‹ã€‚è¿˜è¦æ³¨æ„ï¼Œä¸å¯ä¿¡ä»£ç å¯æ•æ‰ <code>ThreadAbortException</code> ï¼Œå¹¶åœ¨ <code>catch</code> å—ä¸­æŠ›å‡ºå…¶ä»–ç§ç±»çš„ä¸€ä¸ªå¼‚å¸¸ã€‚å¦‚æœè¿™ä¸ªå…¶ä»–çš„å¼‚å¸¸æ•æ‰åˆ°ï¼ŒCLR ä¼šåœ¨ <code>catch</code> å—çš„å°¾éƒ¨è‡ªåŠ¨é‡æ–°æŠ›å‡º <code>ThreadAbortException</code> å¼‚å¸¸ã€‚</p><p>ğŸ’¡å°ç»“ï¼š <code>System.AppDomainManager</code> ç±»å…è®¸å®¿ä¸»ä½¿ç”¨æ‰˜ç®¡ä»£ç  (è€Œä¸æ˜¯éæ‰˜ç®¡ä»£ç ) è¦†ç›– CLR çš„é»˜è®¤è¡Œä¸ºã€‚å½“ç„¶ï¼Œä½¿ç”¨æ‰˜ç®¡ä»£ç ä½¿å®¿ä¸»çš„å®ç°å˜å¾—æ›´å®¹æ˜“ã€‚ä½ å”¯ä¸€è¦åšçš„å°±æ˜¯å®šä¹‰è‡ªå·±çš„ç±»ï¼Œè®©å®ƒä» <code>System.AppDomainManager</code> æ´¾ç”Ÿï¼Œé‡å†™æƒ³æ¥æ‰‹æ§åˆ¶çš„ä»»ä½•è™šæ–¹æ³•ã€‚ç„¶åï¼Œåœ¨ä¸“ç”¨çš„ç¨‹åºé›†ä¸­ç”Ÿæˆç±»ï¼Œå¹¶å°†ç¨‹åºé›†å®‰è£…åˆ° GAC ä¸­ã€‚è¿™æ˜¯ç”±äºè¯¥ç¨‹åºé›†éœ€è¦è¢«æˆäºˆå®Œå…¨ä¿¡ä»»æƒé™ï¼Œè€Œ GAC ä¸­çš„æ‰€æœ‰ç¨‹åºé›†éƒ½æ€»æ˜¯è¢«æˆäºˆå®Œå…¨ä¿¡ä»»æƒé™ã€‚ <code>AppDomainManager</code> æ´¾ç”Ÿç±»çš„ä½œç”¨æ˜¯ä½¿å®¿ä¸»ä¿æŒæ§åˆ¶æƒï¼Œå³ä½¿æ˜¯åœ¨åŠ è½½é¡¹ (add-in) è¯•å›¾åˆ›å»ºè‡ªå·±çš„ AppDomain æ—¶ã€‚è¿›ç¨‹ä¸­çš„ä»£ç è¯•å›¾åˆ›å»ºæ–° AppDomain æ—¶ï¼Œé‚£ä¸ª AppDomain ä¸­çš„ <code>AppDomainManager</code> æ´¾ç”Ÿå¯¹è±¡å¯ä¿®æ”¹å®‰å…¨æ€§å’Œé…ç½®è®¾ç½®ã€‚å®ƒè¿˜å¯å†³å®šé˜»æ­¢ä¸€æ¬¡ AppDomain åˆ›å»ºï¼Œæˆ–è¿”å›å¯¹ç°æœ‰ AppDomain çš„å¼•ç”¨ã€‚æ–° AppDomain åˆ›å»ºå¥½ä¹‹åï¼ŒCLR ä¼šåœ¨å…¶ä¸­åˆ›å»ºæ–°çš„ <code>AppDomainManager</code> æ´¾ç”Ÿå¯¹è±¡ã€‚æ–° AppDomain åˆ›å»ºå¥½ä¹‹åï¼ŒCLR ä¼šåœ¨å…¶ä¸­åˆ›å»ºæ–°çš„ <code>AppDomainManager</code> æ´¾ç”Ÿå¯¹è±¡ã€‚è¿™ä¸ªå¯¹è±¡ä¹Ÿèƒ½ä¿®æ”¹é…ç½®è®¾ç½®ã€å†³å®šæ‰§è¡Œä¸Šä¸‹æ–‡å¦‚ä½•åœ¨çº¿ç¨‹ä¹‹é—´åˆ‡æ¢ï¼Œå¹¶å†³å®šå‘ç¨‹åºé›†æˆäºˆçš„æƒé™ã€‚æ‰˜ç®¡ä»£ç å‡ºç°é”™è¯¯æ—¶ï¼Œå®¿ä¸»å¯å‘Šè¯‰ CLR é‡‡å–ä»€ä¹ˆè¡ŒåŠ¨ã€‚ä¾‹å¦‚ï¼Œå¦‚æœçº¿ç¨‹æ‰§è¡Œæ—¶é—´è¿‡é•¿ï¼ŒCLR å¯ç»ˆæ­¢çº¿ç¨‹å¹¶è¿”å›ä¸€ä¸ªå“åº”ã€‚CLR å¯å¸è½½ AppDomainã€‚è¿™ä¼šç»ˆæ­¢è¯¥ AppDomain ä¸­çš„æ‰€æœ‰çº¿ç¨‹ï¼Œå¯¼è‡´æœ‰é—®é¢˜çš„ä»£ç å¸è½½ã€‚CLR å¯è¢«ç¦ç”¨ã€‚è¿™ä¼šé˜»æ­¢æ›´å¤šçš„æ‰˜ç®¡ä»£ç åœ¨ç¨‹åºä¸­è¿è¡Œï¼Œä½†ä»ç„¶å…è®¸éæ‰˜ç®¡ä»£ç è¿è¡Œã€‚CLR å¯é€€å‡º Windows è¿›ç¨‹ã€‚é¦–å…ˆä¼šç»ˆæ­¢æ‰€æœ‰çº¿ç¨‹ï¼Œå¹¶å¸è½½æ‰€æœ‰ AppDomainï¼Œä½¿èµ„æºæ¸…ç†æ“ä½œå¾—ä»¥æ‰§è¡Œï¼Œç„¶åæ‰ä¼šç»ˆæ­¢è¿›ç¨‹ã€‚CLR å¯ä»¥å¾—ä½“åœ° (gracefully) æˆ–è€…ç²—é²åœ° (rudely) ç»ˆæ­¢çº¿ç¨‹æˆ– AppDomainã€‚å¾—ä½“æ„å‘³ç€ä¼šæ‰§è¡Œ (èµ„æº) æ¸…ç†ä»£ç ã€‚æ¢è¨€ä¹‹ï¼Œ <code>finally</code> å—ä¸­çš„ä»£ç ä¼šè¿è¡Œï¼Œå¯¹è±¡çš„ <code>Finalize</code> æ–¹æ³•ä¹Ÿå°†è¢«æ‰§è¡Œã€‚è€Œç²—é²æ„å‘³ç€æ¸…ç†ä»£ç ä¸ä¼šæ‰§è¡Œã€‚æ¢è¨€ä¹‹ï¼Œ <code>finally</code> å—ä¸­çš„ä»£ç å¯èƒ½ä¸ä¼šè¿è¡Œï¼Œå¯¹è±¡çš„ <code>Finalize</code> æ–¹æ³•ä¹Ÿå¯èƒ½ä¸ä¼šæ‰§è¡Œã€‚å¦‚æœå¾—ä½“åœ°ç»ˆæ­¢ï¼Œå½“å‰æ­£åœ¨ä¸€ä¸ª <code>catch</code> å—æˆ– <code>finally</code> å—ä¸­çš„çº¿ç¨‹ã€‚é—æ†¾çš„æ˜¯ï¼Œéæ‰˜ç®¡ä»£ç æˆ–è€…çº¦æŸæ‰§è¡ŒåŒº (Constrained Execution Regionï¼ŒCER) ä¸­çš„çº¿ç¨‹å®Œå…¨æ— æ³•ç»ˆæ­¢ã€‚å®¿ä¸»å¯è®¾ç½®æ‰€è°“çš„å‡çº§ç­–ç•¥ (escalation policy)ï¼Œä»è€Œå‘Šè¯‰ CLR åº”è¯¥å¦‚ä½•å¤„ç†æ‰˜ç®¡ä»£ç çš„é”™è¯¯ã€‚çº¿ç¨‹åœ¨ä¸´ç•ŒåŒºæ—¶ï¼ŒCLR è®¤ä¸ºçº¿ç¨‹è®¿é—®çš„æ•°æ®æ˜¯ç”±åŒä¸€ä¸ª AppDomain ä¸­çš„å¤šä¸ªçº¿ç¨‹å…±äº«çš„ã€‚æ¯•ç«Ÿï¼Œè¿™æ‰æ˜¯å¯¼è‡´çº¿ç¨‹è·‘å»è·å–ä¸€ä¸ªé”çš„åŸå› ã€‚ç›´æ¥ç»ˆæ­¢æ­£åœ¨è®¿é—®å…±äº«æ•°æ®çš„çº¿ç¨‹æ˜¯ä¸åˆé€‚çš„ï¼Œå› ä¸ºå…¶ä»–çº¿ç¨‹éšåå¾—åˆ°çš„å°±å¯èƒ½æ˜¯å·²æŸåçš„æ•°æ®ï¼Œé€ æˆ AppDomain çš„è¿è¡Œå˜å¾—æ— æ³•é¢„æµ‹ï¼Œç”šè‡³å¯èƒ½ç•™ä¸‹å®‰å…¨éšæ‚£ã€‚æ‰€ä»¥ï¼Œä½äºä¸´ç•ŒåŒºçš„çº¿ç¨‹é­é‡æœªå¤„ç†çš„å¼‚å¸¸æ—¶ï¼ŒCLR é¦–å…ˆå°è¯•å°†å¼‚å¸¸å‡çº§æˆä¸€æ¬¡å¾—ä½“çš„ AppDomain å¸è½½ï¼Œä»è€Œæ‘†è„± (æ¸…ç†) å½“å‰æ­£åœ¨è¿™ä¸ª AppDomain ä¸­çš„æ‰€æœ‰çº¿ç¨‹ä»¥åŠå½“å‰æ­£åœ¨ä½¿ç”¨çš„æ•°æ®å¯¹è±¡ã€‚å¦‚æœ AppDomain æœªèƒ½åœ¨æŒ‡å®šæ—¶é—´å†…å¸è½½ï¼ŒCLR å°±å°†å¾—ä½“çš„ AppDomain å¸è½½å‡çº§æˆç²—é²çš„ AppDomain å¸è½½ã€‚</p><div class="tags"><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> è¯»ä¹¦ç¬”è®°</a> <a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C#</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2023-02-03 18:58:55" itemprop="dateModified" datetime="2023-02-03T18:58:55+08:00">2023-02-03</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(ï¿£â–½ï¿£)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Sakupinera WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Sakupinera Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Sakupinera PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Sakupinera <i class="ic i-at"><em>@</em></i>Sakupinera</li><li class="link"><strong>Post link: </strong><a href="http://sakupinera.github.io/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/" title="CLR via C# - Chapter 22 CLR Hosting and AppDomains">http://sakupinera.github.io/2022/11/28/csharp/clr-via-csharp/Chapter 22 CLR Hosting and AppDomains/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicivghyooj20zk0m8dir.jpg" title="CLR via C# - Chapter 21 The Managed Heap and Garbage  Collection"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 21 The Managed Heap and Garbage Collection</h3></a></div><div class="item right"><a href="/2022/11/29/csharp/clr-via-csharp/Chapter%2023%20Assembly%20Loading%20and%20Reflection/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclil3m4ej20zk0m8tn8.jpg" title="CLR via C# - Chapter 23 Assembly Loading and Reflection"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 23 Assembly Loading and Reflection</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-22-clr-hosting-and-appdomains"><span class="toc-number">1.</span> <span class="toc-text">Chapter 22 CLR Hosting and AppDomains</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#clr-hosting"><span class="toc-number">1.1.</span> <span class="toc-text">CLR Hosting</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#appdomains"><span class="toc-number">1.2.</span> <span class="toc-text">AppDomains</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#accessing-objects-across-appdomain-boundaries"><span class="toc-number">1.2.1.</span> <span class="toc-text">Accessing Objects Across AppDomain Boundaries</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#demo-1-cross-appdomain-communication-using-marshal-by-reference"><span class="toc-number">1.2.2.</span> <span class="toc-text">Demo #1: Cross-AppDomain Communication Using Marshal-by-Reference</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#demo-2-cross-appdomain-communication-using-marshal-by-value"><span class="toc-number">1.2.3.</span> <span class="toc-text">Demo #2: Cross-AppDomain Communication Using Marshal-by-Value</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#demo-3-cross-appdomain-communication-using-non-marshalable-types"><span class="toc-number">1.2.4.</span> <span class="toc-text">Demo #3: Cross-AppDomain Communication Using Non-Marshalable Types</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#appdomain-unloading"><span class="toc-number">1.3.</span> <span class="toc-text">AppDomain Unloading</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#appdomain-monitoring"><span class="toc-number">1.4.</span> <span class="toc-text">AppDomain Monitoring</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#appdomain-first-chance-exception-notifications"><span class="toc-number">1.5.</span> <span class="toc-text">AppDomain First-Chance Exception Notifications</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#how-hosts-use-appdomains"><span class="toc-number">1.6.</span> <span class="toc-text">How Hosts Use AppDomains</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#executable-applications"><span class="toc-number">1.6.1.</span> <span class="toc-text">Executable Applications</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#microsoft-silverlight-rich-internet-applications"><span class="toc-number">1.6.2.</span> <span class="toc-text">Microsoft Silverlight Rich Internet Applications</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#microsoft-aspnet-and-xml-web-services-applications"><span class="toc-number">1.6.3.</span> <span class="toc-text">Microsoft ASP.NET and XML Web Services Applications</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#microsoft-sql-server"><span class="toc-number">1.6.4.</span> <span class="toc-text">Microsoft SQL Server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#your-own-imagination"><span class="toc-number">1.6.5.</span> <span class="toc-text">Your Own Imagination</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#advanced-host-control"><span class="toc-number">1.7.</span> <span class="toc-text">Advanced Host Control</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#managing-the-clr-by-using-managed-code"><span class="toc-number">1.7.1.</span> <span class="toc-text">Managing the CLR by Using Managed Code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#writing-a-robust-host-application"><span class="toc-number">1.7.2.</span> <span class="toc-text">Writing a Robust Host Application</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#how-a-host-gets-its-thread-back"><span class="toc-number">1.7.3.</span> <span class="toc-text">How a Host Gets Its Thread Back</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"><ul><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/" rel="bookmark" title="CLR via C# - Chapter 1 The CLRâ€™s Execution Model">CLR via C# - Chapter 1 The CLRâ€™s Execution Model</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/" rel="bookmark" title="CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types">CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%203%20Shared%20Assemblies%20and%20Strongly%20Named%20Assemblies/" rel="bookmark" title="CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies">CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies</a></li><li><a href="/2022/09/27/csharp/clr-via-csharp/Chapter%204%20Type%20Fundamentals/" rel="bookmark" title="CLR via C# - Chapter 4 Type Fundamentals">CLR via C# - Chapter 4 Type Fundamentals</a></li><li><a href="/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/" rel="bookmark" title="CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals">CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals</a></li><li><a href="/2022/10/21/csharp/clr-via-csharp/Chapter%206%20Type%20and%20Member%20Basics/" rel="bookmark" title="CLR via C# - Chapter 6 Type and Member Basics">CLR via C# - Chapter 6 Type and Member Basics</a></li><li><a href="/2022/10/24/csharp/clr-via-csharp/Chapter%207%20Constants%20and%20Fields/" rel="bookmark" title="CLR via C# - Chapter 7 Constants and Fields">CLR via C# - Chapter 7 Constants and Fields</a></li><li><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" rel="bookmark" title="CLR via C# - Chapter 8 Methods">CLR via C# - Chapter 8 Methods</a></li><li><a href="/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/" rel="bookmark" title="CLR via C# - Chapter 9 Parameters">CLR via C# - Chapter 9 Parameters</a></li><li><a href="/2022/10/28/csharp/clr-via-csharp/Chapter%2010%20Properties/" rel="bookmark" title="CLR via C# - Chapter 10 Properties">CLR via C# - Chapter 10 Properties</a></li><li><a href="/2022/10/29/csharp/clr-via-csharp/Chapter%2011%20Events/" rel="bookmark" title="CLR via C# - Chapter 11 Events">CLR via C# - Chapter 11 Events</a></li><li><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" rel="bookmark" title="CLR via C# - Chapter 12 Generics">CLR via C# - Chapter 12 Generics</a></li><li><a href="/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/" rel="bookmark" title="CLR via C# - Chapter 13 Interfaces">CLR via C# - Chapter 13 Interfaces</a></li><li><a href="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/" rel="bookmark" title="CLR via C# - Chapter 14 Chars, Strings, and Working with Text">CLR via C# - Chapter 14 Chars, Strings, and Working with Text</a></li><li><a href="/2022/11/17/csharp/clr-via-csharp/Chapter%2015%20Enumerated%20Types%20and%20Bit%20Flags/" rel="bookmark" title="CLR via C# - Chapter 15 Enumerated Types and Bit Flags">CLR via C# - Chapter 15 Enumerated Types and Bit Flags</a></li><li><a href="/2022/11/19/csharp/clr-via-csharp/Chapter%2016%20Arrays/" rel="bookmark" title="CLR via C# - Chapter 16 Arrays">CLR via C# - Chapter 16 Arrays</a></li><li><a href="/2022/11/21/csharp/clr-via-csharp/Chapter%2017%20Delegates/" rel="bookmark" title="CLR via C# - Chapter 17 Delegates">CLR via C# - Chapter 17 Delegates</a></li><li><a href="/2022/11/22/csharp/clr-via-csharp/Chapter%2018%20Custom%20Attributes/" rel="bookmark" title="CLR via C# - Chapter 18 Custom Attributes">CLR via C# - Chapter 18 Custom Attributes</a></li><li><a href="/2022/11/23/csharp/clr-via-csharp/Chapter%2019%20Nullable%20Value%20Types/" rel="bookmark" title="CLR via C# - Chapter 19 Nullable Value Types">CLR via C# - Chapter 19 Nullable Value Types</a></li><li><a href="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/" rel="bookmark" title="CLR via C# - Chapter 20 Exceptions and State Management">CLR via C# - Chapter 20 Exceptions and State Management</a></li><li><a href="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/" rel="bookmark" title="CLR via C# - Chapter 21 The Managed Heap and Garbage  Collection">CLR via C# - Chapter 21 The Managed Heap and Garbage Collection</a></li><li class="active"><a href="/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/" rel="bookmark" title="CLR via C# - Chapter 22 CLR Hosting and AppDomains">CLR via C# - Chapter 22 CLR Hosting and AppDomains</a></li><li><a href="/2022/11/29/csharp/clr-via-csharp/Chapter%2023%20Assembly%20Loading%20and%20Reflection/" rel="bookmark" title="CLR via C# - Chapter 23 Assembly Loading and Reflection">CLR via C# - Chapter 23 Assembly Loading and Reflection</a></li><li><a href="/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/" rel="bookmark" title="CLR via C# - Chapter 24 Runtime Serialization">CLR via C# - Chapter 24 Runtime Serialization</a></li><li><a href="/2022/12/06/csharp/clr-via-csharp/Chapter%2025%20Interoperating%20with%20WinRT%20%20Components/" rel="bookmark" title="CLR via C# - Chapter 25 Interoperating with WinRT Components">CLR via C# - Chapter 25 Interoperating with WinRT Components</a></li><li><a href="/2023/02/06/csharp/clr-via-csharp/Chapter%2026%20Thread%20Basics/" rel="bookmark" title="CLR via C# - Chapter 26 Thread Basics">CLR via C# - Chapter 26 Thread Basics</a></li><li><a href="/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations">CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations</a></li><li><a href="/2023/02/08/csharp/clr-via-csharp/Chapter%2028%20IO-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 28 IO-Bound Asynchronous Operations">CLR via C# - Chapter 28 IO-Bound Asynchronous Operations</a></li><li><a href="/2023/02/09/csharp/clr-via-csharp/Chapter%2029%20Primitive%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 29 Primitive Thread Synchronization">CLR via C# - Chapter 29 Primitive Thread Synchronization</a></li><li><a href="/2023/02/10/csharp/clr-via-csharp/Chapter%2030%20Hybrid%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 30 Hybrid Thread Synchronization">CLR via C# - Chapter 30 Hybrid Thread Synchronization</a></li></ul></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sakupinera" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Sakupinera</p><div class="description" itemprop="description">ä¿æŒä½ çš„å†³å¿ƒï¼</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">89</span> <span class="name">posts</span></a></div><div class="item categories"><a href="/categories/"><span class="count">17</span> <span class="name">categories</span></a></div><div class="item tags"><a href="/tags/"><span class="count">8</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nha3VwaW5lcmE=" title="https:&#x2F;&#x2F;github.com&#x2F;sakupinera"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQwNzIyOTA3MQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;407229071"><i class="ic i-cloud-music"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMjIzMDczOTg/c3BtX2lkX2Zyb209MzMzLjEwMDcuMC4w" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;22307398?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li><li class="item"><a href="/games/" rel="section"><i class="ic i-flag"></i>games</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-person"></i>About</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/11/29/csharp/clr-via-csharp/Chapter%2023%20Assembly%20Loading%20and%20Reflection/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2022/12/10/cpp/cpp-primer/Chapter%202%20Variables%20and%20Basic%20Types/" title="C++ Primer - Chapter 2 Variables and Basic Types">C++ Primer - Chapter 2 Variables and Basic Types</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2023/01/03/cpp/cpp-primer/Chapter%2011%20Associative%20Containers/" title="C++ Primer - Chapter 11 Associative Containers">C++ Primer - Chapter 11 Associative Containers</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CSharp-in-a-Nutshell/" title="In CSharp-in-a-Nutshell">CSharp-in-a-Nutshell</a></div><span><a href="/2022/08/29/csharp/csharp-in-a-nutshell/%E7%AC%AC3%E7%AB%A0%20%E5%9C%A8CSharp%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%9E%8B/" title="C# in a Nutshell - ç¬¬3ç«  åœ¨C#ä¸­åˆ›å»ºç±»å‹">C# in a Nutshell - ç¬¬3ç«  åœ¨C#ä¸­åˆ›å»ºç±»å‹</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/UnityShader/" title="In UnityShader">UnityShader</a></div><span><a href="/2022/09/19/computer-graphics/unityshader/%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/" title="UnityShader - æ¸²æŸ“æµæ°´çº¿">UnityShader - æ¸²æŸ“æµæ°´çº¿</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CSharp-in-a-Nutshell/" title="In CSharp-in-a-Nutshell">CSharp-in-a-Nutshell</a></div><span><a href="/2022/08/30/csharp/csharp-in-a-nutshell/%E7%AC%AC8%E7%AB%A0%20LINQ%E6%9F%A5%E8%AF%A2/" title="C# in a Nutshell - ç¬¬8ç«  LINQæŸ¥è¯¢">C# in a Nutshell - ç¬¬8ç«  LINQæŸ¥è¯¢</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/10/03/computer-graphics/games101/%E5%87%A0%E4%BD%95/" title="GAMES101 - Geometryï¼ˆå‡ ä½•ï¼‰">GAMES101 - Geometryï¼ˆå‡ ä½•ï¼‰</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/" title="CLR via C# - Chapter 22 CLR Hosting and AppDomains">CLR via C# - Chapter 22 CLR Hosting and AppDomains</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/22/csharp/clr-via-csharp/Chapter%2018%20Custom%20Attributes/" title="CLR via C# - Chapter 18 Custom Attributes">CLR via C# - Chapter 18 Custom Attributes</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/" title="CLR via C# - Chapter 13 Interfaces">CLR via C# - Chapter 13 Interfaces</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/10/14/computer-graphics/games101/%E6%9D%90%E8%B4%A8%E4%B8%8E%E5%A4%96%E8%A7%82/" title="GAMES101 - Materials and Appearancesï¼ˆæè´¨ä¸å¤–è§‚ï¼‰">GAMES101 - Materials and Appearancesï¼ˆæè´¨ä¸å¤–è§‚ï¼‰</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 â€“ <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Sakupinera @ Hanamai Sora</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="Symbols count total">2.2m words</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="Reading time total">34:05</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/11/28/csharp/clr-via-csharp/Chapter 22 CLR Hosting and AppDomains/",favicon:{show:"ï¼ˆâ—Â´3ï½€â—ï¼‰Goooood",hide:"(Â´Ğ”ï½€)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/shifuku.model.json"},display:{position:"left",width:250,height:500},mobile:{show:!1},react:{opacity:.9},log:!1})</script></body></html>