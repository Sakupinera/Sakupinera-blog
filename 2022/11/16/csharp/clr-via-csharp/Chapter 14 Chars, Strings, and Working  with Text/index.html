<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sakupinera" href="http://sakupinera.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sakupinera" href="http://sakupinera.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sakupinera" href="http://sakupinera.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="读书笔记,C#"><link rel="canonical" href="http://sakupinera.github.io/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/"><title>CLR via C# - Chapter 14 Chars, Strings, and Working with Text - CLR-via-CSharp - CSharp | Hanamai Sora = Sakupinera</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">CLR via C# - Chapter 14 Chars, Strings, and Working with Text</h1><div class="meta"><span class="item" title="Created: 2022-11-16 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2022-11-16T00:00:00+08:00">2022-11-16</time> </span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">Symbols count in article</span> <span>96k</span> <span class="text">words</span> </span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">Reading time</span> <span>1:27</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hanamai Sora</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipexj2jgzj20zk0m8b09.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gicljitigmj20zk0m87fp.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipev1x5e4j20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipewr8iypj20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipey0a334j20zk0m8qpt.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclh3brzpj20zk0m8ann.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/" itemprop="item" rel="index" title="In CSharp"><span itemprop="name">CSharp</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/CLR-via-CSharp/" itemprop="item" rel="index" title="In CLR-via-CSharp"><span itemprop="name">CLR-via-CSharp</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://sakupinera.github.io/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Sakupinera"><meta itemprop="description" content=", 保持你的决心！"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakupinera"></span><div class="body md" itemprop="articleBody"><h1 id="chapter-14-chars-strings-and-working-with-text"><a class="anchor" href="#chapter-14-chars-strings-and-working-with-text">#</a> Chapter 14 Chars, Strings, and Working with Text</h1><h2 id="characters"><a class="anchor" href="#characters">#</a> Characters</h2><blockquote><p>In the .NET Framework, characters are always represented in 16-bit Unicode code values, easing the development of global applications. A character is represented with an instance of the <code>System.Char</code> structure (a value type). The <code>System.Char</code> type is pretty simple. It offers two public read-only constant fields: <code>MinValue</code> , defined as '\0', and <code>MaxValue</code> , defined as '\uffff'.</p></blockquote><blockquote><p>Given an instance of a Char, you can call the static <code>GetUnicodeCategory</code> method, which returns a value of the <code>System.Globalization.UnicodeCategory</code> enumerated type. This value indicates whether the character is a control character, a currency symbol, a lowercase letter, an uppercase letter, a punctuation character, a math symbol, or another character (as defined by the Unicode standard).</p></blockquote><blockquote><p>To ease developing, the Char type also offers several static methods, such as <code>IsDigit</code> , <code>IsLetter</code> , <code>IsWhiteSpace</code> , <code>IsUpper</code> , <code>IsLower</code> , <code>IsPunctuation</code> , <code>IsLetterOrDigit</code> , <code>IsControl</code> , <code>IsNumber</code> , <code>IsSeparator</code> , <code>IsSurrogate</code> , <code>IsLowSurrogate</code> , <code>IsHighSurrogate</code> , and <code>IsSymbol</code> . Most of these methods call <code>GetUnicodeCategory</code> internally and simply return true or false accordingly. Note that all of these methods take either a single character for a parameter or a String and the index of a character within the String as parameters.</p></blockquote><blockquote><p>In addition, you can convert a single character to its lowercase or uppercase equivalent in a culture-agnostic way by calling the static <code>ToLowerInvariant</code> or <code>ToUpperInvariant</code> method. Alternatively, the <code>ToLower</code> and <code>ToUpper</code> methods convert the character by using the culture information associated with the calling thread (which the methods obtain internally by querying the static <code>CurrentCulture</code> property of the <code>System.Globalization.CultureInfo</code> class). You can also specify a particular culture by passing an instance of the <code>CultureInfo</code> class to these methods. <code>ToLower</code> and <code>ToUpper</code> require culture information because letter casing is a culture-dependent operation. For example, Turkish considers the uppercase of U+0069 (LATIN LOWERCASE LETTER I) to be U+0130 (LATIN UPPERCASE LETTER I WITH DOT ABOVE), whereas other cultures consider the result to be U+0049 (LATIN CAPITAL LETTER I).</p></blockquote><blockquote><p>Besides these static methods, the Char type also offers a few instance methods of its own. The Equals method returns true if two Char instances represent the same 16-bit Unicode code point. The <code>CompareTo</code> methods (defined by the <code>IComparable</code> / <code>IComparable</code> interfaces) return a comparison of two Char instances; this comparison is not culture-sensitive. The ConvertFromUtf32 method produces a string consisting of one or two UTF-16 characters from a single UTF-32 character. The ConvertToUtf32 produces a UTF-32 character from a low/high surrogate pair or from a string. The <code>ToString</code> method returns a String consisting of a single character. The opposite of <code>ToString</code> is <code>Parse</code> / <code>TryParse</code> , which takes a single-character String and returns its UTF-16 code point.</p></blockquote><blockquote><p>The last method, <code>GetNumericValue</code> , returns the numeric equivalent of a character. I demonstrate this method in the following code.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">Double</span> d<span class="token punctuation">;</span> <span class="token comment">// '\u0033' is the "digit 3" </span></pre></td></tr><tr><td data-num="5"></td><td><pre> d <span class="token operator">=</span> Char<span class="token punctuation">.</span><span class="token function">GetNumericValue</span><span class="token punctuation">(</span><span class="token char">'\u0033'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// '3' would work too </span></pre></td></tr><tr><td data-num="6"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "3" </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// '\u00bc' is the "vulgar fraction one quarter ('¼')" </span></pre></td></tr><tr><td data-num="8"></td><td><pre> d <span class="token operator">=</span> Char<span class="token punctuation">.</span><span class="token function">GetNumericValue</span><span class="token punctuation">(</span><span class="token char">'\u00bc'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "0.25" </span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// 'A' is the "Latin capital letter A" </span></pre></td></tr><tr><td data-num="11"></td><td><pre> d <span class="token operator">=</span> Char<span class="token punctuation">.</span><span class="token function">GetNumericValue</span><span class="token punctuation">(</span><span class="token char">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "-1" </span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Finally, three techniques allow you to convert between various numeric types to Char instances and vice versa. The techniques are listed here in order of preference:</p><ul><li><p>Casting The easiest way to convert a Char to a numeric value such as an Int32 is simply by casting. Of the three techniques, this is the most efficient because the compiler emits Intermediate Language (IL) instructions to perform the conversion, and no methods have to be called. In addition, some languages (such as C#) allow you to indicate whether the conversion should be performed using checked or unchecked code (discussed in Chapter 5, “Primitive, Reference, and Value Types”).</p></li><li><p>Use the Convert type The <code>System.Convert</code> type offers several static methods that are capable of converting a Char to a numeric type and vice versa. All of these methods perform the conversion as a checked operation, causing an <code>OverflowException</code> to be thrown if the conversion results in the loss of data.</p></li><li><p>Use the <code>IConvertible</code> interface The Char type and all of the numeric types in the .NET Framework Class Library (FCL) implement the <code>IConvertible</code> interface. This interface defines methods such as ToUInt16 and <code>ToChar</code> . This technique is the least efficient of the three because calling an interface method on a value type requires that the instance be boxed— Char and all of the numeric types are value types. The methods of <code>IConvertible</code> throw a <code>System.InvalidCastException</code> if the type can’t be converted (such as converting a Char to a Boolean) or if the conversion results in a loss of data. Note that many types (including the FCL’s Char and numeric types) implement <code>IConvertible</code> ’s methods as explicit interface member implementations (described in Chapter 13, “Interfaces”). This means that you must explicitly cast the instance to an <code>IConvertible</code> before you can call any of the interface’s methods. All of the methods of <code>IConvertible</code> except <code>GetTypeCode</code> accept a reference to an object that implements the <code>IFormatProvider</code> interface. This parameter is useful if for some reason the conversion needs to take culture information into account. For most conversions, you can pass null for this parameter because it would be ignored anyway.</p></li></ul></blockquote><blockquote><p>The following code demonstrates how to use these three techniques.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">Char</span> c<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token class-name">Int32</span> n<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Convert number &lt;-> character using C# casting </span></pre></td></tr><tr><td data-num="7"></td><td><pre> c <span class="token operator">=</span> <span class="token punctuation">(</span>Char<span class="token punctuation">)</span> <span class="token number">65</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "A" </span></pre></td></tr><tr><td data-num="9"></td><td><pre> n <span class="token operator">=</span> <span class="token punctuation">(</span>Int32<span class="token punctuation">)</span> c<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "65" </span></pre></td></tr><tr><td data-num="11"></td><td><pre> c <span class="token operator">=</span> <span class="token keyword">unchecked</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Char<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">65536</span> <span class="token operator">+</span> <span class="token number">65</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "A" </span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token comment">// Convert number &lt;-> character using Convert </span></pre></td></tr><tr><td data-num="14"></td><td><pre> c <span class="token operator">=</span> Convert<span class="token punctuation">.</span><span class="token function">ToChar</span><span class="token punctuation">(</span><span class="token number">65</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "A" </span></pre></td></tr><tr><td data-num="16"></td><td><pre> n <span class="token operator">=</span> Convert<span class="token punctuation">.</span><span class="token function">ToInt32</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "65" </span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token comment">// This demonstrates Convert's range checking </span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="20"></td><td><pre> c <span class="token operator">=</span> Convert<span class="token punctuation">.</span><span class="token function">ToChar</span><span class="token punctuation">(</span><span class="token number">70000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Too big for 16 bits </span></pre></td></tr><tr><td data-num="21"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Doesn't execute </span></pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">OverflowException</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="24"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Can't convert 70000 to a Char."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token comment">// Convert number &lt;-> character using IConvertible </span></pre></td></tr><tr><td data-num="27"></td><td><pre> c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>IConvertible<span class="token punctuation">)</span> <span class="token number">65</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToChar</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="28"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "A" </span></pre></td></tr><tr><td data-num="29"></td><td><pre> n <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>IConvertible<span class="token punctuation">)</span> c<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToInt32</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="30"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "65" </span></pre></td></tr><tr><td data-num="31"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>💡小结：<span class="exturl" data-url="aHR0cDovL3huLS0zZHMuTkVU">在.NET</span> Framework 中，字符总是表示成 16 位 Unicode 代码值，这简化了国际化应用程序的开发。可调用静态方法 <code>ToLowerInvariant</code> 或者 <code>ToUpperInvariant</code> ，以忽略语言文化（culture）的方式将字符转换为小写或大写形式。 <code>ToLower</code> 和 <code>ToUpper</code> 之所以需要语言文化信息，是因为字母的大小写转换是一种依赖于语言文化的操作。除了静态方法之外，Char 类型还有自己的实例方法。 其中， <code>Equals</code> 方法在两个 Char 实例代表同一个 16 位 Unicode 码位的前提下返回 true。（在字符编码术语中，码位或称编码位置，即英文的 code point 或 code position，是组成码空间（或代码页）的数值。例如，ASCII 码包含 128 个码位。可以使用三种技术实现各种数值类型与 Char 实例的相互转换，它们分别是：转型（强制类型转换），这种效率最高，因为编译器会生成中间语言（IL）指令来执行转换，而且不必调用方法；使用 <code>Convert</code> 类型，所有转换都以 checked 方式执行，发现转换将造成数据丢失就抛出异常；使用 <code>IConvertible</code> 接口，Char 类型和 FCL 中的所有数值类型都实现了 <code>IConvertible</code> 接口。这种效率最差，因为在值类型上调用接口方法要求对实例进行装箱 ——Char 和所有数值类型都是值类型。注意，许多类型（包括 FCL 的 Char 和数值类型）都将 <code>IConvertible</code> 的方法实现为显式接口成员。这意味着为了调用接口的任何方法，都必须先将实例显式转型为一个 <code>IConvertible</code> 。 <code>IConvertible</code> 的所有方法（ <code>GetTypeCode</code> 除外）都接受对实现了 <code>IFormatProvider</code> 接口的一个对象的引用。如果转换时需要考虑语言文化信息，该参数就很有用。但大多数时候都可以忽略语言文化，为这个参数传递 null 值。</p><h2 id="the-systemstring-type"><a class="anchor" href="#the-systemstring-type">#</a> The System.String Type</h2><blockquote><p>One of the most used types in any application is System.String. A String represents an immutable sequence of characters. The String type is derived immediately from Object, making it a reference type, and therefore, String objects (its array of characters) always live in the heap, never on a thread’s stack. The String type also implements several interfaces (IComparable/ IComparable, ICloneable, IConvertible, IEnumerable/IEnumerable, and IEquatable).</p></blockquote><h3 id="constructing-strings"><a class="anchor" href="#constructing-strings">#</a> Constructing Strings</h3><blockquote><p>Many programming languages (including C#) consider String to be a primitive type—that is, the compiler lets you express literal strings directly in your source code. The compiler places these literal strings in the module’s metadata, and they are then loaded and referenced at run time.</p></blockquote><blockquote><p>In C#, you can’t use the new operator to construct a String object from a literal string.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">String</span><span class="token punctuation">(</span><span class="token string">"Hi there."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt;-- Error </span></pre></td></tr><tr><td data-num="5"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Instead, you must use the following simplified syntax.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"Hi there."</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>If you compile this code and examine its IL (using ILDasm.exe), you’d see the following.</p></blockquote><figure class="highlight clike"><figcaption data-lang="C-like"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">.</span>method public hidebysig static void <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> cil managed </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token punctuation">.</span>entrypoint </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// Code size 13 (0xd) </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">.</span>maxstack <span class="token number">1</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">.</span>locals init <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> string s<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> IL_0000<span class="token punctuation">:</span> ldstr <span class="token string">"Hi there."</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> IL_0005<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">0</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> IL_0006<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> IL_0007<span class="token punctuation">:</span> call void <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Console<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> IL_000c<span class="token punctuation">:</span> ret </pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of method Program::Main</span></pre></td></tr></table></figure><blockquote><p>The newobj IL instruction constructs a new instance of an object. However, no newobj instruction appears in the IL code example. Instead, you see the special ldstr (load string) IL instruction, which constructs a String object by using a literal string obtained from metadata. This shows you that the common language runtime (CLR) does, in fact, have a special way of constructing literal String objects.</p></blockquote><blockquote><p>If you are using unsafe code, you can construct a String object from a Char* or SByte*. To accomplish this, you would use C#’s new operator and call one of the constructors provided by the String type that takes Char* or SByte* parameters. These constructors create a String object, initializing the string from an array of Char instances or signed bytes. The other constructors don’t have any pointer parameters and can be called using safe (verifiable) code written in any managed programming language.</p></blockquote><blockquote><p>C# offers some special syntax to help you enter literal strings into the source code. For special characters such as new lines, carriage returns, and backspaces, C# uses the escape mechanism familiar to C/C++ developers.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// String containing carriage-return and newline characters </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"Hi\r\nthere."</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>💡重要提示：上例虽然在字符串中硬编码了回车符和换行符，但一般不建议这样做。相反， <code>System.Environment</code> 类型定义了只读 <code>NewLine</code> 属性。应用程序在 Microsoft Windows 上运行时，该属性返回由回车符和换换行符构成的字符串。例如，如果将公共语言基础结构 (CLI) 移植到 UNIX 系统， <code>NewLine</code> 属性将返回由单字符 `\n‘构成的字符串。以下才是定义上述字符串的正确方式，它在任何平台上都能正确工作：</p><p><code>String s = &quot;Hi&quot; + Environment.NewLine + &quot;there.&quot;</code> ；</p><blockquote><p>You can concatenate several strings to form a single string by using C#’s + operator as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Three literal strings concatenated to form a single literal string </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"Hi"</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> <span class="token string">"there."</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>In this code, because all of the strings are literal strings, the C# compiler concatenates them at compile time and ends up placing just one string—&quot;Hi there.&quot;—in the module’s metadata. Using the + operator on nonliteral strings causes the concatenation to be performed at run time. To concatenate several strings together at run time, avoid using the + operator because it creates multiple string objects on the garbage-collected heap. Instead, use the System.Text.StringBuilder type (which I’ll explain later in this chapter).</p></blockquote><blockquote><p>Finally, C# also offers a special way to declare a string in which all characters between quotes are considered part of the string. These special declarations are called verbatim strings and are typically used when specifying the path of a file or directory or when working with regular expressions. Here is some code showing how to declare the same string with and without using the verbatim string character (@).</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Specifying the pathname of an application </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">String</span> file <span class="token operator">=</span> <span class="token string">"C:\\Windows\\System32\\Notepad.exe"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// Specifying the pathname of an application by using a verbatim string </span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token class-name">String</span> file <span class="token operator">=</span> <span class="token string">@"C:\Windows\System32\Notepad.exe"</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>You could use either one of the preceding code lines in a program because they produce identical strings in the assembly’s metadata. However, the @ symbol before the string on the second line tells the compiler that the string is a verbatim string. In effect, this tells the compiler to treat backslash characters as backslash characters instead of escape characters, making the path much more readable in your source code.</p></blockquote><blockquote><p>Now that you’ve seen how to construct a string, let’s talk about some of the operations you can perform on String objects.</p></blockquote><h3 id="strings-are-immutable"><a class="anchor" href="#strings-are-immutable">#</a> Strings Are Immutable</h3><blockquote><p>The most important thing to know about a String object is that it is immutable. That is, once created, a string can never get longer, get shorter, or have any of its characters changed. Having immutable strings offers several benefits. First, it allows you to perform operations on a string without actually changing the string.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">ToUpperInvariant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Substring</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">EndsWith</span><span class="token punctuation">(</span><span class="token string">"EXE"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token range operator">..</span><span class="token punctuation">.</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Here, ToUpperInvariant returns a new string; it doesn’t modify the characters of the string s. Substring operates on the string returned by ToUpperInvariant and also returns a new string, which is then examined by EndsWith. The two temporary strings created by ToUpperInvariant and Substring are not referenced for long by the application code, and the garbage collector will reclaim their memory at the next collection. If you perform a lot of string manipulations, you end up creating a lot of String objects on the heap, which causes more frequent garbage collections, thus hurting your application’s performance.</p></blockquote><blockquote><p>Having immutable strings also means that there are no thread synchronization issues when manipulating or accessing a string. In addition, it’s possible for the CLR to share multiple identical String contents through a single String object. This can reduce the number of strings in the system—thereby conserving memory usage—and it is what string interning (discussed later in the chapter) is all about.</p></blockquote><blockquote><p>For performance reasons, the String type is tightly integrated with the CLR. Specifically, the CLR knows the exact layout of the fields defined within the String type, and the CLR accesses these fields directly. This performance and direct access come at a small development cost: the String class is sealed, which means that you cannot use it as a base class for your own type. If you were able to define your own type, using String as a base type, you could add your own fields, which would break the CLR’s assumptions. In addition, you could break some assumptions that the CLR team has made about String objects being immutable.</p></blockquote><h3 id="comparing-strings"><a class="anchor" href="#comparing-strings">#</a> Comparing Strings</h3><blockquote><p>Comparing is probably the most common operation performed on strings. There are two reasons to compare two strings with each other. We compare two strings to determine equality or to sort them (usually for presentation to a user).</p></blockquote><blockquote><p>In determining string equality or when comparing strings for sorting, it is highly recommended that you call one of these methods (defined by the String class).</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token return-type class-name">Boolean</span> <span class="token function">Equals</span><span class="token punctuation">(</span><span class="token class-name">String</span> <span class="token keyword">value</span><span class="token punctuation">,</span> <span class="token class-name">StringComparison</span> comparisonType<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name">Boolean</span> <span class="token function">Equals</span><span class="token punctuation">(</span><span class="token class-name">String</span> a<span class="token punctuation">,</span> <span class="token class-name">String</span> b<span class="token punctuation">,</span> <span class="token class-name">StringComparison</span> comparisonType<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">Compare</span><span class="token punctuation">(</span><span class="token class-name">String</span> strA<span class="token punctuation">,</span> <span class="token class-name">String</span> strB<span class="token punctuation">,</span> <span class="token class-name">StringComparison</span> comparisonType<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">Compare</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> strA<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span></span> strB<span class="token punctuation">,</span> <span class="token class-name">Boolean</span> ignoreCase<span class="token punctuation">,</span> <span class="token class-name">CultureInfo</span> culture<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">Compare</span><span class="token punctuation">(</span><span class="token class-name">String</span> strA<span class="token punctuation">,</span> <span class="token class-name">String</span> strB<span class="token punctuation">,</span> <span class="token class-name">CultureInfo</span> culture<span class="token punctuation">,</span> <span class="token class-name">CompareOptions</span> options<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">Compare</span><span class="token punctuation">(</span><span class="token class-name">String</span> strA<span class="token punctuation">,</span> <span class="token class-name">Int32</span> indexA<span class="token punctuation">,</span> <span class="token class-name">String</span> strB<span class="token punctuation">,</span> <span class="token class-name">Int32</span> indexB<span class="token punctuation">,</span> <span class="token class-name">Int32</span> length<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token class-name">StringComparison</span> comparisonType<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">Compare</span><span class="token punctuation">(</span><span class="token class-name">String</span> strA<span class="token punctuation">,</span> <span class="token class-name">Int32</span> indexA<span class="token punctuation">,</span> <span class="token class-name">String</span> strB<span class="token punctuation">,</span> <span class="token class-name">Int32</span> indexB<span class="token punctuation">,</span> <span class="token class-name">Int32</span> length<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token class-name">CultureInfo</span> culture<span class="token punctuation">,</span> <span class="token class-name">CompareOptions</span> options<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">Compare</span><span class="token punctuation">(</span><span class="token class-name">String</span> strA<span class="token punctuation">,</span> <span class="token class-name">Int32</span> indexA<span class="token punctuation">,</span> <span class="token class-name">String</span> strB<span class="token punctuation">,</span> <span class="token class-name">Int32</span> indexB<span class="token punctuation">,</span> <span class="token class-name">Int32</span> length<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token class-name">Boolean</span> ignoreCase<span class="token punctuation">,</span> <span class="token class-name">CultureInfo</span> culture<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token return-type class-name">Boolean</span> <span class="token function">StartsWith</span><span class="token punctuation">(</span><span class="token class-name">String</span> <span class="token keyword">value</span><span class="token punctuation">,</span> <span class="token class-name">StringComparison</span> comparisonType<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token return-type class-name">Boolean</span> <span class="token function">StartsWith</span><span class="token punctuation">(</span><span class="token class-name">String</span> <span class="token keyword">value</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token class-name">Boolean</span> ignoreCase<span class="token punctuation">,</span> <span class="token class-name">CultureInfo</span> culture<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token return-type class-name">Boolean</span> <span class="token function">EndsWith</span><span class="token punctuation">(</span><span class="token class-name">String</span> <span class="token keyword">value</span><span class="token punctuation">,</span> <span class="token class-name">StringComparison</span> comparisonType<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token return-type class-name">Boolean</span> <span class="token function">EndsWith</span><span class="token punctuation">(</span><span class="token class-name">String</span> <span class="token keyword">value</span><span class="token punctuation">,</span> <span class="token class-name">Boolean</span> ignoreCase<span class="token punctuation">,</span> <span class="token class-name">CultureInfo</span> culture<span class="token punctuation">)</span></pre></td></tr></table></figure><blockquote><p>When sorting, you should always perform case-sensitive comparisons. The reason is that if two strings differing only by case are considered to be equal, they could be ordered differently each time you sort them; this would confuse the user.</p></blockquote><blockquote><p>The comparisonType argument (in most of the preceding methods) is one of the values defined by the StringComparison enumerated type, which is defined as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">StringComparison</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> CurrentCulture <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> CurrentCultureIgnoreCase <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> InvariantCulture <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> InvariantCultureIgnoreCase <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> Ordinal <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> OrdinalIgnoreCase <span class="token operator">=</span> <span class="token number">5</span> </pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The options argument (in two of the preceding methods) is one of the values defined by the CompareOptions enumerator type.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Flags</span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">CompareOptions</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> None <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre> IgnoreCase <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre> IgnoreNonSpace <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre> IgnoreSymbols <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre> IgnoreKanaType <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="8"></td><td><pre> IgnoreWidth <span class="token operator">=</span> <span class="token number">0x00000010</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="9"></td><td><pre> Ordinal <span class="token operator">=</span> <span class="token number">0x40000000</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="10"></td><td><pre> OrdinalIgnoreCase <span class="token operator">=</span> <span class="token number">0x10000000</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="11"></td><td><pre> StringSort <span class="token operator">=</span> <span class="token number">0x20000000</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Methods that accept a CompareOptions argument also force you to explicitly pass in a culture. When passing in the Ordinal or OrdinalIgnoreCase flag, these Compare methods ignore the specified culture.</p></blockquote><blockquote><p>Many programs use strings for internal programmatic purposes such as path names, file names, URLs, registry keys and values, environment variables, reflection, Extensible Markup Language (XML) tags, XML attributes, and so on. Often, these strings are not shown to a user and are used only within the program. When comparing programmatic strings, you should always use StringComparison.Ordinal or StringComparison.OrdinalIgnoreCase. This is the fastest way to perform a comparison that is not to be affected in any linguistic way because culture information is not taken into account when performing the comparison.</p></blockquote><blockquote><p>On the other hand, when you want to compare strings in a linguistically correct manner (usually for display to an end user), you should use StringComparison.CurrentCulture or StringComparison.CurrentCultureIgnoreCase.</p></blockquote><p>💡重要提示： <code>StringComparison.InvariantCulture</code> 和 <code>StringComparison.InvariantCultureIgnoreCase</code> 平时最好不要用。虽然这两个值保证比较时的语言文化正确性，但用来比较内部编程所需的字符串，所花的时间远超出序号比较 &lt;sup&gt;①&lt;/sup&gt;。此外，如果传递 <code>StringComparison.InvariantCulture</code> (固定语言文化)，其实就是不使用任何具体的语言文化。所以在处理要向用户显示的字符串时，选择它并不恰当。</p><p>① 传递 <code>StringComparison.Ordinal</code> 执行的就是序号比较，也就是不考虑语言文化信息，只比较字符串中的每个 <code>Char</code> 的 Unicode 码位。</p><p>💡重要提示：要在序号比较前更改字符串中的字符的大小写，应该使用 <code>String</code> 的 <code>ToUpperInvariant</code> 或 <code>ToLowerInvariant</code> 方法。强烈建议用 <code>ToUpperInvariant</code> 方法对字符串进行正规化 (normalizing)，而不要用 <code>ToLowerInvariant</code> ，因为 Microsoft 对执行大写比较的代码进行了优化。事实上，执行不区分大小写的比较之前，FCL 会自动将字符串正规化为大写形式。之所以要用 <code>ToUpperInvariant</code> 和 <code>ToLowerInvariant</code> 方法，是因为 <code>String</code> 类没有提供 <code>ToUpperOrdinal</code> 和 <code>ToLowerOrdinal</code> 方法。之所以不用 <code>ToUpper</code> 和 <code>ToLower</code> 方法，是因为它们对语言文化敏感。</p><blockquote><p>Sometimes, when you compare strings in a linguistically correct manner, you want to specify a specific culture rather than use a culture that is associated with the calling thread. In this case, you can use the overloads of the StartsWith, EndsWith, and Compare methods shown earlier, all of which take Boolean and CultureInfo arguments.</p></blockquote><p>💡重要提示：除了前面列出之外， <code>String</code> 类型还为 <code>Equals</code> ， <code>StartsWith</code> , <code>EndsWith</code> 和 <code>Compare</code> 方法定义了其他几个重载版本。但是，Microsoft 建议避免使用这些额外的版本 (也就是本书没有列出的版本)。除此之外， <code>String</code> 的其他比较方法 —— <code>CompareTo</code> ( <code>IComparable</code> 接口所要求的)、用这些方法和操作符，是因为调用者不显式指出以什么方式执行字符串比较，而你无法从方法名看出默认比较方式。例如， <code>CompareTo</code> 默认执行对语言文化敏感的比较，而 <code>Equals</code> 执行普通的序号 (ordinal) 比较。如果总是显式地指出以什么方式执行字符串比较，代码将更容易阅读和维护。</p><blockquote><p>Now, let’s talk about how to perform linguistically correct comparisons. The .NET Framework uses the System.Globalization.CultureInfo type to represent a language/country pair (as described by the RFC 1766 standard). For example, “en-US” identifies English as written in the United States, “enAU” identifies English as written in Australia, and “de-DE” identifies German as written in Germany. In the CLR, every thread has two properties associated with it. Each of these properties refers to a CultureInfo object. The two properties are:</p><ul><li><p>CurrentUICulture This property is used to obtain resources that are shown to an end user. It is most useful for GUI or Web Forms applications because it indicates the language that should be used when displaying UI elements such as labels and buttons. By default, when you create a thread, this thread property is set to a CultureInfo object, which identifies the language of the Windows version the application is running on using the Win32 GetUserDefaultUILanguage function. If you’re running a Multilingual User Interface (MUI) version of Windows, you can set this via the Regional And Language Options Control Panel Settings dialog box. On a non-MUI version of Windows, the language is determined by the localized version of the operating system installed (or the installed language pack) and the language is not changeable.</p></li><li><p>CurrentCulture This property is used for everything that CurrentUICulture isn’t used for, including number and date formatting, string casing, and string comparing. When formatting, both the language and country parts of the CultureInfo object are used. By default, when you create a thread, this thread property is set to a CultureInfo object, whose value is determined by calling the Win32 GetUserDefaultLCID method, whose value is set in the Regional And Language Control Panel applet.</p></li></ul></blockquote><blockquote><p>For the two thread properties mentioned above, you can override the default value used by the system when a new thread gets created with AppDomain defaults by setting CultureInfo’s static DefaultThreadCurrentCulture and DefaultThreadCurrentUICulture properties.</p></blockquote><blockquote><p>On many computers, a thread’s CurrentUICulture and CurrentCulture properties will be set to the same CultureInfo object, which means that they both use the same language/country information. However, they can be set differently. For example: an application running in the United States could use Spanish for all of its menu items and other GUI elements while properly displaying all of the currency and date formatting for the United States. To do this, the thread’s CurrentUICulture property should be set to a CultureInfo object initialized with a language of “es” (for Spanish), while the thread’s CurrentCulture property should be set to a CultureInfo object initialized with a language/country pair of “en-US.”</p></blockquote><blockquote><p>Internally, a CultureInfo object has a field that refers to a System.Globalization.CompareInfo object, which encapsulates the culture’s character-sorting table information as defined by the Unicode standard. The following code demonstrates the difference between performing an ordinal comparison and a culturally aware string comparison.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Globalization</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token string">"Strasse"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token string">"Straße"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token class-name">Boolean</span> eq<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// CompareOrdinal returns nonzero. </span></pre></td></tr><tr><td data-num="9"></td><td><pre> eq <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">Compare</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> StringComparison<span class="token punctuation">.</span>Ordinal<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Ordinal comparison: '&#123;0&#125;' &#123;2&#125; '&#123;1&#125;'"</span><span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> eq <span class="token punctuation">?</span> <span class="token string">"=="</span> <span class="token punctuation">:</span> <span class="token string">"!="</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// Compare Strings appropriately for people </span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token comment">// who speak German (de) in Germany (DE) </span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token class-name">CultureInfo</span> ci <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">CultureInfo</span><span class="token punctuation">(</span><span class="token string">"de-DE"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// Compare returns zero. </span></pre></td></tr><tr><td data-num="16"></td><td><pre> eq <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">Compare</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> ci<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Cultural comparison: '&#123;0&#125;' &#123;2&#125; '&#123;1&#125;'"</span><span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="18"></td><td><pre> eq <span class="token punctuation">?</span> <span class="token string">"=="</span> <span class="token punctuation">:</span> <span class="token string">"!="</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Building and running this code produces the following output.</p></blockquote><pre><code class="language-cmd">Ordinal comparison: 'Strasse' != 'Straße' 
Cultural comparison: 'Strasse' == 'Straße'
</code></pre><p>💡注意： <code>Compare</code> 方法如果执行的不是序号比较就会进行 “字符展开”(character expansion)，也就是将一个字符展开成忽视语言文化的多个字符。在前例中，德语 Eszet 字符 “ß” 总是展开成 “ss”。类似地，“Æ” 连字总是展开成 “AE”。所以在上述代码中，无论传递什么语言文化，对 <code>Compare</code> 的第二个调用始终返回 0。</p><blockquote><p>In some rare circumstances, you may need to have even more control when comparing strings for equality or for sorting. This could be necessary when comparing strings consisting of Japanese characters. This additional control can be accessed via the CultureInfo object’s CompareInfo property. As mentioned earlier, a CompareInfo object encapsulates a culture’s character comparison tables, and there is just one CompareInfo object per culture.</p></blockquote><blockquote><p>When you call String’s Compare method, if the caller specifies a culture, the specified culture is used, or if no culture is specified, the value in the calling thread’s CurrentCulture property is used. Internally, the Compare method obtains the reference to the CompareInfo object for the appropriate culture and calls the Compare method of the CompareInfo object, passing along the appropriate options (such as case insensitivity). Naturally, you could call the Compare method of a specific CompareInfo object yourself if you need the additional control.</p></blockquote><blockquote><p>The Compare method of the CompareInfo type takes as a parameter a value from the CompareOptions enumerated type (as shown earlier). You can OR these bit flags together to gain significantly greater control when performing string comparisons. For a complete description of these symbols, consult the .NET Framework documentation.</p></blockquote><blockquote><p>The following code demonstrates how important culture is to sorting strings and shows various ways of performing string comparisons.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Text</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Windows<span class="token punctuation">.</span>Forms</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Globalization</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Threading</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token class-name">String</span> output <span class="token operator">=</span> String<span class="token punctuation">.</span>Empty<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token class-name">String<span class="token punctuation">[</span><span class="token punctuation">]</span></span> symbol <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">String<span class="token punctuation">[</span><span class="token punctuation">]</span></span> <span class="token punctuation">&#123;</span> <span class="token string">"&lt;"</span><span class="token punctuation">,</span> <span class="token string">"="</span><span class="token punctuation">,</span> <span class="token string">">"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token class-name">Int32</span> x<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token class-name">CultureInfo</span> ci<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// The code below demonstrates how strings compare </span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token comment">// differently for different cultures. </span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token string">"coté"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token string">"côte"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token comment">// Sorting strings for French in France. </span></pre></td></tr><tr><td data-num="17"></td><td><pre> ci <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">CultureInfo</span><span class="token punctuation">(</span><span class="token string">"fr-FR"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="18"></td><td><pre> x <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">Sign</span><span class="token punctuation">(</span>ci<span class="token punctuation">.</span>CompareInfo<span class="token punctuation">.</span><span class="token function">Compare</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> output <span class="token operator">+=</span> String<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"&#123;0&#125; Compare: &#123;1&#125; &#123;3&#125; &#123;2&#125;"</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="20"></td><td><pre> ci<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> symbol<span class="token punctuation">[</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="21"></td><td><pre> output <span class="token operator">+=</span> Environment<span class="token punctuation">.</span>NewLine<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token comment">// Sorting strings for Japanese in Japan. </span></pre></td></tr><tr><td data-num="23"></td><td><pre> ci <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">CultureInfo</span><span class="token punctuation">(</span><span class="token string">"ja-JP"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="24"></td><td><pre> x <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">Sign</span><span class="token punctuation">(</span>ci<span class="token punctuation">.</span>CompareInfo<span class="token punctuation">.</span><span class="token function">Compare</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="25"></td><td><pre> output <span class="token operator">+=</span> String<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"&#123;0&#125; Compare: &#123;1&#125; &#123;3&#125; &#123;2&#125;"</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="26"></td><td><pre> ci<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> symbol<span class="token punctuation">[</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="27"></td><td><pre> output <span class="token operator">+=</span> Environment<span class="token punctuation">.</span>NewLine<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="28"></td><td><pre> <span class="token comment">// Sorting strings for the thread's culture </span></pre></td></tr><tr><td data-num="29"></td><td><pre> ci <span class="token operator">=</span> Thread<span class="token punctuation">.</span>CurrentThread<span class="token punctuation">.</span>CurrentCulture<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="30"></td><td><pre> x <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">Sign</span><span class="token punctuation">(</span>ci<span class="token punctuation">.</span>CompareInfo<span class="token punctuation">.</span><span class="token function">Compare</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="31"></td><td><pre> output <span class="token operator">+=</span> String<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"&#123;0&#125; Compare: &#123;1&#125; &#123;3&#125; &#123;2&#125;"</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="32"></td><td><pre> ci<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> symbol<span class="token punctuation">[</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="33"></td><td><pre> output <span class="token operator">+=</span> Environment<span class="token punctuation">.</span>NewLine <span class="token operator">+</span> Environment<span class="token punctuation">.</span>NewLine<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="34"></td><td><pre> <span class="token comment">// The code below demonstrates how to use CompareInfo.Compare's </span></pre></td></tr><tr><td data-num="35"></td><td><pre> <span class="token comment">// advanced options with 2 Japanese strings. One string represents </span></pre></td></tr><tr><td data-num="36"></td><td><pre> <span class="token comment">// the word "shinkansen" (the name for the Japanese high-speed </span></pre></td></tr><tr><td data-num="37"></td><td><pre> <span class="token comment">// train) in hiragana (one subtype of Japanese writing), and the </span></pre></td></tr><tr><td data-num="38"></td><td><pre> <span class="token comment">// other represents the same word in katakana (another subtype of </span></pre></td></tr><tr><td data-num="39"></td><td><pre> <span class="token comment">// Japanese writing). </span></pre></td></tr><tr><td data-num="40"></td><td><pre> s1 <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span> <span class="token comment">// ("\u3057\u3093\u304B\u3093\u305b\u3093")</span></pre></td></tr><tr><td data-num="41"></td><td><pre> s2 <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span> <span class="token comment">// ("\u30b7\u30f3\u30ab\u30f3\u30bb\u30f3")</span></pre></td></tr><tr><td data-num="42"></td><td><pre> <span class="token comment">// Here is the result of a default comparison </span></pre></td></tr><tr><td data-num="43"></td><td><pre> ci <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">CultureInfo</span><span class="token punctuation">(</span><span class="token string">"ja-JP"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="44"></td><td><pre> x <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">Sign</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">Compare</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> ci<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="45"></td><td><pre> output <span class="token operator">+=</span> String<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"Simple &#123;0&#125; Compare: &#123;1&#125; &#123;3&#125; &#123;2&#125;"</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="46"></td><td><pre> ci<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> symbol<span class="token punctuation">[</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="47"></td><td><pre> output <span class="token operator">+=</span> Environment<span class="token punctuation">.</span>NewLine<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="48"></td><td><pre> <span class="token comment">// Here is the result of a comparison that ignores </span></pre></td></tr><tr><td data-num="49"></td><td><pre> <span class="token comment">// kana type (a type of Japanese writing) </span></pre></td></tr><tr><td data-num="50"></td><td><pre> <span class="token class-name">CompareInfo</span> compareInfo <span class="token operator">=</span> CompareInfo<span class="token punctuation">.</span><span class="token function">GetCompareInfo</span><span class="token punctuation">(</span><span class="token string">"ja-JP"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="51"></td><td><pre> x <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">Sign</span><span class="token punctuation">(</span>compareInfo<span class="token punctuation">.</span><span class="token function">Compare</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> CompareOptions<span class="token punctuation">.</span>IgnoreKanaType<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="52"></td><td><pre> output <span class="token operator">+=</span> String<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"Advanced &#123;0&#125; Compare: &#123;1&#125; &#123;3&#125; &#123;2&#125;"</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="53"></td><td><pre> ci<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> symbol<span class="token punctuation">[</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="54"></td><td><pre> MessageBox<span class="token punctuation">.</span><span class="token function">Show</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> <span class="token string">"Comparing Strings For Sorting"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="55"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="56"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>💡注意：源代码不要用 ANSI 格式保存，否则日语字符会丢失。要在 Microsoft Visual Studio 中保存这个文件，请打开 “另存文件为” 对话框，单击 “保存” 按钮右侧的下箭头，选择 “编码保存”，并选择 “Unicode (UTF-8 带签名)- 代码页 65001”。Microsoft C# 编译器用这个代码也就能成功解析源代码文件了。</p><blockquote><p>Building and running this code produces the output shown in Figure 14-1.</p></blockquote><p><img data-src="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/image-20221107174021156-1668742125901-2.png" alt="image-20221107174021156"></p><p><strong>FIGURE 14-1</strong> String sorting results.</p><blockquote><p>In addition to Compare, the CompareInfo class offers the IndexOf, LastIndexOf, IsPrefix, and IsSuffix methods. Because all of these methods offer overloads that take a CompareOptions enumeration value as a parameter, they give you more control than the Compare, IndexOf, LastIndexOf, StartsWith, and EndsWith methods defined by the String class. Also, you should be aware that the FCL includes a System.StringComparer class that you can also use for performing string comparisons. This class is useful when you want to perform the same kind of comparison repeatedly for many different strings.</p></blockquote><h3 id="string-interning"><a class="anchor" href="#string-interning">#</a> String Interning</h3><blockquote><p>As I said in the preceding section, checking strings for equality is a common operation for many applications—this task can hurt performance significantly. When performing an ordinal equality check, the CLR quickly tests to see if both strings have the same number of characters. If they don’t, the strings are definitely not equal; if they do, the strings might be equal, and the CLR must then compare each individual character to determine for sure. When performing a culturally aware comparison, the CLR must always compare all of the individual characters because strings of different lengths might be considered equal.</p></blockquote><blockquote><p>In addition, if you have several instances of the same string duplicated in memory, you’re wasting memory because strings are immutable. You’ll use memory much more efficiently if there is just one instance of the string in memory and all variables needing to refer to the string can just point to the single string object.</p></blockquote><blockquote><p>If your application frequently compares strings for equality by using case-sensitive, ordinal comparisons, or if you expect to have many string objects with the same value, you can enhance performance substantially if you take advantage of the string interning mechanism in the CLR. When the CLR initializes, it creates an internal hash table in which the keys are strings and the values are references to String objects in the managed heap. Initially, the table is empty (of course). The String class offers two methods that allow you to access this internal hash table.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">String</span> <span class="token function">Intern</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">String</span> <span class="token function">IsInterned</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>The first method, Intern, takes a String, obtains a hash code for it, and checks the internal hash table for a match. If an identical string already exists, a reference to the already existing String object is returned. If an identical string doesn’t exist, a copy of the string is made, the copy is added to the internal hash table, and a reference to this copy is returned. If the application no longer holds a reference to the original String object, the garbage collector is able to free the memory of that string. Note that the garbage collector can’t free the strings that the internal hash table refers to because the hash table holds the reference to those String objects. String objects referred to by the internal hash table can’t be freed until the AppDomain is unloaded or the process terminates.</p></blockquote><blockquote><p>As does the Intern method, the IsInterned method takes a String and looks it up in the internal hash table. If a matching string is in the hash table, IsInterned returns a reference to the interned string object. If a matching string isn’t in the hash table, however, IsInterned returns null; it doesn’t add the string to the hash table.</p></blockquote><blockquote><p>By default, when an assembly is loaded, the CLR interns all of the literal strings described in the assembly’s metadata. Microsoft learned that this hurts performance significantly due to the additional hash table lookups, so it is now possible to turn this “feature” off. If an assembly is marked with a System.Runtime.CompilerServices.CompilationRelaxationsAttribute specifying the System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning flag value, the CLR may, according to the ECMA specification, choose not to intern all of the strings defined in that assembly’s metadata. Note that, in an attempt to improve your application’s performance, the C# compiler always specifies this attribute/flag whenever you compile an assembly.</p></blockquote><blockquote><p>Even if an assembly has this attribute/flag specified, the CLR may choose to intern the strings, but you should not count on this. In fact, you really should never write code that relies on strings being interned unless you have written code that explicitly calls the String’s Intern method yourself.</p></blockquote><blockquote><p>The following code demonstrates string interning.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">ReferenceEquals</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Should be 'False' </span></pre></td></tr><tr><td data-num="4"></td><td><pre>s1 <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">Intern</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre>s2 <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">Intern</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">ReferenceEquals</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'True'</span></pre></td></tr></table></figure><blockquote><p>In the first call to the ReferenceEquals method, s1 refers to a &quot;Hello&quot; string object in the heap, and s2 refers to a different &quot;Hello&quot; string object in the heap. Because the references are different, False should be displayed. However, if you run this on version 4.5 of the CLR, you’ll see that True is displayed. The reason is because this version of the CLR chooses to ignore the attribute/flag emitted by the C# compiler, and the CLR interns the literal &quot;Hello&quot; string when the assembly is loaded into the AppDomain. This means that s1 and s2 refer to the single &quot;Hello&quot; string in the heap. However, as mentioned previously, you should never write code that relies on this behavior because a future version of the CLR might honor the attribute/flag and not intern the &quot;Hello&quot; string. In fact, version 4.5 of the CLR does honor the attribute/flag when this assembly’s code has been compiled using the NGen.exe utility.</p></blockquote><blockquote><p>Before the second call to the ReferenceEquals method, the &quot;Hello&quot; string has been explicitly interned, and s1 now refers to an interned &quot;Hello&quot;. Then by calling Intern again, s2 is set to refer to the same &quot;Hello&quot; string as s1. Now, when ReferenceEquals is called the second time, we are guaranteed to get a result of True regardless of whether the assembly was compiled with the attribute/flag.</p></blockquote><blockquote><p>So now, let’s look at an example to see how you can use string interning to improve performance and reduce memory usage. The NumTimesWordAppearsEquals method below takes two arguments: a word and an array of strings in which each array element refers to a single word. This method then determines how many times the specified word appears in the wordlist and returns this count.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">NumTimesWordAppearsEquals</span><span class="token punctuation">(</span><span class="token class-name">String</span> word<span class="token punctuation">,</span> <span class="token class-name">String<span class="token punctuation">[</span><span class="token punctuation">]</span></span> wordlist<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Int32</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> wordnum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> wordnum <span class="token operator">&lt;</span> wordlist<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> wordnum<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>word<span class="token punctuation">.</span><span class="token function">Equals</span><span class="token punctuation">(</span>wordlist<span class="token punctuation">[</span>wordnum<span class="token punctuation">]</span><span class="token punctuation">,</span> StringComparison<span class="token punctuation">.</span>Ordinal<span class="token punctuation">)</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> count<span class="token operator">++</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">return</span> count<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>As you can see, this method calls String’s Equals method, which internally compares the strings’ individual characters and checks to ensure that all characters match. This comparison can be slow. In addition, the wordlist array might have multiple entries that refer to multiple String objects containing the same set of characters. This means that multiple identical strings might exist in the heap and are surviving ongoing garbage collections.</p></blockquote><blockquote><p>Now, let’s look at a version of this method that was written to take advantage of string interning.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">NumTimesWordAppearsIntern</span><span class="token punctuation">(</span><span class="token class-name">String</span> word<span class="token punctuation">,</span> <span class="token class-name">String<span class="token punctuation">[</span><span class="token punctuation">]</span></span> wordlist<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// This method assumes that all entries in wordlist refer to interned strings. </span></pre></td></tr><tr><td data-num="3"></td><td><pre> word <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">Intern</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">Int32</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> wordnum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> wordnum <span class="token operator">&lt;</span> wordlist<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> wordnum<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">ReferenceEquals</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> wordlist<span class="token punctuation">[</span>wordnum<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> count<span class="token operator">++</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">return</span> count<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>This method interns the word and assumes that the wordlist contains references to interned strings. First, this version might be saving memory if a word appears in the wordlist multiple times because, in this version, wordlist would now contain multiple references to the same single String object in the heap. Second, this version will be faster because determining if the specified word is in the array is simply a matter of comparing pointers.</p></blockquote><blockquote><p>Although the NumTimesWordAppearsIntern method is faster than the NumTimesWordAppearsEquals method, the overall performance of the application might be slower when using the NumTimesWordAppearsIntern method because of the time it takes to intern all of the strings when they were added to the wordlist array (code not shown). The NumTimesWordAppearsIntern method will really show its performance and memory improvement if the application needs to call the method multiple times using the same wordlist. The point of this discussion is to make it clear that string interning is useful, but it should be used with care and caution. In fact, this is why the C# compiler indicates that it doesn’t want string interning to be enabled.</p></blockquote><h3 id="string-pooling"><a class="anchor" href="#string-pooling">#</a> String Pooling</h3><blockquote><p>When compiling source code, your compiler must process each literal string and emit the string into the managed module’s metadata. If the same literal string appears several times in your source code, emitting all of these strings into the metadata will bloat the size of the resulting file.</p></blockquote><blockquote><p>To remove this bloat, many compilers (including the C# compiler) write the literal string into the module’s metadata only once. All code that references the string will be modified to refer to the one string in the metadata. This ability of a compiler to merge multiple occurrences of a single string into a single instance can reduce the size of a module substantially. This process is nothing new—C/C++ compilers have been doing it for years. (Microsoft’s C/C++ compiler calls this string pooling.) Even so, string pooling is another way to improve the performance of strings and just one more piece of knowledge that you should have in your repertoire.</p></blockquote><h3 id="examining-a-strings-characters-and-text-elements"><a class="anchor" href="#examining-a-strings-characters-and-text-elements">#</a> Examining a String’s Characters and Text Elements</h3><blockquote><p>Although comparing strings is useful for sorting them or for detecting equality, sometimes you need just to examine the characters within a string. The String type offers several properties and methods to help you do this, including Length, Chars (an indexer in C#), GetEnumerator, ToCharArray, Contains, IndexOf, LastIndexOf, IndexOfAny, and LastIndexOfAny.</p></blockquote><blockquote><p>In reality, a System.Char represents a single 16-bit Unicode code value that doesn’t necessarily equate to an abstract Unicode character. For example, some abstract Unicode characters are a combination of two code values. When combined, the U+0625 (the Arabic letter Alef with Hamza below) and U+0650 (the Arabic Kasra) characters form a single abstract character or text element.</p></blockquote><blockquote><p>In addition, some Unicode text elements require more than a 16-bit value to represent them. These text elements are represented using two 16-bit code values. The first code value is called the high surrogate, and the second code value is called the low surrogate. High surrogates have a value between U+D800 and U+DBFF, and low surrogates have a value between U+DC00 and U+DFFF. The use of surrogates allows Unicode to express more than a million different characters.</p></blockquote><blockquote><p>Surrogates are rarely used in the United States and Europe but are more commonly used in East Asia. To properly work with text elements, you should use the System.Globalization.StringInfo type. The easiest way to use this type is to construct an instance of it, passing its constructor a string. Then you can see how many text elements are in the string by querying the StringInfo’s LengthInTextElements property. You can then call StringInfo’s SubstringByTextElements method to extract the text element or the number of consecutive text elements that you desire.</p></blockquote><blockquote><p>In addition, the StringInfo class offers a static GetTextElementEnumerator method, which acquires a System.Globalization.TextElementEnumerator object that allows you to enumerate through all of the abstract Unicode characters contained in the string. Finally, you could call StringInfo’s static ParseCombiningCharacters method to obtain an array of Int32 values. The length of the array indicates how many text elements are contained in the string. Each element of the array identifies an index into the string where the first code value for a new text element can be found.</p></blockquote><blockquote><p>The following code demonstrates the various ways of using the StringInfo class to manipulate a string’s text elements.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Text</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Globalization</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Windows<span class="token punctuation">.</span>Forms</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// The string below contains combining characters </span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"a\u0304\u0308bc\u0327"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token function">SubstringByTextElements</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token function">EnumTextElements</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token function">EnumTextElementIndexes</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SubstringByTextElements</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token class-name">String</span> output <span class="token operator">=</span> String<span class="token punctuation">.</span>Empty<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token class-name">StringInfo</span> si <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">StringInfo</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> element <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> element <span class="token operator">&lt;</span> si<span class="token punctuation">.</span>LengthInTextElements<span class="token punctuation">;</span> element<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> output <span class="token operator">+=</span> String<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span> </pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token string">"Text element &#123;0&#125; is '&#123;1&#125;'&#123;2&#125;"</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> element<span class="token punctuation">,</span> si<span class="token punctuation">.</span><span class="token function">SubstringByTextElements</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="20"></td><td><pre> Environment<span class="token punctuation">.</span>NewLine<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="22"></td><td><pre> MessageBox<span class="token punctuation">.</span><span class="token function">Show</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> <span class="token string">"Result of SubstringByTextElements"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">EnumTextElements</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token class-name">String</span> output <span class="token operator">=</span> String<span class="token punctuation">.</span>Empty<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token class-name">TextElementEnumerator</span> charEnum <span class="token operator">=</span> </pre></td></tr><tr><td data-num="27"></td><td><pre> StringInfo<span class="token punctuation">.</span><span class="token function">GetTextElementEnumerator</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="28"></td><td><pre> <span class="token keyword">while</span> <span class="token punctuation">(</span>charEnum<span class="token punctuation">.</span><span class="token function">MoveNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="29"></td><td><pre> output <span class="token operator">+=</span> String<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span> </pre></td></tr><tr><td data-num="30"></td><td><pre> <span class="token string">"Character at index &#123;0&#125; is '&#123;1&#125;'&#123;2&#125;"</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="31"></td><td><pre> charEnum<span class="token punctuation">.</span>ElementIndex<span class="token punctuation">,</span> charEnum<span class="token punctuation">.</span><span class="token function">GetTextElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="32"></td><td><pre> Environment<span class="token punctuation">.</span>NewLine<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="33"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="34"></td><td><pre> MessageBox<span class="token punctuation">.</span><span class="token function">Show</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> <span class="token string">"Result of GetTextElementEnumerator"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="35"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="36"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">EnumTextElementIndexes</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="37"></td><td><pre> <span class="token class-name">String</span> output <span class="token operator">=</span> String<span class="token punctuation">.</span>Empty<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="38"></td><td><pre> <span class="token class-name">Int32<span class="token punctuation">[</span><span class="token punctuation">]</span></span> textElemIndex <span class="token operator">=</span> StringInfo<span class="token punctuation">.</span><span class="token function">ParseCombiningCharacters</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="39"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> textElemIndex<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="40"></td><td><pre> output <span class="token operator">+=</span> String<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span> </pre></td></tr><tr><td data-num="41"></td><td><pre> <span class="token string">"Character &#123;0&#125; starts at index &#123;1&#125;&#123;2&#125;"</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="42"></td><td><pre> i<span class="token punctuation">,</span> textElemIndex<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> Environment<span class="token punctuation">.</span>NewLine<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="43"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="44"></td><td><pre> MessageBox<span class="token punctuation">.</span><span class="token function">Show</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> <span class="token string">"Result of ParseCombiningCharacters"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="45"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="46"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Building and running this code produces the message boxes shown in Figures 14-2, 14-3, and 14-4.</p></blockquote><p><img data-src="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/image-20221107174516896-1668742125901-1.png" alt="image-20221107174516896"></p><p><strong>FIGURE 14-2</strong> Result of <code>SubstringByTextElements</code> .</p><p><img data-src="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/image-20221107174527366-1668742125901-4.png" alt="image-20221107174527366"></p><p><strong>FIGURE 14-3</strong> Result of <code>GetTextElementEnumerator</code> .</p><p><img data-src="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/image-20221107174540551-1668742125901-3.png" alt="image-20221107174540551"></p><p><strong>FIGURE 14-4</strong> Result of <code>ParseCombiningCharacters</code> .</p><h3 id="other-string-operations"><a class="anchor" href="#other-string-operations">#</a> Other String Operations</h3><blockquote><p>The String type also offers methods that allow you to copy a string or parts of it. Table 14-1 summarizes these methods.</p></blockquote><p><img data-src="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/image-20221107174709067-1668742125901-5.png" alt="image-20221107174709067"></p><blockquote><p>In addition to these methods, String offers many static and instance methods that manipulate a string, such as Insert, Remove, PadLeft, Replace, Split, Join, ToLower, ToUpper, Trim, Concat, Format, and so on. Again, the important thing to remember about all of these methods is that they return new string objects; because strings are immutable, after they’re created, they can’t be modified (using safe code).</p></blockquote><p>💡小结：一个 String 代表一个不可变（immutable）的顺序字符集。String 类型直接派生自 Object，所以是引用类型。因此，String 对象（它的字符数组）总是存在于堆上，永远不会跑到线程栈。许多编程语言（包括 C#）都将 String 视为基元类型 —— 也就是说，编译器允许在源代码中直接使用字面值（literal）字符串。C# 不允许使用 new 操作符从字面值构造 String 对象（在 <code>cmd</code> 用 <code>csc.exe</code> 编译会报错，但是用 VS 发现可以，可能是被优化了），观察 IL 代码也看不到 <code>newobj</code> 指令，只有一个特殊 <code>ldstr</code> （即 load string）指令，它使用从元数据获得的字面值（literal）字符串构造 String 对象。这证明 CLR 实际是用一种特殊方式构造字面值 String 对象。如果使用不安全的（unsafe）代码，可以从一个 <code>Char*</code> 或 <code>SByte*</code> 构造 String 对象，这时就可以用 new 操作符调用由 String 类型提供的、能接受 <code>Char*</code> 或 <code>Sbyte*</code> 参数的某个构造器。记住，除非指定了 /unsafe 编译器开关，否则 C# 代码必须是安全的或者说具有可验证性，确保代码不会引起安全风险和稳定性风险。其他构造器则不允许接受任何指针参数，用任何托管编程语言写的安全（可验证）代码都能调用它们。如果所有字符串都是字面值，使用 + 操作符 C# 编译器能在编译时连接它们，最终只将字符串放到模块的元数据中。对非字面值字符串使用 + 操作符，连接则在运行时进行。运行时连接不要使用 + 操作符，因为这样会在堆上创建多个字符串对象，而堆是需要垃圾回收的，对性能由影响。相反，应该使用 <code>System.Text.StringBuilder</code> 类型。在字符串之前添加 @符号使编译器知道这是逐字字符串。编译器会将反斜杠字符视为字面值（literal）而非转义符，使文件路径在源代码中更易读。字符串不可变意味着方法通常会返回一个新的字符串，这还意味着在操纵或访问字符串时不会发生线程同步问题。此外，CLR 可通过一个 String 对象共享多个完全一致的 String 内容。这样能减少系统中的字符串数量 —— 从而节省内存 —— 这就是所谓的 “字符串留用 “（string interning）。处于对性能的考虑，String 类型与 CLR 紧密集成。具体地说，CLR 知道 String 类型中定义的字段如何布局，会直接访问这些字段。但为了获得这种性能和直接访问的好处，String 只能是密封类。如果允许 String 作为基类来定义自己的类型，就能添加自己的字段，从而破坏 CLR 对于 String 类型的各种预设。此外，还可能破坏 CLR 团队因为 String 对象 “不可变” 而做出的各种预设。字符串排序时应该总是执行区分大小写的比较。原因是假如只是大小写不同的两个字符串被视为相等，那么每次排序都可能按不同顺序排序，用户会感到迷惑。处于编程目的而比较字符串时，应该总是使用 <code>StringComparison.Ordinal</code> 或者 <code>StringComparison.OrdinalIgnoreCase</code> （序号比较，值比较字符串中的每个 Char 值的 Unicode 码位）。忽略语言文化是字符串比较最快的方式。另一方面，要以语言文化正确的方式来比较字符串（通常为了向用户显示），就应该使用 <code>StringComarison.CurrentCulture</code> 或者 <code>StringComparison.CurrentCultureIgnoreCase</code> 。在 CLR 中，每个线程都关联了两个特殊属性，每个属性都引用一个 <code>CultureInfo</code> 对象。这两个属性分别是 <code>CurrentUICulture</code> 和 <code>CurrentCulture</code> 。在许多计算机上，线程的 <code>CurrentUICulture</code> 和 <code>CurrentCulture</code> 属性都被设为同一个 <code>CultureInfo</code> 对象。也就是说，它们使用相同的语言 / 国家信息。但也可以把它们设为不同对象。比较字符串以判断相等性或执行排序时，偶尔需要更多的控制。额外的控制通过 <code>CultureInfo</code> 对象的 <code>CompareInfo</code> 属性获得。 <code>CompareInfo</code> 对象封装了一种语言文化的字符比较表，每种语言文化只有一个 <code>CompareInfo</code> 对象。执行序号（ordinal）相等性检查时，CLR 快速测试两个字符串是否包含相同数量的字符。答案否定，字符串肯定不相等；答案肯定，字符串则可能相等。然后，CLR 必须比较每个单独的字符才能最终确认。而执行对语言文化敏感的比较时，CLR 必须比较所有单独的字符，因为两个字符串即使长度不同也可能相等。如果应用程序经常对字符串进行区分大小写的序号比较，或者事先知道许多字符串对象都有相同的值，就可利用 CLR 的字符串留用（string interning）机制来显著提升性能。CLR 初始化时会创建一个内部哈希表。在这个表中，键（key）时字符串，而值（value）是对托管堆中的 String 对象的引用。哈希表最开始是空的（理应如此）。String 提供了两个方法访问这个内部哈希表。 <code>String.Intern</code> 获取一个 String，如果不存在完全相同的字符串，就创建字符串的副本，将副本添加到内部哈希表中，返回对该副本的引用。如果应用程序不在保持对原始 String 对象的引用，垃圾回收器就可释放那个字符串的内存。注意垃圾回收器不能释放内部哈希表内部哈希表引用的字符串，因为哈希表正在容纳对它们的引用。除非卸载 <code>AppDomain</code> 或进程终止，否则内部哈希表引用的 String 对象不能被释放。 <code>String.IsInterned</code> 会在不存在字符串时返回 null，不会将字符串添加到哈希表中。程序集加载时，CLR 默认留用程序集的元数据中描述的所有字面值（literal）字符串。Microsoft 知道可能因为额外的哈希表查找而显著影响性能，为了提升应用程序性能，C# 编译器在编译程序集时总是指定相应的特性和标志不留用字符串，但我们不能依赖 CLR 的这个行为，因为有的 CLR 版本会选择忽视 C# 编译器插入的特性的标志。同一个字符串如果在源代码中多次出现，把它们都嵌入元数据会使生成的文件无谓地增大，为了解决这个问题，许多编译器（包括 C# 编译器）只在模块的元数据中将字面值写入一次。引用该字符串的所有代码都被修改成引用元数据中的同一个字符串。编译器将单个字符串的多个实例合并成一个实例，能显著减少模块的大小。 <code>System.Char</code> 实际代表一个 16 位 Unicode 码值，而且该值不一定就等于一个抽象 Unicode 字符。例如，有的抽象 Unicode 字符是两个码值的组合。除此之外，有的 Unicode 文本元素要求用两个 16 位值表示。第一个称为 “高位代理项”（high surrogate），第二个称为 “低位代理项”（low surrogate）。有了代理项，Unicode 就能表示 100 万个以上不同的字符。为了正确处理文本元素，应当使用 <code>System.Globalization.StringInfo</code> 类型。还可利用 String 类型提供的一些方法来复制字符串。除了这些方法，String 还提供了多个处理字符串的静态方法和实例方法。使用这些方法时都请牢记一点，它们返回的都是新的字符串对象。这是由于字符串是不可变的。一经创建，便不能修改（使用安全代码的话）。</p><h2 id="constructing-a-string-efficiently"><a class="anchor" href="#constructing-a-string-efficiently">#</a> Constructing a String Efficiently</h2><blockquote><p>Because the String type represents an immutable string, the FCL provides another type, System. Text.StringBuilder, which allows you to perform dynamic operations efficiently with strings and characters to create a String. Think of StringBuilder as a fancy constructor to create a String that can be used with the rest of the framework. In general, you should design methods that take String parameters, not StringBuilder parameters.</p></blockquote><blockquote><p>Logically, a StringBuilder object contains a field that refers to an array of Char structures. StringBuilder’s members allow you to manipulate this character array, effectively shrinking the string or changing the characters in the string. If you grow the string past the allocated array of characters, the StringBuilder automatically allocates a new, larger array, copies the characters, and starts using the new array. The previous array is garbage collected.</p></blockquote><blockquote><p>When finished using the StringBuilder object to construct your string, “convert” the StringBuilder’s character array into a String simply by calling the StringBuilder’s ToString method. This creates a new String object in the heap that contains the string that was in the StringBuilder at the time you called ToString. At this point, you can continue to manipulate the string inside the StringBuilder, and later you can call ToString again to convert it into another String object.</p></blockquote><h3 id="constructing-a-stringbuilder-object"><a class="anchor" href="#constructing-a-stringbuilder-object">#</a> Constructing a StringBuilder Object</h3><blockquote><p>Unlike with the String class, the CLR has no special information about the StringBuilder class. In addition, most languages (including C#) don’t consider the StringBuilder class to be a primitive type. You construct a StringBuilder object as you would any other non-primitive type.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>The StringBuilder type offers many constructors. The job of each constructor is to allocate and initialize the state maintained by each StringBuilder object:</p><ul><li><p>Maximum capacity An Int32 value that specifies the maximum number of characters that can be placed in the string. The default is Int32.MaxValue (approximately 2 billion). It’s unusual to change this value. However, you might specify a smaller maximum capacity to ensure that you never create a string over a certain length. Once constructed, a StringBuilder’s maximum capacity value can’t be changed.</p></li><li><p>Capacity An Int32 value indicating the size of the character array being maintained by the StringBuilder. The default is 16. If you have some idea of how many characters you’ll place in the StringBuilder, you should use this number to set the capacity when constructing the StringBuilder object. When appending characters to the character array, the StringBuilder detects if the array is trying to grow beyond the array’s capacity. If it is, the StringBuilder automatically doubles the capacity field, allocates a new array (the size of the new capacity), and copies the characters from the original array into the new array. The original array will be garbage collected in the future. Dynamically growing the array hurts performance; avoid this by setting a good initial capacity.</p></li><li><p>Character array An array of Char structures that maintains the set of characters in the “string.” The number of characters is always less than or equal to the capacity and maximum capacity values. You can use the StringBuilder’s Length property to obtain the number of characters used in the array. The Length is always less than or equal to the StringBuilder’s capacity value. When constructing a StringBuilder, you can pass a String to initialize the character array. If you don’t specify a string, the array initially contains no characters—that is, the Length property returns 0.</p></li></ul></blockquote><h3 id="stringbuilder-members"><a class="anchor" href="#stringbuilder-members">#</a> StringBuilder Members</h3><blockquote><p>Unlike a String, a StringBuilder represents a mutable string. This means that most of StringBuilder’s members change the contents in the array of characters and don’t cause new objects to be allocated on the managed heap. A StringBuilder allocates a new object on only two occasions:</p><ul><li><p>You dynamically build a string whose length is longer than the capacity you’ve set.</p></li><li><p>You call StringBuilder’s ToString method.</p></li></ul></blockquote><p><img data-src="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/image-20221115111421381-1668742125901-6.png" alt="image-20221115111421381"></p><p><img data-src="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/image-20221115111440641-1668742125901-7.png" alt="image-20221115111440641"></p><blockquote><p>One important thing to note about StringBuilder’s methods is that most of them return a reference to the same StringBuilder object. This allows a convenient syntax to chain several operations together.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">String</span> s <span class="token operator">=</span> sb<span class="token punctuation">.</span><span class="token function">AppendFormat</span><span class="token punctuation">(</span><span class="token string">"&#123;0&#125; &#123;1&#125;"</span><span class="token punctuation">,</span> <span class="token string">"Jeffrey"</span><span class="token punctuation">,</span> <span class="token string">"Richter"</span><span class="token punctuation">)</span><span class="token punctuation">.</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token function">Replace</span><span class="token punctuation">(</span><span class="token char">' '</span><span class="token punctuation">,</span> <span class="token char">'-'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Remove</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "Jeff-Richter"</span></pre></td></tr></table></figure><blockquote><p>You’ll notice that the String and StringBuilder classes don’t have full method parity; that is, String has ToLower, ToUpper, EndsWith, PadLeft, PadRight, Trim, and so on. The StringBuilder class doesn’t offer any of these methods. On the other hand, the StringBuilder class offers a richer Replace method that allows you to replace characters or strings in a portion of the string (not the whole string). It’s unfortunate that there isn’t complete parity between these two classes because now you must convert between String and StringBuilder to accomplish certain tasks. For example, to build up a string, convert all characters to uppercase, and then insert a string requires code like the following.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Construct a StringBuilder to perform string manipulations. </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// Perform some string manipulations by using the StringBuilder. </span></pre></td></tr><tr><td data-num="4"></td><td><pre>sb<span class="token punctuation">.</span><span class="token function">AppendFormat</span><span class="token punctuation">(</span><span class="token string">"&#123;0&#125; &#123;1&#125;"</span><span class="token punctuation">,</span> <span class="token string">"Jeffrey"</span><span class="token punctuation">,</span> <span class="token string">"Richter"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Replace</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">,</span> <span class="token string">"-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// Convert the StringBuilder to a String in </span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// order to uppercase all the characters. </span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token class-name">String</span> s <span class="token operator">=</span> sb<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToUpper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// Clear the StringBuilder (allocates a new Char array). </span></pre></td></tr><tr><td data-num="9"></td><td><pre>sb<span class="token punctuation">.</span>Length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">// Load the uppercase String into the StringBuilder, </span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">// and perform more manipulations. </span></pre></td></tr><tr><td data-num="12"></td><td><pre>sb<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">"Marc-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment">// Convert the StringBuilder back to a String. </span></pre></td></tr><tr><td data-num="14"></td><td><pre>s <span class="token operator">=</span> sb<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">// Display the String to the user. </span></pre></td></tr><tr><td data-num="16"></td><td><pre>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "JEFFREY-Marc-RICHTER"</span></pre></td></tr></table></figure><blockquote><p>It’s inconvenient and inefficient to have to write this code just because StringBuilder doesn’t offer all of the operations that String does. In the future, I hope that Microsoft will add more string operation methods to StringBuilder to make it a more complete class.</p></blockquote><p>💡小结：和 String 不同， <code>StringBuilder</code> 代表可变（mutable）字符串。从逻辑上说， <code>StringBuilder</code> 对象包含一个字段，该字段引用了由 <code>Char</code> 结构构成的数组。和 String 类不同，CLR 不觉得 <code>StringBuilder</code> 类有什么特别。此外，大多数语言（包括 C#）都不将 <code>StringBuilder</code> 类视为基元类型。 <code>StringBuilder</code> 的最大容量指定了能放到字符串中的最大字符数，容量则是 <code>StringBuilder</code> 维护的字符数组的长度，追加字符造成数组超过设定的容量则会动态扩容，将原始数组中的字符复制到新数组中。随后，原始数组可以被垃圾回收。数组动态扩容会损害性能。要避免就要设置一个合适的初始容量。 <code>StringBuilder</code> 的大多数成员都能更改字符数组的内容，同时不会造成在托管堆上分配新对象。 <code>StringBuilder</code> 在两种情况下回分配新对象。1. 动态构造字符串，其长度超过了设置的 “容量”。2. 调用 <code>StringBuilder</code> 的 <code>ToString</code> 方法。 <code>String</code> 和 <code>StringBuilder</code> 类提供的方法并不完全对应。由于两个类不完全对应，所以有时需要在 <code>String</code> 和 <code>StringBuilder</code> 之间转换以完成特定任务。</p><h2 id="obtaining-a-string-representation-of-an-object-tostring"><a class="anchor" href="#obtaining-a-string-representation-of-an-object-tostring">#</a> Obtaining a String Representation of an Object: ToString</h2><blockquote><p>You frequently need to obtain a string representation of an object. Usually, this is necessary when you want to display a numeric type (such as Byte, Int32, and Single) or a DateTime object to the user. Because the .NET Framework is an object-oriented platform, every type is responsible for providing code that converts an instance’s value to a string equivalent. When designing how types should accomplish this, the designers of the FCL devised a pattern that would be used consistently throughout. In this section, I’ll describe this pattern.</p></blockquote><blockquote><p>You can obtain a string representation for any object by calling the ToString method. A public, virtual, parameterless ToString method is defined by System.Object and is therefore callable using an instance of any type. Semantically, ToString returns a string representing the object’s current value, and this string should be formatted for the calling thread’s current culture; that is, the string representation of a number should use the proper decimal separator, digit-grouping symbol, and other elements associated with the culture assigned to the calling thread.</p></blockquote><blockquote><p>System.Object’s implementation of ToString simply returns the full name of the object’s type. This value isn’t particularly useful, but it is a reasonable default for the many types that can’t offer a sensible string. For example, what should a string representation of a FileStream or a Hashtable object look like?</p></blockquote><blockquote><p>All types that want to offer a reasonable way to obtain a string representing the current value of the object should override the ToString method. Many of the core types built into the FCL (Byte, Int32, UInt64, Double, and so on) override their ToString method and return a culturally aware string. In the Visual Studio debugger, a datatip is displayed when the mouse is placed over a particular variable. The text shown in the datatip is obtained by calling the object’s ToString method. So, when you define a class, you should always override the ToString method so that you get good debugging support.</p></blockquote><h3 id="specific-formats-and-cultures"><a class="anchor" href="#specific-formats-and-cultures">#</a> Specific Formats and Cultures</h3><blockquote><p>The parameterless ToString method has two problems. First, the caller has no control over the formatting of the string. For example, an application might want to format a number into a currency string, decimal string, percent string, or hexadecimal string. Second, the caller can’t easily choose to format a string by using a specific culture. This second problem is more troublesome for server-side application code than for client-side code. On rare occasions, an application needs to format a string by using a culture other than the culture associated with the calling thread. To have more control over string formatting, you need a version of the ToString method that allows you to specify precise formatting and culture information.</p></blockquote><blockquote><p>Types that offer the caller a choice in formatting and culture implement the System.IFormattable interface.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IFormattable</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token return-type class-name">String</span> <span class="token function">ToString</span><span class="token punctuation">(</span><span class="token class-name">String</span> format<span class="token punctuation">,</span> <span class="token class-name">IFormatProvider</span> formatProvider<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In the FCL, all of the base types (Byte, SByte, Int16/UInt16, Int32/UInt32, Int64/UInt64, Single, Double, Decimal, and DateTime) implement this interface. In addition, some other types, such as Guid, implement it. Finally, every enumerated type definition will automatically implement the IFormattable interface so that a meaningful string symbol from an instance of the enumerated type can be obtained.</p></blockquote><blockquote><p>IFormattable’s ToString method takes two parameters. The first, format, is a string that tells the method how the object should be formatted. ToString’s second parameter, formatProvider, is an instance of a type that implements the System.IFormatProvider interface. This type supplies specific culture information to the ToString method. I’ll discuss how shortly.</p></blockquote><blockquote><p>The type implementing the IFormattable interface’s ToString method determines which format strings it’s going to recognize. If you pass a format string that the type doesn’t recognize, the type is supposed to throw a System.FormatException.</p></blockquote><blockquote><p>Many of the types Microsoft has defined in the FCL recognize several formats. For example, the DateTime type supports “d” for short date, “D” for long date, “g” for general, “M” for month/day, “s” for sortable, “T” for long time, “u” for universal time in ISO 8601 format, “U” for universal time in full date format, “Y” for year/month, and others. All enumerated types support “G” for general, “F” for flags, “D” for decimal, and “X” for hexadecimal. I’ll cover formatting enumerated types in more detail in Chapter 15, “Enumerated Types and Bit Flags.”</p></blockquote><blockquote><p>Also, all of the built-in numeric types support “C” for currency, “D” for decimal, “E” for exponential (scientific) notation, “F” for fixed-point, “G” for general, “N” for number, “P” for percent, “R” for round-trip, and “X” for hexadecimal. In fact, the numeric types also support picture format strings just in case the simple format strings don’t offer you exactly what you’re looking for. Picture format strings contain special characters that tell the type’s ToString method exactly how many digits to show, exactly where to place a decimal separator, exactly how many digits to place after the decimal separator, and so on. For complete information about format strings, see “Formatting Types” in the .NET Framework SDK.</p></blockquote><blockquote><p>For most types, calling ToString and passing null for the format string is identical to calling ToString and passing “G” for the format string. In other words, objects format themselves using the “General format” by default. When implementing a type, choose a format that you think will be the most commonly used format; this format is the “General format.” By the way, the ToString method that takes no parameters assumes that the caller wants the “General format.”</p></blockquote><blockquote><p>So now that format strings are out of the way, let’s turn to culture information. By default, strings are formatted using the culture information associated with the calling thread. The parameterless ToString method certainly does this, and so does IFormattable’s ToString if you pass null for the formatProvider parameter.</p></blockquote><blockquote><p>Culture-sensitive information applies when you’re formatting numbers (including currency, integers, floating point, percentages, dates, and times). The Guid type has a ToString method that returns only a string representing its value. There’s no need to consider a culture when generating the Guid’s string because GUIDs are used for programmatic purposes only.</p></blockquote><blockquote><p>When formatting a number, the ToString method sees what you’ve passed for the formatProvider parameter. If null is passed, ToString determines the culture associated with the calling thread by reading the System.Globalization.CultureInfo.CurrentCulture property. This property returns an instance of the System.Globalization.CultureInfo type.</p></blockquote><blockquote><p>Using this object, ToString reads its NumberFormat or DateTimeFormat property, depending on whether a number or date/time is being formatted. These properties return an instance of System.Globalization.NumberFormatInfo or System.Globalization.DateTimeFormatInfo, respectively. The NumberFormatInfo type defines a bunch of properties, such as CurrencyDecimalSeparator, CurrencySymbol, NegativeSign, NumberGroupSeparator, and PercentSymbol. Likewise, the DateTimeFormatInfo type defines an assortment of properties, such as Calendar, DateSeparator, DayNames, LongDatePattern, ShortTimePattern, and TimeSeparator. ToString reads these properties when constructing and formatting a string.</p></blockquote><blockquote><p>When calling IFormattable’s ToString method, instead of passing null, you can pass a reference to an object whose type implements the IFormatProvider interface.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IFormatProvider</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token return-type class-name">Object</span> <span class="token function">GetFormat</span><span class="token punctuation">(</span><span class="token class-name">Type</span> formatType<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Here’s the basic idea behind the IFormatProvider interface: when a type implements this interface, it is saying that an instance of the type is able to provide culture-specific formatting information and that the culture information associated with the calling thread should be ignored.</p></blockquote><blockquote><p>The System.Globalization.CultureInfo type is one of the very few types defined in the FCL that implements the IFormatProvider interface. If you want to format a string for, say, Vietnam, you’d construct a CultureInfo object and pass that object in as ToString’s formatProvider parameter. The following code obtains a string representation of a Decimal numeric value formatted as currency appropriate for Vietnam.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Decimal</span> price <span class="token operator">=</span> <span class="token number">123.54M</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">String</span> s <span class="token operator">=</span> price<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">CultureInfo</span><span class="token punctuation">(</span><span class="token string">"vi-VN"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre>MessageBox<span class="token punctuation">.</span><span class="token function">Show</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>If you build and run this code, the message box shown in Figure 14-5 appears.</p></blockquote><p><img data-src="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/image-20221115200310845-1668742125901-8.png" alt="image-20221115200310845"></p><p><strong>FIGURE 14-5</strong> Numeric value formatted correctly to represent Vietnamese currency.</p><blockquote><p>Internally, Decimal’s ToString method sees that the formatProvider argument is not null and calls the object’s GetFormat method as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">NumberFormatInfo</span> nfi <span class="token operator">=</span> <span class="token punctuation">(</span>NumberFormatInfo<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> formatProvider<span class="token punctuation">.</span><span class="token function">GetFormat</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">NumberFormatInfo</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>This is how ToString requests the appropriate number-formatting information from the (CultureInfo) object. Number types (such as Decimal) request only number-formatting information. But other types (such as DateTime) could call GetFormat like the following</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">DateTimeFormatInfo</span> dtfi <span class="token operator">=</span> <span class="token punctuation">(</span>DateTimeFormatInfo<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> formatProvider<span class="token punctuation">.</span><span class="token function">GetFormat</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">DateTimeFormatInfo</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>Actually, because GetFormat’s parameter can identify any type, the method is flexible enough to allow any type of format information to be requested. The types in the .NET Framework call GetFormat, requesting only number or date/time information; in the future, other kinds of formatting information could be requested.</p></blockquote><blockquote><p>By the way, if you want to obtain a string for an object that isn’t formatted for any particular culture, you should call System.Globalization.CultureInfo’s static InvariantCulture property and pass the object returned as ToString’s formatProvider parameter.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Decimal</span> price <span class="token operator">=</span> <span class="token number">123.54M</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">String</span> s <span class="token operator">=</span> price<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">,</span> CultureInfo<span class="token punctuation">.</span>InvariantCulture<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre>MessageBox<span class="token punctuation">.</span><span class="token function">Show</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>If you build and run this code, the message box shown in Figure 14-6 appears. Notice the first character in the resulting string: ¤. This is the international sign for currency (U+00A4).</p></blockquote><p><img data-src="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/image-20221115200214296-1668742125901-9.png" alt="image-20221115200214296"></p><p><strong>FIGURE 14-6</strong> Numeric value formatted to represent a culture-neutral currency.</p><blockquote><p>Normally, you wouldn’t display a string formatted by using the invariant culture to a user. Typically, you’d just save this string in a data file so that it could be parsed later.</p></blockquote><blockquote><p>In the FCL, just three types implement the IFormatProvider interface. The first is CultureInfo, which I’ve already explained. The other two are NumberFormatInfo and DateTimeFormatInfo. When GetFormat is called on a NumberFormatInfo object, the method checks whether the type being requested is a NumberFormatInfo. If it is, this is returned; if it’s not, null is returned. Similarly, calling GetFormat on a DateTimeFormatInfo object returns this if a DateTimeFormatInfo is requested and null if it’s not. These two types implement this interface simply as a programming convenience. When trying to obtain a string representation of an object, the caller commonly specifies a format and uses the culture associated with the calling thread. For this reason, you often call ToString, passing a string for the format parameter and null for the formatProvider parameter. To make calling ToString easier for you, many types offer several overloads of the ToString method. For example, the Decimal type offers four different ToString methods.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// This version calls ToString(null, null). </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// Meaning: General numeric format, thread's culture information </span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name">String</span> <span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// This version is where the actual implementation of ToString goes. </span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// This version implements IFormattable's ToString method. </span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// Meaning: Caller-specified format and culture information </span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name">String</span> <span class="token function">ToString</span><span class="token punctuation">(</span><span class="token class-name">String</span> format<span class="token punctuation">,</span> <span class="token class-name">IFormatProvider</span> formatProvider<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// This version simply calls ToString(format, null). </span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// Meaning: Caller-specified format, thread's culture information </span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name">String</span> <span class="token function">ToString</span><span class="token punctuation">(</span><span class="token class-name">String</span> format<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">// This version simply calls ToString(null, formatProvider). </span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment">// This version implements IConvertible's ToString method. </span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment">// Meaning: General format, caller-specified culture information </span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name">String</span> <span class="token function">ToString</span><span class="token punctuation">(</span><span class="token class-name">IFormatProvider</span> formatProvider<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="formatting-multiple-objects-into-a-single-string"><a class="anchor" href="#formatting-multiple-objects-into-a-single-string">#</a> Formatting Multiple Objects into a Single String</h3><blockquote><p>So far, I’ve explained how an individual type formats its own objects. At times, however, you want to construct strings consisting of many formatted objects. For example, the following string has a date, a person’s name, and an age.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">String</span> s <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"On &#123;0&#125;, &#123;1&#125; is &#123;2&#125; years old."</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">DateTime</span><span class="token punctuation">(</span><span class="token number">2012</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Aidan"</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>If you build and run this code where “en-US” is the thread’s current culture, you’ll see the following line of output.</p></blockquote><pre><code class="language-cmd">On 4/22/2012 2:35:05 PM, Aidan is 9 years old.
</code></pre><blockquote><p>String’s static Format method takes a format string that identifies replaceable parameters by using numbers in braces. The format string used in this example tells the Format method to replace {0} with the first parameter after the format string (the date/time), replace {1} with the second parameter after the format string (“Aidan”), and replace {2} with the third parameter after the format string (9).</p></blockquote><blockquote><p>Internally, the Format method calls each object’s ToString method to obtain a string representation for the object. Then the returned strings are all appended and the complete, final string is returned. This is all fine and good, but it means that all of the objects are formatted by using their general format and the calling thread’s culture information.</p></blockquote><blockquote><p>You can have more control when formatting an object if you specify format information within braces. For example, the following code is identical to the previous example except that I’ve added formatting information to replaceable parameters 0 and 2.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">String</span> s <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"On &#123;0:D&#125;, &#123;1&#125; is &#123;2:E&#125; years old."</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">DateTime</span><span class="token punctuation">(</span><span class="token number">2012</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Aidan"</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>If you build and run this code where “en-US” is the thread’s current culture, you’ll see the following line of output.</p></blockquote><pre><code class="language-cmd">On Sunday, April 22, 2012, Aidan is 9.000000E+000 years old.
</code></pre><blockquote><p>When the Format method parses the format string, it sees that replaceable parameter 0 should have its IFormattable interface’s ToString method called passing &quot;D&quot; and null for its two parameters. Likewise, Format calls replaceable parameter 2’s IFormattable ToString method, passing &quot;E&quot; and null. If the type doesn’t implement the IFormattable interface, Format calls its parameterless ToString method inherited from Object (and possibly overridden), and the default format is appended into the resulting string.</p></blockquote><blockquote><p>The String class offers several overloads of the static Format method. One version takes an object that implements the IFormatProvider interface so that you can format all of the replaceable parameters by using caller-specified culture information. Obviously, Format calls each object’s IFormattable.ToString method, passing it whatever IFormatProvider object was passed to Format.</p></blockquote><blockquote><p>If you’re using StringBuilder instead of String to construct a string, you can call StringBuilder’s AppendFormat method. This method works exactly as String’s Format method except that it formats a string and appends to the StringBuilder’s character array. As does String’s Format, AppendFormat takes a format string, and there’s a version that takes an IFormatProvider.</p></blockquote><blockquote><p>System.Console offers Write and WriteLine methods that also take format strings and replaceable parameters. However, there are no overloads of Console’s Write and WriteLine methods that allow you to pass an IFormatProvider. If you want to format a string for a specific culture, you have to call String’s Format method, first passing the desired IFormatProvider object and then passing the resulting string to Console’s Write or WriteLine method. This shouldn’t be a big deal because, as I said earlier, it’s rare for client-side code to format a string by using a culture other than the one associated with the calling thread.</p></blockquote><h3 id="providing-your-own-custom-formatter"><a class="anchor" href="#providing-your-own-custom-formatter">#</a> Providing Your Own Custom Formatter</h3><blockquote><p>By now it should be clear that the formatting capabilities in the .NET Framework were designed to offer you a great deal of flexibility and control. However, we’re not quite finished. It’s possible for you to define a method that StringBuilder’s AppendFormat method will call whenever any object is being formatted into a string. In other words, instead of calling ToString for each object, AppendFormat can call a function you define, allowing you to format any or all of the objects in any way you want. What I’m about to describe also works with String’s Format method.</p></blockquote><blockquote><p>Let me explain this mechanism by way of an example. Let’s say that you’re formatting HTML text that a user will view in an Internet browser. You want all Int32 values to appear in bold. To accomplish this, every time an Int32 value is formatted into a String, you want to surround the string with HTML bold tags: <strong>and</strong> . The following code demonstrates how easy it is to do this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Text</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Threading</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> sb<span class="token punctuation">.</span><span class="token function">AppendFormat</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">BoldInt32s</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"&#123;0&#125; &#123;1&#125; &#123;2:M&#125;"</span><span class="token punctuation">,</span> <span class="token string">"Jeff"</span><span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">,</span> DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>sb<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">BoldInt32s</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IFormatProvider</span><span class="token punctuation">,</span> <span class="token class-name">ICustomFormatter</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Object</span> <span class="token function">GetFormat</span><span class="token punctuation">(</span><span class="token class-name">Type</span> formatType<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>formatType <span class="token operator">==</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">ICustomFormatter</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">return</span> Thread<span class="token punctuation">.</span>CurrentThread<span class="token punctuation">.</span>CurrentCulture<span class="token punctuation">.</span><span class="token function">GetFormat</span><span class="token punctuation">(</span>formatType<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">String</span> <span class="token function">Format</span><span class="token punctuation">(</span><span class="token class-name">String</span> format<span class="token punctuation">,</span> <span class="token class-name">Object</span> arg<span class="token punctuation">,</span> <span class="token class-name">IFormatProvider</span> formatProvider<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token class-name">String</span> s<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token class-name">IFormattable</span> formattable <span class="token operator">=</span> arg <span class="token keyword">as</span> <span class="token class-name">IFormattable</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>formattable <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> s <span class="token operator">=</span> arg<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token keyword">else</span> s <span class="token operator">=</span> formattable<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span>format<span class="token punctuation">,</span> formatProvider<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>arg<span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">Int32</span><span class="token punctuation">)</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token keyword">return</span> <span class="token string">"&lt;B>"</span> <span class="token operator">+</span> s <span class="token operator">+</span> <span class="token string">"&lt;/B>"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token keyword">return</span> s<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When you compile and run this code where “en-US” is the thread’s current culture, it displays the following output (your date may be different, of course).</p></blockquote><pre><code class="language-cmd">Jeff &lt;B&gt;123&lt;/B&gt; September 1
</code></pre><blockquote><p>In Main, I’m constructing an empty StringBuilder and then appending a formatted string into it. When I call AppendFormat, the first parameter is an instance of the BoldInt32s class. This class implements the IFormatProvider interface that I discussed earlier. In addition, this class implements the ICustomFormatter interface.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ICustomFormatter</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token return-type class-name">String</span> <span class="token function">Format</span><span class="token punctuation">(</span><span class="token class-name">String</span> format<span class="token punctuation">,</span> <span class="token class-name">Object</span> arg<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">IFormatProvider</span> formatProvider<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>This interface’s Format method is called whenever StringBuilder’s AppendFormat needs to obtain a string for an object. You can do some pretty clever things inside this method that give you a great deal of control over string formatting. Let’s look inside the AppendFormat method to see exactly how it works. The following pseudocode shows how AppendFormat works.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name">StringBuilder</span> <span class="token function">AppendFormat</span><span class="token punctuation">(</span><span class="token class-name">IFormatProvider</span> formatProvider<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">String</span> format<span class="token punctuation">,</span> <span class="token keyword">params</span> <span class="token class-name">Object<span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// If an IFormatProvider was passed, find out </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// whether it offers an ICustomFormatter object. </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token class-name">ICustomFormatter</span> cf <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>formatProvider <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> cf <span class="token operator">=</span> <span class="token punctuation">(</span>ICustomFormatter<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> formatProvider<span class="token punctuation">.</span><span class="token function">GetFormat</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">ICustomFormatter</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// Keep appending literal characters (not shown in this pseudocode) </span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// and replaceable parameters to the StringBuilder's character array. </span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token class-name">Boolean</span> MoreReplaceableArgumentsToAppend <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">while</span> <span class="token punctuation">(</span>MoreReplaceableArgumentsToAppend<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token comment">// argFormat refers to the replaceable format string obtained </span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token comment">// from the format parameter </span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token class-name">String</span> argFormat <span class="token operator">=</span> <span class="token comment">/* ... */</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token comment">// argObj refers to the corresponding element </span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token comment">// from the args array parameter </span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token class-name">Object</span> argObj <span class="token operator">=</span> <span class="token comment">/* ... */</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token comment">// argStr will refer to the formatted string to be appended </span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token comment">// to the final, resulting string </span></pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token class-name">String</span> argStr <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token comment">// If a custom formatter is available, let it format the argument. </span></pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>cf <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="24"></td><td><pre> argStr <span class="token operator">=</span> cf<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span>argFormat<span class="token punctuation">,</span> argObj<span class="token punctuation">,</span> formatProvider<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token comment">// If there is no custom formatter or if it didn't format </span></pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token comment">// the argument, try something else. </span></pre></td></tr><tr><td data-num="27"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>argStr <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="28"></td><td><pre> <span class="token comment">// Does the argument's type support rich formatting? </span></pre></td></tr><tr><td data-num="29"></td><td><pre> <span class="token class-name">IFormattable</span> formattable <span class="token operator">=</span> argObj <span class="token keyword">as</span> <span class="token class-name">IFormattable</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="30"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>formattable <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="31"></td><td><pre> <span class="token comment">// Yes; pass the format string and provider to </span></pre></td></tr><tr><td data-num="32"></td><td><pre> <span class="token comment">// the type's IFormattable ToString method. </span></pre></td></tr><tr><td data-num="33"></td><td><pre> argStr <span class="token operator">=</span> formattable<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span>argFormat<span class="token punctuation">,</span> formatProvider<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="34"></td><td><pre> <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="35"></td><td><pre> <span class="token comment">// No; get the default format by using </span></pre></td></tr><tr><td data-num="36"></td><td><pre> <span class="token comment">// the thread's culture information. </span></pre></td></tr><tr><td data-num="37"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>argObj <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> argStr <span class="token operator">=</span> argObj<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="38"></td><td><pre> <span class="token keyword">else</span> argStr <span class="token operator">=</span> String<span class="token punctuation">.</span>Empty<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="39"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="40"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="41"></td><td><pre> <span class="token comment">// Append argStr's characters to the character array field member. </span></pre></td></tr><tr><td data-num="42"></td><td><pre> <span class="token comment">/* ... */</span> </pre></td></tr><tr><td data-num="43"></td><td><pre> <span class="token comment">// Check if any remaining parameters to format </span></pre></td></tr><tr><td data-num="44"></td><td><pre> MoreReplaceableArgumentsToAppend <span class="token operator">=</span> <span class="token comment">/* ... */</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="45"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="46"></td><td><pre> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="47"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When Main calls AppendFormat, AppendFormat calls my format provider’s GetFormat method, passing it the ICustomFormatter type. The GetFormat method defined in my BoldInt32s type sees that the ICustomFormatter is being requested and returns a reference to itself because it implements this interface. If my GetFormat method is called and is passed any other type, I call the GetFormat method of the CultureInfo object associated with the calling thread.</p></blockquote><blockquote><p>Whenever AppendFormat needs to format a replaceable parameter, it calls ICustomFormatter’s Format method. In my example, AppendFormat calls the Format method defined by my BoldInt32s type. In my Format method, I check whether the object being formatted supports rich formatting via the IFormattable interface. If the object doesn’t, I then call the simple, parameterless ToString method (inherited from Object) to format the object. If the object does support IFormattable, I then call the rich ToString method, passing it the format string and the format provider.</p></blockquote><blockquote><p>Now that I have the formatted string, I check whether the corresponding object is an Int32 type, and if it is, I wrap the formatted string in &lt;B&gt;and&lt;/B&gt; HTML tags and return the new string. If the object is not an Int32, I simply return the formatted string without any further processing.</p></blockquote><p>💡小结：无参 <code>ToString</code> 方法虽然能给许多不能提供有意义的字符串的类型的类型一个合理的默认值。但调用者无法控制字符串的格式，例如货币、十进制、百分比或者十六进制字符串之类的表示，此外调用者不能方便地选择一种特定语言文化来格式化字符串。相较于客户端代码，服务器端应用程序在第二个问题上尤其麻烦。为了使调用者能选择格式和语言文化，类型应该实现 <code>System.IFormattable</code> 接口。FCL 的所有基元值类型都实现了这个接口。此外，还有另一些类型（比如 <code>Guid</code> ）也实现了它。最后，每个枚举类型都自动实现 <code>IFormattable</code> 接口，以便从枚举类型的实例获取一个有意义的字符串符号。 <code>IFormattable</code> 的 <code>ToString</code> 方法获取两个参数，第一个参数 <code>format</code> 提供一个特殊字符串告诉方法如何格式化对象，第二个参数 <code>formatProvider</code> 提供一个实现 <code>System.IFormatProvider</code> 接口的一个类型的实例。实现 <code>IFormattable</code> 接口的 <code>ToString</code> 方法的类型决定哪些格式字符串能被识别。Microsoft 在 FCL 中定义的许多类型都能同时识别几种格式。对于大多数类型，调用 <code>ToString</code> 并为格式字符串传递 null 值完全等价于调用 <code>ToString</code> 并为格式字符串传递 “G”。字符串默认使用与调用线程关联的语言文化信息进行格式化，如果为 <code>formatProvider</code> 参数传递 null 值， <code>IFormattable</code> 的 <code>ToString</code> 也会这么做。生成 <code>Guid</code> 的字符串时不必考虑语言文化，因为 <code>Guid</code> 只用于编程。 <code>IFormatProvider</code> 接口的基本思路是：当一个类型实现了该接口，就认为该类型的实例能提供对语言文化敏感的格式信息，与调用线程关联的语言文化应被忽略。FCL 的类型只有少数实现了 <code>IFormatProvider</code> 接口。 <code>System.Globalization.CultureInfo</code> 类型就是其中之一。.NET Framework 中的类型在调用 <code>GetFormat</code> 时，暂时只会请求数字或日期 / 时间信息，但未来可能会请求其他格式信息。另外两个实现了 <code>IFormatProvider</code> 接口的是 <code>NumberFormatInfo</code> 和 <code>DateTimeFormatInfo</code> 。这两个方法会检查被请求的类型是不是自己，如果是就返回 this，否则返回 null。String 的静态 Format 方法获取一个格式字符串。在格式字符串中，大括号中的数字指定了可供替换的参数。在内部， <code>Format</code> 方法会调用每个对象的 <code>ToString</code> 方法来获取对象的字符串表示。在大括号内指定格式信息，可以更全面地控制对象格式化。之后 <code>Format</code> 方法会调用可替换的参数的 <code>IFormattable</code> 接口的 <code>ToString</code> 方法。假如可替换参数没有实现 <code>IFormattable</code> 接口， <code>Format</code> 会调用从 <code>Object</code> 继承（而且有可能重写）的无参 <code>ToString</code> 方法，并将默认格式附加到最终生成的字符串中。如果使用 <code>StringBuilder</code> 而不是 String 来构造字符串，可以调用 <code>StringBuilder</code> 的 <code>AppendFormat</code> 方法。它的原理与 <code>String</code> 的 <code>Format</code> 方法类似，只是会格式化字符串并将其附加到 <code>StringBuilder</code> 的字符数组中。 <code>System.Console</code> 的 <code>Write</code> 和 <code>WriteLine</code> 方法也能获取格式字符串和可替换参数。但 <code>Console</code> 的 <code>Write</code> 和 <code>WriteLine</code> 方法没有重载版本能获取一个 <code>IFormatProvider</code> 。我们还可以定义一个方法，在任何对象需要格式化成字符串的时候由 <code>StringBuilder</code> 的 <code>AppendFormat</code> 方法调用该方法。也就是说， <code>AppendFormat</code> 不是为每个对象调用 <code>ToString</code> ，而是调用定制的方法，按照我们希望的任何方式格式化部分或全部对象。任何时候只要 <code>StringBuilder</code> 的 <code>AppendFormat</code> 方法需要获取对象的字符串表示，就会调用这个接口的 <code>Format</code> 方法。可在方法内部通过一些巧妙的操作对字符串格式化进行全面控制。</p><h2 id="parsing-a-string-to-obtain-an-object-parse"><a class="anchor" href="#parsing-a-string-to-obtain-an-object-parse">#</a> Parsing a String to Obtain an Object: Parse</h2><blockquote><p>In the preceding section, I explained how to take an object and obtain a string representation of that object. In this section, I’ll talk about the opposite: how to take a string and obtain an object representation of it. Obtaining an object from a string isn’t a very common operation, but it does occasionally come in handy. Microsoft felt it necessary to formalize a mechanism by which strings can be parsed into objects.</p></blockquote><blockquote><p>Any type that can parse a string offers a public, static method called Parse. This method takes a String and returns an instance of the type; in a way, Parse acts as a factory. In the FCL, a Parse method exists on all of the numeric types as well as for DateTime, TimeSpan, and a few other types (such as the SQL data types).</p></blockquote><blockquote><p>Let’s look at how to parse a string into a number type. Almost all of the numeric types (Byte, SByte, Int16/UInt16, Int32/UInt32, Int64/UInt64, Single, Double, Decimal, and BigInteger) offer at least one Parse method. Here I’ll show you just the Parse method defined by the Int32 type. (The Parse methods for the other numeric types work similarly to Int32’s Parse method.)</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">Parse</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token class-name">NumberStyles</span> style<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">IFormatProvider</span> provider<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>Just from looking at the prototype, you should be able to guess exactly how this method works. The String parameter, s, identifies a string representation of a number you want parsed into an Int32 object. The System.Globalization.NumberStyles parameter, style, is a set of bit flags that identify characters that Parse should expect to find in the string. And the IFormatProvider parameter, provider, identifies an object that the Parse method can use to obtain culture-specific information, as discussed earlier in this chapter.</p></blockquote><blockquote><p>For example, the following code causes Parse to throw a System.FormatException because the string being parsed contains a leading space.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Int32</span> x <span class="token operator">=</span> Int32<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span><span class="token string">" 123"</span><span class="token punctuation">,</span> NumberStyles<span class="token punctuation">.</span>None<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>To allow Parse to skip over the leading space, change the style parameter as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Int32</span> x <span class="token operator">=</span> Int32<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span><span class="token string">" 123"</span><span class="token punctuation">,</span> NumberStyles<span class="token punctuation">.</span>AllowLeadingWhite<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>See the .NET Framework SDK documentation for a complete description of the bit symbols and common combinations that the NumberStyles enumerated type defines.</p></blockquote><blockquote><p>Here’s a code fragment showing how to parse a hexadecimal number.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Int32</span> x <span class="token operator">=</span> Int32<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span><span class="token string">"1A"</span><span class="token punctuation">,</span> NumberStyles<span class="token punctuation">.</span>HexNumber<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "26"</span></pre></td></tr></table></figure><blockquote><p>This Parse method accepts three parameters. For convenience, many types offer additional overloads of Parse so you don’t have to pass as many arguments. For example, Int32 offers four overloads of the Parse method.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Passes NumberStyles.Integer for style </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// and thread's culture's provider information. </span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">Parse</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// Passes thread's culture's provider information. </span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">Parse</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token class-name">NumberStyles</span> style<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// Passes NumberStyles.Integer for the style parameter. </span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">Parse</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token class-name">IFormatProvider</span> provider<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// This is the method I've been talking about in this section. </span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">Parse</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token class-name">NumberStyles</span> style<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token class-name">IFormatProvider</span> provider<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>The DateTime type also offers a Parse method<span class="token punctuation">.</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">DateTime</span> <span class="token function">Parse</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token class-name">IFormatProvider</span> provider<span class="token punctuation">,</span> <span class="token class-name">DateTimeStyles</span> styles<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>The DateTime type also offers a Parse method.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">DateTime</span> <span class="token function">Parse</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">IFormatProvider</span> provider<span class="token punctuation">,</span> <span class="token class-name">DateTimeStyles</span> styles<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>This method works just as the Parse method defined on the number types except that DateTime’s Parse method takes a set of bit flags defined by the System.Globalization.DateTimeStyles enumerated type instead of the NumberStyles enumerated type. See the .NET Framework SDK documentation for a complete description of the bit symbols and common combinations the DateTimeStyles type defines.</p></blockquote><blockquote><p>For convenience, the DateTime type offers three overloads of the Parse method.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Passes thread's culture's provider information </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// and DateTimeStyles.None for the style </span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">DateTime</span> <span class="token function">Parse</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// Passes DateTimeStyles.None for the style </span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">DateTime</span> <span class="token function">Parse</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token class-name">IFormatProvider</span> provider<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// This is the method I've been talking about in this section. </span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">DateTime</span> <span class="token function">Parse</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token class-name">IFormatProvider</span> provider<span class="token punctuation">,</span> <span class="token class-name">DateTimeStyles</span> styles<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>Parsing dates and times is complex. Many developers have found the Parse method of the DateTime type too forgiving in that it sometimes parses strings that don’t contain dates or times. For this reason, the DateTime type also offers a ParseExact method that accepts a picture format string that indicates exactly how the date/time string should be formatted and how it should be parsed. For more information about picture format strings, see the DateTimeFormatInfo class in the .NET Framework SDK.</p></blockquote><p>💡注意：一些开发人员向 Microsoft 报告了这样一个问题：如果应用程序频繁调用 <code>Parse</code> ，而且 <code>Parse</code> 频繁抛出异常时 (由于无效的用户输入)，应用程序的性能会显著下降。为此，Microsoft 在所有数值数据类型、 <code>DateTime</code> 类型、 <code>TimeSpan</code> 类型、甚至 <code>IPAddress</code> 类型中加入了 <code>TryParse</code> 方法。下面是 <code>Int32</code> 的 <code>TryParse</code> 方法的两个重载版本之一：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Boolean</span> <span class="token function">TryParse</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token class-name">NumberStyles</span> style<span class="token punctuation">,</span> <span class="token class-name">IFormatProvider</span> provider<span class="token punctuation">,</span> <span class="token keyword">out</span> <span class="token class-name">Int32</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>可以看出，方法会返回 <code>true</code> 或 <code>false</code> ，指出传递的字符串是否能解析成 <code>Int32</code> 。如果返回 <code>true</code> ，以 “传引用” 的方式传给 <code>result</code> 参数的变量将包含解析好的数值， <code>TryXXX</code> 模式的详情将在第 20 章 “异常和状态管理” 中讨论。</p><p>💡小结：能解析字符串的任何类型都提供了公共静态方法 Parse。方法获取一个 <code>String</code> 并返回类型的实例。从某种意义上说， <code>Parse</code> 扮演了一个工厂（factory）的角色。在 FCL 中，所有数值类型、 <code>DateTime</code> 、 <code>TimeSpan</code> 以及其他一些类型（比如各种 SQL 数据类型）均提供了 Parse 方法。在数值类型的 Parse 方法中， <code>System.Globalization.NumberStyles</code> 参数 style 是位标志（bit blag）集合，标识了 <code>Parse</code> 应在字符串查找的字符（也就是字符串中允许的样式，有不允许的样式会抛出异常）。此外， <code>DateTime</code> 获取的是由 <code>System.Globalization.DateTimeStyles</code> 枚举类型定义的位标志集合。 <code>DateTime</code> 类型的 <code>Parse</code> 方法比较宽松，有时会解析不含日期或时间的字符串。有鉴于此， <code>DateTime</code> 类型还提供了 <code>ParseExact</code> 方法，它接受一个 picture 格式字符串，能准确描述应该如何格式化日期 / 时间字符串，以及如何对它进行解析。</p><h2 id="encodings-converting-between-characters-and-bytes"><a class="anchor" href="#encodings-converting-between-characters-and-bytes">#</a> Encodings: Converting Between Characters and Bytes</h2><blockquote><p>In Win32, programmers all too frequently have to write code to convert Unicode characters and strings to Multi-Byte Character Set (MBCS) characters and strings. I’ve certainly written my share of this code, and it’s very tedious to write and error-prone to use. In the CLR, all characters are represented as 16-bit Unicode code values and all strings are composed of 16-bit Unicode code values. This makes working with characters and strings easy at run time.</p></blockquote><blockquote><p>At times, however, you want to save strings to a file or transmit them over a network. If the strings consist mostly of characters readable by English-speaking people, saving or transmitting a set of 16- bit values isn’t very efficient because half of the bytes written would contain zeros. Instead, it would be more efficient to encode the 16-bit values into a compressed array of bytes and then decode the array of bytes back into an array of 16-bit values.</p></blockquote><blockquote><p>Encodings also allow a managed application to interact with strings created by non-Unicode systems. For example, if you want to produce a file readable by an application running on a Japanese version of Windows 95, you have to save the Unicode text by using the Shift-JIS (code page 932) encoding. Likewise, y ou’d use Shift-JIS encoding to read a text file produced on a Japanese Windows 95 system into the CLR.</p></blockquote><blockquote><p>Encoding is typically done when you want to send a string to a file or network stream by using the System.IO.BinaryWriter or System.IO.StreamWriter type. Decoding is typically done when you want to read a string from a file or network stream by using the System.IO.BinaryReader or System.IO.StreamReader type. If you don’t explicitly select an encoding, all of these types default to using UTF-8. (UTF stands for Unicode Transformation Format.) However, at times, you might want to explicitly encode or decode a string. Even if you don't want to explicitly do this, this section will give you more insight into the reading and writing of strings from and to streams.</p></blockquote><blockquote><p>Fortunately, the FCL offers some types to make character encoding and decoding easy. The two most frequently used encodings are UTF-16 and UTF-8:</p><ul><li><p>UTF-16 encodes each 16-bit character as 2 bytes. It doesn’t affect the characters at all, and no compression occurs—its performance is excellent. UTF-16 encoding is also referred to as Unicode encoding. Also note that UTF-16 can be used to convert from little-endian to big-endian and vice versa.</p></li><li><p>UTF-8 encodes some characters as 1 byte, some characters as 2 bytes, some characters as 3 bytes, and some characters as 4 bytes. Characters with a value below 0x0080 are compressed to 1 byte, which works very well for characters used in the United States. Characters between 0x0080 and 0x07FF are converted to 2 bytes, which works well for European and Middle Eastern languages. Characters of 0x0800 and above are converted to 3 bytes, which works well for East Asian languages. Finally, surrogate pairs are written out as 4 bytes. UTF-8 is an extremely popular encoding, but it’s less efficient than UTF-16 if you encode many characters with values of 0x0800 or above.</p></li></ul></blockquote><blockquote><p>Although the UTF-16 and UTF-8 encodings are by far the most common, the FCL also supports some encodings that are used less frequently:</p><ul><li><p>UTF-32 encodes all characters as 4 bytes. This encoding is useful when you want to write a simple algorithm to traverse characters and you don’t want to have to deal with characters taking a variable number of bytes. For example, with UTF-32, you do not need to think about surrogates because every character is 4 bytes. Obviously, UTF-32 is not an efficient encoding in terms of memory usage and is therefore rarely used for saving or transmitting strings to a file or network. This encoding is typically used inside the program itself. Also note that UTF-32 can be used to convert from little-endian to big-endian and vice versa.</p></li><li><p>UTF-7 encoding is typically used with older systems that work with characters that can be expressed using 7-bit values. You should avoid this encoding because it usually ends up expanding the data rather than compressing it. The Unicode Consortium has deprecated this encoding.</p></li><li><p>ASCII encodes the 16-bit characters into ASCII characters; that is, any 16-bit character with a value of less than 0x0080 is converted to a single byte. Any character with a value greater than 0x007F can’t be converted, so that character’s value is lost. For strings consisting of characters in the ASCII range (0x00 to 0x7F), this encoding compresses the data in half and is very fast (because the high byte is just cut off). This encoding isn’t appropriate if you have characters outside of the ASCII range because the character’s values will be lost.</p></li></ul></blockquote><blockquote><p>Finally, the FCL also allows you to encode 16-bit characters to an arbitrary code page. As with the ASCII encoding, encoding to a code page is dangerous because any character whose value can’t be expressed in the specified code page is lost. You should always use UTF-16 or UTF-8 encoding unless you must work with some legacy files or applications that already use one of the other encodings.</p></blockquote><blockquote><p>When you need to encode or decode a set of characters, you should obtain an instance of a class derived from System.Text.Encoding. Encoding is an abstract base class that offers several static readonly properties, each of which returns an instance of an Encoding-derived class.</p></blockquote><blockquote><p>Here’s an example that encodes and decodes characters by using UTF-8.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Text</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// This is the string we're going to encode. </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"Hi there."</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// Obtain an Encoding-derived object that knows how </span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// to encode/decode using UTF8 </span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token class-name">Encoding</span> encodingUTF8 <span class="token operator">=</span> Encoding<span class="token punctuation">.</span>UTF8<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// Encode a string into an array of bytes. </span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token class-name">Byte<span class="token punctuation">[</span><span class="token punctuation">]</span></span> encodedBytes <span class="token operator">=</span> encodingUTF8<span class="token punctuation">.</span><span class="token function">GetBytes</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// Show the encoded byte values. </span></pre></td></tr><tr><td data-num="13"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Encoded bytes: "</span> <span class="token operator">+</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> BitConverter<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span>encodedBytes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// Decode the byte array back to a string. </span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token class-name">String</span> decodedString <span class="token operator">=</span> encodingUTF8<span class="token punctuation">.</span><span class="token function">GetString</span><span class="token punctuation">(</span>encodedBytes<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token comment">// Show the decoded string. </span></pre></td></tr><tr><td data-num="18"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Decoded string: "</span> <span class="token operator">+</span> decodedString<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>This code yields the following output.</p></blockquote><pre><code class="language-cmd">Encoded bytes: 48-69-20-74-68-65-72-65-2E 
Decoded string: Hi there.
</code></pre><blockquote><p>In addition to the UTF8 static property, the Encoding class also offers the following static properties: Unicode, BigEndianUnicode, UTF32, UTF7, ASCII, and Default. The Default property returns an object that is able to encode/decode using the user’s code page as specified by the Language For Non-Unicode Programs option of the Region/Administrative dialog box in Control Panel. (See the GetACP Win32 function for more information.) However, using the Default property is discouraged because your application’s behavior would be machine-setting dependent, so if you change the system’s default code page or if your application runs on another machine, your application will behave differently.</p></blockquote><blockquote><p>In addition to these properties, Encoding also offers a static GetEncoding method that allows you to specify a code page (by integer or by string) and returns an object that can encode/decode using the specified code page. You can call GetEncoding, passing &quot;Shift-JIS&quot; or 932, for example.</p></blockquote><blockquote><p>When you first request an encoding object, the Encoding class’s property or GetEncoding method constructs a single object for the requested encoding and returns this object. If an alreadyrequested encoding object is requested in the future, the encoding class simply returns the object it previously constructed; it doesn’t construct a new object for each request. This efficiency reduces the number of objects in the system and reduces pressure in the garbage-collected heap.</p></blockquote><blockquote><p>Instead of calling one of Encoding’s static properties or its GetEncoding method, you could also construct an instance of one of the following classes: System.Text.UnicodeEncoding, System.Text.UTF8Encoding, System.Text.UTF32Encoding, System.Text.UTF7Encoding, or System.Text.ASCIIEncoding. However, keep in mind that constructing any of these classes creates new objects in the managed heap, which hurts performance.</p></blockquote><blockquote><p>Four of these classes, UnicodeEncoding, UTF8Encoding, UTF32Encoding, and UTF7Encoding, offer multiple constructors, providing you with more control over the encoding and preamble. (Preamble is sometimes referred to as a byte order mark or BOM.) The first three aforementioned classes also offer constructors that let you tell the class to throw exceptions when decoding an invalid byte sequence; you should use these constructors when you want your application to be secure and resistant to invalid incoming data.</p></blockquote><blockquote><p>You might want to explicitly construct instances of these encoding types when working with a BinaryWriter or a StreamWriter. The ASCIIEncoding class has only a single constructor and therefore doesn’t offer any more control over the encoding. If you need an ASCIIEncoding object, always obtain it by querying Encoding’s ASCII property; this returns a reference to a single ASCIIEncoding object. If you construct ASCIIEncoding objects yourself, you are creating more objects on the heap, which hurts your application’s performance.</p></blockquote><blockquote><p>After you have an Encoding-derived object, you can convert a string or an array of characters to an array of bytes by calling the GetBytes method. (Several overloads of this method exist.) To convert an array of bytes to an array of characters or a string, call the GetChars method or the more useful GetString method. (Several overloads exist for both of these methods.) The preceding code demonstrated calls to the GetBytes and GetString methods.</p></blockquote><blockquote><p>All Encoding-derived types offer a GetByteCount method that obtains the number of bytes necessary to encode a set of characters without actually encoding. Although GetByteCount isn’t especially useful, you can use this method to allocate an array of bytes. There’s also a GetCharCount method that returns the number of characters that would be decoded without actually decoding them. These methods are useful if you’re trying to save memory and reuse an array.</p></blockquote><blockquote><p>The GetByteCount/GetCharCount methods aren’t that fast because they must analyze the array of characters/bytes in order to return an accurate result. If you prefer speed to an exact result, you can call the GetMaxByteCount or GetMaxCharCount method instead. Both methods take an integer specifying the number of bytes or number of characters and return a worst-case value.</p></blockquote><blockquote><p>Each Encoding-derived object offers a set of public read-only properties that you can query to obtain detailed information about the encoding. See the .NET Framework SDK documentation for a description of these properties.</p></blockquote><blockquote><p>To illustrate most of the properties and their meanings, I wrote the following program that displays the property values for several different encodings.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Text</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name">EncodingInfo</span> ei <span class="token keyword">in</span> Encoding<span class="token punctuation">.</span><span class="token function">GetEncodings</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token class-name">Encoding</span> e <span class="token operator">=</span> ei<span class="token punctuation">.</span><span class="token function">GetEncoding</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"&#123;1&#125;&#123;0&#125;"</span> <span class="token operator">+</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token string">"\tCodePage=&#123;2&#125;, WindowsCodePage=&#123;3&#125;&#123;0&#125;"</span> <span class="token operator">+</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token string">"\tWebName=&#123;4&#125;, HeaderName=&#123;5&#125;, BodyName=&#123;6&#125;&#123;0&#125;"</span> <span class="token operator">+</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token string">"\tIsBrowserDisplay=&#123;7&#125;, IsBrowserSave=&#123;8&#125;&#123;0&#125;"</span> <span class="token operator">+</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token string">"\tIsMailNewsDisplay=&#123;9&#125;, IsMailNewsSave=&#123;10&#125;&#123;0&#125;"</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> Environment<span class="token punctuation">.</span>NewLine<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> e<span class="token punctuation">.</span>EncodingName<span class="token punctuation">,</span> e<span class="token punctuation">.</span>CodePage<span class="token punctuation">,</span> e<span class="token punctuation">.</span>WindowsCodePage<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> e<span class="token punctuation">.</span>WebName<span class="token punctuation">,</span> e<span class="token punctuation">.</span>HeaderName<span class="token punctuation">,</span> e<span class="token punctuation">.</span>BodyName<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> e<span class="token punctuation">.</span>IsBrowserDisplay<span class="token punctuation">,</span> e<span class="token punctuation">.</span>IsBrowserSave<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> e<span class="token punctuation">.</span>IsMailNewsDisplay<span class="token punctuation">,</span> e<span class="token punctuation">.</span>IsMailNewsSave<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Running this program yields the following output (abridged to conserve paper).</p></blockquote><pre><code class="language-cmd">IBM EBCDIC (US-Canada) 
 CodePage=37, WindowsCodePage=1252 
 WebName=IBM037, HeaderName=IBM037, BodyName=IBM037 
 IsBrowserDisplay=False, IsBrowserSave=False 
 IsMailNewsDisplay=False, IsMailNewsSave=False 
OEM United States 
 CodePage=437, WindowsCodePage=1252 
 WebName=IBM437, HeaderName=IBM437, BodyName=IBM437 
 IsBrowserDisplay=False, IsBrowserSave=False 
 IsMailNewsDisplay=False, IsMailNewsSave=False 
IBM EBCDIC (International) 
 CodePage=500, WindowsCodePage=1252 
 WebName=IBM500, HeaderName=IBM500, BodyName=IBM500 
 IsBrowserDisplay=False, IsBrowserSave=False 
 IsMailNewsDisplay=False, IsMailNewsSave=False 
Arabic (ASMO 708) 
 CodePage=708, WindowsCodePage=1256 
 WebName=ASMO-708, HeaderName=ASMO-708, BodyName=ASMO-708 
 IsBrowserDisplay=True, IsBrowserSave=True 
 IsMailNewsDisplay=False, IsMailNewsSave=False 
Unicode 
 CodePage=1200, WindowsCodePage=1200 
 WebName=utf-16, HeaderName=utf-16, BodyName=utf-16 
 IsBrowserDisplay=False, IsBrowserSave=True 
 IsMailNewsDisplay=False, IsMailNewsSave=False 
Unicode (Big-Endian) 
 CodePage=1201, WindowsCodePage=1200 
 WebName=unicodeFFFE, HeaderName=unicodeFFFE, BodyName=unicodeFFFE 
 IsBrowserDisplay=False, IsBrowserSave=False 
 IsMailNewsDisplay=False, IsMailNewsSave=False 
Western European (DOS) 
 CodePage=850, WindowsCodePage=1252 
 WebName=ibm850, HeaderName=ibm850, BodyName=ibm850 
 IsBrowserDisplay=False, IsBrowserSave=False 
 IsMailNewsDisplay=False, IsMailNewsSave=False 
Unicode (UTF-8) 
 CodePage=65001, WindowsCodePage=1200 
 WebName=utf-8, HeaderName=utf-8, BodyName=utf-8 
 IsBrowserDisplay=True, IsBrowserSave=True 
 IsMailNewsDisplay=True, IsMailNewsSave=True
</code></pre><blockquote><p>Table 14-3 covers the most commonly used methods offered by all Encoding-derived classes.</p></blockquote><p><img data-src="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/image-20221116115931131-1668742125902-11.png" alt="image-20221116115931131"></p><h3 id="encoding-and-decoding-streams-of-characters-and-bytes"><a class="anchor" href="#encoding-and-decoding-streams-of-characters-and-bytes">#</a> Encoding and Decoding Streams of Characters and Bytes</h3><blockquote><p>Imagine that you’re reading a UTF-16 encoded string via a System.Net.Sockets.NetworkStream object. The bytes will very likely stream in as chunks of data. In other words, you might first read 5 bytes from the stream, followed by 7 bytes. In UTF-16, each character consists of 2 bytes. So calling Encoding’s GetString method passing the first array of 5 bytes will return a string consisting of just two characters. If you later call GetString, passing in the next 7 bytes that come in from the stream, GetString will return a string consisting of three characters, and all of the code points will have the wrong values!</p></blockquote><blockquote><p>This data corruption problem occurs because none of the Encoding-derived classes maintains any state in between calls to their methods. If you’ll be encoding or decoding characters/bytes in chunks, you must do some additional work to maintain state between calls, preventing any loss of data.</p></blockquote><blockquote><p>To decode chunks of bytes, you should obtain a reference to an Encoding-derived object (as described in the previous section) and call its GetDecoder method. This method returns a reference to a newly constructed object whose type is derived from the System.Text.Decoder class. Like the Encoding class, the Decoder class is an abstract base class. If you look in the .NET Framework SDK documentation, you won’t find any classes that represent concrete implementations of the Decoder class. However, the FCL does define a bunch of Decoder-derived classes. These classes are all internal to the FCL, but the GetDecoder method can construct instances of these classes and return them to your application code.</p></blockquote><blockquote><p>All Decoder-derived classes offer two important methods: GetChars and GetCharCount. Obviously, these methods are used for decoding an array of bytes and work similarly to Encoding’s GetChars and GetCharCount methods, discussed earlier. When you call one of these methods, it decodes the byte array as much as possible. If the byte array doesn’t contain enough bytes to complete a character, the leftover bytes are saved inside the decoder object. The next time you call one of these methods, the decoder object uses the leftover bytes plus the new byte array passed to it—this ensures that the chunks of data are decoded properly. Decoder objects are very useful when reading bytes from a stream.</p></blockquote><blockquote><p>An Encoding-derived type can be used for stateless encoding and decoding. However, a Decoderderived type can be used only for decoding. If you want to encode strings in chunks, call GetEncoder instead of calling the Encoding object’s GetDecoder method. GetEncoder returns a newly constructed object whose type is derived from the abstract base class System.Text.Encoder. Again, the .NET Framework SDK documentation doesn’t contain any classes representing concrete implementations of the Encoder class. However, the FCL does define some Encoder-derived classes. As with the Decoderderived classes, these classes are all internal to the FCL, but the GetEncoder method can construct instances of these classes and return them to your application code.</p></blockquote><blockquote><p>All Encoder-derived classes offer two important methods: GetBytes and GetByteCount. On each call, the Encoder-derived object maintains any leftover state information so that you can encode data in chunks.</p></blockquote><h3 id="base-64-string-encoding-and-decoding"><a class="anchor" href="#base-64-string-encoding-and-decoding">#</a> Base-64 String Encoding and Decoding</h3><blockquote><p>As of this writing, the UTF-16 and UTF-8 encodings are quite popular. It is also quite popular to encode a sequence of bytes to a base-64 string. The FCL does offer methods to do base-64 encoding and decoding, and you might expect that this would be accomplished via an Encoding-derived type. However, for some reason, base-64 encoding and decoding is done using some static methods offered by the System.Convert type.</p></blockquote><blockquote><p>To encode a base-64 string as an array of bytes, you call Convert’s static FromBase64String or FromBase64CharArray method. Likewise, to decode an array of bytes as a base-64 string, you call Convert’s static ToBase64String or ToBase64CharArray method. The following code demonstrates how to use some of these methods.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// Get a set of 10 randomly generated bytes </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token class-name">Byte<span class="token punctuation">[</span><span class="token punctuation">]</span></span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Byte</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">NextBytes</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// Display the bytes </span></pre></td></tr><tr><td data-num="8"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>BitConverter<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// Decode the bytes into a base-64 string and show the string </span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token class-name">String</span> s <span class="token operator">=</span> Convert<span class="token punctuation">.</span><span class="token function">ToBase64String</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// Encode the base-64 string back to bytes and show the bytes </span></pre></td></tr><tr><td data-num="13"></td><td><pre> bytes <span class="token operator">=</span> Convert<span class="token punctuation">.</span><span class="token function">FromBase64String</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>BitConverter<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Compiling this code and running the executable file produces the following output (your output might vary from mine because of the randomly generated bytes).</p></blockquote><pre><code class="language-cmd">3B-B9-27-40-59-35-86-54-5F-F1 
O7knQFk1hlRf8Q== 
3B-B9-27-40-59-35-86-54-5F-F1
</code></pre><p>💡小结：Win32 开发人员经常要写代码将 Unicode 字符和字符串转换成 “多字节字符集”（Multi-Byte Character Set，MBCS）格式。在 CLR 中，所有字符都表示成 16 位 Unicode 码值，而所有字符串都有 16 位 Unicode 码值构成，这简化了运行时的字符和字符串处理。但如果字符串中的大多数字符都是英语用户用的，那么保存或传输一系列 16 位值，效率就显得不那么理想，因为写入的半数字节都由零构成。相反，更有效的做法是将 16 位值编码成压缩的字节数组，以后再将字节数组解码回 16 位值的数组。 <code>System.IO</code> 提供的类型默认使用 UTF-8 编码。FCL 提供了一些类型来简化字符编码和解码。UTF-16 将每个 16 位字符编码成 2 个字节。不对字符产生任何影响，也不发生压缩 —— 性能非常出色。UTF-16 编码也称为 “Unicode” 编码。还要注意，UTF-16 可用于从 “低位优先”（little-endian）转换成 “高位优先”（big-endian），或者从 “高位优先” 转换成 “低位优先 “。UTF-8 将部分字符编码成 1 个字节，部分编码成 2 个字节，部分编码成 3 个字节，再有部分编码成 4 个字节。最后，代理项对（surrogate pair）表示成 4 个字节。UTF-8 编码方法非常流行，但如果编码的许多字符都具有 0x0800 或者之上的值，效率反而不如 UTF-16。UTF-16 和 UTF-8 编码是目前最常用的编码方法，此外 FCL 还支持不常用的 UTF-32、UTF-7 以及 ASCII 编码。ASCII 编码方法将 16 位字符编码成 ASCII 字符。最后，FCL 还允许将 1 位字符编码到任意代码页。和 ASCII 一样，编码到代码页也是危险的，因为代码页表示不了的任何字符都会丢失。除非必须和使用其他编码方案的遗留文件或应用程序兼容，否则应该总是选择 UTF-16 或 UTF-8 编码。要编码或解码一组字符时，应获取从 <code>System.Text.Encoding</code> 派生的一个类的实例。首次请求一个编码对象时， <code>Encoding</code> 类的属性或者 <code>GetEncoding</code> 方法会为请求的编码方法构造对象，并返回该对象。假如请求的编码对象以前请求过， <code>Encoding</code> 类回直接返回之前构造好的对象；不会位每个请求都构造新对象。除了调用 <code>Encoding</code> 的某个静态属性或者它的 <code>GetEncoding</code> 方法，还可以构造具体的一些编码类，它们提供了多个构造器，允许对编码的前导码进行更多的控制（返回一个字节数组，指出在写入任何已编码字节之前，首先应该在一个流中写入什么字节，这些字节经常称为前导码（preamble）或 “字节顺序标记”，即 Byte Order Mark 或者 BOM，开始从一个流中读取时，BOM 字节自动帮助检测当初写入流时采用的编码，以确保使用正确的解码器）。但 <code>ASCIIEncoding</code> 类仅一个构造器，没有提供更多的编码控制。所以如果需要 <code>ASCIIEncoding</code> 对象，最好查询 <code>Encoding</code> 的 <code>ASCII</code> 属性来获得。自己构造 <code>ASCIIEncoding</code> 对象会在堆上创建更多的对象，无谓地损害应用程序的性能。字节流通常以数据块（data chunk）的形式传输。但 UTF-16 的每个字符都由 2 个字节构成，所以可能回出现数据损坏，是由于所有 <code>Encoding</code> 派生都不维护多个方法调用之间的状态。要编码或解码以数据块形式传输的字符 / 字节，必须进行一些额外的工作来维护方法调用之间的状态，从而防止丢失数据。字符块解码首先要获取一个 <code>Encoding</code> 派生对象引用，在调用其 <code>GetDecoder</code> 方法。方法返回对一个新构造对象的引用，该对象的类型从 <code>System.Text.Decoder</code> 类派生。和 <code>Encoding</code> 类一样， <code>Decoder</code> 也是抽象基类。 <code>Decoder</code> 的所有派生类都提供了两个重要的方法： <code>GetChars</code> 和 <code>GetCharCount</code> 。调用其中一个方法时，它会尽可能多地解析字节数组。假如字节数组包含的字节不足以完成一个字符，剩余的字节会保存到 <code>Decoder</code> 对象内部。下次调用其中一个方法时， <code>Decoder</code> 对象会利用之前剩余的字节再加上传给它的新字节数组。这样一来，就可以确保对数据块进行正确解码。从 <code>Encoding</code> 派生的类型可用于无状态（中途不保持状态）编码和解码。而从 <code>Decoder</code> 派生的类型只能用于解码。以成块的方式编码字符串需要调用 <code>GetEncoder</code> 方法，而不是调用 <code>Encoding</code> 对象的 <code>GetDecoder</code> 方法。和从 <code>Decoder</code> 派生的类一样，这些类全部再 FCL 内部使用，只是 <code>GetEncoder</code> 方法能构造这些类的实例，并将这些实例返回给应用程序代码。另一个流行的方案是将字节序列编码成 Base-64 字符串。Base-64 编码和解码用 <code>System.Convert</code> 类型提供的一些静态方法来进行。</p><h2 id="secure-strings"><a class="anchor" href="#secure-strings">#</a> Secure Strings</h2><blockquote><p>Often, String objects are used to contain sensitive data such as a user’s password or credit-card information. Unfortunately, String objects contain an array of characters in memory, and if some unsafe or unmanaged code is allowed to execute, the unsafe/unmanaged code could snoop around the process’s address space, locate the string containing the sensitive information, and use this data in an unauthorized way. Even if the String object is used for just a short time and then garbage collected, the CLR might not immediately reuse the String object’s memory (especially if the String object was in an older generation), leaving the String’s characters in the process’s memory, where the information could be compromised. In addition, because strings are immutable, as you manipulate them, the old copies linger in memory and you end up with different versions of the string scattered all over memory.</p></blockquote><blockquote><p>Some governmental departments have stringent security requirements that require very specific security guarantees. To meet these requirements, Microsoft added a more secure string class to the FCL: System.Security.SecureString. When you construct a SecureString object, it internally allocates a block of unmanaged memory that contains an array of characters. Unmanaged memory is used so that the garbage collector isn’t aware of it.</p></blockquote><blockquote><p>These string’s characters are encrypted, protecting the sensitive information from any malicious unsafe/unmanaged code. You can append, insert, remove, or set a character in the secure string by using any of these methods: AppendChar, InsertAt, RemoveAt, and SetAt. Whenever you call any of these methods, internally, the method decrypts the characters, performs the operation in place, and then re-encrypts the characters. This means that the characters are in an unencrypted state for a very short period of time. This also means that the performance of each operation is less than stellar, so you should perform as few of these operations as possible.</p></blockquote><blockquote><p>The SecureString class implements the IDisposable interface to provide an easy way to deterministically destroy the string’s secured contents. When your application no longer needs the sensitive string information, you simply call SecureString’s Dispose method or use a SecureString instance in a using construct. Internally, Dispose zeroes out the contents of the memory buffer to make sure that the sensitive information is not accessible to malicious code, and then the buffer is freed. Internally, a SecureString object has a field to a SafeBuffer-derived object, which maintains the actual string. Because the SafeBuffer class is ultimately derived from CriticalFinalizerObject, discussed in Chapter 21, “The Managed Heap and Garbage Collection,” the string’s characters are guaranteed to be zeroed out and have its buffer freed when it is finalized. Unlike a String object, when a SecureString object is finalized, the encrypted string’s characters will no longer be in memory.</p></blockquote><blockquote><p>Now that you know how to create and modify a SecureString object, let’s talk about how to use one. Unfortunately, the most recent FCL has limited support for the SecureString class. In other words, there are only a few methods that accept a SecureString argument. In the .NET Framework 4, you can pass a SecureString as a password when</p><ul><li><p>Working with a cryptographic service provider (CSP). See the System.Security.Cryptography.CspParameters class.</p></li><li><p>Creating, importing, or exporting an X.509 certificate. See the System.Security.Cryptography.X509Certificates.X509Certificate and System.Security.Cryptography. X509Certificates.X509Certificate2 classes.</p></li><li><p>Starting a new process under a specific user account. See the System.Diagnostics. Process and System.Diagnostics.ProcessStartInfo classes.</p></li><li><p>Constructing an event log session. See the System.Diagnostics.Eventing.Reader. EventLogSession class.</p></li><li><p>Using the System.Windows.Controls.PasswordBox control. See this class’s SecurePassword property.</p></li></ul></blockquote><blockquote><p>Finally, you can create your own methods that can accept a SecureString object parameter. Inside your method, you must have the SecureString object create an unmanaged memory buffer that contains the decrypted characters before your method uses the buffer. To keep the window of opportunity for malicious code to access the sensitive data as small as possible, your code should require access to the decrypted string for as short a period of time as possible. When finished using the string, your code should zero the buffer and free it as soon as possible. Also, never put the contents of a SecureString into a String: if you do, the String lives unencrypted in the heap and will not have its characters zeroed out until the memory is reused after a garbage collection. The SecureString class does not override the ToString method specifically to avoid exposing the sensitive data (which converting it to a String would do).</p></blockquote><blockquote><p>Here is some sample code demonstrating how to initialize and use a SecureString (when compiling this, you’ll need to specify the /unsafe switch to the C# compiler).</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Security</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>InteropServices</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token class-name">SecureString</span> ss <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SecureString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token string">"Please enter password: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token class-name">ConsoleKeyInfo</span> cki <span class="token operator">=</span> Console<span class="token punctuation">.</span><span class="token function">ReadKey</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>cki<span class="token punctuation">.</span>Key <span class="token operator">==</span> ConsoleKey<span class="token punctuation">.</span>Enter<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// Append password characters into the SecureString </span></pre></td></tr><tr><td data-num="12"></td><td><pre> ss<span class="token punctuation">.</span><span class="token function">AppendChar</span><span class="token punctuation">(</span>cki<span class="token punctuation">.</span>KeyChar<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token comment">// Password entered, display it for demonstration purposes </span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token function">DisplaySecureString</span><span class="token punctuation">(</span>ss<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token comment">// After 'using', the SecureString is Disposed; no sensitive data in memory </span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token comment">// This method is unsafe because it accesses unmanaged memory </span></pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">unsafe</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">DisplaySecureString</span><span class="token punctuation">(</span><span class="token class-name">SecureString</span> ss<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="23"></td><td><pre> Char<span class="token operator">*</span> pc <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token comment">// Decrypt the SecureString into an unmanaged memory buffer </span></pre></td></tr><tr><td data-num="26"></td><td><pre> pc <span class="token operator">=</span> <span class="token punctuation">(</span>Char<span class="token operator">*</span><span class="token punctuation">)</span> Marshal<span class="token punctuation">.</span><span class="token function">SecureStringToCoTaskMemUnicode</span><span class="token punctuation">(</span>ss<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="27"></td><td><pre> <span class="token comment">// Access the unmanaged memory buffer that </span></pre></td></tr><tr><td data-num="28"></td><td><pre> <span class="token comment">// contains the decrypted SecureString </span></pre></td></tr><tr><td data-num="29"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> pc<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="30"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>pc<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="31"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="32"></td><td><pre> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="33"></td><td><pre> <span class="token comment">// Make sure we zero and free the unmanaged memory buffer that contains </span></pre></td></tr><tr><td data-num="34"></td><td><pre> <span class="token comment">// the decrypted SecureString characters </span></pre></td></tr><tr><td data-num="35"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>pc <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="36"></td><td><pre> Marshal<span class="token punctuation">.</span><span class="token function">ZeroFreeCoTaskMemUnicode</span><span class="token punctuation">(</span><span class="token punctuation">(</span>IntPtr<span class="token punctuation">)</span> pc<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="37"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="38"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="39"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The System.Runtime.InteropServices.Marshal class offers five methods that you can call to decrypt a SecureString’s characters into an unmanaged memory buffer. All of these methods are static, all accept a SecureString argument, and all return an IntPtr. Each of these methods has a corresponding method that you must call in order to zero the internal buffer and free it. Table 14-4 shows the System.Runtime.InteropServices.Marshal class’s methods to decrypt a SecureString into a memory buffer and the corresponding method to zero and free the buffer.</p></blockquote><p><img data-src="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/image-20221117101318334-1668742125901-10.png" alt="image-20221117101318334"></p><p>💡小结：String 对象在内存中包含一个字符数组。如果允许执行不安全或者非托管的代码，这些代码就可以扫描进程的地址空间，找到包含敏感数据的字符串，并以非授权的方式加以利用。Microsoft 在 FCL 中增添了一个更安全的字符串类，即 <code>System.Security.SecureString</code> 。构造 <code>SecureString</code> 对象时，会在内部分配一个非托管内存块，其中包含一个字符数组。使用非托管内存是为了避开垃圾回收器的 “魔爪”。这些字符串的字符是经过加密的，能防范任何恶意的非安全 / 非托管代码获取机密信息。可在安全字符串中附加、插入、删除或者设置一个字符。调用其中任何一个方法时，方法内部会解密字符，执行特定的操作，再重新加密字符。这意味着字符有一小段时间处于未加密状态。还意味着这些操作的性能会比较一般。所以，应该尽可能少地执行这些操作。 <code>SecureString</code> 类实现了 <code>IDisposable</code> 接口，允许以简单的方式确定性地摧毁字符串中的安全内容。应用程序不再需要敏感的字符串内容时，只需调用 <code>SecureString</code> 的 <code>Dispose</code> 方法。在内部， <code>Disposse</code> 会对内存缓存区的内容进行清零，确保恶意代码无法获得敏感信息，然后释放缓冲区。 <code>SecureString</code> 对象内部的一个字段引用了一个从 <code>SafeBuffer</code> 派生的对象，它负责维护实际的字符串。由于 <code>SafeBuffer</code> 类最终从 <code>CriticalFinalizerObject</code> 类派生，所以字符串在垃圾回收时，它的字符内容保证会被清零，而且缓冲区会得到释放。和 String 对象不同， <code>SecureString</code> 对象在被回收之后，加密字符串的内容不再存在于内存中。可以创建自己的方法来接受 <code>SecureString</code> 对象参数。方法内部必须先让 <code>SecureString</code> 对象创建一个非托管内存缓冲区，它将用于包含解密过的字符，然后才能让该方法使用缓冲区。为了最大程度降低恶意代码获取敏感数据的风险，代码在访问解密过的字符串时，时间应尽可能短。结束使用字符串之后，代码应尽快清零并释放缓冲区。此外，绝对不要将 <code>SecureString</code> 的内容放到一个 <code>String</code> 中。否则，String 会在堆中保持未加密状态，只有经过垃圾回收，而且内存被重用的时候，它的字符内容才会被清零。 <code>SecureString</code> 类特地没有重写 <code>ToString</code> 方法，目的就是避免泄露敏感数据。</p><div class="tags"><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 读书笔记</a> <a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C#</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2022-11-18 11:29:04" itemprop="dateModified" datetime="2022-11-18T11:29:04+08:00">2022-11-18</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Sakupinera WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Sakupinera Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Sakupinera PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Sakupinera <i class="ic i-at"><em>@</em></i>Sakupinera</li><li class="link"><strong>Post link: </strong><a href="http://sakupinera.github.io/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/" title="CLR via C# - Chapter 14 Chars, Strings, and Working with Text">http://sakupinera.github.io/2022/11/16/csharp/clr-via-csharp/Chapter 14 Chars, Strings, and Working with Text/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipexoj0moj20zk0m8kgu.jpg" title="CLR via C# - Chapter 13 Interfaces"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 13 Interfaces</h3></a></div><div class="item right"><a href="/2022/11/17/csharp/clr-via-csharp/Chapter%2015%20Enumerated%20Types%20and%20Bit%20Flags/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclhnx9glj20zk0m8npd.jpg" title="CLR via C# - Chapter 15 Enumerated Types and Bit Flags"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 15 Enumerated Types and Bit Flags</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-14-chars-strings-and-working-with-text"><span class="toc-number">1.</span> <span class="toc-text">Chapter 14 Chars, Strings, and Working with Text</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#characters"><span class="toc-number">1.1.</span> <span class="toc-text">Characters</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#the-systemstring-type"><span class="toc-number">1.2.</span> <span class="toc-text">The System.String Type</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#constructing-strings"><span class="toc-number">1.2.1.</span> <span class="toc-text">Constructing Strings</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strings-are-immutable"><span class="toc-number">1.2.2.</span> <span class="toc-text">Strings Are Immutable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#comparing-strings"><span class="toc-number">1.2.3.</span> <span class="toc-text">Comparing Strings</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string-interning"><span class="toc-number">1.2.4.</span> <span class="toc-text">String Interning</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string-pooling"><span class="toc-number">1.2.5.</span> <span class="toc-text">String Pooling</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#examining-a-strings-characters-and-text-elements"><span class="toc-number">1.2.6.</span> <span class="toc-text">Examining a String’s Characters and Text Elements</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#other-string-operations"><span class="toc-number">1.2.7.</span> <span class="toc-text">Other String Operations</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#constructing-a-string-efficiently"><span class="toc-number">1.3.</span> <span class="toc-text">Constructing a String Efficiently</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#constructing-a-stringbuilder-object"><span class="toc-number">1.3.1.</span> <span class="toc-text">Constructing a StringBuilder Object</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stringbuilder-members"><span class="toc-number">1.3.2.</span> <span class="toc-text">StringBuilder Members</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#obtaining-a-string-representation-of-an-object-tostring"><span class="toc-number">1.4.</span> <span class="toc-text">Obtaining a String Representation of an Object: ToString</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#specific-formats-and-cultures"><span class="toc-number">1.4.1.</span> <span class="toc-text">Specific Formats and Cultures</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#formatting-multiple-objects-into-a-single-string"><span class="toc-number">1.4.2.</span> <span class="toc-text">Formatting Multiple Objects into a Single String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#providing-your-own-custom-formatter"><span class="toc-number">1.4.3.</span> <span class="toc-text">Providing Your Own Custom Formatter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#parsing-a-string-to-obtain-an-object-parse"><span class="toc-number">1.5.</span> <span class="toc-text">Parsing a String to Obtain an Object: Parse</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#encodings-converting-between-characters-and-bytes"><span class="toc-number">1.6.</span> <span class="toc-text">Encodings: Converting Between Characters and Bytes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#encoding-and-decoding-streams-of-characters-and-bytes"><span class="toc-number">1.6.1.</span> <span class="toc-text">Encoding and Decoding Streams of Characters and Bytes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#base-64-string-encoding-and-decoding"><span class="toc-number">1.6.2.</span> <span class="toc-text">Base-64 String Encoding and Decoding</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#secure-strings"><span class="toc-number">1.7.</span> <span class="toc-text">Secure Strings</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"><ul><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/" rel="bookmark" title="CLR via C# - Chapter 1 The CLR’s Execution Model">CLR via C# - Chapter 1 The CLR’s Execution Model</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/" rel="bookmark" title="CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types">CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%203%20Shared%20Assemblies%20and%20Strongly%20Named%20Assemblies/" rel="bookmark" title="CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies">CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies</a></li><li><a href="/2022/09/27/csharp/clr-via-csharp/Chapter%204%20Type%20Fundamentals/" rel="bookmark" title="CLR via C# - Chapter 4 Type Fundamentals">CLR via C# - Chapter 4 Type Fundamentals</a></li><li><a href="/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/" rel="bookmark" title="CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals">CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals</a></li><li><a href="/2022/10/21/csharp/clr-via-csharp/Chapter%206%20Type%20and%20Member%20Basics/" rel="bookmark" title="CLR via C# - Chapter 6 Type and Member Basics">CLR via C# - Chapter 6 Type and Member Basics</a></li><li><a href="/2022/10/24/csharp/clr-via-csharp/Chapter%207%20Constants%20and%20Fields/" rel="bookmark" title="CLR via C# - Chapter 7 Constants and Fields">CLR via C# - Chapter 7 Constants and Fields</a></li><li><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" rel="bookmark" title="CLR via C# - Chapter 8 Methods">CLR via C# - Chapter 8 Methods</a></li><li><a href="/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/" rel="bookmark" title="CLR via C# - Chapter 9 Parameters">CLR via C# - Chapter 9 Parameters</a></li><li><a href="/2022/10/28/csharp/clr-via-csharp/Chapter%2010%20Properties/" rel="bookmark" title="CLR via C# - Chapter 10 Properties">CLR via C# - Chapter 10 Properties</a></li><li><a href="/2022/10/29/csharp/clr-via-csharp/Chapter%2011%20Events/" rel="bookmark" title="CLR via C# - Chapter 11 Events">CLR via C# - Chapter 11 Events</a></li><li><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" rel="bookmark" title="CLR via C# - Chapter 12 Generics">CLR via C# - Chapter 12 Generics</a></li><li><a href="/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/" rel="bookmark" title="CLR via C# - Chapter 13 Interfaces">CLR via C# - Chapter 13 Interfaces</a></li><li class="active"><a href="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/" rel="bookmark" title="CLR via C# - Chapter 14 Chars, Strings, and Working with Text">CLR via C# - Chapter 14 Chars, Strings, and Working with Text</a></li><li><a href="/2022/11/17/csharp/clr-via-csharp/Chapter%2015%20Enumerated%20Types%20and%20Bit%20Flags/" rel="bookmark" title="CLR via C# - Chapter 15 Enumerated Types and Bit Flags">CLR via C# - Chapter 15 Enumerated Types and Bit Flags</a></li><li><a href="/2022/11/19/csharp/clr-via-csharp/Chapter%2016%20Arrays/" rel="bookmark" title="CLR via C# - Chapter 16 Arrays">CLR via C# - Chapter 16 Arrays</a></li><li><a href="/2022/11/21/csharp/clr-via-csharp/Chapter%2017%20Delegates/" rel="bookmark" title="CLR via C# - Chapter 17 Delegates">CLR via C# - Chapter 17 Delegates</a></li><li><a href="/2022/11/22/csharp/clr-via-csharp/Chapter%2018%20Custom%20Attributes/" rel="bookmark" title="CLR via C# - Chapter 18 Custom Attributes">CLR via C# - Chapter 18 Custom Attributes</a></li><li><a href="/2022/11/23/csharp/clr-via-csharp/Chapter%2019%20Nullable%20Value%20Types/" rel="bookmark" title="CLR via C# - Chapter 19 Nullable Value Types">CLR via C# - Chapter 19 Nullable Value Types</a></li><li><a href="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/" rel="bookmark" title="CLR via C# - Chapter 20 Exceptions and State Management">CLR via C# - Chapter 20 Exceptions and State Management</a></li><li><a href="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/" rel="bookmark" title="CLR via C# - Chapter 21 The Managed Heap and Garbage  Collection">CLR via C# - Chapter 21 The Managed Heap and Garbage Collection</a></li><li><a href="/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/" rel="bookmark" title="CLR via C# - Chapter 22 CLR Hosting and AppDomains">CLR via C# - Chapter 22 CLR Hosting and AppDomains</a></li><li><a href="/2022/11/29/csharp/clr-via-csharp/Chapter%2023%20Assembly%20Loading%20and%20Reflection/" rel="bookmark" title="CLR via C# - Chapter 23 Assembly Loading and Reflection">CLR via C# - Chapter 23 Assembly Loading and Reflection</a></li><li><a href="/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/" rel="bookmark" title="CLR via C# - Chapter 24 Runtime Serialization">CLR via C# - Chapter 24 Runtime Serialization</a></li><li><a href="/2022/12/06/csharp/clr-via-csharp/Chapter%2025%20Interoperating%20with%20WinRT%20%20Components/" rel="bookmark" title="CLR via C# - Chapter 25 Interoperating with WinRT Components">CLR via C# - Chapter 25 Interoperating with WinRT Components</a></li><li><a href="/2023/02/06/csharp/clr-via-csharp/Chapter%2026%20Thread%20Basics/" rel="bookmark" title="CLR via C# - Chapter 26 Thread Basics">CLR via C# - Chapter 26 Thread Basics</a></li><li><a href="/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations">CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations</a></li><li><a href="/2023/02/08/csharp/clr-via-csharp/Chapter%2028%20IO-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 28 IO-Bound Asynchronous Operations">CLR via C# - Chapter 28 IO-Bound Asynchronous Operations</a></li><li><a href="/2023/02/09/csharp/clr-via-csharp/Chapter%2029%20Primitive%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 29 Primitive Thread Synchronization">CLR via C# - Chapter 29 Primitive Thread Synchronization</a></li><li><a href="/2023/02/10/csharp/clr-via-csharp/Chapter%2030%20Hybrid%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 30 Hybrid Thread Synchronization">CLR via C# - Chapter 30 Hybrid Thread Synchronization</a></li></ul></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sakupinera" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Sakupinera</p><div class="description" itemprop="description">保持你的决心！</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">89</span> <span class="name">posts</span></a></div><div class="item categories"><a href="/categories/"><span class="count">17</span> <span class="name">categories</span></a></div><div class="item tags"><a href="/tags/"><span class="count">8</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nha3VwaW5lcmE=" title="https:&#x2F;&#x2F;github.com&#x2F;sakupinera"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9zYWt1cGluZXJh" title="https:&#x2F;&#x2F;twitter.com&#x2F;sakupinera"><i class="ic i-twitter"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQwNzIyOTA3MQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;407229071"><i class="ic i-cloud-music"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMjIzMDczOTg/c3BtX2lkX2Zyb209MzMzLjEwMDcuMC4w" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;22307398?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li><li class="item"><a href="/games/" rel="section"><i class="ic i-flag"></i>games</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-person"></i>About</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/11/17/csharp/clr-via-csharp/Chapter%2015%20Enumerated%20Types%20and%20Bit%20Flags/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2023/01/02/cpp/cpp-primer/Chapter%2010%20Generic%20Algorithms/" title="C++ Primer - Chapter 10 Generic Algorithms">C++ Primer - Chapter 10 Generic Algorithms</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/08/28/linux/learn-linux/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="LearnLinux - Linux常用命令">LearnLinux - Linux常用命令</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/" title="CLR via C# - Chapter 9 Parameters">CLR via C# - Chapter 9 Parameters</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/10/24/csharp/clr-via-csharp/Chapter%207%20Constants%20and%20Fields/" title="CLR via C# - Chapter 7 Constants and Fields">CLR via C# - Chapter 7 Constants and Fields</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/" title="CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations">CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/09/18/computer-graphics/games101/%E5%8F%98%E6%8D%A2/" title="GAMES101 - Transformation（变换）">GAMES101 - Transformation（变换）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/09/06/computer-graphics/games101/%E5%90%91%E9%87%8F%E5%92%8C%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" title="GAMES101 - 向量和线性代数">GAMES101 - 向量和线性代数</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/10/28/csharp/clr-via-csharp/Chapter%2010%20Properties/" title="CLR via C# - Chapter 10 Properties">CLR via C# - Chapter 10 Properties</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Language/" title="In Language">Language</a> <i class="ic i-angle-right"></i> <a href="/categories/Language/Japanese/" title="In Japanese">Japanese</a></div><span><a href="/2024/10/23/language/japanese/%E6%97%A5%E6%9C%AC%E8%AA%9E%E3%81%AE%E5%8B%89%E5%BC%B7/" title="日本語の勉強">日本語の勉強</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/08/28/linux/learn-linux/Linux%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/" title="LearnLinux - Linux系统简介">LearnLinux - Linux系统简介</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Sakupinera @ Hanamai Sora</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="Symbols count total">2.2m words</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="Reading time total">34:05</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/11/16/csharp/clr-via-csharp/Chapter 14 Chars, Strings, and Working  with Text/",favicon:{show:"（●´3｀●）Goooood",hide:"(´Д｀)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/shifuku.model.json"},display:{position:"left",width:250,height:500},mobile:{show:!1},react:{opacity:.9},log:!1})</script></body></html>