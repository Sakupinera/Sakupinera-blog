<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sakupinera" href="http://sakupinera.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sakupinera" href="http://sakupinera.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sakupinera" href="http://sakupinera.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="读书笔记,C#"><link rel="canonical" href="http://sakupinera.github.io/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/"><title>CLR via C# - Chapter 20 Exceptions and State Management - CLR-via-CSharp - CSharp | Hanamai Sora = Sakupinera</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">CLR via C# - Chapter 20 Exceptions and State Management</h1><div class="meta"><span class="item" title="Created: 2022-11-25 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2022-11-25T00:00:00+08:00">2022-11-25</time> </span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">Symbols count in article</span> <span>107k</span> <span class="text">words</span> </span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">Reading time</span> <span>1:38</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hanamai Sora</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giph4baakhj20zk0m8h5q.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giciszlczyj20zk0m816d.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giciryrr3rj20zk0m8nhk.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipexj2jgzj20zk0m8b09.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipex2cdtbj20zk0m8x6p.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gicm0fdw5cj20zk0m8hdt.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/" itemprop="item" rel="index" title="In CSharp"><span itemprop="name">CSharp</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/CLR-via-CSharp/" itemprop="item" rel="index" title="In CLR-via-CSharp"><span itemprop="name">CLR-via-CSharp</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://sakupinera.github.io/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Sakupinera"><meta itemprop="description" content=", 保持你的决心！"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakupinera"></span><div class="body md" itemprop="articleBody"><h1 id="chapter-20-exceptions-and-state-management"><a class="anchor" href="#chapter-20-exceptions-and-state-management">#</a> Chapter 20 Exceptions and State Management</h1><h2 id="defining-exception"><a class="anchor" href="#defining-exception">#</a> Defining “Exception”</h2><blockquote><p>When designing a type, you first imagine the various situations in which the type will be used. The type name is usually a noun, such as FileStream or StringBuilder. Then you define the properties, methods, events, and so on for the type. The way you define these members (property data types, method parameters, return values, and so forth) becomes the programmatic interface for your type. These members indicate actions that can be performed by the type itself or on an instance of the type. These action members are usually verbs such as Read, Write, Flush, Append, Insert, Remove, etc. When an action member cannot complete its task, the member should throw an exception.</p></blockquote><p>💡重要提示：异常时指成员没有完成它的名称所宣称的行动。</p><blockquote><p>Look at the following class definition.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Account</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Transfer</span><span class="token punctuation">(</span><span class="token class-name">Account</span> from<span class="token punctuation">,</span> <span class="token class-name">Account</span> to<span class="token punctuation">,</span> <span class="token class-name">Decimal</span> amount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> from <span class="token operator">-=</span> amount<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> to <span class="token operator">+=</span> amount<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The Transfer method accepts two Account objects and a Decimal value that identifies an amount of money to transfer between accounts. Obviously, the goal of the Transfer method is to subtract money from one account and add money to another. The Transfer method could fail for many reasons: the from or to argument might be null; the from or to argument might not refer to an open account; the from account might have insufficient funds; the to account might have so much money in it that adding more would cause it to overflow; or the amount argument might be 0, negative, or have more than two digits after the decimal place.</p></blockquote><blockquote><p>When the Transfer method is called, its code must check for all of these possibilities, and if any of them are detected, it cannot transfer the money and should notify the caller that it failed by throwing an exception. In fact, notice that the Transfer method’s return type is void. This is because the Transfer method has no meaningful value to return; if it returns at all, it was successful. If it fails, it throws a meaningful exception.</p></blockquote><blockquote><p>Object-oriented programming allows developers to be very productive because you get to write code like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Boolean</span> f <span class="token operator">=</span> <span class="token string">"Jeff"</span><span class="token punctuation">.</span><span class="token function">Substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToUpper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">EndsWith</span><span class="token punctuation">(</span><span class="token string">"E"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></pre></td></tr></table></figure><blockquote><p>Here I’m composing my intent by chaining several operations together.1 This code was easy for me to write and is easy for others to read and maintain because the intent is obvious: take a string, grab a portion of it, uppercase that portion, and see if it ends with an “E.” This is great, but there is a big assumption being made here: no operation fails. But, of course, errors are always possible, so we need a way to handle those errors. In fact, there are many object-oriented constructs—constructors, getting/setting a property, adding/removing an event, calling an operator overload, calling a conversion operator—that have no way to return error codes, but these constructs must still be able to report an error. The mechanism provided by the Microsoft .NET Framework and all programming languages that support it is called exception handling.</p></blockquote><p>💡重要提示 许多开发人员都错误地认为异常和某件事件的发生频率有关。例如，一个设计文件 <code>Read</code> 方法的开发人员可能会这样想：” 读取文件最终会抵达文件尾。由于抵达文件尾部是会发生，所以我设计这个 <code>Read</code> 方法返回一个特殊值来报告抵达了文件尾；我不让它抛出异常。“<br>问题在于，这是设计 <code>Read</code> 方法的开发人员的想法，而非调用 <code>Read</code> 方法的开发人员的想法。</p><p>设计 <code>Read</code> 方法的开发人员不可能知道这个方法的所有调用情形。所以，开发人员不可能知道 <code>Read</code> 的调用者是不是每次都会一路读取到文件尾。事实上，由于大多数文件包含的都是结构化数据，所以一路读取直至文件尾的情况是很少发生的。</p><p>💡小结：许多面向对象的构造 —— 构造器、获取和设置属性、添加和删除事件、调用操作符重载和调用转换操作符等 —— 都没办法返回错误代码，但它们仍然需要报告错误。Microsoft .NET Framework 和所有编程语言通过异常处理来解决这个问题。</p><h2 id="exception-handling-mechanics"><a class="anchor" href="#exception-handling-mechanics">#</a> Exception-Handling Mechanics</h2><blockquote><p>In this section, I’ll introduce the mechanics and C# constructs needed in order to use exception handling, but it’s not my intention to explain them in great detail. The purpose of this chapter is to offer useful guidelines for when and how to use exception handling in your code. If you want more information about the mechanics and language constructs for using exception handling, see the .NET Framework documentation and the C# language specification. Also, the .NET Framework exceptionhandling mechanism is built using the Structured Exception Handling (SEH) mechanism offered by Windows. SEH has been discussed in many resources, including the book, Windows via C/C++, Fifth Edition, by myself and Christophe Nasarre (Microsoft Press, 2007), which contains three chapters devoted to SEH.</p></blockquote><blockquote><p>The following C# code shows a standard usage of the exception-handling mechanism. This code gives you an idea of what exception-handling blocks look like and what their purpose is. In the subsections after the code, I’ll formally describe the try, catch, and finally blocks and their purpose and provide some notes about their use.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SomeMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// Put code requiring graceful recovery and/or cleanup operations here...</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InvalidOperationException</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Put code that recovers from an InvalidOperationException here...</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// Put code that recovers from an IOException here...</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">catch</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// Put code that recovers from any kind of exception other than those preceding this...</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token comment">// When catching any exception, you usually re-throw the exception.</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token comment">// I explain re-throwing later in this chapter. </span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token keyword">throw</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token comment">// Put code that cleans up any operations started within the try block here...</span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token comment">// The code in here ALWAYS executes, regardless of whether an exception is thrown. </span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token comment">// Code below the finally block executes if no exception is thrown within the try block</span></pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token comment">// or if a catch block catches the exception and doesn't throw or re-throw an exception. </span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>This code demonstrates one possible way to use exception-handling blocks. Don’t let the code scare you—most methods have simply a try block matched with a single finally block or a try block matched with a single catch block. It’s unusual to have as many catch blocks as in this example. I put them there for illustration purposes.</p></blockquote><h3 id="the-try-block"><a class="anchor" href="#the-try-block">#</a> The try Block</h3><blockquote><p>A try block contains code that requires common cleanup operations, exception-recovery operations, or both. The cleanup code should be placed in a single finally block. A try block can also contain code that might potentially throw an exception. The exception-recovery code should be placed in one or more catch blocks. You create one catch block for each kind of exception that your application can safely recover from. A try block must be associated with at least one catch or finally block; it makes no sense to have a try block that stands by itself, and C# will prevent you from doing this.</p></blockquote><p>💡重要提示：开发人员有时不知道应该在一个 <code>try</code> 块中放入多少代码。这据图取决于状态管理。如果在一个 <code>try</code> 块中执行多个可能抛出同一个异常类型的操作，但不同的操作有不同的异常恢复措施，就应该将每个操作都放到它自己的 <code>try</code> 块中，这样才能正确地恢复状态。</p><h3 id="the-catch-block"><a class="anchor" href="#the-catch-block">#</a> The catch Block</h3><blockquote><p>A catch block contains code to execute in response to an exception. A try block can have zero or more catch blocks associated with it. If the code in a try block doesn’t cause an exception to be thrown, the CLR will never execute the code contained within any of its catch blocks. The thread will simply skip over all of the catch blocks and execute the code in the finally block (if one exists). After the code in the finally block executes, execution continues with the statement following the finally block.</p></blockquote><blockquote><p>The parenthetical expression appearing after the catch keyword is called the catch type. In C#, you must specify a catch type of System.Exception or a type derived from System.Exception. For example, the previous code contains catch blocks for handling an InvalidOperationException (or any exception derived from it) and an IOException (or any exception derived from it). The last catch block (which doesn’t specify a catch type) handles any exception except for the exception type specified by earlier catch blocks; this is equivalent to having a catch block that specifies a catch type of System.Exception except that you cannot access the exception information via code inside the catch block’s braces.</p></blockquote><p>💡注意：用 Microsoft Visual Studio 调试 <code>catch</code> 块时，可在监视窗口中添加特殊变量名称 <code>$Exception</code> 来查看当前抛出的异常对象。</p><blockquote><p>The CLR searches from top to bottom for a matching catch type, and therefore you should place the more specific exception types at the top. The most-derived exception types should appear first, followed by their base types (if any), down to System.Exception (or an exception block that doesn’t specify a catch type). In fact, the C# compiler generates an error if more specific catch blocks appear closer to the bottom because the catch block would be unreachable.</p></blockquote><blockquote><p>If an exception is thrown by code executing within the try block (or any method called from within the try block), the CLR starts searching for catch blocks whose catch type is the same type as or a base type of the thrown exception. If none of the catch types matches the exception, the CLR continues searching up the call stack looking for a catch type that matches the exception. If after reaching the top of the call stack, no catch block is found with a matching catch type, an unhandled exception occurs. I’ll talk more about unhandled exceptions later in this chapter.</p></blockquote><blockquote><p>After the CLR locates a catch block with a matching catch type, it executes the code in all inner finally blocks, starting from within the try block whose code threw the exception and stopping with the catch block that matched the exception. Note that any finally block associated with the catch block that matched the exception is not executed yet. The code in this finally block won’t execute until after the code in the handling catch block has executed.</p></blockquote><blockquote><p>After all the code in the inner finally blocks has executed, the code in the handling catch block executes. This code typically performs some operations to deal with the exception. At the end of the catch block, you have three choices:</p><ul><li><p>Re-throw the same exception, notifying code higher up in the call stack of the exception.</p></li><li><p>Throw a different exception, giving richer exception information to code higher up in the call stack.</p></li><li><p>Let the thread fall out of the bottom of the catch block.</p></li></ul></blockquote><blockquote><p>Later in this chapter, I’ll offer some guidelines for when you should use each of these techniques. If you choose either of the first two techniques, you’re throwing an exception, and the CLR behaves just as it did before: it walks up the call stack looking for a catch block whose type matches the type of the exception thrown.</p></blockquote><blockquote><p>If you pick the last technique, when the thread falls out of the bottom of the catch block, it immediately starts executing code contained in the finally block (if one exists). After all of the code in the finally block executes, the thread drops out of the finally block and starts executing the statements immediately following the finally block. If no finally block exists, the thread continues execution at the statement following the last catch block.</p></blockquote><blockquote><p>In C#, you can specify a variable name after a catch type. When an exception is caught, this variable refers to the System.Exception-derived object that was thrown. The catch block’s code can reference this variable to access information specific to the exception (such as the stack trace leading up to the exception). Although it’s possible to modify this object, you shouldn’t; consider the object to be read-only. I’ll explain the Exception type and what you can do with it later in this chapter.</p></blockquote><p>💡注意：你的代码可向 <code>AppDomain</code> 的 <code>FirstChanceException</code> 事件登记，这样只要 AppDomain 中发生异常，就会收到通知。这个通知是在 CLR 开始搜索任何 <code>catch</code> 块之前发生的。欲知该事件的详情，请参见第 22 章 ”CLR 寄宿和 AppDomain”。</p><h3 id="the-finally-block"><a class="anchor" href="#the-finally-block">#</a> The finally Block</h3><blockquote><p>A finally block contains code that’s guaranteed to execute.2 Typically, the code in a finally block performs the cleanup operations required by actions taken in the try block. For example, if you open a file in a try block, you’d put the code to close the file in a finally block.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ReadData</span><span class="token punctuation">(</span><span class="token class-name">String</span> pathname<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">FileStream</span> fs <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> fs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">FileStream</span><span class="token punctuation">(</span>pathname<span class="token punctuation">,</span> FileMode<span class="token punctuation">.</span>Open<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token comment">// Process the data in the file...</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Put code that recovers from an IOException here...</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// Make sure that the file gets closed. </span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>fs <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> fs<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>If the code in the try block executes without throwing an exception, the file is guaranteed to be closed. If the code in the try block does throw an exception, the code in the finally block still executes, and the file is guaranteed to be closed, regardless of whether the exception is caught. It’s improper to put the statement to close the file after the finally block; the statement wouldn’t execute if an exception were thrown and not caught, which would result in the file being left open (until the next garbage collection).</p></blockquote><blockquote><p>A try block doesn’t require a finally block associated with it; sometimes the code in a try block just doesn’t require any cleanup code. However, if you do have a finally block, it must appear after any and all catch blocks. A try block can have no more than one finally block associated with it.</p></blockquote><blockquote><p>When a thread reaches the end of the code contained in a finally block, the thread simply starts executing the statements immediately following the finally block. Remember that the code in the finally block is cleanup code. This code should execute only what is necessary to clean up operations initiated in the try block. The code inside catch and finally blocks should be very short and should have a high likelihood of succeeding without itself throwing an exception. Usually the code in these blocks is just one or two lines of code.</p></blockquote><blockquote><p>It is always possible that exception-recovery code or cleanup code could fail and throw an exception. Although possible, it is unlikely and if it does happen it usually means that there is something very wrong somewhere. Most likely some state has gotten corrupted somewhere. If an exception is inadvertently thrown within a catch or finally block, the world will not come to an end—the CLR’s exception mechanism will execute as though the exception were thrown after the finally block. However, the CLR does not keep track of the first exception that was thrown in the corresponding try block (if any), and you will lose any and all information (such as the stack trace) available about the first exception. Probably (and hopefully), this new exception will not be handled by your code and the exception will turn into an unhandled exception. The CLR will then terminate your process, which is good because all the corrupted state will now be destroyed. This is much better than having your application continue to run with unpredictable results and possible security holes.</p></blockquote><blockquote><p>Personally, I think the C# team should have chosen different language keywords for the exceptionhandling mechanism. What programmers want to do is try to execute some piece of code. And then, if something fails, either recover from the failure and move on or compensate to undo some state change and continue to report the failure up to a caller. Programmers also want to have guaranteed cleanup no matter what happens.</p></blockquote><blockquote><p>The code on the left is what you have to write to make the C# compiler happy, but the code on the right is the way I prefer to think about it.</p></blockquote><p><img data-src="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/image-20221124102617217.png" alt="image-20221124102617217"></p><p><strong>CLS 和非 CLS 异常</strong></p><p>所有面向 CLR 的编程语言都必须支持抛出从 <code>Exception</code> 派生的对象，因为公共语言规范 (Common Language Specification, CLS) 对此进行了硬性规定。但是，CLR 实际允许抛出任何类型的实例，而且有些编程语言允许代码抛出非 CLS 相容的异常对象，比如一个 <code>String</code> ， <code>Int32</code> 和 <code>DateTime</code> 等。C# 编译器只允许代码抛出从 <code>Exception</code> 派生的对象，而用其他一些语言写的代码不仅允许抛出 <code>Exception</code> 派生对象，还允许抛出非 <code>Exception</code> 派生对象。</p><p>许多程序员没有意识到 CLR 允许抛出任何对象来报告异常。大多数开发人员以为只有派生自 <code>Exception</code> 的对象才能抛出。在 CLR 的 2.0 版本之前，程序员写 <code>catch</code> 块来捕捉异常时，只能捕捉 CLS 相容的异常。如果一个 C# 方法调用了用另一种编程语言写的方法，而且那个方法抛出一个非 CLS 相容的异常，那么 C# 代码根本不能捕捉这个异常，从而造成一些安全隐患。</p><p>在 CLR 的 2.0 版本中，Microsoft 引入了新的 <code>RuntimeWrappedException</code> 类 (在命名空间 <code>System.Runtime.CompilerServices</code> 中定义)。该类派生自 <code>Exception</code> ，所以它是一个 CLS 相容的异常类型。 <code>RuntimeWrappedException</code> 类含有一个 <code>Object</code> 类型的一个 CLS 相容的异常类型。 <code>RuntimeWrappedException</code> 类含有一个 <code>Object</code> 类型的私有字段 (可通过 <code>RuntimeWrappedException</code> 类的只读属性 <code>WrappedException</code> 来访问)。在 CLR 2.0 中，非 CLS 相容的一个异常被抛出时，CLR 会自动构造 <code>RuntimeWrappedException</code> 类的实例，并初始化该实例的私有字段，使之引用实际抛出的对象。这样 CLR 就将非 CLS 相容的异常转变成了 CLS 相容的异常。所以，任何能捕捉 <code>Exception</code> 类型的代码，现在都能捕捉非 CLS 相容的异常，从而消除了潜在的安全隐患。</p><p>虽然 C# 编译器只允许开发人员抛出派生自 <code>Exception</code> 的对象，但在 C# 的 2.0 版本之前，C# 编译器确实允许开发人员使用以下形式的代码捕捉非 CLS 相容的异常：</p><pre><code class="language-C#">private void SomeMethod() &#123;
    try &#123;
        // 需要得体地进行恢复和/或清理的代码放在这里
    &#125;
    catch (Exception e) &#123;
        // C# 2.0 以前，这个块只能捕捉 CLS 相容的异常：
        // 而现在，这个块能捕捉 CLS 相容和不相容的异常
        throw;   // 重新抛出捕捉到的任何东西
    &#125;
    catch &#123;
        // 在所有版本的 C# 中，这个块可以捕捉 CLS 相容和不相容的异常
        throw;  // 重新抛出捕捉到的任何东西
    &#125;
&#125;
</code></pre><p>现在，一些开发人员注意到 CLR 同时支持相容和不相容于 CLS 的异常，他们可能像上面展示的那样写两个 <code>catch</code> 块来捕捉这两种异常。为 CLR 2.0 或更高版本重新编译上述代码，第二个 <code>catch</code> 块永远执行不到，C# 编译器显示以下警告消息：</p><p>CS1058: 上一个 catch 子句已捕获所有异常。引发的所有非异常均被包装在 <code>System.Runtime.CompilerServices.RuntimeWrappedException</code> 中。</p><p>开发人员有两个办法迁移 .NET Framework 2.0 之前的代码。首先，两个 <code>catch</code> 块中的代码可以合并到一个 <code>catch</code> 块中，并删除其中的一个 <code>catch</code> 块中，并删除其中的一个 <code>catch</code> 块。这是推荐的办法。另外，还可以向 CLR 说明程序集中的代码想按照旧的规则行事。也就是说，告诉 CLR 你的 <code>catch(Exception)</code> 块不应捕捉新的 <code>RuntimeWrappedException</code> 类的一个实例。在这种情况下，CLR 不会将非 CLS 相容的对象包装到一个 <code>RuntimeWrappedException</code> 实例中，而且只有在你提供了一个没有指定任何类型的 <code>catch</code> 块时才调用你的代码。为了告诉 CLR 需要旧的行为，可向你的程序集应用 <code>RuntimeCompatibilityAttribute</code> 类的实例：</p><pre><code class="language-C#">using System.Runtime.CompilerServices;
[assembly:RuntimeCompatibility(WrapNonExceptionThrows = false)]
</code></pre><p>注意，该特性影响的是整个程序集。在同一个程序集中，包装和不包装异常这两种处理方式不能同时存在。向包含旧代码的程序集 (假如 CLR 不支持在其中包装异常) 添加新代码 (希望 CLR 包装异常) 时要特别小心。</p><p>💡小结：.NET Framework 异常处理机制是用 Microsoft Windows 提供的结构化异常处理（Structured Exception Handling，SEH）机制构建的。一个 try 块至少要有一个关联的 catch 块或 finally 块，单独一个 try 块没有意义，C# 也不允许。一个 <code>try</code> 块可以关联 0 个或多个 <code>catch</code> 块。 <code>catch</code> 关键字后的圆括号中的表达式称为<strong>捕捉类型</strong>。C# 要求捕捉类型必须是 <code>System.Exception</code> 或者它的派生类型。CLR 自上而下搜索匹配的 <code>catch</code> 块，所以应该将具体的异常放在顶部。也就是说，首先出现的是派生程度最大的异常类型，接着是它们的基类型 (如果有的话)，最后是 <code>System.Exception</code> (或者没有指定任何捕捉类型的 <code>catch</code> 块)。事实上，如果弄反了这个顺序，将较具体的 <code>catch</code> 块放在靠近底部的位置，C# 编译器会报错，因为这样的 <code>catch</code> 块是不可达的。在 <code>try</code> 块的代码 (或者从 <code>try</code> 块调用的任何方法) 中抛出异常，CLR 将搜索捕捉类型与抛出的异常相同 (或者是它的基类) 的 <code>catch</code> 块。如果没有任何捕捉类型与抛出异常匹配，CLR 会去调用栈 &lt;sup&gt;①&lt;/sup &gt; 更高的一层搜索与异常匹配的捕捉类型。如果都到了调用栈的顶部，还是没有找到匹配的 <code>catch</code> 块，就会发生未处理的异常。一旦 CLR 找到匹配的 <code>catch</code> 块，就会执行内层所有 <code>finally</code> 块中的代码。所谓 “内存 <code>finally</code> 块” 是指从抛出异常的 <code>try</code> 块开始，到匹配异常的 <code>catch</code> 块之间的所有 <code>finally</code> 块。注意，匹配异常的那个 <code>catch</code> 块所关联的 <code>finally</code> 块尚未执行，该 <code>finally</code> 块中的代码一直要等到这个 <code>catch</code> 块中的代码执行完毕才会执行。所有内层 <code>finally</code> 块执行完毕之后，匹配异常的那个 <code>catch</code> 块中的代码才开始执行。C# 允许在捕捉类型后指定一个变量。捕捉到异常时，该变量将引用抛出的 <code>System.Exception</code> 派生对象。 <code>catch</code> 块的代码可通过引用该变量来访问异常的具体信息。虽然这个对象可以修改，但最好不要这么做，而应把它当成是只读的。 <code>finally</code> 块包含的是保证会执行的代码。一般在 <code>finally</code> 块中执行 <code>try</code> 块的行动所要求的资源清理操作。终止线程或卸载 AppDomain 会造成 CLR 抛出一个 <code>ThreadAbortException</code> ，使 <code>finally</code> 块能够执行。如果直接用 Win32 函数 <code>TerminateThread</code> 杀死线程，或者用 Win32 函数 <code>TerminateProcess</code> 或 <code>System.Environment</code> 的 <code>FailFast</code> 方法杀死进程， <code>finally</code> 块不会执行。当然，进程终止后， Windows 会清理该进程使用的所有资源。即使 <code>catch</code> 或 <code>finally</code> 块内部抛出了异常也不是世界末日 —— CLR 的异常机制仍会正常运转，好像异常是在 <code>finally</code> 块之后抛出的第一个异常，关于第一个异常的所有信息 (例如堆栈跟踪) 都将丢失<br>。这个新异常可能 (而且极有可能) 不会由你的代码处理，最终变成一个未处理的异常。在这种情况下，CLR 会终止你的进程。这是件好事情，因为损坏的所有状态现在都会被销毁。相较于让应用程序继续运行，造成不可预知的结果以及可能的安全漏洞，这样处理要好得多。</p><h2 id="the-systemexception-class"><a class="anchor" href="#the-systemexception-class">#</a> The System.Exception Class</h2><blockquote><p>The CLR allows an instance of any type to be thrown for an exception—from an Int32 to a String and beyond. However, Microsoft decided against forcing all programming languages to throw and catch exceptions of any type, so they defined the System.Exception type and decreed that all CLScompliant programming languages must be able to throw and catch exceptions whose type is derived from this type. Exception types that are derived from System.Exception are said to be CLS-compliant. C# and many other language compilers allow your code to throw only CLS-compliant exceptions.</p></blockquote><blockquote><p>The System.Exception type is a very simple type that contains the properties described in Table 20-1. Usually, you will not write any code to query or access these properties in any way. Instead, when your application terminates due to an unhandled exception, you will look at these properties in the debugger or in a report that gets generated and written out to the Windows Application event log or crash dump.</p></blockquote><p><img data-src="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/image-20221124111323255.png" alt="image-20221124111323255"></p><p><img data-src="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/image-20221124111347671.png" alt="image-20221124111347671"></p><blockquote><p>I’d like to say a few words about System.Exception’s read-only StackTrace property. A catch block can read this property to obtain the stack trace indicating what methods were called that led up to the exception. This information can be extremely valuable when you’re trying to detect the cause of an exception so that you can correct your code. When you access this property, you’re actually calling into code in the CLR; the property doesn’t simply return a string. When you construct a new object of an Exception-derived type, the StackTrace property is initialized to null. If you were to read the property, you wouldn’t get back a stack trace; you would get back null.</p></blockquote><blockquote><p>When an exception is thrown, the CLR internally records where the throw instruction occurred. When a catch block accepts the exception, the CLR records where the exception was caught. If, inside a catch block, you now access the thrown exception object’s StackTrace property, the code that implements the property calls into the CLR, which builds a string identifying all of the methods between the place where the exception was thrown and the filter that caught the exception.</p></blockquote><p>💡重要提示：抛出异常时，CLR 会重置异常起点；也就是说，CLR 只记录最新的异常对象的抛出位置。</p><blockquote><p>The following code throws the same exception object that it caught and causes the CLR to reset its starting point for the exception.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SomeMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token range operator">..</span><span class="token punctuation">.</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">throw</span> e<span class="token punctuation">;</span> <span class="token comment">// CLR thinks this is where exception originated. </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// FxCop reports this as an error </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In contrast, if you re-throw an exception object by using the throw keyword by itself, the CLR doesn’t reset the stack’s starting point. The following code re-throws the same exception object that it caught, causing the CLR to not reset its starting point for the exception.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SomeMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token range operator">..</span><span class="token punctuation">.</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">throw</span><span class="token punctuation">;</span> <span class="token comment">// This has no effect on where the CLR thinks the exception </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// originated. FxCop does NOT report this as an error </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In fact, the only difference between these two code fragments is what the CLR thinks is the original location where the exception was thrown. Unfortunately, when you throw or re-throw an exception, Windows does reset the stack’s starting point. So if the exception becomes unhandled, the stack location that gets reported to Windows Error Reporting is the location of the last throw or re-throw, even though the CLR knows the stack location where the original exception was thrown. This is unfortunate because it makes debugging applications that have failed in the field much more difficult. Some developers have found this so intolerable that they have chosen a different way to implement their code to ensure that the stack trace truly reflects the location where an exception was originally thrown.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SomeMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Boolean</span> trySucceeds <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token range operator">..</span><span class="token punctuation">.</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> trySucceeds <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>trySucceeds<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* catch code goes in here */</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The string returned from the StackTrace property doesn’t include any of the methods in the call stack that are above the point where the catch block accepted the exception object. If you want the complete stack trace from the start of the thread up to the exception handler, you can use the System.Diagnostics.StackTrace type. This type defines some properties and methods that allow a developer to programmatically manipulate a stack trace and the frames that make up the stack trace.</p></blockquote><blockquote><p>You can construct a StackTrace object by using several different constructors. Some constructors build the frames from the start of the thread to the point where the StackTrace object is constructed. Other constructors initialize the frames of the StackTrace object by using an Exceptionderived object passed as an argument.</p></blockquote><blockquote><p>If the CLR can find debug symbols (located in the .pdb files) for your assemblies, the string returned by System.Exception’s StackTrace property or System.Diagnostics.StackTrace’s ToString method will include source code file paths and line numbers. This information is incredibly useful for debugging.</p></blockquote><blockquote><p>Whenever you obtain a stack trace, you might find that some methods in the actual call stack don’t appear in the stack trace string. There are two reasons for this. First, the stack is really a record of where the thread should return to, not where the thread has come from. Second, the just-in-time (JIT) compiler can inline methods to avoid the overhead of calling and returning from a separate method. Many compilers (including the C# compiler) offer a /debug command-line switch. When this switch is used, these compilers embed information into the resulting assembly to tell the JIT compiler not to inline any of the assembly’s methods, making stack traces more complete and meaningful to the developer debugging the code.</p></blockquote><p>💡注意：JIT 编译器会检查应用于程序集的 <code>System.Diagnostics.Debuggabletrribute</code> 定制特性。C# 编译器会自动应用该特性。如果该特性指定了 <code>DisableOptimizations</code> 标志，JIT 编译器就不会对程序集的方法进行内联。使用 C# 编译器的 <code>/debug</code> 开关就会设置这个标志。另外，向方法应用定制特性 <code>System.Runtime.CompilerServices.MethodImplAttribute</code> 将禁止 JIT 编译器在调试和发布生成 (debug and release build) 时对该方法进行内联处理，以下方法定义示范了如何禁止方法内联：</p><pre><code class="language-C#">using System;
using System.Runtime.CompilerServices;

internal sealed class SomeType &#123;
    
    [MethodImpl(MethodImplOptions.NoInlining)]
    public void SomeMethod() &#123;
        ...
    &#125;
&#125;
</code></pre><p>💡小结：CLR 允许异常抛出任何类型的实例 —— 从 <code>Int32</code> 到 <code>String</code> 都可以。而 C# 定义了 <code>System.Exception</code> 类型，并规定所有 CLS 相容的编程语言都必须能抛出和捕捉派生自该类型的异常。派生自 <code>System.Exception</code> 的异常类型被认为是 CLS 相容的。C# 和其他许多语言的编译器都只允许抛出 CLS 相容的异常。 <code>System.Exception</code> 定义了一些属性。但一般不要写任何代码以任何方式查询或访问这些属性。相反，当应用程序因为未处理的异常而终止时，可以在调试器中查看这些属性，或者在 Windows 应用程序事件日志或崩溃转储 (crash dump) 中查看。构造 <code>Exception</code> 派生类型的新对象时， <code>StackTrace</code> 属性被初始化为 <code>null</code> 。如果此时读取该属性，得到的不是堆栈跟踪，而是一个 <code>null</code> 。一个异常抛出时，CLR 在内部记录 <code>throw</code> 指令的位置 (抛出位置)。一个 <code>catch</code> 块捕捉到该异常时，CLR 记录捕捉位置。在 <code>catch</code> 块内访问被抛出的异常对象的 <code>StackTrace</code> 属性，负责实现该属性的代码会调用 CLR 内部的代码，后者创建一个字符串来指出从异常抛出位置到异常捕捉位置的所有方法。但如果仅仅使用 <code>throw</code> 关键字本身 (删除后面的 <code>e</code> ) 来重新抛出异常对象，CLR 就不会重置堆栈的起点。以下代码重新抛出它捕捉到的异常，但不会导致 CLR 重置起点。遗憾的是，不管抛出还是重新抛出异常，Windows 都会重置栈的起点。因此，如果一个异常成为未处理的异常，那么向 Windows Error Reporting 报告的栈位置就是最后一次抛出或重新抛出的位置 (即使 CLR 知道异常的原始抛出位置)。 <code>StackTrace</code> 属性返回的字符串不包含调用栈中比较受异常对象的那个 <code>catch</code> 块高的任何方法（栈顶移动即 “升高”，向栈底移动即 “降低”）。要获得从线程起始处到异常处理程序（catch 块）之间的完整堆栈追踪，需要使用 <code>System.Diagnostics.StackTrace</code> 类型。该类型定义了一些属性和方法，允许开发人员程序化地处理堆栈跟踪以及构成堆栈跟踪的栈桢（栈桢 (stack frame) 代表当前线程的调用栈中的一个方法调用。执行线程的过程中进行的每个方法调用都会在调用栈中创建并压入一个 <code>StackFrame</code> ）。如果 CLR 能找到你的程序集的调试符号 (存储在.pdb 文件中)，那么在 <code>System.Exception</code> 的 <code>StackTrace</code> 属性或者 <code>System.Diagnostics.StackTrace</code> 的 <code>ToString</code> 方法返回的字符串中，将包括源代码文件路径和代码行号，这些信息对于调试是很有用的。获得堆栈跟踪后，可能发现实际调用栈中的一些方法没有出现在堆栈跟踪字符串中。这可能有两方面的原因。首先，调用栈记录的是线程的返回位置 (而非来源位置)。其次， JIT 编译器可能进行了优化，将一些方法内联 (inline)，以避免调用单独的方法并从中返回的开销。许多编译器 (包括 C# 编译器) 都支持 <code>/debug</code> 命令行开关。使用这个开关，编译器会在生成的程序集中嵌入信息，告诉 JIT 编译器不要内联程序集的任何方法，确保调试人员获得更完整、更有意义的堆栈跟踪。</p><h2 id="fcl-defined-exception-classes"><a class="anchor" href="#fcl-defined-exception-classes">#</a> FCL-Defined Exception Classes</h2><blockquote><p>The Framework Class Library (FCL) defines many exception types (all ultimately derived from System. Exception). The following hierarchy shows the exception types defined in the MSCorLib.dll assembly; other assemblies define even more exception types. (The application used to obtain this hierarchy is shown in Chapter 23, “Assembly Loading and Reflection.”)</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>System<span class="token punctuation">.</span>Exception</pre></td></tr><tr><td data-num="2"></td><td><pre> System<span class="token punctuation">.</span>AggregateException</pre></td></tr><tr><td data-num="3"></td><td><pre> System<span class="token punctuation">.</span>ApplicationException</pre></td></tr><tr><td data-num="4"></td><td><pre>     System<span class="token punctuation">.</span>Reflection<span class="token punctuation">.</span>InvalidFilterCriteriaException</pre></td></tr><tr><td data-num="5"></td><td><pre>     System<span class="token punctuation">.</span>Reflection<span class="token punctuation">.</span>TargetException</pre></td></tr><tr><td data-num="6"></td><td><pre>     System<span class="token punctuation">.</span>Reflection<span class="token punctuation">.</span>TargetInvocationException</pre></td></tr><tr><td data-num="7"></td><td><pre>     System<span class="token punctuation">.</span>Reflection<span class="token punctuation">.</span>TargetParameterCountException</pre></td></tr><tr><td data-num="8"></td><td><pre>     System<span class="token punctuation">.</span>Threading<span class="token punctuation">.</span>WaitHandleCannotBeOpenedException</pre></td></tr><tr><td data-num="9"></td><td><pre> System<span class="token punctuation">.</span>Diagnostics<span class="token punctuation">.</span>Tracing<span class="token punctuation">.</span>EventSourceException</pre></td></tr><tr><td data-num="10"></td><td><pre> System<span class="token punctuation">.</span>InvalidTimeZoneException</pre></td></tr><tr><td data-num="11"></td><td><pre> System<span class="token punctuation">.</span>IO<span class="token punctuation">.</span>IsolatedStorage<span class="token punctuation">.</span>IsolatedStorageException</pre></td></tr><tr><td data-num="12"></td><td><pre> System<span class="token punctuation">.</span>Threading<span class="token punctuation">.</span>LockRecursionException</pre></td></tr><tr><td data-num="13"></td><td><pre> System<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>CompilerServices<span class="token punctuation">.</span>RuntimeWrappedException</pre></td></tr><tr><td data-num="14"></td><td><pre> System<span class="token punctuation">.</span>SystemException</pre></td></tr><tr><td data-num="15"></td><td><pre>     System<span class="token punctuation">.</span>Threading<span class="token punctuation">.</span>AbandonedMutexException</pre></td></tr><tr><td data-num="16"></td><td><pre>     System<span class="token punctuation">.</span>AccessViolationException</pre></td></tr><tr><td data-num="17"></td><td><pre>     System<span class="token punctuation">.</span>Reflection<span class="token punctuation">.</span>AmbiguousMatchException</pre></td></tr><tr><td data-num="18"></td><td><pre>     System<span class="token punctuation">.</span>AppDomainUnloadedException</pre></td></tr><tr><td data-num="19"></td><td><pre>     System<span class="token punctuation">.</span>ArgumentException</pre></td></tr><tr><td data-num="20"></td><td><pre>         System<span class="token punctuation">.</span>ArgumentNullException</pre></td></tr><tr><td data-num="21"></td><td><pre>         System<span class="token punctuation">.</span>ArgumentOutOfRangeException</pre></td></tr><tr><td data-num="22"></td><td><pre>         System<span class="token punctuation">.</span>Globalization<span class="token punctuation">.</span>CultureNotFoundException</pre></td></tr><tr><td data-num="23"></td><td><pre>         System<span class="token punctuation">.</span>Text<span class="token punctuation">.</span>DecoderFallbackException</pre></td></tr><tr><td data-num="24"></td><td><pre>         System<span class="token punctuation">.</span>DuplicateWaitObjectException</pre></td></tr><tr><td data-num="25"></td><td><pre>         System<span class="token punctuation">.</span>Text<span class="token punctuation">.</span>EncoderFallbackException</pre></td></tr><tr><td data-num="26"></td><td><pre>	 System<span class="token punctuation">.</span>ArithmeticException</pre></td></tr><tr><td data-num="27"></td><td><pre>         System<span class="token punctuation">.</span>DivideByZeroException</pre></td></tr><tr><td data-num="28"></td><td><pre>         System<span class="token punctuation">.</span>NotFiniteNumberException</pre></td></tr><tr><td data-num="29"></td><td><pre>         System<span class="token punctuation">.</span>OverflowException</pre></td></tr><tr><td data-num="30"></td><td><pre>     System<span class="token punctuation">.</span>ArrayTypeMismatchException</pre></td></tr><tr><td data-num="31"></td><td><pre>     System<span class="token punctuation">.</span>BadImageFormatException</pre></td></tr><tr><td data-num="32"></td><td><pre>     System<span class="token punctuation">.</span>CannotUnloadAppDomainException</pre></td></tr><tr><td data-num="33"></td><td><pre>     System<span class="token punctuation">.</span>ContextMarshalException</pre></td></tr><tr><td data-num="34"></td><td><pre>     System<span class="token punctuation">.</span>Security<span class="token punctuation">.</span>Cryptography<span class="token punctuation">.</span>CryptographicException</pre></td></tr><tr><td data-num="35"></td><td><pre> 	 	 System<span class="token punctuation">.</span>Security<span class="token punctuation">.</span>Cryptography<span class="token punctuation">.</span>CryptographicUnexpectedOperationException</pre></td></tr><tr><td data-num="36"></td><td><pre>     System<span class="token punctuation">.</span>DataMisalignedException</pre></td></tr><tr><td data-num="37"></td><td><pre>     System<span class="token punctuation">.</span>ExecutionEngineException</pre></td></tr><tr><td data-num="38"></td><td><pre>     System<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>InteropServices<span class="token punctuation">.</span>ExternalException</pre></td></tr><tr><td data-num="39"></td><td><pre>         System<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>InteropServices<span class="token punctuation">.</span>COMException</pre></td></tr><tr><td data-num="40"></td><td><pre>         System<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>InteropServices<span class="token punctuation">.</span>SEHException</pre></td></tr><tr><td data-num="41"></td><td><pre> 	System<span class="token punctuation">.</span>FormatException</pre></td></tr><tr><td data-num="42"></td><td><pre> 		 System<span class="token punctuation">.</span>Reflection<span class="token punctuation">.</span>CustomAttributeFormatException</pre></td></tr><tr><td data-num="43"></td><td><pre>     System<span class="token punctuation">.</span>Security<span class="token punctuation">.</span>HostProtectionException</pre></td></tr><tr><td data-num="44"></td><td><pre>     System<span class="token punctuation">.</span>Security<span class="token punctuation">.</span>Principal<span class="token punctuation">.</span>IdentityNotMappedException</pre></td></tr><tr><td data-num="45"></td><td><pre>     System<span class="token punctuation">.</span>IndexOutOfRangeException </pre></td></tr><tr><td data-num="46"></td><td><pre>     System<span class="token punctuation">.</span>InsufficientExecutionStackException</pre></td></tr><tr><td data-num="47"></td><td><pre>     System<span class="token punctuation">.</span>InvalidCastException</pre></td></tr><tr><td data-num="48"></td><td><pre>     System<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>InteropServices<span class="token punctuation">.</span>InvalidComObjectException</pre></td></tr><tr><td data-num="49"></td><td><pre>     System<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>InteropServices<span class="token punctuation">.</span>InvalidOleVariantTypeException</pre></td></tr><tr><td data-num="50"></td><td><pre>     System<span class="token punctuation">.</span>InvalidOperationException</pre></td></tr><tr><td data-num="51"></td><td><pre> 		 System<span class="token punctuation">.</span>ObjectDisposedException</pre></td></tr><tr><td data-num="52"></td><td><pre>     System<span class="token punctuation">.</span>InvalidProgramException</pre></td></tr><tr><td data-num="53"></td><td><pre>     System<span class="token punctuation">.</span>IO<span class="token punctuation">.</span>IOException</pre></td></tr><tr><td data-num="54"></td><td><pre>         System<span class="token punctuation">.</span>IO<span class="token punctuation">.</span>DirectoryNotFoundException</pre></td></tr><tr><td data-num="55"></td><td><pre>         System<span class="token punctuation">.</span>IO<span class="token punctuation">.</span>DriveNotFoundException</pre></td></tr><tr><td data-num="56"></td><td><pre>         System<span class="token punctuation">.</span>IO<span class="token punctuation">.</span>EndOfStreamException</pre></td></tr><tr><td data-num="57"></td><td><pre>         System<span class="token punctuation">.</span>IO<span class="token punctuation">.</span>FileLoadException</pre></td></tr><tr><td data-num="58"></td><td><pre>         System<span class="token punctuation">.</span>IO<span class="token punctuation">.</span>FileNotFoundException</pre></td></tr><tr><td data-num="59"></td><td><pre>         System<span class="token punctuation">.</span>IO<span class="token punctuation">.</span>PathTooLongException</pre></td></tr><tr><td data-num="60"></td><td><pre>     System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>Generic<span class="token punctuation">.</span>KeyNotFoundException</pre></td></tr><tr><td data-num="61"></td><td><pre>     System<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>InteropServices<span class="token punctuation">.</span>MarshalDirectiveException</pre></td></tr><tr><td data-num="62"></td><td><pre>     System<span class="token punctuation">.</span>MemberAccessException</pre></td></tr><tr><td data-num="63"></td><td><pre>         System<span class="token punctuation">.</span>FieldAccessException</pre></td></tr><tr><td data-num="64"></td><td><pre>         System<span class="token punctuation">.</span>MethodAccessException</pre></td></tr><tr><td data-num="65"></td><td><pre>         System<span class="token punctuation">.</span>MissingMemberException</pre></td></tr><tr><td data-num="66"></td><td><pre>             System<span class="token punctuation">.</span>MissingFieldException</pre></td></tr><tr><td data-num="67"></td><td><pre>             System<span class="token punctuation">.</span>MissingMethodException</pre></td></tr><tr><td data-num="68"></td><td><pre>     System<span class="token punctuation">.</span>Resources<span class="token punctuation">.</span>MissingManifestResourceException</pre></td></tr><tr><td data-num="69"></td><td><pre>     System<span class="token punctuation">.</span>Resources<span class="token punctuation">.</span>MissingSatelliteAssemblyException</pre></td></tr><tr><td data-num="70"></td><td><pre>     System<span class="token punctuation">.</span>MulticastNotSupportedException</pre></td></tr><tr><td data-num="71"></td><td><pre>     System<span class="token punctuation">.</span>NotImplementedException</pre></td></tr><tr><td data-num="72"></td><td><pre>     System<span class="token punctuation">.</span>NotSupportedException</pre></td></tr><tr><td data-num="73"></td><td><pre>		 System<span class="token punctuation">.</span>PlatformNotSupportedException</pre></td></tr><tr><td data-num="74"></td><td><pre>     System<span class="token punctuation">.</span>NullReferenceException</pre></td></tr><tr><td data-num="75"></td><td><pre>     System<span class="token punctuation">.</span>OperationCanceledException</pre></td></tr><tr><td data-num="76"></td><td><pre>		 System<span class="token punctuation">.</span>Threading<span class="token punctuation">.</span>Tasks<span class="token punctuation">.</span>TaskCanceledException</pre></td></tr><tr><td data-num="77"></td><td><pre>	 System<span class="token punctuation">.</span>OutOfMemoryException</pre></td></tr><tr><td data-num="78"></td><td><pre>		 System<span class="token punctuation">.</span>InsufficientMemoryException</pre></td></tr><tr><td data-num="79"></td><td><pre>     System<span class="token punctuation">.</span>Security<span class="token punctuation">.</span>Policy<span class="token punctuation">.</span>PolicyException</pre></td></tr><tr><td data-num="80"></td><td><pre>     System<span class="token punctuation">.</span>RankException</pre></td></tr><tr><td data-num="81"></td><td><pre>     System<span class="token punctuation">.</span>Reflection<span class="token punctuation">.</span>ReflectionTypeLoadException</pre></td></tr><tr><td data-num="82"></td><td><pre>     System<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>Remoting<span class="token punctuation">.</span>RemotingException</pre></td></tr><tr><td data-num="83"></td><td><pre>		 System<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>Remoting<span class="token punctuation">.</span>RemotingTimeoutException</pre></td></tr><tr><td data-num="84"></td><td><pre>     System<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>InteropServices<span class="token punctuation">.</span>SafeArrayRankMismatchException</pre></td></tr><tr><td data-num="85"></td><td><pre>     System<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>InteropServices<span class="token punctuation">.</span>SafeArrayTypeMismatchException</pre></td></tr><tr><td data-num="86"></td><td><pre>     System<span class="token punctuation">.</span>Security<span class="token punctuation">.</span>SecurityException</pre></td></tr><tr><td data-num="87"></td><td><pre>     System<span class="token punctuation">.</span>Threading<span class="token punctuation">.</span>SemaphoreFullException</pre></td></tr><tr><td data-num="88"></td><td><pre>     System<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>Serialization<span class="token punctuation">.</span>SerializationException</pre></td></tr><tr><td data-num="89"></td><td><pre>     System<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>Remoting<span class="token punctuation">.</span>ServerException</pre></td></tr><tr><td data-num="90"></td><td><pre>     System<span class="token punctuation">.</span>StackOverflowException</pre></td></tr><tr><td data-num="91"></td><td><pre>     System<span class="token punctuation">.</span>Threading<span class="token punctuation">.</span>SynchronizationLockException</pre></td></tr><tr><td data-num="92"></td><td><pre>     System<span class="token punctuation">.</span>Threading<span class="token punctuation">.</span>ThreadAbortException</pre></td></tr><tr><td data-num="93"></td><td><pre>     System<span class="token punctuation">.</span>Threading<span class="token punctuation">.</span>ThreadInterruptedException</pre></td></tr><tr><td data-num="94"></td><td><pre>     System<span class="token punctuation">.</span>Threading<span class="token punctuation">.</span>ThreadStartException</pre></td></tr><tr><td data-num="95"></td><td><pre>     System<span class="token punctuation">.</span>Threading<span class="token punctuation">.</span>ThreadStateException</pre></td></tr><tr><td data-num="96"></td><td><pre>     System<span class="token punctuation">.</span>TimeoutException</pre></td></tr><tr><td data-num="97"></td><td><pre>     System<span class="token punctuation">.</span>TypeInitializationException</pre></td></tr><tr><td data-num="98"></td><td><pre>     System<span class="token punctuation">.</span>TypeLoadException</pre></td></tr><tr><td data-num="99"></td><td><pre>         System<span class="token punctuation">.</span>DllNotFoundException</pre></td></tr><tr><td data-num="100"></td><td><pre>         System<span class="token punctuation">.</span>EntryPointNotFoundException</pre></td></tr><tr><td data-num="101"></td><td><pre>         System<span class="token punctuation">.</span>TypeAccessException</pre></td></tr><tr><td data-num="102"></td><td><pre>     System<span class="token punctuation">.</span>TypeUnloadedException</pre></td></tr><tr><td data-num="103"></td><td><pre>     System<span class="token punctuation">.</span>UnauthorizedAccessException</pre></td></tr><tr><td data-num="104"></td><td><pre>		 System<span class="token punctuation">.</span>Security<span class="token punctuation">.</span>AccessControl<span class="token punctuation">.</span>PrivilegeNotHeldException</pre></td></tr><tr><td data-num="105"></td><td><pre>     System<span class="token punctuation">.</span>Security<span class="token punctuation">.</span>VerificationException</pre></td></tr><tr><td data-num="106"></td><td><pre>     System<span class="token punctuation">.</span>Security<span class="token punctuation">.</span>XmlSyntaxException</pre></td></tr><tr><td data-num="107"></td><td><pre> System<span class="token punctuation">.</span>Threading<span class="token punctuation">.</span>Tasks<span class="token punctuation">.</span>TaskSchedulerException</pre></td></tr><tr><td data-num="108"></td><td><pre> System<span class="token punctuation">.</span>TimeZoneNotFoundException</pre></td></tr></table></figure><p>💡小结：Microsoft 本来是打算将 <code>System.Exception</code> 类型作为所有异常的基类型，而另外两个类型 <code>System.SystemException</code> 和 <code>System.ApplicationException</code> 是唯一直接从 <code>Exception</code> 派生的类型。另外，CLR 抛出的所有异常都从 <code>SystemException</code> 派生，应用程序抛出的所有异常都从 <code>ApplicationException</code> 派生。这样就可以写一个 <code>catch</code> 块来捕捉 CLR 抛出的所有异常或者应用程序抛出的所有异常。但实际上规则没有得到严格遵守，因此结构一团糟。</p><h2 id="throwing-an-exception"><a class="anchor" href="#throwing-an-exception">#</a> Throwing an Exception</h2><blockquote><p>When implementing your own methods, you should throw an exception when the method cannot complete its task as indicated by its name. When you want to throw an exception, there are two issues that you really need to think about and consider.</p></blockquote><blockquote><p>The first issue is about which Exception-derived type you are going to throw. You really want to select a type that is meaningful here. Consider the code that is higher up the call stack and how that code might want to determine that a method failed in order to execute some graceful recovery code. You can use a type that is already defined in the FCL, but there may not be one in the FCL that matches your exact semantics. So you’ll probably need to define your own type, ultimately derived from System.Exception.</p></blockquote><blockquote><p>If you want to define an exception type hierarchy, it is highly recommended that the hierarchy be shallow and wide in order to create as few base classes as possible. The reason is that base classes act as a way of treating lots of errors as one error, and this is usually dangerous. Along these lines, you should never throw a <code>System.Exception</code> object, and you should use extreme caution if you throw any other base class exception type.</p></blockquote><p>💡重要提示：还要考虑版本问题。如果定义从现有异常类型派生的一个新异常类型，捕捉现有基类型的所有代码也能捕捉新类型。这有时可能正好是你期望的，但有时也可能不是，具体取决于捕捉基类的代码以什么样的方式响应异常类型及其派生类型。从未预料到会有新异常的代码现在可能出现非预期的行为，并可能留下安全隐患。而定义新异常类型的人一般不知道基异常的所有捕捉位置以及具体处理方式。所以这里事实不可能做出面面俱到的决定。</p><blockquote><p>The second issue is about deciding what string message you are going to pass to the exception type’s constructor. When you throw an exception, you should include a string message with detailed information indicating why the method couldn’t complete its task. If the exception is caught and handled, this string message is not seen. However, if the exception becomes an unhandled exception, this message is usually logged. An unhandled exception indicates a true bug in the application, and a developer must get involved to fix the bug. An end user will not have the source code or the ability to fix the code and recompile it. In fact, this string message should not be shown to an end user. So these string messages can be very technically detailed and as geeky as is necessary to help developers fix their code.</p></blockquote><blockquote><p>Furthermore, because all developers have to speak English (at least to some degree, because programming languages and the FCL classes and methods are in English), there is usually no need to localize exception string messages. However, you may want to localize the strings if you are building a class library that will be used by developers who speak different languages. Microsoft localizes the exception messages thrown by the FCL, because developers all over the world will be using this class library.</p></blockquote><p>💡小结：强烈建议定义浅而宽的异常类型层次结构 &lt;sup&gt;①&lt;/sup&gt;，以创建尽量少的基类。原因是基类的主要作用就是将大量错误当作一个错误，而这通常是危险的。基于同样的考虑，永远都不要抛出一个 <code>System.Exception</code> 对象 &lt;sup&gt;②&lt;/sup&gt;，抛出其他任何基类异常类型时也要特别谨慎。向异常类型传递的字符串信息应详细说明方法为什么无法完成任务。如果异常被捕捉到并进行了处理，用户就看不到该字符串的信息。但是，如果成为未处理的异常，消息通常会被写入日志。这个字符串消息根本不应该向最终用户显式，所以，字符串消息可以包含非常详细的技术细节，以帮助开发人员修正代码。</p><h2 id="defining-your-own-exception-class"><a class="anchor" href="#defining-your-own-exception-class">#</a> Defining Your Own Exception Class</h2><blockquote><p>Unfortunately, designing your own exception is tedious and error prone. The main reason for this is because all Exception-derived types should be serializable so that they can cross an AppDomain boundary or be written to a log or database. There are many issues related to serialization and they are discussed in Chapter 24, “Runtime Serialization.” So, in an effort to simplify things, I made my own generic Exception class, which is defined as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Serializable</span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Exception<span class="token punctuation">&lt;</span>TExceptionArgs<span class="token punctuation">></span></span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Exception</span><span class="token punctuation">,</span> <span class="token class-name">ISerializable</span></span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">where</span> <span class="token class-name">TExceptionArgs</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">ExceptionArgs</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">const</span> <span class="token class-name">String</span> c_args <span class="token operator">=</span> <span class="token string">"Args"</span><span class="token punctuation">;</span> <span class="token comment">// For (de)serialization</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">TExceptionArgs</span> m_args<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">TExceptionArgs</span> Args <span class="token punctuation">&#123;</span> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> m_args<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Exception</span><span class="token punctuation">(</span><span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token class-name">Exception</span> innerException <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> message<span class="token punctuation">,</span> innerException<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Exception</span><span class="token punctuation">(</span><span class="token class-name">TExceptionArgs</span> args<span class="token punctuation">,</span> <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token class-name">Exception</span> innerException <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">base</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> innerException<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> m_args <span class="token operator">=</span> args<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// This constructor is for deserialization; since the class is sealed, the constructor is</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// private. If this class were not sealed, this constructor should be protected </span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token punctuation">[</span><span class="token function">SecurityPermission</span><span class="token punctuation">(</span>SecurityAction<span class="token punctuation">.</span>LinkDemand<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="14"></td><td><pre> Flags<span class="token operator">=</span>SecurityPermissionFlag<span class="token punctuation">.</span>SerializationFormatter<span class="token punctuation">)</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token keyword">private</span> <span class="token function">Exception</span><span class="token punctuation">(</span><span class="token class-name">SerializationInfo</span> info<span class="token punctuation">,</span> <span class="token class-name">StreamingContext</span> context<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token punctuation">:</span> <span class="token keyword">base</span><span class="token punctuation">(</span>info<span class="token punctuation">,</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre> m_args <span class="token operator">=</span> <span class="token punctuation">(</span>TExceptionArgs<span class="token punctuation">)</span>info<span class="token punctuation">.</span><span class="token function">GetValue</span><span class="token punctuation">(</span>c_args<span class="token punctuation">,</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">TExceptionArgs</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token comment">// This method is for serialization; it’s public because of the ISerializable interface</span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token punctuation">[</span><span class="token function">SecurityPermission</span><span class="token punctuation">(</span>SecurityAction<span class="token punctuation">.</span>LinkDemand<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="21"></td><td><pre> Flags<span class="token operator">=</span>SecurityPermissionFlag<span class="token punctuation">.</span>SerializationFormatter<span class="token punctuation">)</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">GetObjectData</span><span class="token punctuation">(</span><span class="token class-name">SerializationInfo</span> info<span class="token punctuation">,</span> <span class="token class-name">StreamingContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre> info<span class="token punctuation">.</span><span class="token function">AddValue</span><span class="token punctuation">(</span>c_args<span class="token punctuation">,</span> m_args<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">GetObjectData</span><span class="token punctuation">(</span>info<span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name">String</span> Message <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="27"></td><td><pre> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre> <span class="token class-name">String</span> baseMsg <span class="token operator">=</span> <span class="token keyword">base</span><span class="token punctuation">.</span>Message<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre> <span class="token keyword">return</span> <span class="token punctuation">(</span>m_args <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">?</span> baseMsg <span class="token punctuation">:</span> baseMsg <span class="token operator">+</span> <span class="token string">" ("</span> <span class="token operator">+</span> m_args<span class="token punctuation">.</span>Message <span class="token operator">+</span> <span class="token string">")"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name">Boolean</span> <span class="token function">Equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="33"></td><td><pre> <span class="token class-name">Exception<span class="token punctuation">&lt;</span>TExceptionArgs<span class="token punctuation">></span></span> other <span class="token operator">=</span> obj <span class="token keyword">as</span> <span class="token class-name">Exception<span class="token punctuation">&lt;</span>TExceptionArgs<span class="token punctuation">></span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>other <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre> <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">Equals</span><span class="token punctuation">(</span>m_args<span class="token punctuation">,</span> other<span class="token punctuation">.</span>m_args<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">Equals</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="37"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">GetHashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">GetHashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="38"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>And the ExceptionArgs base class that TExceptionArgs is constrained to is very simple and looks like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Serializable</span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ExceptionArgs</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token return-type class-name">String</span> Message <span class="token punctuation">&#123;</span> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> String<span class="token punctuation">.</span>Empty<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Now, with these two classes defined, I can trivially define more exception classes when I need to. To define an exception type indicating the disk is full, I simply do the following.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Serializable</span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">DiskFullExceptionArgs</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">ExceptionArgs</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">String</span> m_diskpath<span class="token punctuation">;</span> <span class="token comment">// private field set at construction time</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token function">DiskFullExceptionArgs</span><span class="token punctuation">(</span><span class="token class-name">String</span> diskpath<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> m_diskpath <span class="token operator">=</span> diskpath<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// Public read-only property that returns the field</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">String</span> DiskPath <span class="token punctuation">&#123;</span> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> m_diskpath<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// Override the Message property to include our field (if set)</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name">String</span> Message <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">return</span> <span class="token punctuation">(</span>m_diskpath <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">?</span> <span class="token keyword">base</span><span class="token punctuation">.</span>Message <span class="token punctuation">:</span> <span class="token string">"DiskPath="</span> <span class="token operator">+</span> m_diskpath<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>And, if I have no additional data that I want to put inside the class, it gets as simple as the following.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Serializable</span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">DiskFullExceptionArgs</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">ExceptionArgs</span></span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>And now I can write code like this, which throws and catches one of these.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">TestException</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Exception<span class="token punctuation">&lt;</span>DiskFullExceptionArgs<span class="token punctuation">></span></span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">DiskFullExceptionArgs</span><span class="token punctuation">(</span><span class="token string">@"C:\"), "</span>The disk <span class="token keyword">is</span> <span class="token class-name">full</span>"<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception<span class="token punctuation">&lt;</span>DiskFullExceptionArgs<span class="token punctuation">></span></span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>Message<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>💡注意：我的 <code>Exception&lt;TExceptionArgs&gt;</code> 类有两个问题需要注意。第一个问题是，用它定义的任何异常类型都总是派生自 <code>System.Exception</code> 。这在大多数时候都不是问题，而且浅而宽的异常类型层次结构还是一件好事。第二个问题是，Visual Studio 的未处理异常对话框不会显示 <code>Exception&lt;T&gt;</code> 类型的泛型类型参数，如下图所示。</p><p><img data-src="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/image-20221125132316254.png" alt="image-20221125132316254"></p><p>💡小结：设计自己的异常不仅繁琐，还容易出错。主要原因是从 <code>Exception</code> 派生的所有类型都应该是可序列化的（serializable），使它们能穿越 <code>AppDomain</code> 边界或者写入日志 / 数据库。</p><h2 id="trading-reliability-for-productivity"><a class="anchor" href="#trading-reliability-for-productivity">#</a> Trading Reliability for Productivity</h2><blockquote><p>I started writing software in 1975. I did a fair amount of BASIC programming, and as I got more interested in hardware, I switched to assembly language. Over time, I switched to the C programming language because it allowed me access to hardware with a much higher level of abstraction, making my programming easier. My background is in writing operating systems’ code and platform/library code, so I always work hard to make my code as small and as fast as possible, because applications can only be as good as the operating system and libraries they consume.</p></blockquote><blockquote><p>In addition to creating small and fast code, I always focused on error recovery. When allocating memory (by using C++’s new operator or by calling malloc, HeapAlloc, VirtualAlloc, etc.), I would always check the return value to ensure that the memory I requested was actually given to me. And, if the memory request failed, I always had an alternate code path ensuring that the rest of the program’s state was unaffected and would let any of my callers know that I failed so that the calling code can take corrective measures too.</p></blockquote><blockquote><p>For some reason that I can’t quite explain, this attention to detail is not done when writing code for the .NET Framework. Getting an out-of-memory situation is always possible and yet I almost never see any code containing a catch block to recover from an OutOfMemoryException. In fact, I’ve even had some developers tell me that the CLR doesn’t let a program catch an OutOfMemoryException. For the record, this is absolutely not true; you can catch this exception. In fact, there are many errors that are possible when executing managed code and I hardly ever see developers write code that attempts to recover from these potential failures. In this section, I’d like to point out some of the potential failures and why it has become culturally acceptable to ignore them. I’d also like to point out some of the significant problems that can occur when ignoring these failures and suggest some ways to help mitigate these problems.</p></blockquote><blockquote><p>Object-oriented programming allows developers to be very productive. A big part of this is composability which makes it easy to write, read and maintain code. Take this line of code, for example.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Boolean</span> f <span class="token operator">=</span> <span class="token string">"Jeff"</span><span class="token punctuation">.</span><span class="token function">Substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToUpper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">EndsWith</span><span class="token punctuation">(</span><span class="token string">"E"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>There is a big assumption being made with the preceding code: no errors occur. But, of course, errors are always possible, and so we need a way to handle those errors. This is what the exception handling constructs and mechanisms are all about and why we need them as opposed to having methods that return true/false or an HRESULT to indicate success/failure the way that Win32 and COM functions do.</p></blockquote><blockquote><p>In addition to code composability, we are productive due to all kinds of great features provided by our compilers. For example, the compiler implicitly:</p><ul><li><p>Inserts optional parameters when calling a method.</p></li><li><p>Boxes value type instances.</p></li><li><p>Constructs/initializes parameter arrays.</p></li><li><p>Binds to members of dynamic variables and expressions.</p></li><li><p>Binds to extension methods.</p></li><li><p>Binds/invokes overloaded operators.</p></li><li><p>Constructs delegate objects.</p></li><li><p>Infers types when calling generic methods, declaring a local variable, and using a lambda expression.</p></li><li><p>Defines/constructs closure classes for lambda expressions and iterators.</p></li><li><p>Defines/constructs/initializes anonymous types and instances of them.</p></li><li><p>Rewrites code to support Language Integrated Queries (LINQs; query expressions and expression trees).</p></li></ul></blockquote><blockquote><p>And, the CLR itself does all kinds of great things for developers to make our lives even easier. For example, the CLR implicitly:</p><ul><li><p>Invokes virtual methods and interface methods.</p></li><li><p>Loads assemblies and JIT-compiles methods that can potentially throw FileLoadException, BadImageFormatException, InvalidProgramException, FieldAccessException, MethodAccessException, MissingFieldException, MissingMethodException, and VerificationException.</p></li><li><p>Transitions across AppDomain boundaries when accessing an object of a MarshalByRefObject-derived type which can potentially throw AppDomainUnloadedException.</p></li><li><p>Serializes and deserializes objects when crossing an AppDomain boundary.</p></li><li><p>Causes thread(s) to throw a ThreadAbortException when Thread.Abort or AppDomain.Unload is called.</p></li><li><p>Invokes Finalize methods after a garbage collection before objects have their memory reclaimed.</p></li><li><p>Creates type objects in the loader heap when using generic types.</p></li><li><p>Invokes a type’s static constructor potential throwing of TypeInitializationException.</p></li><li><p>Throws various exceptions, including OutOfMemoryException, DivideByZeroException, NullReferenceException, RuntimeWrappedException, TargetInvocationException, OverflowException, NotFiniteNumberException, ArrayTypeMismatchException, DataMisalignedException, IndexOutOfRangeException, InvalidCastException, RankException, SecurityException, and more.</p></li></ul></blockquote><blockquote><p>And, of course, the .NET Framework ships with a massive class library that contains tens of thousands of types, each type encapsulating common, reusable functionality. There are types for building web form applications, web services, rich GUI applications, working with security, manipulation of images, speech recognition, and the list goes on and on. Any of this code could throw an exception, indicating failure. And future versions could introduce new exception types derived from existing exception types and now your catch blocks catch exception types that never existed before.</p></blockquote><blockquote><p>All of this stuff—object-oriented programming, compiler features, CLR features, and the enormous class library—is what makes the .NET Framework such a compelling software development platform.4 My point is that all of this stuff introduces points of failure into your code, which you have little control over. As long as everything is working great, all is well: we write code easily, the code is easy to read and maintain. But, when something goes wrong, it is nearly impossible to fully understand what went wrong and why.</p></blockquote><blockquote><p>Here is an example that should really help get my point across.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name">Object</span> <span class="token function">OneStatement</span><span class="token punctuation">(</span><span class="token class-name">Stream</span> stream<span class="token punctuation">,</span> <span class="token class-name">Char</span> charToFind<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">return</span> <span class="token punctuation">(</span>charToFind <span class="token operator">+</span> <span class="token string">": "</span> <span class="token operator">+</span> stream<span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> String<span class="token punctuation">.</span>Empty <span class="token operator">+</span> <span class="token punctuation">(</span>stream<span class="token punctuation">.</span>Position <span class="token operator">+</span> <span class="token number">512M</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>c<span class="token operator">=></span>c <span class="token operator">==</span> charToFind<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>This slightly contrived method contains just one C# statement in it, but this statement does an awful lot of work. In fact, here is the Intermediate Language (IL) the C# compiler produced for this method. (I’ve put some lines in boldface italics that are potential points of failure due to implicit operations that are occurring.)</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">.</span>method <span class="token keyword">private</span> hidebysig <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">object</span></span> <span class="token function">OneStatement</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span><span class="token class-name">System<span class="token punctuation">.</span>IO<span class="token punctuation">.</span>Stream</span> stream<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">char</span></span> charToFind<span class="token punctuation">)</span> <span class="token return-type class-name">cil</span> managed <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token punctuation">.</span>maxstack <span class="token number">4</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token punctuation">.</span><span class="token return-type class-name">locals</span> init <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">class</span> <span class="token class-name">Program</span><span class="token operator">/</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token class-name">c__DisplayClass1</span> V_0<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token class-name"><span class="token keyword">object</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> V_1<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre> IL_0000<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> Program<span class="token operator">/</span><span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass1<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre> IL_0005<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">0</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> IL_0006<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> IL_0007<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">1</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> IL_0008<span class="token punctuation">:</span> stfld <span class="token keyword">char</span> Program<span class="token operator">/</span><span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass1<span class="token punctuation">::</span><span class="token class-name">charToFind</span></pre></td></tr><tr><td data-num="12"></td><td><pre> IL_000d<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span><span class="token number">5</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> IL_000e<span class="token punctuation">:</span> newarr <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span><span class="token class-name">System<span class="token punctuation">.</span>Object</span></pre></td></tr><tr><td data-num="14"></td><td><pre> IL_0013<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">1</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> IL_0014<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">1</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> IL_0015<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span><span class="token number">0</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> IL_0016<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span> </pre></td></tr><tr><td data-num="18"></td><td><pre> IL_0017<span class="token punctuation">:</span> ldfld <span class="token keyword">char</span> Program<span class="token operator">/</span><span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass1<span class="token punctuation">::</span><span class="token class-name">charToFind</span></pre></td></tr><tr><td data-num="19"></td><td><pre> IL_001c<span class="token punctuation">:</span> box <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span><span class="token class-name">System<span class="token punctuation">.</span>Char</span></pre></td></tr><tr><td data-num="20"></td><td><pre> IL_0021<span class="token punctuation">:</span> <span class="token class-name">stelem<span class="token punctuation">.</span><span class="token keyword">ref</span></span> </pre></td></tr><tr><td data-num="21"></td><td><pre> IL_0022<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">1</span> </pre></td></tr><tr><td data-num="22"></td><td><pre> IL_0023<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span><span class="token number">1</span> </pre></td></tr><tr><td data-num="23"></td><td><pre> IL_0024<span class="token punctuation">:</span> ldstr <span class="token string">": "</span></pre></td></tr><tr><td data-num="24"></td><td><pre> IL_0029<span class="token punctuation">:</span> <span class="token class-name">stelem<span class="token punctuation">.</span><span class="token keyword">ref</span></span> </pre></td></tr><tr><td data-num="25"></td><td><pre> IL_002a<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">1</span> </pre></td></tr><tr><td data-num="26"></td><td><pre> IL_002b<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span><span class="token number">2</span> </pre></td></tr><tr><td data-num="27"></td><td><pre> IL_002c<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span> </pre></td></tr><tr><td data-num="28"></td><td><pre> IL_002d<span class="token punctuation">:</span> callvirt instance <span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Type <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Object<span class="token punctuation">::</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="29"></td><td><pre> IL_0032<span class="token punctuation">:</span> <span class="token class-name">stelem<span class="token punctuation">.</span><span class="token keyword">ref</span></span> </pre></td></tr><tr><td data-num="30"></td><td><pre> IL_0033<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">1</span> </pre></td></tr><tr><td data-num="31"></td><td><pre> IL_0034<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span><span class="token number">3</span> </pre></td></tr><tr><td data-num="32"></td><td><pre> IL_0035<span class="token punctuation">:</span> ldsfld <span class="token keyword">string</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>String<span class="token punctuation">::</span><span class="token class-name">Empty</span></pre></td></tr><tr><td data-num="33"></td><td><pre> IL_003a<span class="token punctuation">:</span> <span class="token class-name">stelem<span class="token punctuation">.</span><span class="token keyword">ref</span></span> </pre></td></tr><tr><td data-num="34"></td><td><pre> IL_003b<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">1</span> </pre></td></tr><tr><td data-num="35"></td><td><pre> IL_003c<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span><span class="token number">4</span> </pre></td></tr><tr><td data-num="36"></td><td><pre> IL_003d<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="37"></td><td><pre> IL_003e<span class="token punctuation">:</span> callvirt instance int64 <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>IO<span class="token punctuation">.</span>Stream<span class="token punctuation">::</span><span class="token function">get_Position</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="38"></td><td><pre> IL_0043<span class="token punctuation">:</span> call valuetype <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Decimal</pre></td></tr><tr><td data-num="39"></td><td><pre> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Decimal<span class="token punctuation">::</span><span class="token function">op_Implicit</span><span class="token punctuation">(</span>int64<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="40"></td><td><pre> IL_0048<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4 <span class="token number">0x200</span></pre></td></tr><tr><td data-num="41"></td><td><pre> IL_004d<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Decimal<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span>int32<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="42"></td><td><pre> IL_0052<span class="token punctuation">:</span> call valuetype <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Decimal <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Decimal<span class="token punctuation">::</span>op_Addition</pre></td></tr><tr><td data-num="43"></td><td><pre> <span class="token punctuation">(</span>valuetype <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Decimal<span class="token punctuation">,</span> valuetype <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Decimal<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="44"></td><td><pre> IL_0057<span class="token punctuation">:</span> box <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span><span class="token class-name">System<span class="token punctuation">.</span>Decimal</span></pre></td></tr><tr><td data-num="45"></td><td><pre> IL_005c<span class="token punctuation">:</span> <span class="token class-name">stelem<span class="token punctuation">.</span><span class="token keyword">ref</span></span> </pre></td></tr><tr><td data-num="46"></td><td><pre> IL_005d<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">1</span> </pre></td></tr><tr><td data-num="47"></td><td><pre> IL_005e<span class="token punctuation">:</span> call <span class="token keyword">string</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>String<span class="token punctuation">::</span><span class="token function">Concat</span><span class="token punctuation">(</span><span class="token keyword">object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="48"></td><td><pre> IL_0063<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span> </pre></td></tr><tr><td data-num="49"></td><td><pre> IL_0064<span class="token punctuation">:</span> ldftn instance <span class="token keyword">bool</span> Program<span class="token operator">/</span><span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass1<span class="token punctuation">::</span><span class="token operator">&lt;</span>OneStatement<span class="token operator">></span><span class="token function">b__0</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="50"></td><td><pre> IL_006a<span class="token punctuation">:</span> newobj instance </pre></td></tr><tr><td data-num="51"></td><td><pre> <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Func`<span class="token number">2</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span><span class="token punctuation">::</span><span class="token punctuation">.</span>ctor<span class="token class-name"><span class="token punctuation">(</span><span class="token keyword">object</span><span class="token punctuation">,</span> native <span class="token keyword">int</span><span class="token punctuation">)</span></span></pre></td></tr><tr><td data-num="52"></td><td><pre> IL_006f<span class="token punctuation">:</span> call <span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>Generic<span class="token punctuation">.</span>IEnumerable`<span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">!</span><span class="token number">0</span><span class="token operator">></span></pre></td></tr><tr><td data-num="53"></td><td><pre> <span class="token punctuation">[</span>System<span class="token punctuation">.</span>Core<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Linq<span class="token punctuation">.</span>Enumerable<span class="token punctuation">::</span><span class="token generic-method"><span class="token function">Where</span><span class="token generic class-name"><span class="token punctuation">&lt;</span><span class="token keyword">char</span><span class="token punctuation">></span></span></span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="54"></td><td><pre> <span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>Generic<span class="token punctuation">.</span>IEnumerable`<span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">!</span><span class="token number">0</span><span class="token operator">></span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="55"></td><td><pre> <span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Func`<span class="token number">2</span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">!</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="56"></td><td><pre> IL_0074<span class="token punctuation">:</span> call <span class="token operator">!</span><span class="token operator">!</span><span class="token number">0</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">System<span class="token punctuation">.</span>Core</span></span><span class="token punctuation">]</span>System<span class="token punctuation">.</span>Linq<span class="token punctuation">.</span>Enumerable<span class="token punctuation">::</span><span class="token generic-method"><span class="token function">ToArray</span><span class="token generic class-name"><span class="token punctuation">&lt;</span><span class="token keyword">char</span><span class="token punctuation">></span></span></span></pre></td></tr><tr><td data-num="57"></td><td><pre> <span class="token punctuation">(</span><span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>Generic<span class="token punctuation">.</span>IEnumerable`<span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">!</span><span class="token number">0</span><span class="token operator">></span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="58"></td><td><pre> IL_0079<span class="token punctuation">:</span> ret </pre></td></tr><tr><td data-num="59"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>As you can see, an OutOfMemoryException is possible when constructing the &lt;&gt;c__DisplayClass1 class (a compiler-generated type), the Object[] array, the Func delegate, and boxing the char and Decimal. Memory is also allocated internally when Concat, Where, and ToArray are called. Constructing the Decimal instance could cause its type constructor to be invoked, resulting in a TypeInitializationException.5 And then, there are the implicit calls to Decimal’s op_Implicit operator and its op_Addition operator methods, which could do anything, including throwing an OverflowException.</p></blockquote><blockquote><p>Querying Stream’s Position property is interesting. First, it is a virtual property and so my OneStatement method has no idea what code will actually execute which could throw any exception at all. Second, Stream is derived from MarshalByRefObject, so the stream argument could actually refer to a proxy object which itself refers to an object in another AppDomain. The other AppDomain could be unloaded, so an AppDomainUnloadedException could also be thrown here.</p></blockquote><blockquote><p>Of course, all the methods that are being called are methods that I personally have no control over because they are produced by Microsoft. And it’s entirely possible that Microsoft might change how these methods are implemented in the future, so they could throw new exception types that I could not possibly know about on the day I wrote the OneStatement method. How can I possibly write my OneStatement method to be completely robust against all possible failures? By the way, the opposite is also a problem: a catch block could catch an exception type derived from the specified exception type and now I’m executing recovery code for a different kind of failure.</p></blockquote><blockquote><p>So now that you have a sense of all the possible failures, you can probably see why it has become culturally acceptable to not write truly robust and reliable code: it is simply impractical. Moreover, one could argue that it is actually impossible. The fact that errors do not occur frequently is another reason why it has become culturally acceptable. Because errors (like OutOfMemoryException) occur very infrequently, the community has decided to trade truly reliable code for programmer productivity.</p></blockquote><blockquote><p>One of the nice things about exceptions is that an unhandled one causes your application to terminate. This is nice because during testing, you will discover problems quickly and the information you get with an unhandled exception (error message and stack trace) are usually enough to allow you to fix your code. Of course, a lot of companies don’t want their application to just terminate after it has been tested and deployed, so a lot of developers insert code to catch System.Exception, the base class of all exception types. However, the problem with catching System.Exception and allowing the application to continue running is that state may be corrupted.</p></blockquote><blockquote><p>Earlier in this chapter, I showed an Account class that defines a Transfer method whose job is to transfer money from one account to another account. What if, when this Transfer method is called, it successfully subtracts money from the from account and then throws an exception before it adds money to the to account? If calling code catches System.Exception and continues running, then the state of the application is corrupted: both the from and to accounts have less money in them then they should. Because we are talking about money here, this state corruption wouldn’t just be considered a simple bug, it would definitely be considered a security bug. If the application continues running, it will attempt to perform more transfers to and from various accounts and now state corruption is running rampant within the application.</p></blockquote><blockquote><p>One could say that the Transfer method itself should catch System.Exception and restore money back into the from account. And this might actually work out OK if the Transfer method is simple enough. But if the Transfer method produces an audit record of the withdrawn money or if other threads are manipulating the same account at the same time, then attempting to undo the operation could fail as well, producing yet another thrown exception. And now, state corruption is getting worse, not better.</p></blockquote><p>💡注意：有人或许会说，知道哪里出错，比知道出了什么错更有用。例如，更有用的是知道从一个账户转账失败，而不是知道 <code>Transfer</code> 由于 <code>SecurityException</code> 或 <code>OutOfMemoryException</code> 而失败。事实上， Win32 错误模型就是这么设计的，方法是返回 <code>true/false</code> 来指明成功 / 失败，使你知道哪个方法失败。然后，如果程序关心失败的原因，可调用 Win32 函数 <code>GetLastError</code> 。 <code>System.Exception</code> 确实有一个 <code>Source</code> 属性可以告诉你失败的方法。但这个属性是一个你必须进行解析的 <code>String</code> ，而且假如两个方法在内部调用同一个方法，那么单凭 <code>Source</code> 属性是看不出哪个方法失败的。相反，必须解析从 <code>Exception</code> 的 <code>StackTrace</code> 属性返回的 <code>String</code> 来获取这个信息。这实在是太难了，我从未见过任何人真的写代码这样做。</p><blockquote><p>There are several things you can do to help mitigate state corruption:</p><ul><li>The CLR doesn’t allow a thread to be aborted when executing code inside a catch or finally block. So, we could make the Transfer method more robust simply by doing the following.</li></ul></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Transfer</span><span class="token punctuation">(</span><span class="token class-name">Account</span> from<span class="token punctuation">,</span> <span class="token class-name">Account</span> to<span class="token punctuation">,</span> <span class="token class-name">Decimal</span> amount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* do nothing in here */</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> from <span class="token operator">-=</span> amount<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// Now, a thread abort (due to Thread.Abort/AppDomain.Unload) can’t happen here</span></pre></td></tr><tr><td data-num="6"></td><td><pre> to <span class="token operator">+=</span> amount<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>However, it is absolutely not recommended that you write all your code in finally blocks! You should only use this technique for modifying extremely sensitive state.</p><ul><li><p>You can use the System.Diagnostics.Contracts.Contract class to apply code contracts to your methods. Code contracts give you a way to validate arguments and other variables before you attempt to modify state by using these arguments/variables. If the arguments/ variables meet the contract, then the chance of corrupted state is minimized (not completely eliminated). If a contract fails, then an exception is thrown before any state has been modified. I will talk about code contracts later in this chapter.</p></li><li><p>You can use constrained execution regions (CERs), which give you a way to take some CLR uncertainty out of the picture. For example, before entering a try block, you can have the CLR load any assemblies needed by code in any associated catch and finally blocks. In addition, the CLR will compile all the code in the catch and finally blocks including all the methods called from within those blocks. This will eliminate a bunch of potential exceptions (including FileLoadException, BadImageFormatException, InvalidProgramException, FieldAccessException, MethodAccessException, MissingFieldException, and MissingMethodException) from occurring when trying to execute error recovery code (in catch blocks) or cleanup code (in the finally block). It will also reduce the potential for OutOfMemoryException and some other exceptions as well. I talk about CERs later in this chapter.</p></li><li><p>Depending on where the state lives, you can use transactions which ensure that all state is modified or no state is modified. If the data is in a database, for example, transactions work well. Windows also now supports transacted registry and file operations (on an NTFS volume only), so you might be able to use this; however, the .NET Framework doesn’t expose this functionality directly today. You will have to P/Invoke to native code to leverage it. See the System.Transactions.TransactionScope class for more details about this.</p></li><li><p>You can design your methods to be more explicit. For example, the Monitor class is typically used for taking/releasing a thread synchronization lock as follows.</p></li></ul></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> s_myLockObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> SomeMethod <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> Monitor<span class="token punctuation">.</span><span class="token function">Enter</span><span class="token punctuation">(</span>s_myLockObject<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// If this throws, did the lock get taken or </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// not? If it did, then it won't get released!</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// Do thread-safe operation here...</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> Monitor<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span>s_myLockObject<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token comment">// ...</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Due to the problem just shown, the overload of the preceding Monitor’s Enter method used is now discouraged, and it is recommended that you rewrite the preceding code as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> s_myLockObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> SomeMethod <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">Boolean</span> lockTaken <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// Assume the lock was not taken</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// This works whether an exception is thrown or not! </span></pre></td></tr><tr><td data-num="7"></td><td><pre> Monitor<span class="token punctuation">.</span><span class="token function">Enter</span><span class="token punctuation">(</span>s_myLockObject<span class="token punctuation">,</span> <span class="token keyword">ref</span> lockTaken<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Do thread-safe operation here...</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// If the lock was taken, release it</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>lockTaken<span class="token punctuation">)</span> Monitor<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span>s_myLockObject<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// ...</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Although the explicitness in this code is an improvement, in the case of thread synchronization locks, the recommendation now is to not use them with exception handling at all. See Chapter 30, “Hybrid Thread Synchronization Constructs,” for more details about this.</p></blockquote><blockquote><p>If, in your code, you have determined that state has already been corrupted beyond repair, then you should destroy any corrupted state so that it can cause no additional harm. Then, restart your application so your state initializes itself to a good condition and hopefully, the state corruption will not happen again. Because managed state cannot leak outside of an AppDomain, you can destroy any corrupted state that lives within an AppDomain by unloading the entire AppDomain by calling AppDomain’s Unload method (see Chapter 22 for details).</p></blockquote><blockquote><p>And, if you feel that your state is so bad that the whole process should be terminated, then you can call Environment’s static FailFast method.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">FailFast</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">FailFast</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">,</span> <span class="token class-name">Exception</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>This method terminates the process without running any active try/finally blocks or Finalize methods. This is good because executing more code while state is corrupted could easily make matters worse. However, FailFast will allow any CriticalFinalizerObject-derived objects, discussed in Chapter 21, “The Managed Heap and Garbage Collection,” a chance to clean up. This is usually OK because they tend to just close native resources, and Windows state is probably fine even if the CLR’s state or your application’s state is corrupted. The FailFast method writes the message string and optional exception (usually the exception captured in a catch block) to the Windows Application event log, produces a Windows error report, creates a memory dump of your application, and then terminates the current process.</p></blockquote><p>💡重要提示：发生意料之外的异常时，Microsoft 的大多数 FCL 代码都不保证状态保持良好。如果你的代码捕捉从 FCL 代码那里 “漏” 过来的异常并继续使用 FCL 的对象，这些对象的行为有可能变得无法预测。令人难堪的是，现在越来越多的 FCL 对象在面对非预期的异常时不能更好地维护状态或者在状态无法恢复时调用 <code>FailFast</code> 。</p><blockquote><p>The point of this discussion is to make you aware of the potential problems related to using the CLR’s exception-handling mechanism. Most applications cannot tolerate running with a corrupted state because it leads to incorrect data and possible security holes. If you are writing an application that cannot tolerate terminating (like an operating system or database engine), then managed code is not a good technology to use. And although Microsoft Exchange Server is largely written in managed code, it uses a native database to store email messages. The native database is called the Extensible Storage Engine; it ships with Windows, and can usually be found at C:\Windows\System32\EseNT.dll. Your applications can also use this engine if you’d like; search for “Extensible Storage Engine” on the Microsoft MSDN website.</p></blockquote><blockquote><p>Managed code is a good choice for applications that can tolerate an application terminating when state corruption has possibly occurred. There are many applications that fall into this category. Also, it takes significantly more resources and skills to write a robust native class library or application; for many applications, managed code is the better choice because it greatly enhances programmer productivity.</p></blockquote><p>💡小结：为何不去追求完全健壮和可靠的代码：因为不切实际（更极端的说法是根本不可能）。不去追求完全的健壮性和可靠性，另一个原因是错误不经常发生。由于错误（比如 <code>OutOfMemoryException</code> ）及其罕见，所以开发人员决定不去追求完全可靠的代码，牺牲一定的可靠性来换取程序员开发效率的提升。异常的好处在于，未处理的异常会造成应用程序终止。之所以是好事，是因为可在测试期间提早发现问题。利用由未处理异常提供的信息（错误信息和堆栈追踪），通常足以完成对代码的修正。当然，许多公司不希望应用程序在测试和部署之后还发生意外终止的情况，所以会插入代码来捕捉 <code>System.Exception</code> ，也就是所有异常类型的基类。但如果捕捉 <code>System.Exception</code> 并允许应用程序继续运行，一个很大的问题是状态可能遭受破坏。执行 <code>catch</code> 或 <code>finally</code> 块中的代码时，CLR 不允许线程终止。但绝对不建议将所有代码都放到 <code>finally</code> 块中！这个技术只适合修改极其敏感的状态。可以用 <code>System.Diagnostics.Contrancts.Contract</code> 类向方法应用代码协定。通过代码协定，在用实参和其他变量对状态进行修改之前，可以先对这些实参 / 变量进行验证。如果实参 / 变量遵守协定，状态被破坏的可能性将大幅降低 (但不能完全消除)。如果不遵守协定，那么异常会在任何状态被修改之前抛出。可以使用约束执行区域 (Constrained Execution Region，CER)，它能消除 CLR 的某些不确定性。取决于状态存在于何处，可利用事务 (transaction) 来确保状态要么都修改，要么都不修改。在你的代码中，如果确定状态已损坏到无法修复的程度，就应销毁所有损坏的状态，防止它造成更多的伤害。然后，重新启动应用程序，将状态初始化到良好状态，并寄希望于状态不再损坏。由于托管的状态泄露不到 AppDomain 的外部，所以为了销毁 AppDomain 中所有损坏的状态，可调用 <code>AppDomain</code> 的 <code>Unload</code> 方法来卸载整个 AppDomain。如果觉得状态过于糟糕，以至于整个进程都应该终止，那么应该调用 <code>Environment</code> 的静态 <code>FailFast</code> 方法。这个方法在终止进程时，不会运行任何活动的 <code>try/finally</code> 块或者 <code>Finalize</code> 方法。之所以这样做，是因为在状态已损坏的前提下执行更多的代码，很容易使局面变得更坏。不过， <code>FailFast</code> 为从 <code>CriticalFinalizerObject</code> 派生的任何对象提供了进行清理的机会，因为它们一般只是关闭本机资源；而即使 CLR 或者你的应用程序的状态发生损坏，Windows 状态也可能是好的。 <code>FailFast</code> 方法将消息字符串和可选的异常 (通常是 <code>catch</code> 块中捕捉的异常) 写入 Windows Application 事件日志，生成 Windows 错误报告，创建应用程序的内存转储 (dump)，然后终止当前进程。大多数应用程序都不能容忍状态受损而继续运行，因为这可能造成不正确的数据，设置可能造成安全漏洞。如果应用程序不方便终止 (比如操作系统或数据库引擎)，托管代码就不是一个好的技术。如果应用程序 “在状态可能损坏时终止” 不会造成严重后果，就适合用托管代码来写。有许多应用程序都满足这个要求。此外，需要多得多的资源和技能，才能写出健壮的本机 (native) 类库或应用程序。对于许多应用程序，托管代码是更好的选择，因为它极大提升了开发效率。</p><h2 id="guidelines-and-best-practices"><a class="anchor" href="#guidelines-and-best-practices">#</a> Guidelines and Best Practices</h2><blockquote><p>Understanding the exception mechanism is certainly important. It is equally important to understand how to use exceptions wisely. All too often, I see library developers catching all kinds of exceptions, preventing the application developer from knowing that a problem occurred. In this section, I offer some guidelines for developers to be aware of when using exceptions.</p></blockquote><p>💡重要提示：如果你是类库开发人员，要设计供其他开发人员使用的类型，那么一定要严格按照这些规范行事，你的责任很重大，要精心设计类库中的类型，那么一定要更严格按照这些规范行事。你的责任很重大，要精心设计类库中的类型，使之适用于各种各样的应用程序。记住，你无法做到对要回调的代码 (通过委托、虚方法或接口方法) 了如指掌，也不知道哪些代码会调用你 (的代码)。由于无法预知使用类型的每一种情形，所以不要做出任何策略抉择 (遇见到具体异常并相应处理)。换言之，你的代码一定不能想当然地决定一些错误情形；应该让调用者自己决定。</p><p>此外，要严密监视状态，尽量不要破坏它。使用代码协定 (本章稍后讨论) 验证传给方法的实参。尝试完全不去修改状态。如果不得不修改状态，就做好出错的准备，并在出错后尝试恢复状态。遵照本章的设计规范行事，应用程序的开发人员就可以顺畅地使用你的类库中的类型。</p><p>如果你是应用程序开发人员，可定义自己认为合适的任何策略，按照本章的规范行事，有助于在应用程序发布前发现并修复代码中的问题，使应用程序更健壮，但经深思熟虑之后，也可以不按这些规范行事。你要设置自己的策略。例如，应用程序代码在捕捉异常方面可以比类库代码更激进一些。</p><h3 id="use-finally-blocks-liberally"><a class="anchor" href="#use-finally-blocks-liberally">#</a> Use finally Blocks Liberally</h3><blockquote><p>I think finally blocks are awesome! They allow you to specify a block of code that’s guaranteed to execute no matter what kind of exception the thread throws. You should use finally blocks to clean up from any operation that successfully started before returning to your caller or allowing code following the finally block to execute. You also frequently use finally blocks to explicitly dispose of any objects to avoid resource leaking. Here’s an example that has all cleanup code (closing the file) in a finally block.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>IO</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SomeMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token class-name">FileStream</span> fs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">FileStream</span><span class="token punctuation">(</span><span class="token string">@"C:\Data.bin "</span><span class="token punctuation">,</span> FileMode<span class="token punctuation">.</span>Open<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// Display 100 divided by the first byte in the file. </span></pre></td></tr><tr><td data-num="8"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">/</span> fs<span class="token punctuation">.</span><span class="token function">ReadByte</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// Put cleanup code in a finally block to ensure that the file gets closed regardless</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// of whether or not an exception occurs (for example, the first byte was 0). </span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>fs <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> fs<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Ensuring that cleanup code always executes is so important that many programming languages offer constructs that make writing cleanup code easier. For example, the C# language automatically emits try/finally blocks whenever you use the lock, using, and foreach statements. The C# compiler also emits try/finally blocks whenever you override a class’s destructor (the Finalize method). When using these constructs, the compiler puts the code you’ve written inside the try block and automatically puts the cleanup code inside the finally block. Specifically:</p><ul><li><p>When you use the lock statement, the lock is released inside a finally block.</p></li><li><p>When you use the using statement, the object has its Dispose method called inside a finally block.</p></li><li><p>When you use the foreach statement, the IEnumerator object has its Dispose method called inside a finally block.</p></li><li><p>When you define a destructor method, the base class’s Finalize method is called inside a finally block.</p></li></ul></blockquote><blockquote><p>For example, the following C# code takes advantage of the using statement. This code is shorter than the code shown in the previous example, but the code that the compiler generates is identical to the code generated in the previous example.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>IO</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SomeMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token class-name">FileStream</span> fs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">FileStream</span><span class="token punctuation">(</span><span class="token string">@"C:\Data.bin"</span><span class="token punctuation">,</span> FileMode<span class="token punctuation">.</span>Open<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Display 100 divided by the first byte in the file. </span></pre></td></tr><tr><td data-num="7"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">/</span> fs<span class="token punctuation">.</span><span class="token function">ReadByte</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>For more about the using statement, see Chapter 21; and for more about the lock statement, see Chapter 30.</p></blockquote><h3 id="dont-catch-everything"><a class="anchor" href="#dont-catch-everything">#</a> Don’t Catch Everything</h3><blockquote><p>A ubiquitous mistake made by developers who have not been properly trained on the proper use of exceptions is to use catch blocks too often and improperly. When you catch an exception, you’re stating that you expected this exception, you understand why it occurred, and you know how to deal with it. In other words, you’re defining a policy for the application. This all goes back to the “Trading Reliability for Productivity“ section earlier in this chapter.</p></blockquote><blockquote><p>All too often, I see code like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">try</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// try to execute code that the programmer knows might fail... </span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token range operator">..</span><span class="token punctuation">.</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>This code indicates that it was expecting any and all exceptions and knows how to recover from any and all situations. How can this possibly be? A type that’s part of a class library should never, ever, under any circumstance catch and swallow all exceptions because there is no way for the type to know exactly how the application intends to respond to an exception. In addition, the type will frequently call out to application code via a delegate, virtual method, or interface method. If the application code throws an exception, another part of the application is probably expecting to catch this exception. The exception should be allowed to filter its way up the call stack and let the application code handle the exception as it sees fit.</p></blockquote><blockquote><p>If the exception is unhandled, the CLR terminates the process. I’ll discuss unhandled exceptions later in this chapter. Most unhandled exceptions will be discovered during testing of your code. To fix these unhandled exceptions, you will either modify the code to look for a specific exception, or you will rewrite the code to eliminate the conditions that cause the exception to be thrown. The final version of the code that will be running in a production environment should see very few unhandled exceptions and will be extremely robust.</p></blockquote><p>💡注意：有时，不能完成任务的一个方法检测到对象状态已经损坏，而且状态无法恢复。假如允许应用程序继续运行，可能造成不可预测的行为或安全隐患。检测到这种情况，方法不应抛出异常。相反，应调用 <code>System.Environment</code> 的 <code>FailFast</code> 方法强迫进程终止。</p><blockquote><p>By the way, it is OK to catch System.Exception and execute some code inside the catch block’s braces as long as you re-throw the exception at the bottom of that code. Catching System.Exception and swallowing the exception (not re-throwing it) should never be done because it hides failures that allow the application to run with unpredictable results and potential security vulnerabilities. Visual Studio’s code analysis tool (FxCopCmd.exe) will flag any code that contains a catch (Exception) block unless there is a throw statement included in the block’s code. The “Backing Out of a Partially Completed Operation When an Unrecoverable Exception Occurs—Maintaining State” section, coming shortly in this chapter, will discuss this pattern.</p></blockquote><blockquote><p>Finally, it is OK to catch an exception occurring in one thread and re-throw the exception in another thread. The Asynchronous Programming Model (discussed in Chapter 28, “I/O-Bound Asynchronous Operations”) supports this. For example, if a thread pool thread executes code that throws an exception, the CLR catches and swallows the exception and allows the thread to return to the thread pool. Later, a thread should call an EndXxx method to determine the result of the asynchronous operation. The EndXxx method will throw the same exception object that was thrown by the thread pool thread that did the actual work. In this scenario, the exception is being swallowed by the first thread; however, the exception is being re-thrown by the thread that called the EndXxx method, so it is not being hidden from the application.</p></blockquote><h3 id="recovering-gracefully-from-an-exception"><a class="anchor" href="#recovering-gracefully-from-an-exception">#</a> Recovering Gracefully from an Exception</h3><blockquote><p>Sometimes you call a method knowing in advance some of the exceptions that the method might throw. Because you expect these exceptions, you might want to have some code that allows your application to recover gracefully from the situation and continue running. Here’s an example in pseudocode.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name">String</span> <span class="token function">CalculateSpreadsheetCell</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> row<span class="token punctuation">,</span> <span class="token class-name">Int32</span> column<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">String</span> result<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> result <span class="token operator">=</span> <span class="token comment">/* Code to calculate value of a spreadsheet's cell */</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">DivideByZeroException</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> result <span class="token operator">=</span> <span class="token string">"Can't show value: Divide by zero"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">OverflowException</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> result <span class="token operator">=</span> <span class="token string">"Can't show value: Too big"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">return</span> result<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>This pseudocode calculates the contents of a cell in a spreadsheet and returns a string representing the value to the caller so that the caller can display the string in the application’s window. However, a cell’s contents might be the result of dividing one cell by another cell. If the cell containing the denominator contains 0, the CLR will throw a DivideByZeroException object. In this case, the method catches this specific exception and returns a special string that will be displayed to the user. Similarly, a cell’s contents might be the result of multiplying one cell by another. If the multiplied value doesn’t fit in the number of bits allowed, the CLR will throw an OverflowException object, and again, a special string will be displayed to the user.</p></blockquote><blockquote><p>When you catch specific exceptions, fully understand the circumstances that cause the exception to be thrown, and know what exception types are derived from the exception type you’re catching. Don’t catch and handle System.Exception (without re-throwing) because it’s not feasible for you to know all of the possible exceptions that could be thrown within your try block (especially if you consider the OutOfMemoryException or the StackOverflowException, to name two).</p></blockquote><h3 id="backing-out-of-a-partially-completed-operation-when-an-unrecoverable-exception-occursmaintaining-state"><a class="anchor" href="#backing-out-of-a-partially-completed-operation-when-an-unrecoverable-exception-occursmaintaining-state">#</a> Backing Out of a Partially Completed Operation When an Unrecoverable Exception Occurs—Maintaining State</h3><blockquote><p>Usually, methods call several other methods to perform a single abstract operation. Some of the individual methods might complete successfully, and some might not. For example, let’s say that you’re serializing a set of objects to a disk file. After serializing 10 objects, an exception is thrown. (Perhaps the disk is full or the next object to be serialized isn’t marked with the Serializable custom attribute.) At this point, the exception should filter up to the caller, but what about the state of the disk file? The file is now corrupted because it contains a partially serialized object graph. It would be great if the application could back out of the partially completed operation so that the file would be in the state it was in before any objects were serialized into it. The following code demonstrates the correct way to implement this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SerializeObjectGraph</span><span class="token punctuation">(</span><span class="token class-name">FileStream</span> fs<span class="token punctuation">,</span> <span class="token class-name">IFormatter</span> formatter<span class="token punctuation">,</span> <span class="token class-name">Object</span> rootObj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Save the current position of the file. </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Int64</span> beforeSerialization <span class="token operator">=</span> fs<span class="token punctuation">.</span>Position<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// Attempt to serialize the object graph to the file. </span></pre></td></tr><tr><td data-num="6"></td><td><pre> formatter<span class="token punctuation">.</span><span class="token function">Serialize</span><span class="token punctuation">(</span>fs<span class="token punctuation">,</span> rootObj<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">catch</span> <span class="token punctuation">&#123;</span> <span class="token comment">// Catch any and all exceptions. </span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// If ANYTHING goes wrong, reset the file back to a good state. </span></pre></td></tr><tr><td data-num="10"></td><td><pre> fs<span class="token punctuation">.</span>Position <span class="token operator">=</span> beforeSerialization<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// Truncate the file. </span></pre></td></tr><tr><td data-num="12"></td><td><pre> fs<span class="token punctuation">.</span><span class="token function">SetLength</span><span class="token punctuation">(</span>fs<span class="token punctuation">.</span>Position<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token comment">// NOTE: The preceding code isn't in a finally block because </span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token comment">// the stream should be reset only when serialization fails. </span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// Let the caller(s) know what happened by re-throwing the SAME exception. </span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token keyword">throw</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>To properly back out of the partially completed operation, write code that catches all exceptions. Yes, catch all exceptions here because you don’t care what kind of error occurred; you need to put your data structures back into a consistent state. After you’ve caught and handled the exception, don’t swallow it—let the caller know that the exception occurred. You do this by re-throwing the same exception. In fact, C# and many other languages make this easy. Just use C#’s throw keyword without specifying anything after throw, as shown in the previous code.</p></blockquote><blockquote><p>Notice that the catch block in the previous example doesn’t specify any exception type because I want to catch any and all exceptions. In addition, the code in the catch block doesn’t need to know exactly what kind of exception was thrown, just that something went wrong. Fortunately, C# lets me do this easily just by not specifying any exception type and by making the throw statement re-throw whatever object is caught.</p></blockquote><h3 id="hiding-an-implementation-detail-to-maintain-a-contract"><a class="anchor" href="#hiding-an-implementation-detail-to-maintain-a-contract">#</a> Hiding an Implementation Detail to Maintain a “Contract”</h3><blockquote><p>In some situations, you might find it useful to catch one exception and re-throw a different exception. The only reason to do this is to maintain the meaning of a method’s contract. Also, the new exception type that you throw should be a specific exception (an exception that’s not used as the base type of any other exception type). Imagine a PhoneBook type that defines a method that looks up a phone number from a name, as shown in the following pseudocode.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">PhoneBook</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">String</span> m_pathname<span class="token punctuation">;</span> <span class="token comment">// path name of file containing the address book </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// Other methods go here. </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">String</span> <span class="token function">GetPhoneNumber</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token class-name">String</span> phone<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token class-name">FileStream</span> fs <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> fs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">FileStream</span><span class="token punctuation">(</span>m_pathname<span class="token punctuation">,</span> FileMode<span class="token punctuation">.</span>Open<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// Code to read from fs until name is found goes here </span></pre></td></tr><tr><td data-num="10"></td><td><pre> phone <span class="token operator">=</span> <span class="token comment">/* the phone # found */</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token comment">// Throw a different exception containing the name, and </span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token comment">// set the originating exception as the inner exception. </span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">NameNotFoundException</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token comment">// Throw a different exception containing the name, and </span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token comment">// set the originating exception as the inner exception. </span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">NameNotFoundException</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>fs <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> fs<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token keyword">return</span> phone<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The phone book data is obtained from a file (versus a network connection or database). However, the user of the PhoneBook type doesn’t know this because this is an implementation detail that could change in the future. So if the file isn’t found or can’t be read for any reason, the caller would see a FileNotFoundException or IOException, which wouldn’t be anticipated. In other words, the file’s existence and ability to be read is not part of the method’s implied contract: there is no way the caller could have guessed this. So the GetPhoneNumber method catches these two exception types and throws a new NameNotFoundException.</p></blockquote><blockquote><p>When using this technique, you should catch specific exceptions that you fully understand the circumstances that cause the exception to be thrown. And, you should also know what exception types are derived from the exception type you’re catching.</p></blockquote><blockquote><p>Throwing an exception still lets the caller know that the method cannot complete its task, and the NameNotFoundException type gives the caller an abstracted view as to why. Setting the inner exception to FileNotFoundException or IOException is important so that the real cause of the exception isn’t lost. Besides, knowing what caused the exception could be useful to the developer of the PhoneBook type and possibly to a developer using the PhoneBook type.</p></blockquote><p>💡重要提示：使用这个技术时，实际是在两个方面欺骗了调用者。首先，在实际发生的错误上欺骗了调用者。本例是文件未找到，而报告的是没有找到指定的姓名。其次，在错误发生的位置上欺骗了调用者。如果允许 <code>FileNotFoundException</code> 异常在掉应该能栈中向上传递，它的 <code>StackTrace</code> 属性显示错误在 <code>FileStream</code> 的构造器发生。但由于现在是 “吞噬” 该异常并重新抛出新的 <code>NameNotFoundException</code> 异常，所以堆栈跟踪会显示错误在 <code>catch</code> 块中发生，离异常实际发生的位置有好几行远。这会使调试变得困难。所以，这个技术务必慎用。</p><blockquote><p>Now let’s say that the PhoneBook type was implemented a little differently. Assume that the type offers a public PhoneBookPathname property that allows the user to set or get the path name of the file in which to look up a phone number. Because the user is aware of the fact that the phone book data comes from a file, I would modify the GetPhoneNumber method so that it doesn’t catch any exceptions; instead, I let whatever exception is thrown propagate out of the method. Note that I’m not changing any parameters of the GetPhoneNumber method, but I am changing how it’s abstracted to users of the PhoneBook type. Users now expect a path to be part of the PhoneBook’s contract.</p></blockquote><blockquote><p>Sometimes developers catch one exception and throw a new exception in order to add additional data or context to an exception. However, if this is all you want to do, you should just catch the exception type you want, add data to the exception object’s Data property collection, and then re-throw the same exception object.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SomeMethod</span><span class="token punctuation">(</span><span class="token class-name">String</span> filename<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// Do whatevere here...</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Add the filename to the IOException object</span></pre></td></tr><tr><td data-num="7"></td><td><pre> e<span class="token punctuation">.</span>Data<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">"Filename"</span><span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">throw</span><span class="token punctuation">;</span> <span class="token comment">// re-throw the same exception object that now has additional data in it</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Here is a good use of this technique: when a type constructor throws an exception that is not caught within the type constructor method, the CLR internally catches that exception and throws a new TypeInitializationException instead. This is useful because the CLR emits code within your methods to implicitly call type constructors.6 If the type constructor threw a DivideByZeroException, your code might try to catch it and recover from it but you didn’t even know you were invoking the type constructor. So the CLR converts the DivideByZeroException into a TypeInitializationException so that you know clearly that the exception occurred due to a type constructor failing; the problem wasn’t with your code.</p></blockquote><blockquote><p>On the other hand, here is a bad use of this technique: when you invoke a method via reflection, the CLR internally catches any exception thrown by the method and converts it to a TargetInvocationException. This is incredibly annoying because you must now catch the TargetInvocationException object and look at its InnerException property to discern the real reason for the failure. In fact, when using reflection, it is common to see code that looks like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Reflection</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// Invoke a DoSomething method on this object</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> mi <span class="token operator">=</span> o<span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetMethod</span><span class="token punctuation">(</span><span class="token string">"DoSomething"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> mi<span class="token punctuation">.</span><span class="token function">Invoke</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// The DoSomething method might throw an exception</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">System<span class="token punctuation">.</span>Reflection<span class="token punctuation">.</span>TargetInvocationException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// The CLR converts reflection-produced exceptions to TargetInvocationException</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">throw</span> e<span class="token punctuation">.</span>InnerException<span class="token punctuation">;</span> <span class="token comment">// Re-throw what was originally thrown</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>I have good news though: if you use C#’s dynamic primitive type (discussed in Chapter 5, “Primitive, Reference, and Value Types”) to invoke a member, the compiler-generated code does not catch any and all exceptions and throw a TargetInvocationException object; the originally thrown exception object simply walks up the stack. For many developers, this is a good reason to prefer using C#’s dynamic primitive type rather than reflection.</p></blockquote><p>💡小结：确保清理代码的执行时如此重要，以至于许多编程语言都提供了一些构造来简化这种代码的编写。例如，只要使用了 <code>lock</code> ， <code>using</code> 和 <code>foreach</code> 语句，C# 编译器就会自动生成 <code>try/finally</code> 块，另外，重写类的析构器 ( <code>Finalize</code> 方法) 时，C# 编译器也会自动生成 <code>try/finally</code> 块。使用这些构造时，编译器将你写的代码放到 <code>try</code> 块内部，并将清理代码放到 <code>finally</code> 块中。如果类型是类库的一部分，那么任何情况下都绝对不允许捕捉并 “吞噬” 所有异常，因为它不可能准确预知应用程序将如何响应一个异常。此外，类型经常通过委托、虚方法或接口方法调用应用程序代码。应用程序代码抛出异常，应用程序的另一部分可能预期要捕捉该异常。所以，绝对不要写 “大小通吃” 的类型，悄悄地 “吞噬” 异常，而是应该允许异常在调用栈中向上移动，让应用程序代码针对性地处理它。如果异常未得到处理，CLR 会终止进程。大多数未处理异常都能在代码测试期间发现。为了修正这些未处理的异常，要么修改代码来捕捉特定异常，要么重写代码排除会造成异常的出错条件。在生产环境中运行的最终版本应该极少出现未处理的异常，而且应该相当健壮。可以在一个线程中捕捉异常，在另一个线程中重新抛出异常。为此提供支持的是异步编程模型。为了正确回滚已部分完成的操作，代码应捕捉所有异常。是的，这里要捕捉所有异常，因为你不关心发生了什么错误，只关心如何将数据结构恢复为一致状态。捕捉并处理好异常后，不要把它 “吞噬”(假装它没有发生)。相反，要让调用者知道发生了异常。为此，只需重新抛出相同的异常。事实上，C# 和许多其他语言都简化了这项任务，只需像上述代码那样单独使用 C# 的 <code>throw</code> 关键字，不在 <code>throw</code> 后指定任何东西。有时，开发人员之所以捕捉一个异常并抛出一个新异常，目的是在异常中添加额外的数据或上下文。然而，如果这是你唯一的目的，那么只需捕捉希望的异常类型，在异常对象的 <code>Data</code> 属性 (一个键 / 值对的集合) 中添加数据，然后重新抛出相同的异常对象。使用 C# 的 <code>dynamic</code> 基元类型来调用成员，最初抛出的异常对象会正常地在调用栈中向上传递。对于大多数开发人员，这是使用 C# 的 <code>dynamic</code> 基元类型来代替反射的一个很好的理由。</p><h2 id="unhandled-exceptions"><a class="anchor" href="#unhandled-exceptions">#</a> Unhandled Exceptions</h2><blockquote><p>When an exception is thrown, the CLR climbs up the call stack looking for catch blocks that match the type of the exception object being thrown. If no catch block matches the thrown exception type, an unhandled exception occurs. When the CLR detects that any thread in the process has had an unhandled exception, the CLR terminates the process. An unhandled exception identifies a situation that the application didn’t anticipate and is considered to be a true bug in the application. At this point, the bug should be reported back to the company that publishes the application. Hopefully, the publisher will fix the bug and distribute a new version of the application.</p></blockquote><blockquote><p>Class library developers should not even think about unhandled exceptions. Only application developers need to concern themselves with unhandled exceptions, and the application should have a policy in place for dealing with unhandled exceptions. Microsoft actually recommends that application developers just accept the CLR’s default policy. That is, when an application gets an unhandled exception, Windows writes an entry to the system’s event log. You can see this entry by opening the Event Viewer application and then looking under the Windows Logs ➔ Application node in the tree, as shown in Figure 20-1.</p></blockquote><p><img data-src="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/image-20221127161945517.png" alt="image-20221127161945517"></p><p><strong>FIGURE 20-1</strong> Windows Event log showing an application that terminated due to an unhandled exception.</p><blockquote><p>However, you can get more interesting details about the problem by using the Windows Reliability Monitor applet. To start Reliability Monitor, open the Windows Control Panel and search for “reliability history”. From here, you can see the applications that have terminated due to an unhandled exception in the bottom pane, as shown in Figure 20-2.</p></blockquote><p><img data-src="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/image-20221127162114003.png" alt="image-20221127162114003"></p><p><strong>FIGURE 20-2</strong> Reliability Monitor showing an application that terminated due to an unhandled exception.</p><blockquote><p>To see more details about the terminated application, double-click a terminated application in Reliability Monitor. The details will look something like Figure 20-3 and the meaning of the problem signatures are described in Table 20-2. All unhandled exceptions produced by managed applications are placed in the CLR20r3 bucket.</p></blockquote><p><img data-src="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/image-20221127162227127.png" alt="image-20221127162227127"></p><p><strong>FIGURE 20-3</strong> Reliability Monitor showing more details about the failed application.</p><p><img data-src="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/image-20221125094825099.png" alt="image-20221125094825099"></p><blockquote><p>After recording information about the failing application, Windows displays the message box allowing the end user to send information about the failing application to Microsoft servers.7 This is called Windows Error Reporting, and more information about it can be found at the Windows Quality website (<span class="exturl" data-url="aHR0cDovL1dpblF1YWwuTWljcm9zb2Z0LmNvbQ==">http://WinQual.Microsoft.com</span>).</p></blockquote><blockquote><p>Companies can optionally sign up with Microsoft to view this information about their own applications and components. Signing up is free, but it does require that your assemblies be signed with a VeriSign ID (also called a Software Publisher’s Digital ID for Authenticode).</p></blockquote><blockquote><p>Naturally, you could also develop your own system for getting unhandled exception information back to you so that you can fix bugs in your code. When your application initializes, you can inform the CLR that you have a method that you want to be called whenever any thread in your application experiences an unhandled exception.</p></blockquote><blockquote><p>Unfortunately, every application model Microsoft produces has its own way of tapping into unhandled exceptions. The members that you want to look up in the FCL documentation are.</p><ul><li><p>For many applications, look at System.AppDomain’s UnhandledException event. Windows Store applications and Microsoft Silverlight applications cannot access this event. 4</p></li><li><p>For a Windows Store App, look at Windows.UI.Xaml.Application’s UnhandledException event.</p></li><li><p>For a Windows Forms application, look at System.Windows.Forms.NativeWindow’s OnThreadException virtual method, System.Windows.Forms.Application’s OnThreadException virtual method, and System.Windows.Forms.Application’s ThreadException event.</p></li><li><p>For a Windows Presentation Foundation (WPF) application, look at System.Windows. Application’s DispatcherUnhandledException event and System.Windows. Threading.Dispatcher’s UnhandledException and UnhandledExceptionFilter events.</p></li><li><p>For Silverlight, look at System.Windows.Application’s UnhandledException event.</p></li><li><p>For an <span class="exturl" data-url="aHR0cDovL0FTUC5ORVQ=">ASP.NET</span> Web Form application, look at System.Web.UI.TemplateControl’s Error event. TemplateControl is the base class of the System.Web.UI.Page and System.Web.UI.UserControl classes. Furthermore, you should also look at System. Web.HttpApplication’s Error event.</p></li><li><p>For a Windows Communication Foundation application, look at System.ServiceModel. Dispatcher.ChannelDispatcher’s ErrorHandlers property.</p></li></ul></blockquote><blockquote><p>Before I leave this section, I’d like to say a few words about unhandled exceptions that could occur in a distributed application such as a website or web service. In an ideal world, a server application that experiences an unhandled exception should log it, send some kind of notification back to the client indicating that the requested operation could not complete, and then the server should terminate. Unfortunately, we don’t live in an ideal world, and therefore, it may not be possible to send a failure notification back to the client. For some stateful servers (such as Microsoft SQL Server), it may not be practical to terminate the server and start a brand new instance.</p></blockquote><blockquote><p>For a server application, information about the unhandled exception should not be returned to the client because there is little a client could do about it, especially if the client is implemented by a different company. Furthermore, the server should divulge as little information about itself as possible to its clients to reduce that potential of the server being hacked.</p></blockquote><p>💡注意：CLR 认为本机代码 (native code) 抛出的一些异常时损坏状态异常 (corrupted state exceptions, CSE) 异常，因为它们一般由 CLR 自身的 bug 造成，或者由托管开发人员无法控制的本机代码的 bug 造成。CLR 默认不让托管代码捕捉这些异常， <code>finally</code> 块也不会执行。以下本机 Win32 异常被认为是 CSE：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>EXCEPTION_ACCESS_VIOLATION EXCEPTION_STACK_OVERFLOW</pre></td></tr><tr><td data-num="2"></td><td><pre>EXCEPTION_ILLEGAL_INSTRUCTION EXCEPTION_IN_PAGE_ERROR</pre></td></tr><tr><td data-num="3"></td><td><pre>EXCEPTION_INVALID_DISPOSITION EXCEPTION_NONCONTINUABLE_EXCEPTION</pre></td></tr><tr><td data-num="4"></td><td><pre>EXCEPTION_PRIV_INSTRUCTION STATUS_UNWIND_CONSOLIDATE<span class="token punctuation">.</span></pre></td></tr></table></figure><p>但是，单独的托管方法可以覆盖默认设置来捕捉这些异常，这需要向方法应用 <code>System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute</code> 。方法还要应用 <code>System.Security.SecurityCriticalAttribute</code> 。要覆盖整个进程的默认设置，可在应用程序的 XML 配置文件中将 <code>legacyCorruptedStateExceptionPolicy</code> 元素设为 <code>true</code> 。CLR 将上述大多数异常都转换成一个 <code>System.Runtime.InteropServices.SEHException</code> 对象，但有两个异常例外： <code>EXCEPTION_ACCESS_VIOLATION</code> 被转换成 <code>System.AccessViolationException</code> 对象， <code>EXCEPTION_STACK_OVERFLOW</code> 被转换成 <code>System.StackOverflowException</code> 对象。</p><p>💡注意：调用方法前，可调用 <code>RuntimeHelper</code> 类的 <code>EnsureSufficientExecutionStack</code> 检查栈空间是否够用。该方法检查调用线程是否有足够的栈空间来执行一般性的方法 (定义得比较随便的方法)。栈空间不够，方法会抛出一个 <code>InsufficientExecutionStackException</code> ，你可以捕捉这个异常。 <code>EnsureSufficientExecutionStack</code> 方法不接受任何实参，返回值是 <code>void</code> 。 递归方法特别要用好这个方法。</p><p>💡小结：异常抛出时，CLR 在调用栈中向上查找与抛出的异常对象的类型匹配的 <code>catch</code> 块。没有任何 <code>catch</code> 块匹配抛出的异常类型，就发生一个未处理的异常。应用程序发生未处理的异常时，Windows 会向事件日志写一条记录。记录好出错的应用程序有关的信息后，Windows 显示一个消息框，允许用户将与出错的应用程序有关的信息发送给 Microsoft 的服务器。这称为 “Windows 错误报告”(Windows Error Reporting)。作为公司，可以向 Microsoft 注册查看与它们自己的应用程序和组件有关的信息。注册是免费的，但要求程序集用 VeriSign ID (也称为 Software Publisher Digital ID for Authenticode) 进行签名。当然也可以开发自己的系统，将未处理异常的信息传回给你自己，以便修正代码中的 bug。应用程序初始化时，可告诉 CLR 当应用程序中的任何线程发生一个未处理的异常时，都调用一个方法。最后讲一下分布式应用程序 (例如 Web 站点或 Web 服务) 中发生的未处理异常。理想情况下，服务器应用程序发生未处理异常，应该先把它记录到日志中，再向客户端发送通知，表明所请求的操作无法完成，最后终止服务器应用程序。遗憾的是，我们并非生活在理想世界中。因此，也许不可能向客户端发送失败通知。对于某些 “有状态” 的服务器 (比如 Microsoft SQL Server)，终止服务器并重新启动服务器的新实例是不切实际的。对于服务器应用程序，与未处理异常有关的信息不应返回客户端，因为客户端对这种信息基本上是束手无策的，尤其是假如客户端由不同的公司实现。另外，服务器应尽量少暴露自己的相关信息，减少自己被 “黑” 的几率。</p><h2 id="debugging-exceptions"><a class="anchor" href="#debugging-exceptions">#</a> Debugging Exceptions</h2><blockquote><p>The Visual Studio debugger offers special support for exceptions. With a solution open, choose Exceptions from the Debug menu, and you’ll see the dialog box shown in Figure 20-4.</p></blockquote><p><img data-src="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/image-20221127163155842.png" alt="image-20221127163155842"></p><p><strong>FIGURE 20-4</strong> The Exceptions dialog box, showing the different kinds of exceptions.</p><blockquote><p>This dialog box shows the different kinds of exceptions that Visual Studio is aware of. For Common Language Runtime Exceptions, expanding the corresponding branch in the dialog box, as in Figure 20-5, shows the set of namespaces that the Visual Studio debugger is aware of.</p></blockquote><p><img data-src="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/image-20221127163255164.png" alt="image-20221127163255164"></p><p><strong>FIGURE 20-5</strong> The Exceptions dialog box, showing CLR exceptions by namespace.</p><blockquote><p>If you expand a namespace, you’ll see all of the System.Exception-derived types defined within that namespace. For example, Figure 20-6 shows what you’ll see if you open the System namespace.</p></blockquote><blockquote><p>For any exception type, if its Thrown check box is selected, the debugger will break as soon as that exception is thrown. At this point, the CLR has not tried to find any matching catch blocks. This is useful if you want to debug your code that catches and handles an exception. It is also useful when you suspect that a component or library may be swallowing or re-throwing exceptions, and you are uncertain where exactly to set a break point to catch it in the act.</p></blockquote><p><img data-src="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/image-20221127163445451.png" alt="image-20221127163445451"></p><p><strong>FIGURE 20-6</strong> The Exceptions dialog box, showing CLR exceptions defined in the System namespace.</p><blockquote><p>If an exception type’s Thrown check box is not selected, the debugger will also break where the exception was thrown, but only if the exception type was not handled. Developers usually leave the Thrown check box cleared because a handled exception indicates that the application anticipated the situation and dealt with it; the application continues running normally.</p></blockquote><blockquote><p>If you define your own exception types, you can add them to this dialog box by clicking Add. This causes the dialog box in Figure 20-7 to appear.</p></blockquote><p><img data-src="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/image-20221127163606140.png" alt="image-20221127163606140"></p><p><strong>FIGURE 20-7</strong> Making Visual Studio aware of your own exception type: the New Exception dialog box.</p><blockquote><p>In this dialog box, you first select the type of exception to be Common Language Runtime Exceptions, and then you can enter the fully qualified name of your own exception type. Note that the type you enter doesn’t have to be a type derived from System.Exception; non–CLS-compliant types are fully supported. If you have two or more types with the same name but in different assemblies, there is no way to distinguish the types from one another. Fortunately, this situation rarely happens.</p></blockquote><blockquote><p>If your assembly defines several exception types, you must add them one at a time. In the future, I’d like to see this dialog box allow me to browse for an assembly and automatically import all Exception-derived types into Visual Studio’s debugger. Each type could then be identified by assembly as well, which would fix the problem of having two types with the same name in different assemblies.</p></blockquote><p>💡小结：对于任何异常类型，如果勾选了 “引发” 选项框，调试器就会在抛出该异常时中断。注意在中断时，CLR 还没有尝试去查找任何匹配的 <code>catch</code> 块。要对捕捉和处理一个异常的代码进行调试，这个功能相当有用。另外，如果怀疑一个组件或库 “吞噬” 了异常或者重新抛出了异常，但不确定在什么位置设置断点来捕捉它，这个功能也很有用。如果异常类型的 “引发” 框没有勾选，调试器只有在该异常类型未得到处理时才中断。开发人员一般都保持 “引发” 选项框的未勾选状态，因为的到处理的异常表明应用程序已预见到了异常，并会对它进行处理；应用程序能继续正常运行。</p><h2 id="exception-handling-performance-considerations"><a class="anchor" href="#exception-handling-performance-considerations">#</a> Exception-Handling Performance Considerations</h2><blockquote><p>The developer community actively debates the performance of exception handling. Some people claim that exception handling performance is so bad that they refuse to even use exception handling. However, I contend that in an object-oriented platform, exception handling is not an option; it is mandatory. And besides, if you didn’t use it, what would you use instead? Would you have your methods return true/false to indicate success/failure or perhaps some error code enum type? Well, if you did this, then you have the worst of both worlds: the CLR and the class library code will throw exceptions and your code will return error codes. You’d have to now deal with both of these in your code.</p></blockquote><blockquote><p>It’s difficult to compare performance between exception handling and the more conventional means of reporting exceptions (such as HRESULTs, special return codes, and so forth). If you write code to check the return value of every method call and filter the return value up to your own callers, your application’s performance will be seriously affected. But performance aside, the amount of additional coding you must do and the potential for mistakes is incredibly high when you write code to check the return value of every method. Exception handling is a much better alternative.</p></blockquote><blockquote><p>However, exception handling has a price: unmanaged C++ compilers must generate code to track which objects have been constructed successfully. The compiler must also generate code that, when an exception is caught, calls the destructor of each successfully constructed object. It’s great that the compiler takes on this burden, but it generates a lot of bookkeeping code in your application, adversely affecting code size and execution time.</p></blockquote><blockquote><p>On the other hand, managed compilers have it much easier because managed objects are allocated in the managed heap, which is monitored by the garbage collector. If an object is successfully constructed and an exception is thrown, the garbage collector will eventually free the object’s memory. Compilers don’t need to emit any bookkeeping code to track which objects are constructed successfully and don’t need to ensure that a destructor has been called. Compared to unmanaged C++, this means that less code is generated by the compiler, and less code has to execute at run time, resulting in better performance for your application.</p></blockquote><blockquote><p>Over the years, I’ve used exception handling in different programming languages, different operating systems, and different CPU architectures. In each case, exception handling is implemented differently with each implementation having its pros and cons with respect to performance. Some implementations compile exception handling constructs directly into a method, whereas other implementations store information related to exception handling in a data table associated with the method—this table is accessed only if an exception is thrown. Some compilers can’t inline methods that contain exception handlers, and some compilers won’t enregister variables if the method contains exception handlers.</p></blockquote><blockquote><p>The point is that you can’t determine how much additional overhead is added to an application when using exception handling. In the managed world, it’s even more difficult to tell because your assembly’s code can run on any platform that supports the .NET Framework. So the code produced by the JIT compiler to manage exception handling when your assembly is running on an x86 machine will be very different from the code produced by the JIT compiler when your code is running on an x64 or ARM processor. Also, JIT compilers associated with other CLR implementations (such as Microsoft’s .NET Compact Framework or the open-source Mono project) are likely to produce different code.</p></blockquote><blockquote><p>Actually, I’ve been able to test some of my own code with a few different JIT compilers that Microsoft has internally, and the difference in performance that I’ve observed has been quite dramatic and surprising. The point is that you must test your code on the various platforms that you expect your users to run on, and make changes accordingly. Again, I wouldn’t worry about the performance of using exception handling; the benefits typically far outweigh any negative performance impact.</p></blockquote><blockquote><p>If you’re interested in seeing how exception handling impacts the performance of your code, you can use the Performance Monitor tool that comes with Windows. The screen in Figure 20-8 shows the exception-related counters that are installed along with the .NET Framework.</p></blockquote><blockquote><p>Occasionally, you come across a method that you call frequently that has a high failure rate. In this situation, the performance hit of having exceptions thrown can be intolerable. For example, Microsoft heard back from several customers who were calling Int32’s Parse method, frequently passing in data entered from an end user that could not be parsed. Because Parse was called frequently, the performance hit of throwing and catching the exceptions was taking a large toll on the application’s overall performance.</p></blockquote><p>FIGURE 20-8 Performance Monitor showing the .NET CLR Exceptions counters.</p><blockquote><p>To address customers’ concerns and to satisfy all the guidelines described in this chapter, Microsoft added a new method to the Int32 class. This new method is called TryParse, and it has two overloads that look like the following.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Boolean</span> <span class="token function">TryParse</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token keyword">out</span> <span class="token class-name">Int32</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Boolean</span> <span class="token function">TryParse</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token class-name">NumberStyles</span> styles<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> IFormatProvider<span class="token punctuation">,</span> provider<span class="token punctuation">,</span> <span class="token keyword">out</span> <span class="token class-name">Int32</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>You’ll notice that these methods return a Boolean that indicates whether the String passed in contains characters that can be parsed into an Int32. These methods also return an output parameter named result. If the methods return true, result will contain the result of parsing the string into a 32-bit integer. If the methods return false, result will contain 0, but you really shouldn’t execute any code that looks at it anyway.</p></blockquote><blockquote><p>One thing I want to make absolutely clear: A TryXxx method’s Boolean return value returns false to indicate one and only one type of failure. The method should still throw exceptions for any other type of failure. For example, Int32’s TryParse throws an ArgumentException if the style’s argument is not valid, and it is certainly still possible to have an OutOfMemoryException thrown when calling TryParse.</p></blockquote><blockquote><p>I also want to make it clear that object-oriented programming allows programmers to be productive. One way that it does this is by not exposing error codes in a type’s members. In other words, constructors, methods, properties, etc. are all defined with the idea that calling them won’t fail. And, if defined correctly, for most uses of a member, it will not fail, and there will be no performance hit because an exception will not be thrown.</p></blockquote><blockquote><p>When defining types and their members, you should define the members so that it is unlikely that they will fail for the common scenarios in which you expect your types to be used. If you later hear from users that they are dissatisfied with the performance due to exceptions being thrown, then and only then should you consider adding TryXxx methods. In other words, you should produce the best object model first and then, if users push back, add some TryXxx methods to your type so that the users who experience performance trouble can benefit. Users who are not experiencing performance trouble should continue to use the non-TryXxx versions of the methods because this is the better object model.</p></blockquote><p>💡小结：异常处理和较常规的异常报告方式 ( <code>HRESULT</code> 和 特殊返回码等) 相比，很难看出两者在性能上的差异。如果写代码检查每个方法调用的返回值并将返回值 “漏” 给调用者，应用程序性能将受到严重影响。就算不考虑性能，由于要写代码检查每个方法的返回值，也必须进行大量额外的编程，而且出错几率也会大增。异常处理的优选方案。但异常处理也是有代价的：非托管 C++ 编译器必须生成代码来跟踪哪些对象被成功构造。编译器还必须生成代码，以便在一个异常被捕捉到的时候，调用每个已成功构造的对象的析构器。由编译器担负这个责任是很好的，但会在应用程序中生成大量薄记 (bookkeeping) 代码，对代码的大小和执行时间造成负面影响。另一方面，托管编译器就要轻松得多，因为托管对象在托管堆中分配，而托乱堆受垃圾回收器的监视。如对象成功构造，而且抛出了异常，垃圾回收器最终会释放对象的内存。编译器无需生成任何薄记代码来跟踪成功构造的对象，也无需保证析构器的调用。总之，不好判断异常处理到底会使应用程序增大多少额外的开销。在托管世界里更不好说，因为程序集的代码子在支持 .NET Framework 的任何平台上都能运行。所以，当程序集在 x86 处理器上运行时，JIT 编译器生成的用于管理异常处理的代码也会显著有别于程序集在 x64 或 ARM 处理器上运行时生成的代码。另外，与其他 CLR 实现 (比如 Microsoft 的 .NET Compact Framework 或者开源 Mono 项目) 关联的 JIT 编译器也有可能生成不同的代码。定义类型的成员时，应确保在一般使用情形中不会失败。只有用户以后因为抛出异常面对性能不满意时，才应考虑添加一些 <code>TryXXX</code> 方法。换言之，首先应建立一个最佳的对象模型。然后，只有在用户抱怨的时候，才在类型中添加一些 <code>TryXXX</code> 方法，帮助遭遇性能问题的用户改善性能。如果用户没有遇到性能问题，那么应继续使用方法的非 <code>TryXXX</code> 版本，因为那是更佳的对象模型。</p><h2 id="constrained-execution-regions-cers"><a class="anchor" href="#constrained-execution-regions-cers">#</a> Constrained Execution Regions (CERs)</h2><blockquote><p>Many applications don’t need to be robust and recover from any and all kinds of failures. This is true of many client applications like Notepad.exe and Calc.exe. And, of course, many of us have seen Microsoft Office applications like WinWord.exe, Excel.exe, and Outlook.exe terminate due to unhandled exceptions. Also, many server-side applications, like web servers, are stateless and are automatically restarted if they fail due to an unhandled exception. Of course some servers, like SQL Server, are all about state management and having data lost due to an unhandled exception is potentially much more disastrous.</p></blockquote><blockquote><p>In the CLR, we have AppDomains (discussed in Chapter 22), which contain state. When an AppDomain is unloaded, all its state is unloaded. And so, if a thread in an AppDomain experiences an unhandled exception, it is OK to unload the AppDomain (which destroys all its state) without terminating the whole process.</p></blockquote><blockquote><p>By definition, a CER is a block of code that must be resilient to failure. Because AppDomains can be unloaded, destroying their state, CERs are typically used to manipulate any state that is shared by multiple AppDomains or processes. CERs are useful when trying to maintain state in the face of exceptions that get thrown unexpectedly. Sometimes we refer to these kinds of exceptions as asynchronous exceptions. For example, when calling a method, the CLR has to load an assembly, create a type object in the AppDomain’s loader heap, call the type’s static constructor, JIT IL into native code, and so on. Any of these operations could fail, and the CLR reports the failure by throwing an exception.</p></blockquote><blockquote><p>If any of these operations fail within a catch or finally block, then your error recovery or cleanup code won’t execute in its entirety. Here is an example of code that exhibits the potential problem.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Demo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"In try"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Type1’s static constructor is implicitly called in here</span></pre></td></tr><tr><td data-num="7"></td><td><pre> Type1<span class="token punctuation">.</span><span class="token function">M</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Type1</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">static</span> <span class="token function">Type1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// if this throws an exception, M won’t get called</span></pre></td></tr><tr><td data-num="13"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Type1's static ctor called"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">M</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When I run the preceding code, I get the following output.</p></blockquote><pre><code class="language-cmd">In try
Type1's static ctor called
</code></pre><blockquote><p>What we want is to not even start executing the code in the preceding try block unless we know that the code in the associated catch and finally blocks is guaranteed (or as close as we can get to guaranteed) to execute. We can accomplish this by modifying the code as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Demo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Force the code in the finally to be eagerly prepared</span></pre></td></tr><tr><td data-num="3"></td><td><pre> RuntimeHelpers<span class="token punctuation">.</span><span class="token function">PrepareConstrainedRegions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// System.Runtime.CompilerServices namespace</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"In try"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Type2’s static constructor is implicitly called in here</span></pre></td></tr><tr><td data-num="9"></td><td><pre> Type2<span class="token punctuation">.</span><span class="token function">M</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Type2</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">static</span> <span class="token function">Type2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Type2's static ctor called"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token comment">// Use this attribute defined in the System.Runtime.ConstrainedExecution namespace</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token punctuation">[</span><span class="token function">ReliabilityContract</span><span class="token punctuation">(</span>Consistency<span class="token punctuation">.</span>WillNotCorruptState<span class="token punctuation">,</span> Cer<span class="token punctuation">.</span>Success<span class="token punctuation">)</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">M</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Now, when I run this version of the code, I get the following output.</p></blockquote><pre><code class="language-cmd">Type2's static ctor called
In try
</code></pre><blockquote><p>The PrepareConstrainedRegions method is a very special method. When the JIT compiler sees this method being called immediately before a try block, it will eagerly compile the code in the try’s catch and finally blocks. The JIT compiler will load any assemblies, create any type objects, invoke any static constructors, and JIT any methods. If any of these operations result in an exception, then the exception occurs before the thread enters the try block.</p></blockquote><blockquote><p>When the JIT compiler eagerly prepares methods, it also walks the entire call graph eagerly preparing called methods. However, the JIT compiler only prepares methods that have the ReliabilityContractAttribute applied to them with either Consistency.WillNotCorruptState or Consistency.MayCorruptInstance because the CLR can’t make any guarantees about methods that might corrupt AppDomain or process state. Inside a catch or finally block that you are protecting with a call to PrepareConstrainedRegions, you want to make sure that you only call methods with the ReliabillityContractAttribute set as I’ve just described.</p></blockquote><blockquote><p>The ReliabilityContractAttribute looks like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">ReliabilityContractAttribute</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Attribute</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token function">ReliabilityContractAttribute</span><span class="token punctuation">(</span><span class="token class-name">Consistency</span> consistencyGuarantee<span class="token punctuation">,</span> <span class="token class-name">Cer</span> cer<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Cer</span> Cer <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Consistency</span> ConsistencyGuarantee <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>This attribute lets a developer document the reliability contract of a particular method to the method’s potential callers. Both the Cer and Consistency types are enumerated types defined as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">enum</span> <span class="token class-name">Consistency</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> MayCorruptProcess<span class="token punctuation">,</span> MayCorruptAppDomain<span class="token punctuation">,</span> MayCorruptInstance<span class="token punctuation">,</span> WillNotCorruptState</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">enum</span> <span class="token class-name">Cer</span> <span class="token punctuation">&#123;</span> None<span class="token punctuation">,</span> MayFail<span class="token punctuation">,</span> Success <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>If the method you are writing promises not to corrupt any state, use Consistency.WillNotCorruptState. Otherwise, document what your method does by using one of the other three possible values that match whatever state your method might corrupt. If the method that you are writing promises not to fail, use Cer.Success. Otherwise, use Cer.MayFail. Any method that does not have the ReliabiiltyContractAttribute applied to it is equivalent to being marked like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">ReliabilityContract</span><span class="token attribute-arguments"><span class="token punctuation">(</span>Consistency<span class="token punctuation">.</span>MayCorruptProcess<span class="token punctuation">,</span> Cer<span class="token punctuation">.</span>None<span class="token punctuation">)</span></span></span><span class="token punctuation">]</span></pre></td></tr></table></figure><blockquote><p>The Cer.None value indicates that the method makes no CER guarantees. In other words, it wasn’t written with CERs in mind; therefore, it may fail and it may or may not report that it failed. Remember that most of these settings are giving a method a way to document what it offers to potential callers so that they know what to expect. The CLR and JIT compiler do not use this information.</p></blockquote><blockquote><p>When you want to write a reliable method, make it small and constrain what it does. Make sure that it doesn’t allocate any objects (no boxing, for example), don’t call any virtual methods or interface methods, use any delegates, or use reflection because the JIT compiler can’t tell what method will actually be called. However, you can manually prepare these methods by calling one of these methods defined by the RuntimeHelpers’s class.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">PrepareMethod</span><span class="token punctuation">(</span><span class="token class-name">RuntimeMethodHandle</span> method<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">PrepareMethod</span><span class="token punctuation">(</span><span class="token class-name">RuntimeMethodHandle</span> method<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">RuntimeTypeHandle<span class="token punctuation">[</span><span class="token punctuation">]</span></span> instantiation<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">PrepareDelegate</span><span class="token punctuation">(</span><span class="token class-name">Delegate</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">PrepareContractedDelegate</span><span class="token punctuation">(</span><span class="token class-name">Delegate</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>Note that the compiler and the CLR do nothing to verify that you’ve written your method to actually live up to the guarantees you document via the ReliabiltyContractAttribute. If you do something wrong, then state corruption is possible.</p></blockquote><p>💡注意：即使所有方法都提前准备好，方法调用仍有可能造成 <code>StackOverflowException</code> 。在 CLR 没有寄宿的前提下， <code>StackOverflowException</code> 会造成 CLR 在内部调用 <code>Environment.FailFast</code> 来立即终止进程。在已经寄宿的前提下， <code>PrepareConstrainedRegions</code> 方法检查是否剩下约 48 KB 的栈空间。栈空间不足，就在进入 <code>try</code> 块前抛出 <code>StackOverflowException</code> 。</p><blockquote><p>You should also look at RuntimeHelper’s ExecuteCodeWithGuaranteedCleanup method, which is another way to execute code with guaranteed cleanup.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ExecuteCodeWithGuaranteedCleanup</span><span class="token punctuation">(</span><span class="token class-name">TryCode</span> code<span class="token punctuation">,</span> <span class="token class-name">CleanupCode</span> backoutCode<span class="token punctuation">,</span> <span class="token class-name">Object</span> userData<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>When calling this method, you pass the body of the try and finally block as callback methods whose prototypes match these two delegates respectively.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">delegate</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">TryCode</span><span class="token punctuation">(</span><span class="token class-name">Object</span> userData<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">delegate</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">CleanupCode</span><span class="token punctuation">(</span><span class="token class-name">Object</span> userData<span class="token punctuation">,</span> <span class="token class-name">Boolean</span> exceptionThrown<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>And finally, another way to get guaranteed code execution is to use the CriticalFinalizerObject class, which is explained in great detail in Chapter 21.</p></blockquote><p>💡小结：许多服务器端应用程序 (比如 Web 服务器) 都是无状态的，会在因为未处理的异常而失败时自动重启。当然，某些服务器 (比如 SQL Server) 本来就是为状态管理而设计的。这种程序假如因为未处理的异常而发生数据丢失，后果将是灾难性的。在 CLR 中，我们有包含了状态的 AppDomain。AppDomain 卸载时，它的所有状态都会卸载。所以，如果 AppDomain 中的一个线程遭遇未处理的异常，可以在不终止整个进程的情况下卸载 AppDomain。根据定义，CER 是必须对错误有适应力的代码块。由于 AppDomain 可能被卸载，造成它的状态被销毁，所以一般用 CER 处理由多个 AppDomain 或进程共享的状态。如果要在抛出了非预期的异常时维护状态，CER 就非常有用。有时候这些异常称异步异常。 <code>PrepareConstrainedRegions</code> 是一个很特别的方法。JIT 编译器如果发现在一个 <code>try</code> 块之前调用了这个方法，就会提前编译与 <code>try</code> 关联的 <code>catch</code> 和 <code>finally</code> 块中的代码。JIT 编译器会加载任何程序集，创建任何类型对象，调用任何静态构造器，并对任何方法进行 JIT 编译。如果其中任何操作做成异常，这个异常会在线程进入 <code>try</code> 块之前发生。JIT 编译器提前准备方法时，还会遍历整个调用图，提前准备被调用的方法，前提是这些方法应用了 <code>ReliabilityContractAttribute</code> ，而且向这个特性实例的构造器传递的是 <code>Consistency.WillNotCorruptState</code> 或者 <code>Consistency.MayCorruptInstance</code> 枚举成员。这是由于假如方法会损坏 AppDomain 或进程的状态，CLR 便无法对状态一致性做出任何保证。在通过一个 <code>PrepareConstrainedRegions</code> 调用来保护的一个 <code>catch</code> 或 <code>finally</code> 块中，请确保只调用根据刚才的描述设置了 <code>ReliabilityContractAttribute</code> 的方法。 <code>ReliabilityContractAttribute</code> 特性允许开发者向方法的潜在调用者申明方法的可靠性协定 (reliability contract)。 <code>Cer</code> 和 <code>Consistency</code> 都是枚举类型。 <code>Cer.None</code> 这个值表明方法不进行 CER 保证。换言之，方法没有 CER 的概念。因此，这个方法可能失败，而且可能会、也可能不会报告失败。记住，大多数这些设置都为方法提供了一种方式来申明它向潜在的调用者提供的东西，使调用者知道什么可以期待。CLR 和 JIT 编译器不使用这种信息。如果想写一个可靠的方法，务必保持它的短小精悍，同时约束它做的事情。要保证它不分配任何对象 (例如不装箱)。另外，不调用任何虚方法或接口方法，不使用任何委托，也不使用反射，因为 JIT 编译器不知道实际会调用哪个方法。然而，可以调用 <code>RuntimeHelper</code> 类定义方法之一，从而手动准备这些方法。注意，编译器和 CLR 并不验证你写的方法真的符合通过 <code>ReliabilityContractAttribute</code> 来作出的保证。所以，如果犯了错误，状态仍有可能损坏。还应该关注一下 <code>RuntimeHelper</code> 的 <code>ExecuteCodeWithGuaranteedCleanup</code> 方法，它的资源保证得到清理的前提下才执行代码。最后，另一种保证代码得以执行的方式是使用 <code>CriticalFinalizerObject</code> 类。</p><h2 id="code-contracts"><a class="anchor" href="#code-contracts">#</a> Code Contracts</h2><blockquote><p>Code contracts provide a way for you to declaratively document design decisions that you’ve made about your code within the code itself. The contracts take the form of the following:</p><ul><li><p>Preconditions Typically used to validate arguments</p></li><li><p>Postconditions Used to validate state when a method terminates either due to a normal return or due to throwing an exception</p></li><li><p>Object Invariants Used to ensure an object’s fields remain in a good state through an object’s entire lifetime</p></li></ul></blockquote><blockquote><p>Code contracts facilitate code usage, understanding, evolution, testing, documentation, and early error detection.10 You can think of preconditions, postconditions, and object invariants as parts of a method’s signature. As such, you can loosen a contract with a new version of your code, but you cannot make a contract stricter with a new version without breaking backward compatibility.</p></blockquote><blockquote><p>At the heart of the code contracts is the static System.Diagnostics.Contracts.Contract class.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Contract</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Precondition methods: [Conditional("CONTRACTS_FULL")]</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Requires</span><span class="token punctuation">(</span><span class="token class-name">Boolean</span> condition<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">EndContractBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// Preconditions: Always</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">Requires</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>TException<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">Boolean</span> condition<span class="token punctuation">)</span> <span class="token keyword">where</span> <span class="token class-name">TException</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Exception</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// Postcondition methods: [Conditional("CONTRACTS_FULL")]</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Ensures</span><span class="token punctuation">(</span><span class="token class-name">Boolean</span> condition<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">EnsuresOnThrow</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>TException<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">Boolean</span> condition<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">where</span> <span class="token class-name">TException</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Exception</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// Special Postcondition methods: Always</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">T</span> <span class="token generic-method"><span class="token function">Result</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">T</span> <span class="token generic-method"><span class="token function">OldValue</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">T</span> <span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">T</span> <span class="token generic-method"><span class="token function">ValueAtReturn</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token keyword">out</span> <span class="token class-name">T</span> <span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// Object Invariant methods: [Conditional("CONTRACTS_FULL")]</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Invariant</span><span class="token punctuation">(</span><span class="token class-name">Boolean</span> condition<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token comment">// Quantifier methods: Always</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Boolean</span> <span class="token generic-method"><span class="token function">Exists</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> collection<span class="token punctuation">,</span> <span class="token class-name">Predicate<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> predicate<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Boolean</span> <span class="token function">Exists</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> fromInclusive<span class="token punctuation">,</span> <span class="token class-name">Int32</span> toExclusive<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token class-name">Predicate<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">></span></span> predicate<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Boolean</span> <span class="token generic-method"><span class="token function">ForAll</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> collection<span class="token punctuation">,</span> <span class="token class-name">Predicate<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> predicate<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Boolean</span> <span class="token function">ForAll</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> fromInclusive<span class="token punctuation">,</span> <span class="token class-name">Int32</span> toExclusive<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token class-name">Predicate<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">></span></span> predicate<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token comment">// Helper methods: [Conditional("CONTRACTS_FULL")] or [Conditional("DEBUG")]</span></pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Assert</span><span class="token punctuation">(</span><span class="token class-name">Boolean</span> condition<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Assume</span><span class="token punctuation">(</span><span class="token class-name">Boolean</span> condition<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre> <span class="token comment">// Infrastructure event: usually your code will not use this event </span></pre></td></tr><tr><td data-num="28"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">event</span> <span class="token class-name">EventHandler<span class="token punctuation">&lt;</span>ContractFailedEventArgs<span class="token punctuation">></span></span> ContractFailed<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>As previously indicated, many of these static methods have the [Conditional(&quot;CONTRACTS_ FULL&quot;)] attribute applied to them. Some of the helper methods also have the [Conditional­ (&quot;DEBUG&quot;)] attribute applied to them. This means that the compiler will ignore any code you write that calls these methods unless the appropriate symbol is defined when compiling your code. Any methods marked with “Always” mean that the compiler always emits code to call the method. Also, the Requires, Requires, Ensures, EnsuresOnThrow, Invariant, Assert, and Assume methods have an additional overload (not shown) that takes a String message argument so you can explicitly specify a string message that should appear when the contract is violated.</p></blockquote><blockquote><p>By default, contracts merely serve as documentation because you would not define the CONTRACTS_FULL symbol when you build your project. In order to get some additional value out of using contracts, you must download additional tools and a Visual Studio property pane from <span class="exturl" data-url="aHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9kZXZsYWJzL2RkNDkxOTkyLmFzcHg=">http://msdn.microsoft.com/en-us/devlabs/dd491992.aspx</span>. The reason why all the code contract tools are not included with Visual Studio is because this technology is being improved rapidly. The Microsoft DevLabs website can offer new versions and improvements more quickly than Visual Studio itself. After downloading and installing the additional tools, you will see your projects have a new property pane available to them, as shown in Figure 20-9.</p></blockquote><p><strong>FIGURE 20-9</strong> The Code Contracts pane for a Visual Studio project.</p><blockquote><p>To turn on code contract features, select the Perform Runtime Contract Checking check box and select Full from the combo box next to it. This defines the CONTRACTS_FULL symbol when you build your project and invokes the appropriate tools (described shortly) after building your project. Now, at run time, when a contract is violated, Contract’s ContractFailed event is raised. Usually, developers do not register any methods with this event, but if you do, then any methods you register will receive a ContractFailedEventArgs object that looks like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">ContractFailedEventArgs</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">EventArgs</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token function">ContractFailedEventArgs</span><span class="token punctuation">(</span><span class="token class-name">ContractFailureKind</span> failureKind<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">String</span> message<span class="token punctuation">,</span> <span class="token class-name">String</span> condition<span class="token punctuation">,</span> <span class="token class-name">Exception</span> originalException<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">ContractFailureKind</span> FailureKind <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">String</span> Message <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">String</span> Condition <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Exception</span> OriginalException <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Boolean</span> Handled <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// true if any handler called SetHandled</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SetHandled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Call to ignore the violation; sets Handled to true</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Boolean</span> Unwind <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// true if any handler called SetUnwind or threw</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SetUnwind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Call to force ContractException; set Unwind to true</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Multiple event handler methods can be registered with this event. Each method can process the contract violation any way it chooses. For example, a handler can log the violation, ignore the violation (by calling SetHandled), or terminate the process. If any method calls SetHandled, then the violation will be considered handled and, after all the handler methods return, the application code is allowed to continue running unless any handler calls SetUnwind. If a handler calls SetUnwind, then, after all the handler methods have completed running, a System.Diagnostics.Contracts. ContractException is thrown. Note that this type is internal to MSCorLib.dll and therefore you cannot write a catch block to catch it explicitly. Also note that if any handler method throws an unhandled exception, then the remaining handler methods are invoked and then a ContractException is thrown.</p></blockquote><blockquote><p>If there are no event handlers or if none of them call SetHandled, SetUnwind, or throw an unhandled exception, then default processing of the contract violation happens next. If the CLR is being hosted, then the host is notified that a contract failed. If the CLR is running an application on a non-interactive window station (which would be the case for a Windows service application), then Environment.FailFast is called to instantly terminate the process. If you compile with the Assert On Contract Failure check box selected, then an assert dialog box will appear allowing you to connect a debugger to your application. If this option is not selected, then a ContractException is thrown.</p></blockquote><blockquote><p>Let’s look at a sample class that is using code contracts.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Item</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* ... */</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">ShoppingCart</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">List<span class="token punctuation">&lt;</span>Item<span class="token punctuation">></span></span> m_cart <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">List<span class="token punctuation">&lt;</span>Item<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Decimal</span> m_totalCost <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token function">ShoppingCart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">AddItem</span><span class="token punctuation">(</span><span class="token class-name">Item</span> item<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token function">AddItemHelper</span><span class="token punctuation">(</span>m_cart<span class="token punctuation">,</span> item<span class="token punctuation">,</span> <span class="token keyword">ref</span> m_totalCost<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">AddItemHelper</span><span class="token punctuation">(</span><span class="token class-name">List<span class="token punctuation">&lt;</span>Item<span class="token punctuation">></span></span> m_cart<span class="token punctuation">,</span> <span class="token class-name">Item</span> newItem<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">ref</span> <span class="token class-name">Decimal</span> totalCost<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// Preconditions: </span></pre></td></tr><tr><td data-num="13"></td><td><pre> Contract<span class="token punctuation">.</span><span class="token function">Requires</span><span class="token punctuation">(</span>newItem <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> Contract<span class="token punctuation">.</span><span class="token function">Requires</span><span class="token punctuation">(</span>Contract<span class="token punctuation">.</span><span class="token function">ForAll</span><span class="token punctuation">(</span>m_cart<span class="token punctuation">,</span> s <span class="token operator">=></span> s <span class="token operator">!=</span> newItem<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// Postconditions:</span></pre></td></tr><tr><td data-num="16"></td><td><pre> Contract<span class="token punctuation">.</span><span class="token function">Ensures</span><span class="token punctuation">(</span>Contract<span class="token punctuation">.</span><span class="token function">Exists</span><span class="token punctuation">(</span>m_cart<span class="token punctuation">,</span> s <span class="token operator">=></span> s <span class="token operator">==</span> newItem<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre> Contract<span class="token punctuation">.</span><span class="token function">Ensures</span><span class="token punctuation">(</span>totalCost <span class="token operator">>=</span> Contract<span class="token punctuation">.</span><span class="token function">OldValue</span><span class="token punctuation">(</span>totalCost<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre> Contract<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">EnsuresOnThrow</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>IOException<span class="token punctuation">></span></span></span><span class="token punctuation">(</span>totalCost <span class="token operator">==</span> Contract<span class="token punctuation">.</span><span class="token function">OldValue</span><span class="token punctuation">(</span>totalCost<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token comment">// Do some stuff (which could throw an IOException)...</span></pre></td></tr><tr><td data-num="20"></td><td><pre> m_cart<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>newItem<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre> totalCost <span class="token operator">+=</span> <span class="token number">1.00M</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token comment">// Object invariant</span></pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token punctuation">[</span>ContractInvariantMethod<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ObjectInvariant</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre> Contract<span class="token punctuation">.</span><span class="token function">Invariant</span><span class="token punctuation">(</span>m_totalCost <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The AddItemHelper method defines a bunch of code contracts. The preconditions indicate that newItem must not be null and that the item being added to the cart is not already in the cart. The postconditions indicate that the new item must be in the cart and that the total cost must be at least as much as it was before the item was added to the cart. The postconditions also indicate that if AddItemHelper were to throw an IOException for some reason, then totalCost is unchanged from what it was when the method started to execute. The ObjectInvariant method is just a private method that, when called, makes sure that the object’s m_totalCost field never contains a negative value.</p></blockquote><p>💡重要提示：前条件、后条件或不变性测试中引用的任何成员都一定不能有副作用 (改变对象的状态)。这是必须的，因为测试条件不应改变对象本身的状态。除此之外，前条件测试中引用的所有成员的可访问性都至少要和定义前条件的方法一样。这是必须的，因为方法的调用者应该能在调用方法之前验证它们符合所有前条件。另一方面，后条件或不变性测试中引用的成员可具有任何可访问性，只要代码能编译就行。可访问性之所以不重要，是因为后条件和不变性测试不影响调用者正确调用方法的能力。</p><p>💡重要提示：涉及继承时，派生类型不能重写并更改基类型中定义的虚成员的前条件。类似地，实现了接口成员的类型不能更改接口成员定义的前条件。如果一个成员没有定义显式的协定，那么成员将获得一个隐式协定，逻辑上这样表示：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>Contract<span class="token punctuation">.</span><span class="token function">Requires</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>由于协定不能在新版本中变得更严格 (否则会破坏兼容性)，所以在引入新的虚 / 抽象 / 接口成员时，应仔细考虑好前条件。对于后条件和对象不变性，协定可以随意添加和删除，因为虚 / 抽象 / 接口成员中表示的条件和重写成员中表示的条件会 “逻辑 AND” 到一起。</p><blockquote><p>So now you see how to declare contracts. Let’s now talk about how they function at run time. You get to declare all your precondition and postcondition contracts at the top of your methods where they are easy to find. Of course, the precondition contracts will validate their tests when the method is invoked. However, we don’t want the postcondition contracts to validate their tests until the method returns. In order to get the desired behavior, the assembly produced by the C# compiler must be processed by the Code Contract Rewriter tool (CCRewrite.exe, found in C:\Program Files (x86)\Microsoft\Contracts\Bin), which produces a modified version of the assembly. After you select the Perform Runtime Contract Checking check box for your project, Visual Studio will invoke this tool for you automatically whenever you build the project. This tool analyzes the IL in all your methods and it rewrites the IL so that any postcondition contracts are executed at the end of each method. If your method has multiple return points inside it, then the CCRewrite.exe tool modifies the method’s IL code so that all return points execute the postcondition code prior to the method returning.</p></blockquote><blockquote><p>The CCRewrite.exe tool looks in the type for any method marked with the [ContractInvariantMethod] attribute. The method can have any name but, by convention, people usually name the method ObjectInvariant and mark the method as private (as I’ve just done). The method must accept no arguments and have a void return type. When the CCRewrite.exe tool sees a method marked with this attribute, it inserts IL code at the end of every public instance method to call the ObjectInvariant method. This way, the object’s state is checked as each method returns to ensure that no method has violated the contract. Note that the CCRewrite.exe tool does not modify a Finalize method or an IDisposable’s Dispose method to call the ObjectInvariant method because it is OK for an object’s state to be altered if it is considered to be destroyed or disposed. Also note that a single type can define multiple methods with the [ContractInvariantMethod] attribute; this is useful when working with partial types. The CCRewrite.exe tool will modify the IL to call all of these methods (in an undefined order) at the end of each public method.</p></blockquote><blockquote><p>The Assert and Assume methods are unlike the other methods. First, you should not consider them to be part of the method’s signature, and you do not have to put them at the beginning of a method. At run time, these two methods perform identically: they just verify that the condition passed to them is true and throw an exception if it is not. However, there is another tool, the Code Contract Checker (CCCheck.exe), which analyzes the IL produced by the C# compiler in an attempt to statically verify that no code in the method violates a contract. This tool will attempt to prove that any condition passed to Assert is true, but it will just assume that any condition passed to Assume is true and the tool will add the expression to its body of facts known to be true. Usually, you will use Assert and then change an Assert to an Assume if the CCCheck.exe tool can’t statically prove that the expression is true.</p></blockquote><blockquote><p>Let’s walk through an example. Assume that I have the following type definition.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">String</span> s_name <span class="token operator">=</span> <span class="token string">"Jeffrey"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ShowFirstLetter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>s_name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// warning: requires unproven: index &lt; this.Length</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When I build this code with the Perform Static Contract Checking function turned on, the CCCheck.exe tool produces the warning shown as a comment in the preceding code. This warning is notifying me that querying the first letter of s_name may fail and throw an exception because it is unproven that s_name always refers to a string consisting of at least one character.</p></blockquote><blockquote><p>Therefore, what we’d like to do is add an assertion to the ShowFirstLetter method.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ShowFirstLetter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> Contract<span class="token punctuation">.</span><span class="token function">Assert</span><span class="token punctuation">(</span>s_name<span class="token punctuation">.</span>Length <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// warning: assert unproven</span></pre></td></tr><tr><td data-num="3"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>s_name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Unfortunately, when the CCCheck.exe tool analyzes this code, it is still unable to validate that s_name always refers to a string containing at least one letter, so the tool produces a similar warning. Sometimes the tool is unable to validate assertions due to limitations in the tool; future versions of the tool will be able to perform a more complete analysis.</p></blockquote><blockquote><p>To override shortcomings in the tool or to claim that something is true that the tool would never be able to prove, we can change Assert to Assume. If we know for a fact that no other code will modify s_name, then we can change ShowFirstLetter to this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ShowFirstLetter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> Contract<span class="token punctuation">.</span><span class="token function">Assume</span><span class="token punctuation">(</span>s_name<span class="token punctuation">.</span>Length <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// No warning at all now!</span></pre></td></tr><tr><td data-num="3"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>s_name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>With this version of the code, the CCCheck.exe tool just takes our word for it and concludes that s_name always refers to a string containing at least one letter. This version of the ShowFirstLetter method passes the code contract static checker without any warnings at all.</p></blockquote><blockquote><p>Now, let’s talk about the Code Contract Reference Assembly Generator tool (CCRefGen.exe). Running the CCRewrite.exe tool to enable contract checking helps you find bugs more quickly, but all the code emitted during contract checking makes your assembly bigger and hurts its run-time performance. To improve this situation, you use the CCRefGen.exe tool to create a separate contract reference assembly. Visual Studio invokes this tool for you automatically if you set the Contract Reference Assembly combo box to Build. Contract assemblies are usually named AssemName.Contracts.dll (for example, MSCorLib.Contracts.dll), and these assemblies contain only metadata and the IL that describes the contracts—nothing else. You can identify a contract reference assembly because it will have the System.Diagnostics.Contracts.ContractReferenceAssemblyAttribute applied to the assembly’s assembly definition metadata table. The CCRewrite.exe tool and the CCCheck.exe tool can use contract reference assemblies as input when these tools are performing their instrumentation and analysis.</p></blockquote><blockquote><p>The last tool, the Code Contract Document Generator tool (CCDocGen.exe), adds contract information to the XML documentation files already produced by the C# compiler when you use the compiler’s /doc:file switch. This XML file, enhanced by the CCDocGen.exe tool, can be processed by Microsoft’s Sandcastle tool to produce MSDN-style documentation that will now include contract information.</p></blockquote><p>💡小结：代码协定 (code contract) 提供了直线在代码中声明代码设计决策的一种方式。代码协定有利于代码的使用、理解、进化、测试、文档和早期错误检测。可将前条件、后条件和对象不变性想象为方法签名的一部分。所以，代码新版本的协定可以变得更宽松。但不能变得更严格，否则会破坏向后兼容性。代码协定的核心是静态类 <code>System.Diagnostics.Contracts.Contract</code> 。其中许多静态方法都应用了 <code>[Conditional(&quot;CONTRACTS_FULL&quot;)]</code> 特性。有的辅助方法还应用了 <code>[Conditional(&quot;DEBUG&quot;)]</code> ，意味着除非定义了恰当的符号，否则编译器会忽略调用这些方法的任何代码。标记 “Always” 的任何方法意味着编译器总是生成调用方法的代码。另外， <code>Requires</code> ， <code>Requires&lt;TException&gt;</code> ， <code>Ensures</code> ， <code>EnsuresOnThrow</code> ， <code>Invariant</code> ， <code>Assert</code> 和 <code>Assume</code> 方法有一个额外的重载版本 (这里没有列出)，它获取一个 <code>String</code> 实参，用于显式指定违反协定时显示的字符串消息。协定默认只作为文档使用，因为生成项目时没有定义 <code>CONTRACTS_FULL</code> 符号。为了发掘协定的附加价值，必须下载额外的工具和一个 Visual Studio 属性窗格，网址是 <span class="exturl" data-url="aHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9kZXZsYWJzL2RkNDkxOTkyLmFzcHglRTMlODAlODI=">http://msdn.microsoft.com/en-us/devlabs/dd491992.aspx。</span></p><div class="tags"><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 读书笔记</a> <a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C#</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2022-11-27 16:58:41" itemprop="dateModified" datetime="2022-11-27T16:58:41+08:00">2022-11-27</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Sakupinera WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Sakupinera Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Sakupinera PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Sakupinera <i class="ic i-at"><em>@</em></i>Sakupinera</li><li class="link"><strong>Post link: </strong><a href="http://sakupinera.github.io/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/" title="CLR via C# - Chapter 20 Exceptions and State Management">http://sakupinera.github.io/2022/11/25/csharp/clr-via-csharp/Chapter 20 Exceptions and State Management/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/11/23/csharp/clr-via-csharp/Chapter%2019%20Nullable%20Value%20Types/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclh5u05ej20zk0m87df.jpg" title="CLR via C# - Chapter 19 Nullable Value Types"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 19 Nullable Value Types</h3></a></div><div class="item right"><a href="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipex2cdtbj20zk0m8x6p.jpg" title="CLR via C# - Chapter 21 The Managed Heap and Garbage  Collection"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 21 The Managed Heap and Garbage Collection</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-20-exceptions-and-state-management"><span class="toc-number">1.</span> <span class="toc-text">Chapter 20 Exceptions and State Management</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#defining-exception"><span class="toc-number">1.1.</span> <span class="toc-text">Defining “Exception”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exception-handling-mechanics"><span class="toc-number">1.2.</span> <span class="toc-text">Exception-Handling Mechanics</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#the-try-block"><span class="toc-number">1.2.1.</span> <span class="toc-text">The try Block</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#the-catch-block"><span class="toc-number">1.2.2.</span> <span class="toc-text">The catch Block</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#the-finally-block"><span class="toc-number">1.2.3.</span> <span class="toc-text">The finally Block</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#the-systemexception-class"><span class="toc-number">1.3.</span> <span class="toc-text">The System.Exception Class</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fcl-defined-exception-classes"><span class="toc-number">1.4.</span> <span class="toc-text">FCL-Defined Exception Classes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#throwing-an-exception"><span class="toc-number">1.5.</span> <span class="toc-text">Throwing an Exception</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#defining-your-own-exception-class"><span class="toc-number">1.6.</span> <span class="toc-text">Defining Your Own Exception Class</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#trading-reliability-for-productivity"><span class="toc-number">1.7.</span> <span class="toc-text">Trading Reliability for Productivity</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#guidelines-and-best-practices"><span class="toc-number">1.8.</span> <span class="toc-text">Guidelines and Best Practices</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#use-finally-blocks-liberally"><span class="toc-number">1.8.1.</span> <span class="toc-text">Use finally Blocks Liberally</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dont-catch-everything"><span class="toc-number">1.8.2.</span> <span class="toc-text">Don’t Catch Everything</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#recovering-gracefully-from-an-exception"><span class="toc-number">1.8.3.</span> <span class="toc-text">Recovering Gracefully from an Exception</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#backing-out-of-a-partially-completed-operation-when-an-unrecoverable-exception-occursmaintaining-state"><span class="toc-number">1.8.4.</span> <span class="toc-text">Backing Out of a Partially Completed Operation When an Unrecoverable Exception Occurs—Maintaining State</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hiding-an-implementation-detail-to-maintain-a-contract"><span class="toc-number">1.8.5.</span> <span class="toc-text">Hiding an Implementation Detail to Maintain a “Contract”</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unhandled-exceptions"><span class="toc-number">1.9.</span> <span class="toc-text">Unhandled Exceptions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#debugging-exceptions"><span class="toc-number">1.10.</span> <span class="toc-text">Debugging Exceptions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exception-handling-performance-considerations"><span class="toc-number">1.11.</span> <span class="toc-text">Exception-Handling Performance Considerations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#constrained-execution-regions-cers"><span class="toc-number">1.12.</span> <span class="toc-text">Constrained Execution Regions (CERs)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-contracts"><span class="toc-number">1.13.</span> <span class="toc-text">Code Contracts</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"><ul><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/" rel="bookmark" title="CLR via C# - Chapter 1 The CLR’s Execution Model">CLR via C# - Chapter 1 The CLR’s Execution Model</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/" rel="bookmark" title="CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types">CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%203%20Shared%20Assemblies%20and%20Strongly%20Named%20Assemblies/" rel="bookmark" title="CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies">CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies</a></li><li><a href="/2022/09/27/csharp/clr-via-csharp/Chapter%204%20Type%20Fundamentals/" rel="bookmark" title="CLR via C# - Chapter 4 Type Fundamentals">CLR via C# - Chapter 4 Type Fundamentals</a></li><li><a href="/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/" rel="bookmark" title="CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals">CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals</a></li><li><a href="/2022/10/21/csharp/clr-via-csharp/Chapter%206%20Type%20and%20Member%20Basics/" rel="bookmark" title="CLR via C# - Chapter 6 Type and Member Basics">CLR via C# - Chapter 6 Type and Member Basics</a></li><li><a href="/2022/10/24/csharp/clr-via-csharp/Chapter%207%20Constants%20and%20Fields/" rel="bookmark" title="CLR via C# - Chapter 7 Constants and Fields">CLR via C# - Chapter 7 Constants and Fields</a></li><li><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" rel="bookmark" title="CLR via C# - Chapter 8 Methods">CLR via C# - Chapter 8 Methods</a></li><li><a href="/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/" rel="bookmark" title="CLR via C# - Chapter 9 Parameters">CLR via C# - Chapter 9 Parameters</a></li><li><a href="/2022/10/28/csharp/clr-via-csharp/Chapter%2010%20Properties/" rel="bookmark" title="CLR via C# - Chapter 10 Properties">CLR via C# - Chapter 10 Properties</a></li><li><a href="/2022/10/29/csharp/clr-via-csharp/Chapter%2011%20Events/" rel="bookmark" title="CLR via C# - Chapter 11 Events">CLR via C# - Chapter 11 Events</a></li><li><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" rel="bookmark" title="CLR via C# - Chapter 12 Generics">CLR via C# - Chapter 12 Generics</a></li><li><a href="/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/" rel="bookmark" title="CLR via C# - Chapter 13 Interfaces">CLR via C# - Chapter 13 Interfaces</a></li><li><a href="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/" rel="bookmark" title="CLR via C# - Chapter 14 Chars, Strings, and Working with Text">CLR via C# - Chapter 14 Chars, Strings, and Working with Text</a></li><li><a href="/2022/11/17/csharp/clr-via-csharp/Chapter%2015%20Enumerated%20Types%20and%20Bit%20Flags/" rel="bookmark" title="CLR via C# - Chapter 15 Enumerated Types and Bit Flags">CLR via C# - Chapter 15 Enumerated Types and Bit Flags</a></li><li><a href="/2022/11/19/csharp/clr-via-csharp/Chapter%2016%20Arrays/" rel="bookmark" title="CLR via C# - Chapter 16 Arrays">CLR via C# - Chapter 16 Arrays</a></li><li><a href="/2022/11/21/csharp/clr-via-csharp/Chapter%2017%20Delegates/" rel="bookmark" title="CLR via C# - Chapter 17 Delegates">CLR via C# - Chapter 17 Delegates</a></li><li><a href="/2022/11/22/csharp/clr-via-csharp/Chapter%2018%20Custom%20Attributes/" rel="bookmark" title="CLR via C# - Chapter 18 Custom Attributes">CLR via C# - Chapter 18 Custom Attributes</a></li><li><a href="/2022/11/23/csharp/clr-via-csharp/Chapter%2019%20Nullable%20Value%20Types/" rel="bookmark" title="CLR via C# - Chapter 19 Nullable Value Types">CLR via C# - Chapter 19 Nullable Value Types</a></li><li class="active"><a href="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/" rel="bookmark" title="CLR via C# - Chapter 20 Exceptions and State Management">CLR via C# - Chapter 20 Exceptions and State Management</a></li><li><a href="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/" rel="bookmark" title="CLR via C# - Chapter 21 The Managed Heap and Garbage  Collection">CLR via C# - Chapter 21 The Managed Heap and Garbage Collection</a></li><li><a href="/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/" rel="bookmark" title="CLR via C# - Chapter 22 CLR Hosting and AppDomains">CLR via C# - Chapter 22 CLR Hosting and AppDomains</a></li><li><a href="/2022/11/29/csharp/clr-via-csharp/Chapter%2023%20Assembly%20Loading%20and%20Reflection/" rel="bookmark" title="CLR via C# - Chapter 23 Assembly Loading and Reflection">CLR via C# - Chapter 23 Assembly Loading and Reflection</a></li><li><a href="/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/" rel="bookmark" title="CLR via C# - Chapter 24 Runtime Serialization">CLR via C# - Chapter 24 Runtime Serialization</a></li><li><a href="/2022/12/06/csharp/clr-via-csharp/Chapter%2025%20Interoperating%20with%20WinRT%20%20Components/" rel="bookmark" title="CLR via C# - Chapter 25 Interoperating with WinRT Components">CLR via C# - Chapter 25 Interoperating with WinRT Components</a></li><li><a href="/2023/02/06/csharp/clr-via-csharp/Chapter%2026%20Thread%20Basics/" rel="bookmark" title="CLR via C# - Chapter 26 Thread Basics">CLR via C# - Chapter 26 Thread Basics</a></li><li><a href="/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations">CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations</a></li><li><a href="/2023/02/08/csharp/clr-via-csharp/Chapter%2028%20IO-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 28 IO-Bound Asynchronous Operations">CLR via C# - Chapter 28 IO-Bound Asynchronous Operations</a></li><li><a href="/2023/02/09/csharp/clr-via-csharp/Chapter%2029%20Primitive%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 29 Primitive Thread Synchronization">CLR via C# - Chapter 29 Primitive Thread Synchronization</a></li><li><a href="/2023/02/10/csharp/clr-via-csharp/Chapter%2030%20Hybrid%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 30 Hybrid Thread Synchronization">CLR via C# - Chapter 30 Hybrid Thread Synchronization</a></li></ul></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sakupinera" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Sakupinera</p><div class="description" itemprop="description">保持你的决心！</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">89</span> <span class="name">posts</span></a></div><div class="item categories"><a href="/categories/"><span class="count">17</span> <span class="name">categories</span></a></div><div class="item tags"><a href="/tags/"><span class="count">8</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nha3VwaW5lcmE=" title="https:&#x2F;&#x2F;github.com&#x2F;sakupinera"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9zYWt1cGluZXJh" title="https:&#x2F;&#x2F;twitter.com&#x2F;sakupinera"><i class="ic i-twitter"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQwNzIyOTA3MQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;407229071"><i class="ic i-cloud-music"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMjIzMDczOTg/c3BtX2lkX2Zyb209MzMzLjEwMDcuMC4w" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;22307398?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li><li class="item"><a href="/games/" rel="section"><i class="ic i-flag"></i>games</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-person"></i>About</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/11/23/csharp/clr-via-csharp/Chapter%2019%20Nullable%20Value%20Types/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CSharp-in-a-Nutshell/" title="In CSharp-in-a-Nutshell">CSharp-in-a-Nutshell</a></div><span><a href="/2022/09/01/csharp/csharp-in-a-nutshell/%E7%AC%AC12%E7%AB%A0%20%E5%AF%B9%E8%B1%A1%E9%94%80%E6%AF%81%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" title="C# in a Nutshell - 第12章 对象销毁与垃圾回收">C# in a Nutshell - 第12章 对象销毁与垃圾回收</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/UnityShader/" title="In UnityShader">UnityShader</a></div><span><a href="/2022/09/19/computer-graphics/unityshader/%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/" title="UnityShader - 渲染流水线">UnityShader - 渲染流水线</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/08/28/linux/learn-linux/Linux%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/" title="LearnLinux - Linux系统简介">LearnLinux - Linux系统简介</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" title="CLR via C# - Chapter 8 Methods">CLR via C# - Chapter 8 Methods</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/10/28/csharp/clr-via-csharp/Chapter%2010%20Properties/" title="CLR via C# - Chapter 10 Properties">CLR via C# - Chapter 10 Properties</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/29/csharp/clr-via-csharp/Chapter%2023%20Assembly%20Loading%20and%20Reflection/" title="CLR via C# - Chapter 23 Assembly Loading and Reflection">CLR via C# - Chapter 23 Assembly Loading and Reflection</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2022/12/17/cpp/cpp-primer/Chapter%209%20Sequential%20Containers/" title="C++ Primer - Chapter 9 Sequential Containers">C++ Primer - Chapter 9 Sequential Containers</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/" title="CLR via C# - Chapter 21 The Managed Heap and Garbage  Collection">CLR via C# - Chapter 21 The Managed Heap and Garbage Collection</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/10/24/csharp/clr-via-csharp/Chapter%207%20Constants%20and%20Fields/" title="CLR via C# - Chapter 7 Constants and Fields">CLR via C# - Chapter 7 Constants and Fields</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/" title="CLR via C# - Chapter 24 Runtime Serialization">CLR via C# - Chapter 24 Runtime Serialization</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Sakupinera @ Hanamai Sora</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="Symbols count total">2.2m words</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="Reading time total">34:05</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/11/25/csharp/clr-via-csharp/Chapter 20 Exceptions and State Management/",favicon:{show:"（●´3｀●）Goooood",hide:"(´Д｀)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/shifuku.model.json"},display:{position:"left",width:250,height:500},mobile:{show:!1},react:{opacity:.9},log:!1})</script></body></html>