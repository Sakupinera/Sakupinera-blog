<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sakupinera" href="http://sakupinera.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sakupinera" href="http://sakupinera.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sakupinera" href="http://sakupinera.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="è¯»ä¹¦ç¬”è®°,C#"><link rel="canonical" href="http://sakupinera.github.io/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/"><title>CLR via C# - Chapter 13 Interfaces - CLR-via-CSharp - CSharp | Hanamai Sora = Sakupinera</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">CLR via C# - Chapter 13 Interfaces</h1><div class="meta"><span class="item" title="Created: 2022-11-04 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2022-11-04T00:00:00+08:00">2022-11-04</time> </span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">Symbols count in article</span> <span>38k</span> <span class="text">words</span> </span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">Reading time</span> <span>34 mins.</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hanamai Sora</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s2.loli.net/2023/03/08/R9PEJQ54o7HMAis.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/6bW8i2mQY4dyzLo.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/XtZcHusj92O56kz.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/qSxQEJk41eog52I.png"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/KFwBz5WDl3HNyXq.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/cNIvjwsl174ibOo.png"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/" itemprop="item" rel="index" title="In CSharp"><span itemprop="name">CSharp</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/CLR-via-CSharp/" itemprop="item" rel="index" title="In CLR-via-CSharp"><span itemprop="name">CLR-via-CSharp</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://sakupinera.github.io/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Sakupinera"><meta itemprop="description" content=", ä¿æŒä½ çš„å†³å¿ƒï¼"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakupinera"></span><div class="body md" itemprop="articleBody"><h1 id="chapter-13-interfaces"><a class="anchor" href="#chapter-13-interfaces">#</a> Chapter 13 Interfaces</h1><h2 id="class-and-interface-inheritance"><a class="anchor" href="#class-and-interface-inheritance">#</a> Class and Interface Inheritance</h2><blockquote><p>In the Microsoft .NET Framework, there is a class called <code>System.Object</code> that defines four public instance methods: <code>ToString</code> , <code>Equals</code> , <code>GetHashCode</code> , and <code>GetType</code> . This class is the root or ultimate base class of all other classesâ€”all classes will inherit Objectâ€™s four instance methods. This also means that code written to operate on an instance of the Object class can actually perform operations on an instance of any class.</p></blockquote><blockquote><p>Because someone at Microsoft has implemented Objectâ€™s methods, any class derived from Object is actually inheriting the following:</p><ul><li><p>The method signatures This allows code to think that it is operating on an instance of the Object class, when in fact, it could be operating on an instance of some other class.</p></li><li><p>The implementation of these methods This allows the developer defining a class derived from Object not to be required to manually implement Objectâ€™s methods.</p></li></ul></blockquote><blockquote><p>In the CLR, a class is always derived from one and only one class (that must ultimately be derived from Object). This base class provides a set of method signatures and implementations for these methods. And a cool thing about defining a new class is that it can become the base class for another class defined in the future by some other developerâ€”all of the method signatures and their implementations will be inherited by the new derived class.</p></blockquote><blockquote><p>The CLR also allows developers to define an interface, which is really just a way to give a name to a set of method signatures. These methods do not come with any implementation at all. A class inherits an interface by specifying the interfaceâ€™s name, and the class must explicitly provide implementations of the interfaceâ€™s methods before the CLR will consider the type definition to be valid. Of course, implementing interface methods can be tedious, which is why I referred to interface inheritance as a scaled-down mechanism to achieve multiple inheritance. The C# compiler and the CLR actually allow a class to inherit several interfaces, and of course, the class must provide implementations for all of the inherited interface methods.</p></blockquote><blockquote><p>One of the great features of class inheritance is that it allows instances of a derived type to be substituted in all contexts that expect instances of a base type. Similarly, interface inheritance allows instances of a type that implements the interface to be substituted in all contexts that expect instances of the named interface type. We will now look at how to define interfaces to make our discussion more concrete.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šCLR ä¸æ”¯æŒå¤šç»§æ‰¿ï¼ˆå› æ­¤æ‰€æœ‰æ‰˜ç®¡ç¼–ç¨‹è¯­è¨€ä¹Ÿæ”¯æŒä¸äº†ï¼‰ã€‚CLR åªæ˜¯é€šè¿‡æ¥å£æä¾›äº† â€œç¼©æ°´ç‰ˆâ€ çš„å¤šç»§æ‰¿ã€‚ç”±äº Microsoft çš„å¼€å‘å›¢é˜Ÿå·²å®ç°äº† Object çš„æ–¹æ³•ï¼Œæ‰€ä»¥ä» Object æ´¾ç”Ÿçš„ä»»ä½•ç±»å®é™…éƒ½ç»§æ‰¿äº† Object çš„æ–¹æ³•ç­¾åå’Œæ–¹æ³•å®ç°ã€‚é™¤äº†åŸºç±»ï¼ŒCLR è¿˜å…è®¸å¼€å‘äººå‘˜å®šä¹‰æ¥å£ï¼Œå®ƒå®é™…åªæ˜¯å¯¹ä¸€ç»„æ–¹æ³•ç­¾åè¿›è¡Œäº†ç»Ÿä¸€å‘½åã€‚è¿™äº›æ–¹æ³•ä¸æä¾›ä»»ä½•å®ç°ã€‚ç±»é€šè¿‡æŒ‡å®šæ¥å£åç§°æ¥ç»§æ‰¿æ¥å£ï¼Œè€Œä¸”å¿…é¡»æ˜¾å¼å®ç°æ¥å£æ–¹æ³•ï¼Œå¦åˆ™ CLR ä¼šè®¤ä¸ºæ­¤ç±»å‹å®šä¹‰æ— æ•ˆã€‚C# ç¼–è¯‘å™¨å’Œ CLR å…è®¸ä¸€ä¸ªç±»ç»§æ‰¿å¤šä¸ªæ¥å£ã€‚å½“ç„¶ï¼Œç»§æ‰¿çš„æ‰€æœ‰æ¥å£æ–¹æ³•éƒ½å¿…é¡»å®ç°ã€‚</p><h2 id="defining-an-interface"><a class="anchor" href="#defining-an-interface">#</a> Defining an Interface</h2><blockquote><p>As mentioned in the previous section, an interface is a named set of method signatures. Note that interfaces can also define events, parameterless properties, and parameterful properties (indexers in C#) because all of these are just syntax shorthands that map to methods anyway, as shown in previous chapters. However, an interface cannot define any constructor methods. In addition, an interface is not allowed to define any instance fields.</p></blockquote><blockquote><p>Although the CLR does allow an interface to define static methods, static fields, constants, and static constructors, a Common Language Specification (CLS)â€“compliant interface must not have any of these static members because some programming languages arenâ€™t able to define or access them. In fact, C# prevents an interface from defining any of these static members.</p></blockquote><blockquote><p>In C#, you use the interface keyword to define an interface, giving it a name and its set of instance method signatures. Here are the definitions of a few interfaces defined in the Framework Class Library (FCL).</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IDisposable</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IEnumerable</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token return-type class-name">IEnumerator</span> <span class="token function">GetEnumerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span><span class="token keyword">out</span> T<span class="token punctuation">></span></span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IEnumerable</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">new</span> <span class="token return-type class-name">IEnumerator<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token function">GetEnumerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ICollection<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span><span class="token punctuation">,</span> <span class="token class-name">IEnumerable</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token class-name">T</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token return-type class-name">Boolean</span> <span class="token function">Contains</span><span class="token punctuation">(</span><span class="token class-name">T</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">CopyTo</span><span class="token punctuation">(</span><span class="token class-name">T<span class="token punctuation">[</span><span class="token punctuation">]</span></span> array<span class="token punctuation">,</span> <span class="token class-name">Int32</span> arrayIndex<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token return-type class-name">Boolean</span> <span class="token function">Remove</span><span class="token punctuation">(</span><span class="token class-name">T</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token return-type class-name">Int32</span> Count <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// Read-only property </span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token return-type class-name">Boolean</span> IsReadOnly <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// Read-only property </span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>To the CLR, an interface definition is just like a type definition. That is, the CLR will define an internal data structure for the interface type object, and reflection can be used to query features of the interface type. Like types, an interface can be defined at file scope or defined nested within another type. When defining the interface type, you can specify whatever visibility/accessibility (public, protected, internal, etc.) you want.</p></blockquote><blockquote><p>By convention, interface type names are prefixed with an uppercase I, making it easy to spot an interface type in source code. The CLR does support generic interfaces (as you can see from some of the previous examples) as well as generic methods in an interface. I will discuss some of the many features offered by generic interfaces later in this chapter and in Chapter 12, â€œGenerics,â€ in which I cover generics more broadly.</p></blockquote><blockquote><p>An interface definition can â€œinheritâ€ other interfaces. However, I use the word inherit here rather loosely because interface inheritance doesnâ€™t work exactly like class inheritance. I prefer to think of interface inheritance as including the contract of other interfaces. For example, the <code>ICollection</code> interface definition includes the contracts of the <code>IEnumerable</code> and <code>IEnumerable</code> interfaces.</p></blockquote><blockquote><p>This means that:</p><ul><li><p>Any class that inherits the <code>ICollection</code> interface must implement all of the methods defined by the <code>ICollection</code> , <code>IEnumerable</code> , and <code>IEnumerable</code> interfaces.</p></li><li><p>Any code that expects an object whose type implements the <code>ICollection</code> interface can assume that the objectâ€™s type also implements the methods of the <code>IEnumerable</code> and <code>IEnumerable</code> interfaces.</p></li></ul></blockquote><p>ğŸ’¡å°ç»“ï¼šé™¤äº†å®šä¹‰æ–¹æ³•ä¹‹å¤–ï¼Œæ¥å£è¿˜èƒ½å®šä¹‰äº‹ä»¶ã€æ— å‚å±æ€§å’Œæœ‰å‚å±æ€§ï¼ˆC# çš„ç´¢å¼•å™¨ï¼‰ã€‚å¦‚å‰æ‰€è¿°ï¼Œæ‰€æœ‰è¿™äº›ä¸œè¥¿æœ¬è´¨ä¸Šéƒ½æ˜¯æ–¹æ³•ï¼Œå®ƒä»¬åªæ˜¯è¯­æ³•ä¸Šçš„ç®€åŒ–ã€‚ä¸è¿‡ï¼Œæ¥å£ä¸èƒ½å®šä¹‰ä»»ä½•æ„é€ å™¨æ–¹æ³•ï¼Œä¹Ÿä¸èƒ½å®šä¹‰ä»»ä½•å®ä¾‹å­—æ®µã€‚è™½ç„¶ CLR å…è®¸æ¥å£å®šä¹‰é™æ€æ–¹æ³•ã€é™æ€å­—æ®µã€å¸¸é‡å’Œé™æ€æ„é€ å™¨ï¼Œä½†ç¬¦åˆ CLS æ ‡å‡†çš„æ¥å£ç»ä¸å…è®¸ï¼Œå› ä¸ºæœ‰çš„ç¼–ç¨‹è¯­è¨€ä¸èƒ½å®šä¹‰æˆ–è®¿é—®å®ƒä»¬ã€‚äº‹å®ä¸Šï¼ŒC# ç¦æ­¢æ¥å£å®šä¹‰ä»»ä½•ä¸€ç§è¿™æ ·çš„é™æ€æˆå‘˜ã€‚C# ç”¨ interface å…³é”®å­—å®šä¹‰æ¥å£ã€‚è¦ä¸ºæ¥å£æŒ‡å®šåç§°å’Œä¸€ç»„å®ä¾‹æ–¹æ³•ç­¾åã€‚åœ¨ CLR çœ‹æ¥ï¼Œæ¥å£å®šä¹‰å°±æ˜¯ç±»å‹å®šä¹‰ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼ŒCLR ä¼šä¸ºæ¥å£ç±»å‹å¯¹è±¡å®šä¹‰å†…éƒ¨æ•°æ®ç»“æ„ï¼ŒåŒæ—¶å¯é€šè¿‡åå°„æœºåˆ¶æ¥æŸ¥è¯¢æ¥å£ç±»å‹çš„åŠŸèƒ½ã€‚å’Œç±»å‹ä¸€æ ·ï¼Œæ¥å£å¯åœ¨æ–‡ä»¶èŒƒå›´ä¸­å®šä¹‰ï¼Œä¹Ÿå¯åµŒå¥—åœ¨å¦ä¸€ä¸ªç±»å‹ä¸­ã€‚å®šä¹‰æ¥å£ç±»å‹æ—¶ï¼Œå¯æŒ‡å®šä½ å¸Œæœ›çš„ä»»ä½•å¯è§æ€§ / å¯è®¿é—®æ€§ï¼ˆpublicï¼Œprotectedï¼Œinternal ç­‰ï¼‰ã€‚æ¥å£å¯ä»¥å°†å…¶ä»–æ¥å£çš„åå®šï¼ˆcontractï¼‰åŒ…æ‹¬åˆ°æ–°æ¥å£ä¸­ã€‚ä¾‹å¦‚ï¼Œ <code>ICollection&lt;T&gt;</code> æ¥å£å®šä¹‰å°±åŒ…å«äº† <code>IEnumerable&lt;T&gt;</code> å’Œ <code>IEnumerable</code> ä¸¤ä¸ªæ¥å£çš„åå®šã€‚</p><h2 id="inheriting-an-interface"><a class="anchor" href="#inheriting-an-interface">#</a> Inheriting an Interface</h2><blockquote><p>In this section, Iâ€™ll show how to define a type that implements an interface, and then Iâ€™ll show how to create an instance of this type and use the object to call the interfaceâ€™s methods. C# actually makes this pretty simple, but what happens behind the scenes is a bit more complicated. Iâ€™ll explain what is happening behind the scenes later in this chapter.</p></blockquote><blockquote><p>The <code>System.IComparable</code> interface is defined (in MSCorLib.dll) as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IComparable<span class="token punctuation">&lt;</span><span class="token keyword">in</span> T<span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token return-type class-name">Int32</span> <span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token class-name">T</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The following code shows how to define a type that implements this interface and also shows code that compares two Point objects.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// Point is derived from System.Object and implements IComparable&lt;T> for Point. </span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IComparable<span class="token punctuation">&lt;</span>Point<span class="token punctuation">></span></span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_x<span class="token punctuation">,</span> m_y<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> x<span class="token punctuation">,</span> <span class="token class-name">Int32</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> m_x <span class="token operator">=</span> x<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> m_y <span class="token operator">=</span> y<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// This method implements IComparable&lt;T>.CompareTo() for Point </span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token class-name">Point</span> other<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">Sign</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">Sqrt</span><span class="token punctuation">(</span>m_x <span class="token operator">*</span> m_x <span class="token operator">+</span> m_y <span class="token operator">*</span> m_y<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token operator">-</span> Math<span class="token punctuation">.</span><span class="token function">Sqrt</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>m_x <span class="token operator">*</span> other<span class="token punctuation">.</span>m_x <span class="token operator">+</span> other<span class="token punctuation">.</span>m_y <span class="token operator">*</span> other<span class="token punctuation">.</span>m_y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name">String</span> <span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token keyword">return</span> String<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"(&#123;0&#125;, &#123;1&#125;)"</span><span class="token punctuation">,</span> m_x<span class="token punctuation">,</span> m_y<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token class-name">Point<span class="token punctuation">[</span><span class="token punctuation">]</span></span> points <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Point<span class="token punctuation">[</span><span class="token punctuation">]</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Point</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Point</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token comment">// Here is a call to Point's IComparable&lt;T> CompareTo method </span></pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>points<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>points<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token class-name">Point</span> tempPoint <span class="token operator">=</span> points<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="27"></td><td><pre> points<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> points<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="28"></td><td><pre> points<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tempPoint<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="29"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="30"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Points from closest to (0, 0) to farthest:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="31"></td><td><pre> <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name">Point</span> p <span class="token keyword">in</span> points<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="32"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="33"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The C# compiler requires that a method that implements an interface be marked as public. The CLR requires that interface methods be marked as virtual. If you do not explicitly mark the method as virtual in your source code, the compiler marks the method as virtual and sealed; this prevents a derived class from overriding the interface method. If you explicitly mark the method as virtual, the compiler marks the method as virtual (and leaves it unsealed); this allows a derived class to override the interface method.</p></blockquote><blockquote><p>If an interface method is sealed, a derived class cannot override the method. However, a derived class can re-inherit the same interface and can provide its own implementation for the interfaceâ€™s methods. When calling an interfaceâ€™s method on an object, the implementation associated with the objectâ€™s type is called. Here is an example that demonstrates this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">/************************* First Example *************************/</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token class-name">Base</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// Calls Dispose by using b's type: "Base's Dispose" </span></pre></td></tr><tr><td data-num="8"></td><td><pre> b<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// Calls Dispose by using b's object's type: "Base's Dispose" </span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">(</span><span class="token punctuation">(</span>IDisposable<span class="token punctuation">)</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">/************************* Second Example ************************/</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token class-name">Derived</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token comment">// Calls Dispose by using d's type: "Derived's Dispose" </span></pre></td></tr><tr><td data-num="15"></td><td><pre> d<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token comment">// Calls Dispose by using d's object's type: "Derived's Dispose" </span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token punctuation">(</span><span class="token punctuation">(</span>IDisposable<span class="token punctuation">)</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token comment">/************************* Third Example *************************/</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token comment">// Calls Dispose by using b's type: "Base's Dispose" </span></pre></td></tr><tr><td data-num="21"></td><td><pre> b<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token comment">// Calls Dispose by using b's object's type: "Derived's Dispose" </span></pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token punctuation">(</span><span class="token punctuation">(</span>IDisposable<span class="token punctuation">)</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token comment">// This class is derived from Object and it implements IDisposable </span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IDisposable</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="28"></td><td><pre> <span class="token comment">// This method is implicitly sealed and cannot be overridden </span></pre></td></tr><tr><td data-num="29"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="30"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Base's Dispose"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="31"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token comment">// This class is derived from Base and it re-implements IDisposable </span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Base</span><span class="token punctuation">,</span> <span class="token class-name">IDisposable</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="35"></td><td><pre> <span class="token comment">// This method cannot override Base's Dispose. 'new' is used to indicate </span></pre></td></tr><tr><td data-num="36"></td><td><pre> <span class="token comment">// that this method re-implements IDisposable's Dispose method </span></pre></td></tr><tr><td data-num="37"></td><td><pre> <span class="token keyword">new</span> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="38"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Derived's Dispose"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="39"></td><td><pre> <span class="token comment">// NOTE: The next line shows how to call a base class's implementation (if desired) </span></pre></td></tr><tr><td data-num="40"></td><td><pre> <span class="token comment">// base.Dispose(); </span></pre></td></tr><tr><td data-num="41"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="42"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>ğŸ’¡å°ç»“ï¼šC# ç¼–è¯‘å™¨è¦æ±‚å°†å®ç°æ¥å£çš„æ–¹æ³•ï¼ˆåæ–‡ç®€ç§°ä¸º â€œæ¥å£æ–¹æ³•â€ï¼‰æ ‡è®°ä¸º publicã€‚CLR è¦æ±‚å°†æ¥å£æ–¹æ³•æ ‡è®°ä¸º virtualã€‚ä¸å°†æ–¹æ³•æ˜¾å¼æ ‡è®°ä¸º virtualï¼Œç¼–è¯‘å™¨ä¼šå°†å®ƒä»¬æ ‡è®°ä¸º virtual å’Œ sealedï¼›è¿™ä¼šé˜»æ­¢æ´¾ç”Ÿç±»é‡å†™æ¥å£æ–¹æ³•ã€‚å°†æ–¹æ³•æ˜¾å¼æ ‡è®°ä¸º virtualï¼Œç¼–è¯‘å™¨å°±ä¼šå°†è¯¥æ–¹æ³•æ ‡è®°ä¸º virtualï¼ˆå¹¶ä¿æŒå®ƒçš„éå¯†å°çŠ¶æ€ï¼‰ï¼Œä½¿æ´¾ç”Ÿç±»èƒ½é‡å†™å®ƒã€‚æ´¾ç”Ÿç±»ä¸èƒ½é‡å†™ sealed çš„æ¥å£æ–¹æ³•ã€‚ä½†æ´¾ç”Ÿç±»å¯é‡æ–°ç»§æ‰¿åŒä¸€ä¸ªæ¥å£ï¼Œå¹¶ä¸ºæ¥å£æ–¹æ³•æä¾›è‡ªå·±çš„å®ç°ã€‚åœ¨å¯¹è±¡ä¸Šè°ƒç”¨æ¥å£æ–¹æ³•æ—¶ï¼Œè°ƒç”¨çš„æ˜¯è¯¥æ–¹æ³•åœ¨è¯¥å¯¹è±¡çš„ç±»å‹ä¸­çš„å®ç°ã€‚</p><h2 id="more-about-calling-interface-methods"><a class="anchor" href="#more-about-calling-interface-methods">#</a> More About Calling Interface Methods</h2><blockquote><p>The FCLâ€™s <code>System.String</code> type inherits <code>System.Object</code> â€™s method signatures and their implementations. In addition, the String type also implements several interfaces: <code>IComparable</code> , <code>ICloneable</code> , <code>IConvertible</code> , <code>IEnumerable</code> , <code>IComparable</code> , <code>IEnumerable</code> , and <code>IEquatable</code> . This means that the String type isnâ€™t required to implement (or override) the methods its Object base type offers. However, the String type must implement the methods declared in all of the interfaces.</p></blockquote><blockquote><p>The CLR allows you to define field, parameter, or local variables that are of an interface type. Using a variable of an interface type allows you to call methods defined by that interface. In addition, the CLR will allow you to call methods defined by Object because all classes inherit Objectâ€™s methods. The following code demonstrates this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// The s variable refers to a String object. </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"Jeffrey"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// Using s, I can call any method defined in </span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// String, Object, IComparable, ICloneable, IConvertible, IEnumerable, etc. </span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// The cloneable variable refers to the same String object </span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token class-name">ICloneable</span> cloneable <span class="token operator">=</span> s<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// Using cloneable, I can call any method declared by the </span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// ICloneable interface (or any method defined by Object) only. </span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// The comparable variable refers to the same String object </span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token class-name">IComparable</span> comparable <span class="token operator">=</span> s<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">// Using comparable, I can call any method declared by the </span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment">// IComparable interface (or any method defined by Object) only. </span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment">// The enumerable variable refers to the same String object </span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token comment">// At run time, you can cast a variable from one interface to another as </span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">// long as the object's type implements both interfaces. </span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token class-name">IEnumerable</span> enumerable <span class="token operator">=</span> <span class="token punctuation">(</span>IEnumerable<span class="token punctuation">)</span> comparable<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token comment">// Using enumerable, I can call any method declared by the </span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token comment">// IEnumerable interface (or any method defined by Object) only.</span></pre></td></tr></table></figure><blockquote><p>In this code, all of the variables refer to the same â€œJeffreyâ€ String object that is in the managed heap, and therefore, any method that I call while using any of these variables applies to the one â€œJeffreyâ€ String object. However, the type of the variable indicates the action that I can perform on the object. The s variable is of type String, and therefore, I can use s to call any members defined by the String type (such as the Length property). I can also use the variable s to call any methods inherited from Object (such as <code>GetType</code> ).</p></blockquote><blockquote><p>The cloneable variable is of the <code>ICloneable</code> interface type, and therefore, using the cloneable variable, I can call the Clone method defined by this interface. In addition, I can call any method defined by Object (such as <code>GetType</code> ) because the CLR knows that all types derive from Object. However, using the cloneable variable, I cannot call public methods defined by String itself or any methods defined by any other interface that String implements. Similarly, using the comparable variable, I can call <code>CompareTo</code> or any method defined by Object, but no other methods are callable using this variable.</p></blockquote><p>ğŸ’¡é‡è¦æç¤ºï¼šå’Œå¼•ç”¨ç±»å‹ç›¸ä¼¼ï¼Œå€¼ç±»å‹å¯å®ç°é›¶ä¸ªæˆ–å¤šä¸ªæ¥å£ã€‚ä½†å€¼ç±»å‹çš„å®ä¾‹åœ¨è½¬æ¢ä¸ºæ¥å£ç±»å‹æ—¶å¿…é¡»è£…ç®±ã€‚è¿™æ˜¯ç”±äºæ¥å£å˜é‡æ˜¯å¼•ç”¨ï¼Œå¿…é¡»æŒ‡å‘å †ä¸Šçš„å¯¹è±¡ï¼Œä½¿ CLR èƒ½æ£€æŸ¥å¯¹è±¡çš„ç±»å‹å¯¹è±¡çš„ç±»å‹å¯¹è±¡æŒ‡é’ˆï¼Œä»è€Œåˆ¤æ–­å¯¹è±¡çš„ç¡®åˆ‡ç±»å‹ã€‚è°ƒç”¨å·²è£…ç®±å€¼ç±»å‹çš„æ¥å£æ–¹æ³•æ—¶ï¼ŒCLR ä¼šè·Ÿéšå¯¹è±¡çš„ç±»å‹å¯¹è±¡æŒ‡é’ˆæ‰¾åˆ°ç±»å‹å¯¹è±¡çš„æ–¹æ³•è¡¨ï¼Œä»è€Œè°ƒç”¨æ­£ç¡®çš„æ–¹æ³•ã€‚</p><p>ğŸ’¡å°ç»“ï¼šCLR å…è®¸å®šä¹‰æ¥å£ç±»å‹çš„å­—æ®µã€å‚æ•°æˆ–å±€éƒ¨å˜é‡ã€‚ä½¿ç”¨æ¥å£ç±»å‹çš„å˜é‡å¯ä»¥è°ƒç”¨è¯¥æ¥å£å®šä¹‰çš„æ–¹æ³•ã€‚æ­¤å¤–ï¼ŒCLR å…è®¸è°ƒç”¨ Object å®šä¹‰çš„æ–¹æ³•ï¼Œå› ä¸ºæ‰€æœ‰ç±»éƒ½ç»§æ‰¿äº† Object çš„æ–¹æ³•ã€‚</p><h2 id="implicit-and-explicit-interface-method-implementations-whats-happening-behind-the-scenes"><a class="anchor" href="#implicit-and-explicit-interface-method-implementations-whats-happening-behind-the-scenes">#</a> Implicit and Explicit Interface Method Implementations (Whatâ€™s Happening Behind the Scenes)</h2><blockquote><p>When a type is loaded into the CLR, a method table is created and initialized for the type (as discussed in Chapter 1, â€œThe CLRâ€™s Execution Modelâ€). This method table contains one entry for every new method introduced by the type as well as entries for any virtual methods inherited by the type. Inherited virtual methods include methods defined by the base types in the inheritance hierarchy as well as any methods defined by the interface types. So if you have a simple type defined like this:</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SimpleType</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IDisposable</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Dispose"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>the typeâ€™s method table contains entries for the following:</p><ul><li><p>All the virtual instance methods defined by Object, the implicitly inherited base class.</p></li><li><p>All the interface methods defined by <code>IDisposable</code> , the inherited interface. In this example, there is only one method, Dispose, because the <code>IDisposable</code> interface defines just one method.</p></li><li><p>The new method, Dispose, introduced by <code>SimpleType</code> .</p></li></ul></blockquote><blockquote><p>To make things simple for the programmer, the C# compiler assumes that the Dispose method introduced by <code>SimpleType</code> is the implementation for <code>IDisposable</code> â€™s Dispose method. The C# compiler makes this assumption because the method is public, and the signatures of the interface method and the newly introduced method are identical. That is, the methods have the same parameter and return types. By the way, if the new Dispose method were marked as virtual, the C# compiler would still consider this method to be a match for the interface method.</p></blockquote><blockquote><p>When the C# compiler matches a new method to an interface method, it emits metadata indicating that both entries in <code>SimpleType</code> â€™s method table should refer to the same implementation. To help make this clearer, here is some code that demonstrates how to call the classâ€™s public Dispose method as well as how to call the classâ€™s implementation of <code>IDisposable</code> â€™s Dispose method.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">SimpleType</span> st <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SimpleType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// This calls the public Dispose method implementation </span></pre></td></tr><tr><td data-num="5"></td><td><pre> st<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// This calls IDisposable's Dispose method implementation </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token class-name">IDisposable</span> d <span class="token operator">=</span> st<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> d<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In the first call to Dispose, the Dispose method defined by SimpleType is called. Then I define a variable, d, which is of the IDisposable interface type. I initialize the d variable to refer to the SimpleType object. Now when I call d.Dispose(), I am calling the IDisposable interfaceâ€™s Dispose method. Because C# requires the public Dispose method to also be the implementation for IDisposableâ€™s Dispose method, the same code will execute, and, in this example, you canâ€™t see any observable difference. The output is as follows.</p></blockquote><pre><code>Dispose 
Dispose
</code></pre><blockquote><p>Now, let me rewrite the preceding SimpleType so that you can see an observable difference.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SimpleType</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IDisposable</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"public Dispose"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token return-type class-name"><span class="token keyword">void</span></span> IDisposable<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"IDisposable Dispose"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Without changing the Main method shown earlier, if we just recompile and rerun the program, the output will be the following.</p></blockquote><pre><code>public Dispose 
IDisposable Dispose
</code></pre><blockquote><p>In C#, when you prefix the name of a method with the name of the interface that defines the method (IDisposable.Dispose as in this example), you are creating an explicit interface method implementation (EIMI). Note that when you define an explicit interface method in C#, you are not allowed to specify any accessibility (such as public or private). However, when the compiler generates the metadata for the method, its accessibility is set to private, preventing any code using an instance of the class from simply calling the interface method. The only way to call the interface method is through a variable of the interfaceâ€™s type.</p></blockquote><blockquote><p>Also note that an EIMI method cannot be marked as virtual and therefore cannot be overridden. This is because the EIMI method is not really part of the typeâ€™s object model; itâ€™s a way of attaching an interface (set of behaviors or methods) onto a type without making the behaviors/methods obvious. If all of this seems a bit kludgy to you, you are understanding it correctlyâ€”this is all a bit kludgy. Later in this chapter, Iâ€™ll show some valid reasons for using EIMIs.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šç±»å‹åŠ è½½åˆ° CLR ä¸­æ—¶ï¼Œä¼šä¸ºè¯¥ç±»å‹åˆ›å»ºå¹¶åˆå§‹åŒ–ä¸€ä¸ªæ–¹æ³•è¡¨ã€‚åœ¨è¿™ä¸ªæ–¹æ³•è¡¨ä¸­ï¼Œç±»å‹å¼•å…¥çš„æ¯ä¸ªæ–°æ–¹æ³•éƒ½æœ‰å¯¹åº”çš„è®°å½•é¡¹ï¼›å¦å¤–ï¼Œè¿˜ä¸ºè¯¥ç±»å‹ç»§æ‰¿çš„æ‰€æœ‰è™šæ–¹æ³•æ·»åŠ äº†è®°å½•é¡¹ã€‚è®°å½•çš„è™šæ–¹æ³•æ—¢æœ‰ç»§æ‰¿å±‚æ¬¡ç»“æ„ä¸­çš„å„ä¸ªåŸºç±»å‹å®šä¹‰çš„ï¼Œä¹Ÿæœ‰æ¥å£ç±»å‹å®šä¹‰çš„ã€‚åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬åœ¨ <code>SimpleType</code> ä¸­å®šä¹‰äº† <code>Dispose</code> æ–¹æ³•ï¼Œä¸ºç®€åŒ–ç¼–ç¨‹ï¼ŒC# ç¼–è¯‘å™¨å‡å®š <code>SimpleType</code> å¼•å…¥çš„ <code>Dispose</code> æ–¹æ³•æ˜¯å¯¹ <code>IDisposable</code> çš„ <code>Dispose</code> æ–¹æ³•çš„å®ç°ã€‚ä¹‹æ‰€ä»¥è¿™æ ·å‡å®šï¼Œæ˜¯ç”±äº <code>Dispose</code> æ–¹æ³•çš„å¯è®¿é—®æ€§æ˜¯ publicï¼Œè€Œæ¥å£æ–¹æ³•çš„ç­¾åå’Œæ–°å¼•å…¥çš„æ–¹æ³•å®Œå…¨ä¸€è‡´ã€‚å¦‚æœæ–°çš„ <code>Dispose</code> æ–¹æ³•è¢«æ ‡è®°ä¸º virtualï¼ŒC# ç¼–è¯‘å™¨ä»ç„¶è®¤ä¸ºè¯¥æ–¹æ³•åŒ¹é…æ¥å£æ–¹æ³•ã€‚C# ç¼–è¯‘å™¨å°†æ–°æ–¹æ³•å’Œæ¥å£æ–¹æ³•åŒ¹é…èµ·æ¥ä¹‹åï¼Œä¼šç”Ÿæˆå…ƒæ•°æ®ï¼ŒæŒ‡æ˜ <code>SimpleType</code> ç±»å‹çš„æ–¹æ³•è¡¨ä¸­çš„ä¸¤ä¸ªè®°å½•é¡¹åº”å¼•ç”¨åŒä¸€ä¸ªå®ç°ã€‚ç”±äº C# è¦æ±‚å…¬å…± <code>Dispose</code> æ–¹æ³•åŒæ—¶æ˜¯ <code>IDisposable</code> çš„ <code>Dispose</code> æ–¹æ³•çš„å®ç°ï¼Œæ‰€ä»¥ä¼šæ‰§è¡Œç›¸åŒçš„ä»£ç ã€‚åœ¨ C# ä¸­ï¼Œå°†å®šä¹‰æ–¹æ³•çš„é‚£ä¸ªæ¥å£çš„åç§°ä½œä¸ºä½œä¸ºæ–¹æ³•åå‰ç¼€ï¼ˆä¾‹å¦‚ <code>IDisposable.Dispose</code> ï¼‰ï¼Œå°±ä¼šåˆ›å»ºæ˜¾å¼æ¥å£æ–¹æ³•å®ç°ï¼ˆExplicit Interface Method Implementationï¼ŒEIMIï¼‰ã€‚æ³¨æ„ï¼ŒC# ä¸­ä¸å…è®¸åœ¨å®šä¹‰æ˜¾å¼æ¥å£æ–¹æ³•æ—¶æŒ‡å®šå¯è®¿é—®æ€§ï¼ˆæ¯”å¦‚ public æˆ– privateï¼‰ã€‚ä½†æ˜¯ï¼Œç¼–è¯‘å™¨ç”Ÿæˆæ–¹æ³•çš„å…ƒæ•°æ®æ—¶ï¼Œå¯è®¿é—®è¡Œä¼šè‡ªåŠ¨è®¾ä¸º privateï¼Œé˜²æ­¢å…¶ä»–ä»£ç åœ¨ä½¿ç”¨ç±»çš„å®ä¾‹æ—¶ç›´æ¥è°ƒç”¨æ¥å£æ–¹æ³•ã€‚åªæœ‰é€šè¿‡æ¥å£ç±»å‹çš„å˜é‡æ‰èƒ½è°ƒç”¨æ¥å£æ–¹æ³•ã€‚è¿˜è¦æ³¨æ„ï¼ŒEIMI æ–¹æ³•ä¸èƒ½æ ‡è®°ä¸º virtualï¼Œæ‰€ä»¥ä¸èƒ½è¢«é‡å†™ã€‚è¿™æ˜¯ç”±äº EIMI æ–¹æ³•å¹¶éçœŸçš„æ˜¯ç±»å‹çš„å¯¹è±¡æ¨¡å‹çš„ä¸€éƒ¨åˆ†ï¼Œå®ƒåªæ˜¯å°†æ¥å£ï¼ˆä¸€ç»„è¡Œä¸ºæˆ–æ–¹æ³•ï¼‰å’Œç±»å‹è”ç³»èµ·æ¥ï¼ŒåŒæ—¶é¿å…å…¬å¼€è¡Œä¸º / æ–¹æ³•ã€‚</p><h2 id="generic-interfaces"><a class="anchor" href="#generic-interfaces">#</a> Generic Interfaces</h2><blockquote><p>C#â€™s and the CLRâ€™s support of generic interfaces offers many great features for developers. In this section, Iâ€™d like to discuss the benefits offered when using generic interfaces.</p></blockquote><blockquote><p>First, generic interfaces offer great compile-time type safety. Some interfaces (such as the nongeneric IComparable interface) define methods that have Object parameters or return types. When code calls these interface methods, a reference to an instance of any type can be passed. But this is usually not desired. The following code demonstrates.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SomeMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">IComparable</span> c <span class="token operator">=</span> x<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// CompareTo expects an Object; passing y (an Int32) is OK </span></pre></td></tr><tr><td data-num="5"></td><td><pre> c<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// y is boxed here </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// CompareTo expects an Object; passing "2" (a String) compiles </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// but an ArgumentException is thrown at runtime </span></pre></td></tr><tr><td data-num="8"></td><td><pre> c<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Obviously, it is preferable to have the interface method strongly typed, and this is why the FCL includes a generic IComparable interface.</p></blockquote><blockquote><p>Here is the new version of the code revised by using the generic interface.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SomeMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">IComparable<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">></span></span> c <span class="token operator">=</span> x<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// CompareTo expects an Int32; passing y (an Int32) is OK </span></pre></td></tr><tr><td data-num="5"></td><td><pre> c<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// y is not boxed here </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// CompareTo expects an Int32; passing "2" (a String) results </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// in a compiler error indicating that String cannot be cast to an Int32 </span></pre></td></tr><tr><td data-num="8"></td><td><pre> c<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The second benefit of generic interfaces is that much less boxing will occur when working with value types. Notice in SomeMethod1 that the non-generic IComparable interfaceâ€™s CompareTo method expects an Object; passing y (an Int32 value type) causes the value in y to be boxed. However, in SomeMethod2, the generic IComparable interfaceâ€™s CompareTo method expects an Int32; passing y causes it to be passed by value, and no boxing is necessary.</p></blockquote><p>ğŸ’¡æ³¨æ„ FCL å®šä¹‰äº† <code>IComparable</code> ï¼Œ <code>ICollection</code> ï¼Œ <code>IList</code> å’Œ <code>IDictionary</code> ç­‰æ¥å£çš„æ³›å‹å’Œéæ³›å‹ç‰ˆæœ¬ã€‚å®šä¹‰ç±»å‹æ—¶è¦å®ç°å…¶ä¸­ä»»ä½•æ¥å£ï¼Œä¸€èˆ¬åº”å®ç°æ³›å‹ç‰ˆæœ¬ã€‚FCL ä¿ç•™éæ³›å‹ç‰ˆæœ¬æ˜¯ä¸ºäº†å‘åå…¼å®¹ï¼Œç…§é¡¾åœ¨ .NET Framework æ”¯æŒæ³›å‹ä¹‹å‰å†™çš„ä»£ç ã€‚éæ³›å‹ç‰ˆæœ¬è¿˜å…è®¸ç”¨æˆ·ä»¥è¾ƒå¸¸è§„çš„ã€ç±»å‹è¾ƒä¸å®‰å…¨ (more general,less type-safe) çš„æ–¹å¼å¤„ç†æ•°æ®ã€‚</p><p>æœ‰çš„æ³›å‹æ¥å£ç»§æ‰¿äº†éæ³›å‹ç‰ˆæœ¬ï¼Œæ‰€ä»¥å¿…é¡»åŒæ—¶å®ç°æ¥å£çš„æ³›å‹å’Œéæ³›å‹ç‰ˆæœ¬ã€‚ä¾‹å¦‚ï¼Œæ³›å‹ <code>IEnumerable&lt;out T&gt;</code> æ¥å£ç»§æ‰¿äº†éæ³›å‹ <code>IEnumerable</code> æ¥å£ï¼Œæ‰€ä»¥å®ç° <code>IEnumerable&lt;out T&gt;</code> å°±å¿…é¡»å®ç° <code>IEnumerable</code> ã€‚</p><p>å’Œå…¶ä»–ä»£ç é›†æˆæ—¶ï¼Œæœ‰æ—¶å¿…é¡»å®ç°éæ³›å‹æ¥å£ï¼Œå› ä¸ºæ¥å£çš„æ³›å‹ç‰ˆæœ¬å¹¶ä¸å­˜åœ¨ã€‚è¿™æ—¶ï¼Œå¦‚æœæ¥å£çš„ä»»ä½•æ–¹æ³•è·å–æˆ–è¿”å› <code>Object</code> ï¼Œå°±ä¼šå¤±å»ç¼–è¯‘æ—¶çš„ç±»å‹å®‰å…¨æ€§ï¼Œè€Œä¸”å€¼ç±»å‹å°†å‘ç”Ÿè£…ç®±ã€‚å¯åˆ©ç”¨æœ¬ç«  13.9 èŠ‚ â€œç”¨æ˜¾å¼æ¥å£æ–¹æ³•å®ç°æ¥å¢å¼ºç¼–è¯‘æ—¶ç±»å‹å®‰å…¨æ€§â€ ä»‹ç»çš„æŠ€æœ¯æ¥ç¼“è§£è¯¥é—®é¢˜ã€‚</p><blockquote><p>The third benefit of generic interfaces is that a class can implement the same interface multiple times as long as different type parameters are used.</p></blockquote><blockquote><p>The following code shows an example of how useful this could be.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// This class implements the generic IComparable&lt;T> interface twice </span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Number</span><span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IComparable<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">></span></span><span class="token punctuation">,</span> <span class="token class-name">IComparable<span class="token punctuation">&lt;</span>String<span class="token punctuation">></span></span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_val <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// This method implements IComparable&lt;Int32>'s CompareTo </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">return</span> m_val<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// This method implements IComparable&lt;String>'s CompareTo </span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">return</span> m_val<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>Int32<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token class-name">Number</span> n <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Number</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token comment">// Here, I compare the value in n with an Int32 (5) </span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token class-name">IComparable<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">></span></span> cInt32 <span class="token operator">=</span> n<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token class-name">Int32</span> result <span class="token operator">=</span> cInt32<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token comment">// Here, I compare the value in n with a String ("5") </span></pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token class-name">IComparable<span class="token punctuation">&lt;</span>String<span class="token punctuation">></span></span> cString <span class="token operator">=</span> n<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="22"></td><td><pre> result <span class="token operator">=</span> cString<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token string">"5"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>An interfaceâ€™s generic type parameters can also be marked as contra-variant and covariant, which allows even more flexibility for using generic interfaces. For more about contra-variance and covariance, see the â€œDelegate and Interface Contra-variant and Covariant Generic Type Argumentsâ€ section in Chapter 12.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šC# å’Œ CLR æ‰€æ”¯æŒçš„æ³›å‹æ¥å£ä¸ºå¼€å‘äººå‘˜æä¾›äº†éœ€è¦éå¸¸å‡ºè‰²çš„åŠŸèƒ½ã€‚é¦–å…ˆï¼Œæ³›å‹æ¥å£æä¾›äº†å‡ºè‰²çš„ç¼–è¯‘æ—¶ç±»å‹å®‰å…¨æ€§ã€‚æ¥å£æ–¹æ³•ç†æƒ³æƒ…å†µä¸‹åº”è¯¥ä½¿ç”¨å¼ºç±»å‹ã€‚è¿™æ­£æ˜¯ FCL ä¸ºä»€ä¹ˆåŒ…å«ä¼—å¤šæ³›å‹æ¥å£çš„åŸå› ã€‚æ³›å‹æ¥å£çš„ç¬¬äºŒä¸ªå¥½å¤„åœ¨äºï¼Œå¤„ç†å€¼ç±»å‹æ—¶è£…ç®±æ¬¡æ•°ä¼šå°‘å¾ˆå¤šã€‚æ³›å‹æ¥å£çš„ç¬¬ä¸‰ä¸ªå¥½å¤„åœ¨äºï¼Œç±»å¯ä»¥å®ç°åŒä¸€ä¸ªæ¥å£è‹¥å¹²æ¬¡ï¼Œåªè¦æ¯æ¬¡ä½¿ç”¨ä¸åŒçš„ç±»å‹å‚æ•°ã€‚æ¥å£çš„æ³›å‹ç±»å‹å‚æ•°å¯æ ‡è®°ä¸ºé€†å˜å’Œåå˜ï¼Œä¸ºæ³›å‹æ¥å£çš„ä½¿ç”¨æä¾›æ›´å¤§çš„çµæ´»æ€§ã€‚</p><h2 id="generics-and-interface-constraints"><a class="anchor" href="#generics-and-interface-constraints">#</a> Generics and Interface Constraints</h2><blockquote><p>In the previous section, I discussed the benefits of using generic interfaces. In this section, Iâ€™ll discuss the benefits of constraining generic type parameters to interfaces.</p></blockquote><blockquote><p>The first benefit is that you can constrain a single generic type parameter to multiple interfaces. When you do this, the type of parameter you are passing in must implement all of the interface constraints.</p></blockquote><blockquote><p>Here is an example.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">Guid</span> g <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Guid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// This call to M compiles fine because </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Int32 implements IComparable AND IConvertible </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token function">M</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// This call to M causes a compiler error because </span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// Guid implements IComparable but it does not implement IConvertible </span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token function">M</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// M's type parameter, T, is constrained to work only with types that </span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token comment">// implement both the IComparable AND IConvertible interfaces </span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token generic-method"><span class="token function">M</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token keyword">where</span> <span class="token class-name">T</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IComparable</span><span class="token punctuation">,</span> <span class="token class-name">IConvertible</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token range operator">..</span><span class="token punctuation">.</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>This is actually quite cool! When you define a methodâ€™s parameters, each parameterâ€™s type indicates that the argument passed must be of the parameterâ€™s type or be derived from it. If the parameter type is an interface, this indicates that the argument can be of any class type as long as the class implements the interface. Using multiple interface constraints actually lets the method indicate that the passed argument must implement multiple interfaces.</p></blockquote><blockquote><p>In fact, if we constrained T to a class and two interfaces, we are saying that the type of argument passed must be of the specified base class (or derived from it), and it must also implement the two interfaces. This flexibility allows the method to really dictate what callers can pass, and compiler errors will be generated if callers do not meet these constraints.</p></blockquote><blockquote><p>The second benefit of interface constraints is reduced boxing when passing instances of value types. In the previous code fragment, the M method was passed x (an instance of an Int32, which is a value type). No boxing will occur when x is passed to M. If code inside M does call t.CompareTo(...), still no boxing occurs to make the call (boxing may still happen for arguments passed to CompareTo).</p></blockquote><blockquote><p>On the other hand, if M had been declared like this:</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">M</span><span class="token punctuation">(</span><span class="token class-name">IComparable</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token range operator">..</span><span class="token punctuation">.</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>then in order to pass x to M, x would have to be boxed.</p></blockquote><blockquote><p>For interface constraints, the C# compiler emits certain Intermediate Language (IL) instructions that result in calling the interface method on the value type directly without boxing it. Aside from using interface constraints, there is no other way to get the C# compiler to emit these IL instructions, and therefore, calling an interface method on a value type always causes boxing.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šå°†æ³›å‹ç±»å‹å‚æ•°çº¦æŸä¸ºæ¥å£æœ‰ä¸¤ä¸ªå¥½å¤„ã€‚ç¬¬ä¸€ä¸ªå¥½å¤„åœ¨äºï¼Œå¯å°†æ³›å‹ç±»å‹å‚æ•°çº¦æŸä¸ºå¤šä¸ªæ¥å£ã€‚è¿™æ ·ä¸€æ¥ï¼Œä¼ é€’çš„å‚æ•°çš„ç±»å‹å¿…é¡»å®ç°å…¨éƒ¨æ¥å£çº¦æŸã€‚å¦‚æœå°† T çº¦æŸä¸ºä¸€ä¸ªç±»å’Œä¸¤ä¸ªæ¥å£ï¼Œå°±è¡¨ç¤ºä¼ é€’çš„å®å‚ç±»å‹å¿…é¡»æ˜¯æŒ‡å®šçš„åŸºç±»ï¼ˆæˆ–è€…å®ƒçš„æ´¾ç”Ÿç±»ï¼‰ï¼Œè€Œä¸”å¿…é¡»å®ç°ä¸¤ä¸ªæ¥å£ã€‚è¿™ç§çµæ´»æ€§ä½¿æ–¹æ³•èƒ½ç»†è‡´åœ°çº¦æŸè°ƒç”¨è€…èƒ½ä¼ é€’çš„å†…å®¹ã€‚è°ƒç”¨è€…ä¸æ»¡è¶³è¿™äº›çº¦æŸï¼Œå°±ä¼šäº§ç”Ÿç¼–è¯‘é”™è¯¯ã€‚æ¥å£çº¦æŸçš„ç¬¬äºŒä¸ªå¥½å¤„æ˜¯ä¼ é€’å€¼ç±»å‹çš„å®ä¾‹æ—¶å‡å°‘è£…ç®±ã€‚C# ç¼–è¯‘å™¨ä¸ºæ¥å£çº¦æŸç”Ÿæˆç‰¹æ®Š IL æŒ‡ä»¤ï¼Œå¯¼è‡´ç›´æ¥åœ¨å€¼ç±»å‹ä¸Šè°ƒç”¨æ¥å£æ–¹æ³•è€Œä¸è£…ç®±ã€‚ä¸ç”¨æ¥å£çº¦æŸä¾¿æ²¡æœ‰å…¶ä»–åŠæ³•è®© C# ç¼–è¯‘å™¨ç”Ÿæˆè¿™äº› IL æŒ‡ä»¤ã€‚å¦‚æ­¤ä¸€æ¥ï¼Œåœ¨å€¼ç±»å‹ä¸Šè°ƒç”¨æ¥å£æ–¹æ³•æ€»æ˜¯å‘ç”Ÿè£…ç®±ã€‚ä¸€ä¸ªä¾‹å¤–æ˜¯å¦‚æœå€¼ç±»å‹å®ç°äº†ä¸€ä¸ªæ¥å£æ–¹æ³•ï¼Œåœ¨å€¼ç±»å‹çš„å®ä¾‹ä¸Šè°ƒç”¨è¿™ä¸ªæ–¹æ³•ä¸ä¼šé€ æˆå€¼ç±»å‹çš„å®ä¾‹è£…ç®±ã€‚</p><h2 id="implementing-multiple-interfaces-that-have-the-same-method-name-and-signature"><a class="anchor" href="#implementing-multiple-interfaces-that-have-the-same-method-name-and-signature">#</a> Implementing Multiple Interfaces That Have the Same Method Name and Signature</h2><blockquote><p>Occasionally, you might find yourself defining a type that implements multiple interfaces that define methods with the same name and signature. For example, imagine that there are two interfaces defined as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IWindow</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token return-type class-name">Object</span> <span class="token function">GetMenu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IRestaurant</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token return-type class-name">Object</span> <span class="token function">GetMenu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Letâ€™s say that you want to define a type that implements both of these interfaces. Youâ€™d have to implement the typeâ€™s members by using explicit interface method implementations as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// This type is derived from System.Object and </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// implements the IWindow and IRestaurant interfaces. </span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">MarioPizzeria</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IWindow</span><span class="token punctuation">,</span> <span class="token class-name">IRestaurant</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// This is the implementation for IWindow's GetMenu method. </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token return-type class-name">Object</span> IWindow<span class="token punctuation">.</span><span class="token function">GetMenu</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// This is the implementation for IRestaurant's GetMenu method. </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token return-type class-name">Object</span> IRestaurant<span class="token punctuation">.</span><span class="token function">GetMenu</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// This (optional method) is a GetMenu method that has nothing </span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// to do with an interface. </span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Object</span> <span class="token function">GetMenu</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Because this type must implement multiple and separate GetMenu methods, you need to tell the C# compiler which GetMenu method contains the implementation for a particular interface.</p></blockquote><blockquote><p>Code that uses a MarioPizzeria object must cast to the specific interface to call the desired method. The following code demonstrates.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">MarioPizzeria</span> mp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">MarioPizzeria</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// This line calls MarioPizzeria's public GetMenu method </span></pre></td></tr><tr><td data-num="3"></td><td><pre>mp<span class="token punctuation">.</span><span class="token function">GetMenu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// These lines call MarioPizzeria's IWindow.GetMenu method </span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token class-name">IWindow</span> window <span class="token operator">=</span> mp<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre>window<span class="token punctuation">.</span><span class="token function">GetMenu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// These lines call MarioPizzeria's IRestaurant.GetMenu method </span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token class-name">IRestaurant</span> restaurant <span class="token operator">=</span> mp<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre>restaurant<span class="token punctuation">.</span><span class="token function">GetMenu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>ğŸ’¡å°ç»“ï¼šå®šä¹‰å®ç°å¤šä¸ªæ¥å£çš„ç±»å‹æ—¶ï¼Œè¿™äº›æ¥å£å¯èƒ½å®šä¹‰äº†å…·æœ‰ç›¸åŒåç§°å’Œç­¾åçš„æ–¹æ³•ã€‚è¦å®šä¹‰å®ç°è¿™ä¸¤ä¸ªæ¥å£çš„ç±»å‹ï¼Œå¿…é¡»ä½¿ç”¨ â€œæ˜¾å¼æ¥å£æ–¹æ³•å®ç°â€ æ¥å®ç°è¿™ä¸ªç±»å‹çš„æˆå‘˜ï¼Œå¹¶åœ¨ä½¿ç”¨å¯¹åº”æ¥å£çš„æ–¹æ³•æ—¶éœ€è¦å°†å…¶è½¬æ¢ä¸ºå…·ä½“çš„æ¥å£æ‰èƒ½è°ƒç”¨æ‰€éœ€çš„æ–¹æ³•ã€‚</p><h2 id="improving-compile-time-type-safety-with-explicit-interface-method-implementations"><a class="anchor" href="#improving-compile-time-type-safety-with-explicit-interface-method-implementations">#</a> Improving Compile-Time Type Safety with Explicit Interface Method Implementations</h2><blockquote><p>Interfaces are great because they define a standard way for types to communicate with each other. Earlier, I talked about generic interfaces and how they improve compile-time type safety and reduce boxing. Unfortunately, there may be times when you need to implement a non-generic interface because a generic version doesnâ€™t exist. If any of the interfaceâ€™s method(s) accept parameters of type System.Object or return a value whose type is System.Object, you will lose compile-time type safety, and you will get boxing. In this section, Iâ€™ll show you how you can use EIMI to improve this situation somewhat.</p></blockquote><blockquote><p>Look at the very common IComparable interface.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IComparable</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token return-type class-name">Int32</span> <span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token class-name">Object</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>This interface defines one method that accepts a parameter of type System.Object. If I define my own type that implements this interface, the type definition might look like the following.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">struct</span> <span class="token class-name">SomeValueType</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IComparable</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_x<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token function">SomeValueType</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> m_x <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token class-name">Object</span> other<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">return</span><span class="token punctuation">(</span>m_x <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>SomeValueType<span class="token punctuation">)</span> other<span class="token punctuation">)</span><span class="token punctuation">.</span>m_x<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Using SomeValueType, I can now write the following code.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">SomeValueType</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SomeValueType</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Object</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">Int32</span> n <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Undesired boxing </span></pre></td></tr><tr><td data-num="5"></td><td><pre> n <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// InvalidCastException </span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>There are two characteristics of this code that are not ideal.</p><ul><li><p>Undesired boxing When v is passed as an argument to the CompareTo method, it must be boxed because CompareTo expects an Object.</p></li><li><p>The lack of type safety This code compiles, but an InvalidCastException is thrown inside the CompareTo method when it attempts to cast o to SomeValueType.</p></li></ul></blockquote><blockquote><p>Both of these issues can be fixed by using EIMIs. Hereâ€™s a modified version of SomeValueType that has an EIMI added to it.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">struct</span> <span class="token class-name">SomeValueType</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IComparable</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_x<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token function">SomeValueType</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> m_x <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token class-name">SomeValueType</span> other<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">return</span><span class="token punctuation">(</span>m_x <span class="token operator">-</span> other<span class="token punctuation">.</span>m_x<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// NOTE: No public/private used on the next line </span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token return-type class-name">Int32</span> IComparable<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token class-name">Object</span> other<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">return</span> <span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token punctuation">(</span>SomeValueType<span class="token punctuation">)</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Notice several changes in this new version. First, it now has two CompareTo methods. The first CompareTo method no longer takes an Object as a parameter; it now takes a SomeValueType instead. Because this parameter has changed, the code that casts other to SomeValueType is no longer necessary and has been removed. Second, changing the first CompareTo method to make it type-safe means that SomeValueType no longer adheres to the contract placed on it by implementing the IComparable interface. So SomeValueType must implement a CompareTo method that satisfies the IComparable contract. This is the job of the second IComparable.CompareTo method, which is an EIMI.</p></blockquote><blockquote><p>Having made these two changes means that we now get compile-time type safety and no boxing.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">SomeValueType</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SomeValueType</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Object</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">Int32</span> n <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// No boxing </span></pre></td></tr><tr><td data-num="5"></td><td><pre> n <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// compile-time error </span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>If, however, we define a variable of the interface type, we will lose compile-time type safety and experience undesired boxing again.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">SomeValueType</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SomeValueType</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">IComparable</span> c <span class="token operator">=</span> v<span class="token punctuation">;</span> <span class="token comment">// Boxing! </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">Object</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token class-name">Int32</span> n <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Undesired boxing </span></pre></td></tr><tr><td data-num="6"></td><td><pre> n <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// InvalidCastException </span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In fact, as mentioned earlier in this chapter, when casting a value type instance to an interface type, the CLR must box the value type instance. Because of this fact, two boxings will occur in the previous Main method.</p></blockquote><blockquote><p>EIMIs are frequently used when implementing interfaces such as IConvertible, ICollection, IList, and IDictionary. They let you create type-safe versions of these interfacesâ€™ methods, and they enable you to reduce boxing operations for value types.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šæœ‰æ—¶ç”±äºä¸å­˜åœ¨æ³›å‹ç‰ˆæœ¬çš„æ¥å£ï¼Œæ‰€ä»¥ä»éœ€å®ç°éæ³›å‹æ¥å£ã€‚æ¥å£çš„ä»»ä½•æ–¹æ³•æ¥å£ <code>System.Object</code> ç±»å‹çš„å‚æ•°æˆ–è¿”å› <code>System.Object</code> ç±»å‹çš„å€¼ï¼Œå°±ä¼šå¤±å»ç¼–è¯‘æ—¶çš„ç±»å‹å®‰å…¨æ€§ï¼Œè£…ç®±ä¹Ÿä¼šå‘ç”Ÿã€‚è¿™ä¸¤ä¸ªé—®é¢˜éƒ½å¯ä»¥ç”¨ EIMI è§£å†³ã€‚ä¸è¿‡ï¼Œå®šä¹‰æ¥å£ç±»å‹çš„å˜é‡ä¼šå†æ¬¡å¤±å»ç¼–è¯‘æ—¶çš„ç±»å‹å®‰å…¨æ€§ï¼Œè€Œä¸”ä¼šå†æ¬¡å‘ç”Ÿè£…ç®±ã€‚å®ç° <code>IConvertible</code> ï¼Œ <code>ICollection</code> ï¼Œ <code>IList</code> å’Œ <code>IDictionary</code> ç­‰æ¥å£æ—¶ EIMI å¾ˆæœ‰ç”¨ã€‚å¯åˆ©ç”¨å®ƒä¸ºè¿™äº›æ¥å£çš„æ–¹æ³•åˆ›å»ºç±»å‹å®‰å…¨çš„ç‰ˆæœ¬ï¼Œå¹¶å‡å°‘å€¼ç±»å‹çš„è£…ç®±ã€‚</p><h2 id="be-careful-with-explicit-interface-method-implementations"><a class="anchor" href="#be-careful-with-explicit-interface-method-implementations">#</a> Be Careful with Explicit Interface Method Implementations</h2><blockquote><p>It is critically important for you to understand some ramifications that exist when using EIMIs. And because of these ramifications, you should try to avoid EIMIs as much as possible. Fortunately, generic interfaces help you avoid EIMIs quite a bit. But there may still be times when you will need to use them (such as implementing two interface methods with the same name and signature). Here are the big problems with EIMIs:</p><ul><li><p>There is no documentation explaining how a type specifically implements an EIMI method, and there is no Microsoft Visual Studio IntelliSense support.</p></li><li><p>Value type instances are boxed when cast to an interface.</p></li><li><p>An EIMI cannot be called by a derived type.</p></li></ul></blockquote><blockquote><p>Letâ€™s take a closer look at these problems.</p></blockquote><blockquote><p>When examining the methods for a type in the .NET Framework reference documentation, explicit interface method implementations are listed, but no type-specific help exists; you can just read the general help about the interface methods. For example, the documentation for the Int32 type shows that it implements all of <code>IConvertible</code> interfaceâ€™s methods. This is good because developers know that these methods exist; however, this has been very confusing to developers because you canâ€™t call an <code>IConvertible</code> method on an Int32 directly. For example, the following method wonâ€™t compile.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Single</span> s <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">ToSingle</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Trying to call an IConvertible method </span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When compiling this method, the C# compiler produces the following message: messagepil17: 'int' does not contain a definition for ' <code>ToSingle</code> '. This error message confuses the developer because itâ€™s clearly stating that the Int32 type doesnâ€™t define a <code>ToSingle</code> method when, in fact, it does.</p></blockquote><blockquote><p>To call <code>oSingle</code> on an Int32, you must first cast the Int32 to an <code>IConvertible</code> , as shown in the following method.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Single</span> s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>IConvertible<span class="token punctuation">)</span> x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToSingle</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Requiring this cast isnâ€™t obvious at all, and many developers wonâ€™t figure this out on their own. But an even more troublesome problem exists: casting the Int32 value type to an <code>IConvertible</code> also boxes the value type, wasting memory and hurting performance. This is the second of the big problems I mentioned at the beginning of this section.</p></blockquote><blockquote><p>The third and perhaps the biggest problem with EIMIs is that they cannot be called by a derived class. Here is an example.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IComparable</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Explicit Interface Method Implementation </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token return-type class-name">Int32</span> IComparable<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Base's CompareTo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Base</span><span class="token punctuation">,</span> <span class="token class-name">IComparable</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// A public method that is also the interface implementation </span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Derived's CompareTo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// This attempt to call the base class's EIMI causes a compiler error: </span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token comment">// error CS0117: 'Base' does not contain a definition for 'CompareTo' </span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In <code>Derived</code> â€™s <code>CompareTo</code> method, I try to call <code>base.CompareTo</code> , but this causes the C# compiler to issue an error. The problem is that the Base class doesnâ€™t offer a public or protected <code>CompareTo</code> method that can be called; it offers a <code>CompareTo</code> method that can be called only by using a variable that is of the <code>IComparable</code> type. I could modify <code>Derived</code> â€™s <code>CompareTo</code> method so that it looks like the following.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// A public method that is also the interface implementation </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Derived's CompareTo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// This attempt to call the base class's EIMI causes infinite recursion </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token class-name">IComparable</span> c <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> c<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In this version, I am casting this to an <code>IComparable</code> variable, c. And then, I use c to call <code>CompareTo</code> . However, the <code>Derived</code> â€™s public <code>CompareTo</code> method serves as the implementation for <code>Derived</code> â€™s <code>IComparableCompareTo</code> method, and therefore, infinite recursion occurs. This could be fixed by declaring the Derived class without the <code>IComparable</code> interface, like the following.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Base</span></span> <span class="token comment">/*, IComparable */</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Now the previous <code>CompareTo</code> method will call the <code>CompareTo</code> method in Base. But sometimes you cannot simply remove the interface from the type because you want the derived type to implement an interface method. The best way to fix this is for the base class to provide a virtual method in addition to the interface method that it has chosen to implement explicitly. Then the Derived class can override the virtual method. Here is the correct way to define the Base and Derived classes.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IComparable</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Explicit Interface Method Implementation </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token return-type class-name">Int32</span> IComparable<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Base's IComparable CompareTo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">return</span> <span class="token function">CompareTo</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// This now calls the virtual method </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// Virtual method for derived classes (this method could have any name) </span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token return-type class-name">Int32</span> <span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Base's virtual CompareTo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Base</span><span class="token punctuation">,</span> <span class="token class-name">IComparable</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token comment">// A public method that is also the interface implementation </span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name">Int32</span> <span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Derived's CompareTo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token comment">// Now, we can call Base's virtual method </span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token keyword">return</span> <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Note that I have defined the virtual method above as a public method, but in some cases, you will prefer to make the method protected instead. It is fine to make this method protected instead of public, but that will necessitate other minor changes. This discussion clearly shows you that EIMIs should be used with great care. When many developers first learn about EIMIs, they think that theyâ€™re cool and they start using them whenever possible. Donâ€™t do this! EIMIs are useful in some circumstances, but you should avoid them whenever possible because they make using a type much more difficult.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šä½¿ç”¨ EIMI ä¹Ÿå¯èƒ½é€ æˆä¸€äº›ä¸¥é‡åæœï¼Œæ‰€ä»¥åº”è¯¥å°½é‡é¿å…ä½¿ç”¨ EIMIã€‚EIMI æœ€ä¸»è¦çš„é—®é¢˜å¦‚ä¸‹ï¼šæ²¡æœ‰æ–‡æ¡£è§£é‡Šç±»å‹å…·ä½“å¦‚ä½•å®ç°ä¸€ä¸ª EIMI æ–¹æ³•ï¼›å€¼ç±»å‹çš„å®ä¾‹åœ¨è½¬æ¢æˆæ¥å£æ—¶è£…ç®±ï¼›EIMI ä¸èƒ½ç”±æ´¾ç”Ÿç±»å‹è°ƒç”¨ã€‚è§£å†³æ´¾ç”Ÿç±»è°ƒç”¨é—®é¢˜çš„æœ€ä½³æ–¹æ³•æ˜¯åœ¨åŸºç±»ä¸­é™¤äº†æä¾›ä¸€ä¸ªè¢«é€‰ä¸ºæ˜¾å¼å®ç°çš„æ¥å£æ–¹æ³•ï¼Œè¿˜è¦æä¾›ä¸€ä¸ªè™šæ–¹æ³•ã€‚</p><h2 id="design-base-class-or-interface"><a class="anchor" href="#design-base-class-or-interface">#</a> Design: Base Class or Interface?</h2><blockquote><p>I often hear the question, â€œShould I design a base type or an interface?â€ The answer isnâ€™t always clearcut. Here are some guidelines that might help you:</p><ul><li><p>IS-A vs. CAN-DO relationship A type can inherit only one implementation. If the derived type canâ€™t claim an IS-A relationship with the base type, donâ€™t use a base type; use an interface. Interfaces imply a CAN-DO relationship. If the CAN-DO functionality appears to belong with various object types, use an interface. For example, a type can convert instances of itself to another type (IConvertible), a type can serialize an instance of itself (ISerializable), etc. Note that value types must be derived from System.ValueType, and therefore, they cannot be derived from an arbitrary base class. In this case, you must use a CAN-DO relationship and define an interface.</p></li><li><p>Ease of use Itâ€™s generally easier for you as a developer to define a new type derived from a base type than to implement all of the methods of an interface. The base type can provide a lot of functionality, so the derived type probably needs only relatively small modifications to its behavior. If you supply an interface, the new type must implement all of the members.</p></li><li><p>Consistent implementation No matter how well an interface contract is documented, itâ€™s very unlikely that everyone will implement the contract 100 percent correctly. In fact, COM suffers from this very problem, which is why some COM objects work correctly only with Microsoft Word or with Windows Internet Explorer. By providing a base type with a good default implementation, you start off using a type that works and is well tested; you can then modify parts that need modification.</p></li><li><p>Versioning If you add a method to the base type, the derived type inherits the new method, you start off using a type that works, and the userâ€™s source code doesnâ€™t even have to be recompiled. Adding a new member to an interface forces the inheritor of the interface to change its source code and recompile.</p></li></ul></blockquote><blockquote><p>In the FCL, the classes related to streaming data use an implementation inheritance design. The System.IO.Stream class is the abstract base class. It provides a bunch of methods, such as Read and Write. Other classesâ€”System.IO.FileStream, System.IO.MemoryStream, and <span class="exturl" data-url="aHR0cDovL1N5c3RlbS5OZXQ=">System.Net</span>. Sockets.NetworkStreamâ€”are derived from Stream. Microsoft chose an IS-A relationship between each of these three classes and the Stream class because it made implementing the concrete classes easier. For example, the derived classes need to implement only synchronous I/O operations; they inherit the ability to perform asynchronous I/O operations from the Stream base class.</p></blockquote><blockquote><p>Admittedly, choosing to use inheritance for the stream classes isnâ€™t entirely clear-cut; the Stream base class actually provides very little implementation. However, if you consider the Windows Forms control classes, in which Button, CheckBox, ListBox, and all of the other controls are derived from System.Windows.Forms.Control, itâ€™s easy to imagine all of the code that Control implements, which the various control classes simply inherit to function correctly.</p></blockquote><blockquote><p>By contrast, Microsoft designed the FCL collections to be interface based. The System.Collections.Generic namespace defines several collection-related interfaces: IEnumerable, ICollection, IList, and IDictionary. Then Microsoft provided a number of classes, such as List, Dictionary, Queue, Stack, and so on, that implement combinations of these interfaces. Here the designers chose a CAN-DO relationship between the classes and the interfaces because the implementations of these various collection classes are radically different from one another. In other words, there isnâ€™t a lot of sharable code between a List, a Dictionary, and a Queue.</p></blockquote><blockquote><p>The operations these collection classes offer are, nevertheless, pretty consistent. For example, they all maintain a set of elements that can be enumerated, and they all allow adding and removing of elements. If you have a reference to an object whose type implements the IList interface, you can write code to insert elements, remove elements, and search for an element without having to know exactly what type of collection youâ€™re working with. This is a very powerful mechanism.</p></blockquote><blockquote><p>Finally, it should be pointed out that you can actually do both: define an interface and provide a base class that implements the interface. For example, the FCL defines the IComparer interface and any type can choose to implement this interface. In addition, the FCL provides an abstract base class, Comparer, which implements this interface and provides a default implementation for the non-generic IComparerâ€™s Compare method. Having both an interface definition and a base class offers great flexibility because developers can now choose whichever they prefer.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šé€‰æ‹©åŸºç±»è¿˜æ˜¯æ¥å£å¯ä»¥ä»å‡ ä¸ªæ–¹é¢æ¥è€ƒè™‘ï¼š1.IS-A å¯¹æ¯” CAN-DO å…³ç³»ï¼Œå¦‚æœæ´¾ç”Ÿç±»å‹å’ŒåŸºç±»å‹å»ºç«‹ä¸èµ· IS-A å…³ç³»ï¼Œå°±ä¸ç”¨åŸºç±»è€Œç”¨æ¥å£ã€‚æ¥å£æ„å‘³ç€ CAN-DO å…³ç³»ã€‚å¦‚æœå¤šç§å¯¹è±¡ç±»å‹éƒ½ â€œèƒ½â€ åšæŸäº‹ï¼Œå°±ä¸ºå®ƒä»¬åˆ›å»ºæ¥å£ã€‚2. æ˜“ç”¨æ€§ï¼ŒåŸºç±»å‹å¯æä¾›å¤§é‡åŠŸèƒ½ï¼Œæ‰€ä»¥æ´¾ç”Ÿç±»å‹å¯èƒ½åªéœ€ç¨å¾®åšæ”¹åŠ¨ã€‚è€Œæä¾›æ¥å£çš„è¯ï¼Œæ–°ç±»å‹å¿…é¡»å®ç°æ‰€æœ‰æˆå‘˜ã€‚3. ä¸€è‡´æ€§å®ç°ï¼Œæ— è®ºæ¥å£åå®šï¼ˆcontractï¼‰è®¢ç«‹å¾—æœ‰å¤šå¥½ï¼Œéƒ½æ— æ³•ä¿è¯æ‰€æœ‰äººç™¾åˆ†ä¹‹ç™¾æ­£ç¡®å®ç°å®ƒã€‚è€Œå¦‚æœä¸ºåŸºç±»å‹æä¾›è‰¯å¥½çš„é»˜è®¤å®ç°ï¼Œé‚£ä¹ˆä¸€å¼€å§‹å¾—åˆ°çš„å°±æ˜¯èƒ½æ­£å¸¸å·¥ä½œå¹¶ç»è¿‡è‰¯å¥½æµ‹è¯•çš„ç±»å‹ã€‚ä»¥åæ ¹æ®éœ€è¦ä¿®æ”¹å°±å¯ä»¥äº†ã€‚4. ç‰ˆæœ¬æ§åˆ¶ï¼Œå‘åŸºç±»å‹æ·»åŠ ä¸€ä¸ªæ–¹æ³•ï¼Œæ´¾ç”Ÿç±»å‹å°†ç»§æ‰¿æ–°æ–¹æ³•ã€‚ä¸€å¼€å§‹ä½¿ç”¨çš„å°±æ˜¯ä¸€ä¸ªèƒ½æ­£å¸¸å·¥ä½œçš„ç±»å‹ï¼Œç”¨æˆ·çš„æºä»£ç ç”šè‡³ä¸éœ€è¦é‡æ–°ç¼–è¯‘ã€‚è€Œå‘æ¥å£æ·»åŠ æ–°æˆå‘˜ï¼Œä¼šå¼ºè¿«æ¥å£çš„ç»§æ‰¿è€…æ›´æ”¹å…¶æºä»£ç å¹¶é‡æ–°ç¼–è¯‘ã€‚</p><div class="tags"><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> è¯»ä¹¦ç¬”è®°</a> <a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C#</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2022-11-05 16:07:30" itemprop="dateModified" datetime="2022-11-05T16:07:30+08:00">2022-11-05</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(ï¿£â–½ï¿£)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Sakupinera WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Sakupinera Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Sakupinera PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Sakupinera <i class="ic i-at"><em>@</em></i>Sakupinera</li><li class="link"><strong>Post link: </strong><a href="http://sakupinera.github.io/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/" title="CLR via C# - Chapter 13 Interfaces">http://sakupinera.github.io/2022/11/04/csharp/clr-via-csharp/Chapter 13 Interfaces/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;03&#x2F;08&#x2F;iXZtNJQI2kjGuqS.jpg" title="CLR via C# - Chapter 12 Generics"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 12 Generics</h3></a></div><div class="item right"><a href="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;03&#x2F;08&#x2F;dhkXYZz7ENHoCeL.png" title="CLR via C# - Chapter 14 Chars, Strings, and Working with Text"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 14 Chars, Strings, and Working with Text</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-13-interfaces"><span class="toc-number">1.</span> <span class="toc-text">Chapter 13 Interfaces</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#class-and-interface-inheritance"><span class="toc-number">1.1.</span> <span class="toc-text">Class and Interface Inheritance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#defining-an-interface"><span class="toc-number">1.2.</span> <span class="toc-text">Defining an Interface</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inheriting-an-interface"><span class="toc-number">1.3.</span> <span class="toc-text">Inheriting an Interface</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#more-about-calling-interface-methods"><span class="toc-number">1.4.</span> <span class="toc-text">More About Calling Interface Methods</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#implicit-and-explicit-interface-method-implementations-whats-happening-behind-the-scenes"><span class="toc-number">1.5.</span> <span class="toc-text">Implicit and Explicit Interface Method Implementations (Whatâ€™s Happening Behind the Scenes)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#generic-interfaces"><span class="toc-number">1.6.</span> <span class="toc-text">Generic Interfaces</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#generics-and-interface-constraints"><span class="toc-number">1.7.</span> <span class="toc-text">Generics and Interface Constraints</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#implementing-multiple-interfaces-that-have-the-same-method-name-and-signature"><span class="toc-number">1.8.</span> <span class="toc-text">Implementing Multiple Interfaces That Have the Same Method Name and Signature</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#improving-compile-time-type-safety-with-explicit-interface-method-implementations"><span class="toc-number">1.9.</span> <span class="toc-text">Improving Compile-Time Type Safety with Explicit Interface Method Implementations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#be-careful-with-explicit-interface-method-implementations"><span class="toc-number">1.10.</span> <span class="toc-text">Be Careful with Explicit Interface Method Implementations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#design-base-class-or-interface"><span class="toc-number">1.11.</span> <span class="toc-text">Design: Base Class or Interface?</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"><ul><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/" rel="bookmark" title="CLR via C# - Chapter 1 The CLRâ€™s Execution Model">CLR via C# - Chapter 1 The CLRâ€™s Execution Model</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/" rel="bookmark" title="CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types">CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%203%20Shared%20Assemblies%20and%20Strongly%20Named%20Assemblies/" rel="bookmark" title="CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies">CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies</a></li><li><a href="/2022/09/27/csharp/clr-via-csharp/Chapter%204%20Type%20Fundamentals/" rel="bookmark" title="CLR via C# - Chapter 4 Type Fundamentals">CLR via C# - Chapter 4 Type Fundamentals</a></li><li><a href="/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/" rel="bookmark" title="CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals">CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals</a></li><li><a href="/2022/10/21/csharp/clr-via-csharp/Chapter%206%20Type%20and%20Member%20Basics/" rel="bookmark" title="CLR via C# - Chapter 6 Type and Member Basics">CLR via C# - Chapter 6 Type and Member Basics</a></li><li><a href="/2022/10/24/csharp/clr-via-csharp/Chapter%207%20Constants%20and%20Fields/" rel="bookmark" title="CLR via C# - Chapter 7 Constants and Fields">CLR via C# - Chapter 7 Constants and Fields</a></li><li><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" rel="bookmark" title="CLR via C# - Chapter 8 Methods">CLR via C# - Chapter 8 Methods</a></li><li><a href="/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/" rel="bookmark" title="CLR via C# - Chapter 9 Parameters">CLR via C# - Chapter 9 Parameters</a></li><li><a href="/2022/10/28/csharp/clr-via-csharp/Chapter%2010%20Properties/" rel="bookmark" title="CLR via C# - Chapter 10 Properties">CLR via C# - Chapter 10 Properties</a></li><li><a href="/2022/10/29/csharp/clr-via-csharp/Chapter%2011%20Events/" rel="bookmark" title="CLR via C# - Chapter 11 Events">CLR via C# - Chapter 11 Events</a></li><li><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" rel="bookmark" title="CLR via C# - Chapter 12 Generics">CLR via C# - Chapter 12 Generics</a></li><li class="active"><a href="/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/" rel="bookmark" title="CLR via C# - Chapter 13 Interfaces">CLR via C# - Chapter 13 Interfaces</a></li><li><a href="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/" rel="bookmark" title="CLR via C# - Chapter 14 Chars, Strings, and Working with Text">CLR via C# - Chapter 14 Chars, Strings, and Working with Text</a></li><li><a href="/2022/11/17/csharp/clr-via-csharp/Chapter%2015%20Enumerated%20Types%20and%20Bit%20Flags/" rel="bookmark" title="CLR via C# - Chapter 15 Enumerated Types and Bit Flags">CLR via C# - Chapter 15 Enumerated Types and Bit Flags</a></li><li><a href="/2022/11/19/csharp/clr-via-csharp/Chapter%2016%20Arrays/" rel="bookmark" title="CLR via C# - Chapter 16 Arrays">CLR via C# - Chapter 16 Arrays</a></li><li><a href="/2022/11/21/csharp/clr-via-csharp/Chapter%2017%20Delegates/" rel="bookmark" title="CLR via C# - Chapter 17 Delegates">CLR via C# - Chapter 17 Delegates</a></li><li><a href="/2022/11/22/csharp/clr-via-csharp/Chapter%2018%20Custom%20Attributes/" rel="bookmark" title="CLR via C# - Chapter 18 Custom Attributes">CLR via C# - Chapter 18 Custom Attributes</a></li><li><a href="/2022/11/23/csharp/clr-via-csharp/Chapter%2019%20Nullable%20Value%20Types/" rel="bookmark" title="CLR via C# - Chapter 19 Nullable Value Types">CLR via C# - Chapter 19 Nullable Value Types</a></li><li><a href="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/" rel="bookmark" title="CLR via C# - Chapter 20 Exceptions and State Management">CLR via C# - Chapter 20 Exceptions and State Management</a></li><li><a href="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/" rel="bookmark" title="CLR via C# - Chapter 21 The Managed Heap and Garbage  Collection">CLR via C# - Chapter 21 The Managed Heap and Garbage Collection</a></li><li><a href="/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/" rel="bookmark" title="CLR via C# - Chapter 22 CLR Hosting and AppDomains">CLR via C# - Chapter 22 CLR Hosting and AppDomains</a></li><li><a href="/2022/11/29/csharp/clr-via-csharp/Chapter%2023%20Assembly%20Loading%20and%20Reflection/" rel="bookmark" title="CLR via C# - Chapter 23 Assembly Loading and Reflection">CLR via C# - Chapter 23 Assembly Loading and Reflection</a></li><li><a href="/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/" rel="bookmark" title="CLR via C# - Chapter 24 Runtime Serialization">CLR via C# - Chapter 24 Runtime Serialization</a></li><li><a href="/2022/12/06/csharp/clr-via-csharp/Chapter%2025%20Interoperating%20with%20WinRT%20%20Components/" rel="bookmark" title="CLR via C# - Chapter 25 Interoperating with WinRT Components">CLR via C# - Chapter 25 Interoperating with WinRT Components</a></li><li><a href="/2023/02/06/csharp/clr-via-csharp/Chapter%2026%20Thread%20Basics/" rel="bookmark" title="CLR via C# - Chapter 26 Thread Basics">CLR via C# - Chapter 26 Thread Basics</a></li><li><a href="/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations">CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations</a></li><li><a href="/2023/02/08/csharp/clr-via-csharp/Chapter%2028%20IO-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 28 IO-Bound Asynchronous Operations">CLR via C# - Chapter 28 IO-Bound Asynchronous Operations</a></li><li><a href="/2023/02/09/csharp/clr-via-csharp/Chapter%2029%20Primitive%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 29 Primitive Thread Synchronization">CLR via C# - Chapter 29 Primitive Thread Synchronization</a></li><li><a href="/2023/02/10/csharp/clr-via-csharp/Chapter%2030%20Hybrid%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 30 Hybrid Thread Synchronization">CLR via C# - Chapter 30 Hybrid Thread Synchronization</a></li></ul></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sakupinera" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Sakupinera</p><div class="description" itemprop="description">ä¿æŒä½ çš„å†³å¿ƒï¼</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">86</span> <span class="name">posts</span></a></div><div class="item categories"><a href="/categories/"><span class="count">13</span> <span class="name">categories</span></a></div><div class="item tags"><a href="/tags/"><span class="count">6</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nha3VwaW5lcmE=" title="https:&#x2F;&#x2F;github.com&#x2F;sakupinera"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9zYWt1cGluZXJh" title="https:&#x2F;&#x2F;twitter.com&#x2F;sakupinera"><i class="ic i-twitter"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQwNzIyOTA3MQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;407229071"><i class="ic i-cloud-music"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMjIzMDczOTg/c3BtX2lkX2Zyb209MzMzLjEwMDcuMC4w" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;22307398?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li><li class="item"><a href="/games/" rel="section"><i class="ic i-flag"></i>Games</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-person"></i>About</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/08/28/linux/learn-linux/%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/" title="LearnLinux - ç”¨æˆ·å’Œç”¨æˆ·ç»„ç®¡ç†">LearnLinux - ç”¨æˆ·å’Œç”¨æˆ·ç»„ç®¡ç†</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" title="CLR via C# - Chapter 8 Methods">CLR via C# - Chapter 8 Methods</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/09/05/linux/learn-linux/%E5%90%AF%E5%8A%A8%E7%AE%A1%E7%90%86/" title="LearnLinux - å¯åŠ¨ç®¡ç†">LearnLinux - å¯åŠ¨ç®¡ç†</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Network/" title="In Network">Network</a></div><span><a href="/2023/03/21/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="è®¡ç®—æœºç½‘ç»œ">è®¡ç®—æœºç½‘ç»œ</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/" title="CLR via C# - Chapter 14 Chars, Strings, and Working with Text">CLR via C# - Chapter 14 Chars, Strings, and Working with Text</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/08/28/linux/learn-linux/Linux%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/" title="LearnLinux - Linuxç³»ç»Ÿç®€ä»‹">LearnLinux - Linuxç³»ç»Ÿç®€ä»‹</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/08/28/linux/learn-linux/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/" title="LearnLinux - æƒé™ç®¡ç†">LearnLinux - æƒé™ç®¡ç†</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/08/28/linux/learn-linux/Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/" title="LearnLinux - Linuxç³»ç»Ÿå®‰è£…">LearnLinux - Linuxç³»ç»Ÿå®‰è£…</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CSharp-in-a-Nutshell/" title="In CSharp-in-a-Nutshell">CSharp-in-a-Nutshell</a></div><span><a href="/2022/08/29/csharp/csharp-in-a-nutshell/%E7%AC%AC3%E7%AB%A0%20%E5%9C%A8CSharp%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%9E%8B/" title="C# in a Nutshell - ç¬¬3ç«  åœ¨C#ä¸­åˆ›å»ºç±»å‹">C# in a Nutshell - ç¬¬3ç«  åœ¨C#ä¸­åˆ›å»ºç±»å‹</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/" title="CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types">CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 â€“ <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Sakupinera @ Hanamai Sora</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="Symbols count total">2.2m words</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="Reading time total">33:30</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/11/04/csharp/clr-via-csharp/Chapter 13 Interfaces/",favicon:{show:"ï¼ˆâ—Â´3ï½€â—ï¼‰Goooood",hide:"(Â´Ğ”ï½€)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/shifuku.model.json"},display:{position:"left",width:250,height:500},mobile:{show:!1},react:{opacity:.9},log:!1})</script></body></html>