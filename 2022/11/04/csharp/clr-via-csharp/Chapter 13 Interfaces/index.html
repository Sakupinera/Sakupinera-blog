<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sakupinera" href="http://sakupinera.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sakupinera" href="http://sakupinera.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sakupinera" href="http://sakupinera.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="读书笔记,C#"><link rel="canonical" href="http://sakupinera.github.io/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/"><title>CLR via C# - Chapter 13 Interfaces - CLR-via-CSharp - CSharp | Hanamai Sora = Sakupinera</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">CLR via C# - Chapter 13 Interfaces</h1><div class="meta"><span class="item" title="Created: 2022-11-04 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2022-11-04T00:00:00+08:00">2022-11-04</time> </span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">Symbols count in article</span> <span>38k</span> <span class="text">words</span> </span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">Reading time</span> <span>34 mins.</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hanamai Sora</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s2.loli.net/2023/03/08/R9PEJQ54o7HMAis.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/6bW8i2mQY4dyzLo.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/XtZcHusj92O56kz.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/qSxQEJk41eog52I.png"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/KFwBz5WDl3HNyXq.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/cNIvjwsl174ibOo.png"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/" itemprop="item" rel="index" title="In CSharp"><span itemprop="name">CSharp</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/CLR-via-CSharp/" itemprop="item" rel="index" title="In CLR-via-CSharp"><span itemprop="name">CLR-via-CSharp</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://sakupinera.github.io/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Sakupinera"><meta itemprop="description" content=", 保持你的决心！"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakupinera"></span><div class="body md" itemprop="articleBody"><h1 id="chapter-13-interfaces"><a class="anchor" href="#chapter-13-interfaces">#</a> Chapter 13 Interfaces</h1><h2 id="class-and-interface-inheritance"><a class="anchor" href="#class-and-interface-inheritance">#</a> Class and Interface Inheritance</h2><blockquote><p>In the Microsoft .NET Framework, there is a class called <code>System.Object</code> that defines four public instance methods: <code>ToString</code> , <code>Equals</code> , <code>GetHashCode</code> , and <code>GetType</code> . This class is the root or ultimate base class of all other classes—all classes will inherit Object’s four instance methods. This also means that code written to operate on an instance of the Object class can actually perform operations on an instance of any class.</p></blockquote><blockquote><p>Because someone at Microsoft has implemented Object’s methods, any class derived from Object is actually inheriting the following:</p><ul><li><p>The method signatures This allows code to think that it is operating on an instance of the Object class, when in fact, it could be operating on an instance of some other class.</p></li><li><p>The implementation of these methods This allows the developer defining a class derived from Object not to be required to manually implement Object’s methods.</p></li></ul></blockquote><blockquote><p>In the CLR, a class is always derived from one and only one class (that must ultimately be derived from Object). This base class provides a set of method signatures and implementations for these methods. And a cool thing about defining a new class is that it can become the base class for another class defined in the future by some other developer—all of the method signatures and their implementations will be inherited by the new derived class.</p></blockquote><blockquote><p>The CLR also allows developers to define an interface, which is really just a way to give a name to a set of method signatures. These methods do not come with any implementation at all. A class inherits an interface by specifying the interface’s name, and the class must explicitly provide implementations of the interface’s methods before the CLR will consider the type definition to be valid. Of course, implementing interface methods can be tedious, which is why I referred to interface inheritance as a scaled-down mechanism to achieve multiple inheritance. The C# compiler and the CLR actually allow a class to inherit several interfaces, and of course, the class must provide implementations for all of the inherited interface methods.</p></blockquote><blockquote><p>One of the great features of class inheritance is that it allows instances of a derived type to be substituted in all contexts that expect instances of a base type. Similarly, interface inheritance allows instances of a type that implements the interface to be substituted in all contexts that expect instances of the named interface type. We will now look at how to define interfaces to make our discussion more concrete.</p></blockquote><p>💡小结：CLR 不支持多继承（因此所有托管编程语言也支持不了）。CLR 只是通过接口提供了 “缩水版” 的多继承。由于 Microsoft 的开发团队已实现了 Object 的方法，所以从 Object 派生的任何类实际都继承了 Object 的方法签名和方法实现。除了基类，CLR 还允许开发人员定义接口，它实际只是对一组方法签名进行了统一命名。这些方法不提供任何实现。类通过指定接口名称来继承接口，而且必须显式实现接口方法，否则 CLR 会认为此类型定义无效。C# 编译器和 CLR 允许一个类继承多个接口。当然，继承的所有接口方法都必须实现。</p><h2 id="defining-an-interface"><a class="anchor" href="#defining-an-interface">#</a> Defining an Interface</h2><blockquote><p>As mentioned in the previous section, an interface is a named set of method signatures. Note that interfaces can also define events, parameterless properties, and parameterful properties (indexers in C#) because all of these are just syntax shorthands that map to methods anyway, as shown in previous chapters. However, an interface cannot define any constructor methods. In addition, an interface is not allowed to define any instance fields.</p></blockquote><blockquote><p>Although the CLR does allow an interface to define static methods, static fields, constants, and static constructors, a Common Language Specification (CLS)–compliant interface must not have any of these static members because some programming languages aren’t able to define or access them. In fact, C# prevents an interface from defining any of these static members.</p></blockquote><blockquote><p>In C#, you use the interface keyword to define an interface, giving it a name and its set of instance method signatures. Here are the definitions of a few interfaces defined in the Framework Class Library (FCL).</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IDisposable</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IEnumerable</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token return-type class-name">IEnumerator</span> <span class="token function">GetEnumerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span><span class="token keyword">out</span> T<span class="token punctuation">></span></span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IEnumerable</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">new</span> <span class="token return-type class-name">IEnumerator<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token function">GetEnumerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ICollection<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span><span class="token punctuation">,</span> <span class="token class-name">IEnumerable</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token class-name">T</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token return-type class-name">Boolean</span> <span class="token function">Contains</span><span class="token punctuation">(</span><span class="token class-name">T</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">CopyTo</span><span class="token punctuation">(</span><span class="token class-name">T<span class="token punctuation">[</span><span class="token punctuation">]</span></span> array<span class="token punctuation">,</span> <span class="token class-name">Int32</span> arrayIndex<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token return-type class-name">Boolean</span> <span class="token function">Remove</span><span class="token punctuation">(</span><span class="token class-name">T</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token return-type class-name">Int32</span> Count <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// Read-only property </span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token return-type class-name">Boolean</span> IsReadOnly <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// Read-only property </span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>To the CLR, an interface definition is just like a type definition. That is, the CLR will define an internal data structure for the interface type object, and reflection can be used to query features of the interface type. Like types, an interface can be defined at file scope or defined nested within another type. When defining the interface type, you can specify whatever visibility/accessibility (public, protected, internal, etc.) you want.</p></blockquote><blockquote><p>By convention, interface type names are prefixed with an uppercase I, making it easy to spot an interface type in source code. The CLR does support generic interfaces (as you can see from some of the previous examples) as well as generic methods in an interface. I will discuss some of the many features offered by generic interfaces later in this chapter and in Chapter 12, “Generics,” in which I cover generics more broadly.</p></blockquote><blockquote><p>An interface definition can “inherit” other interfaces. However, I use the word inherit here rather loosely because interface inheritance doesn’t work exactly like class inheritance. I prefer to think of interface inheritance as including the contract of other interfaces. For example, the <code>ICollection</code> interface definition includes the contracts of the <code>IEnumerable</code> and <code>IEnumerable</code> interfaces.</p></blockquote><blockquote><p>This means that:</p><ul><li><p>Any class that inherits the <code>ICollection</code> interface must implement all of the methods defined by the <code>ICollection</code> , <code>IEnumerable</code> , and <code>IEnumerable</code> interfaces.</p></li><li><p>Any code that expects an object whose type implements the <code>ICollection</code> interface can assume that the object’s type also implements the methods of the <code>IEnumerable</code> and <code>IEnumerable</code> interfaces.</p></li></ul></blockquote><p>💡小结：除了定义方法之外，接口还能定义事件、无参属性和有参属性（C# 的索引器）。如前所述，所有这些东西本质上都是方法，它们只是语法上的简化。不过，接口不能定义任何构造器方法，也不能定义任何实例字段。虽然 CLR 允许接口定义静态方法、静态字段、常量和静态构造器，但符合 CLS 标准的接口绝不允许，因为有的编程语言不能定义或访问它们。事实上，C# 禁止接口定义任何一种这样的静态成员。C# 用 interface 关键字定义接口。要为接口指定名称和一组实例方法签名。在 CLR 看来，接口定义就是类型定义。也就是说，CLR 会为接口类型对象定义内部数据结构，同时可通过反射机制来查询接口类型的功能。和类型一样，接口可在文件范围中定义，也可嵌套在另一个类型中。定义接口类型时，可指定你希望的任何可见性 / 可访问性（public，protected，internal 等）。接口可以将其他接口的协定（contract）包括到新接口中。例如， <code>ICollection&lt;T&gt;</code> 接口定义就包含了 <code>IEnumerable&lt;T&gt;</code> 和 <code>IEnumerable</code> 两个接口的协定。</p><h2 id="inheriting-an-interface"><a class="anchor" href="#inheriting-an-interface">#</a> Inheriting an Interface</h2><blockquote><p>In this section, I’ll show how to define a type that implements an interface, and then I’ll show how to create an instance of this type and use the object to call the interface’s methods. C# actually makes this pretty simple, but what happens behind the scenes is a bit more complicated. I’ll explain what is happening behind the scenes later in this chapter.</p></blockquote><blockquote><p>The <code>System.IComparable</code> interface is defined (in MSCorLib.dll) as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IComparable<span class="token punctuation">&lt;</span><span class="token keyword">in</span> T<span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token return-type class-name">Int32</span> <span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token class-name">T</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The following code shows how to define a type that implements this interface and also shows code that compares two Point objects.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// Point is derived from System.Object and implements IComparable&lt;T> for Point. </span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IComparable<span class="token punctuation">&lt;</span>Point<span class="token punctuation">></span></span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_x<span class="token punctuation">,</span> m_y<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> x<span class="token punctuation">,</span> <span class="token class-name">Int32</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> m_x <span class="token operator">=</span> x<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> m_y <span class="token operator">=</span> y<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// This method implements IComparable&lt;T>.CompareTo() for Point </span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token class-name">Point</span> other<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">Sign</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">Sqrt</span><span class="token punctuation">(</span>m_x <span class="token operator">*</span> m_x <span class="token operator">+</span> m_y <span class="token operator">*</span> m_y<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token operator">-</span> Math<span class="token punctuation">.</span><span class="token function">Sqrt</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>m_x <span class="token operator">*</span> other<span class="token punctuation">.</span>m_x <span class="token operator">+</span> other<span class="token punctuation">.</span>m_y <span class="token operator">*</span> other<span class="token punctuation">.</span>m_y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name">String</span> <span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token keyword">return</span> String<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"(&#123;0&#125;, &#123;1&#125;)"</span><span class="token punctuation">,</span> m_x<span class="token punctuation">,</span> m_y<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token class-name">Point<span class="token punctuation">[</span><span class="token punctuation">]</span></span> points <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Point<span class="token punctuation">[</span><span class="token punctuation">]</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Point</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Point</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token comment">// Here is a call to Point's IComparable&lt;T> CompareTo method </span></pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>points<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>points<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token class-name">Point</span> tempPoint <span class="token operator">=</span> points<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="27"></td><td><pre> points<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> points<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="28"></td><td><pre> points<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tempPoint<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="29"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="30"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Points from closest to (0, 0) to farthest:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="31"></td><td><pre> <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name">Point</span> p <span class="token keyword">in</span> points<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="32"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="33"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The C# compiler requires that a method that implements an interface be marked as public. The CLR requires that interface methods be marked as virtual. If you do not explicitly mark the method as virtual in your source code, the compiler marks the method as virtual and sealed; this prevents a derived class from overriding the interface method. If you explicitly mark the method as virtual, the compiler marks the method as virtual (and leaves it unsealed); this allows a derived class to override the interface method.</p></blockquote><blockquote><p>If an interface method is sealed, a derived class cannot override the method. However, a derived class can re-inherit the same interface and can provide its own implementation for the interface’s methods. When calling an interface’s method on an object, the implementation associated with the object’s type is called. Here is an example that demonstrates this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">/************************* First Example *************************/</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token class-name">Base</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// Calls Dispose by using b's type: "Base's Dispose" </span></pre></td></tr><tr><td data-num="8"></td><td><pre> b<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// Calls Dispose by using b's object's type: "Base's Dispose" </span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">(</span><span class="token punctuation">(</span>IDisposable<span class="token punctuation">)</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">/************************* Second Example ************************/</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token class-name">Derived</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token comment">// Calls Dispose by using d's type: "Derived's Dispose" </span></pre></td></tr><tr><td data-num="15"></td><td><pre> d<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token comment">// Calls Dispose by using d's object's type: "Derived's Dispose" </span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token punctuation">(</span><span class="token punctuation">(</span>IDisposable<span class="token punctuation">)</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token comment">/************************* Third Example *************************/</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token comment">// Calls Dispose by using b's type: "Base's Dispose" </span></pre></td></tr><tr><td data-num="21"></td><td><pre> b<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token comment">// Calls Dispose by using b's object's type: "Derived's Dispose" </span></pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token punctuation">(</span><span class="token punctuation">(</span>IDisposable<span class="token punctuation">)</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token comment">// This class is derived from Object and it implements IDisposable </span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IDisposable</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="28"></td><td><pre> <span class="token comment">// This method is implicitly sealed and cannot be overridden </span></pre></td></tr><tr><td data-num="29"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="30"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Base's Dispose"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="31"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token comment">// This class is derived from Base and it re-implements IDisposable </span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Base</span><span class="token punctuation">,</span> <span class="token class-name">IDisposable</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="35"></td><td><pre> <span class="token comment">// This method cannot override Base's Dispose. 'new' is used to indicate </span></pre></td></tr><tr><td data-num="36"></td><td><pre> <span class="token comment">// that this method re-implements IDisposable's Dispose method </span></pre></td></tr><tr><td data-num="37"></td><td><pre> <span class="token keyword">new</span> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="38"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Derived's Dispose"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="39"></td><td><pre> <span class="token comment">// NOTE: The next line shows how to call a base class's implementation (if desired) </span></pre></td></tr><tr><td data-num="40"></td><td><pre> <span class="token comment">// base.Dispose(); </span></pre></td></tr><tr><td data-num="41"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="42"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>💡小结：C# 编译器要求将实现接口的方法（后文简称为 “接口方法”）标记为 public。CLR 要求将接口方法标记为 virtual。不将方法显式标记为 virtual，编译器会将它们标记为 virtual 和 sealed；这会阻止派生类重写接口方法。将方法显式标记为 virtual，编译器就会将该方法标记为 virtual（并保持它的非密封状态），使派生类能重写它。派生类不能重写 sealed 的接口方法。但派生类可重新继承同一个接口，并为接口方法提供自己的实现。在对象上调用接口方法时，调用的是该方法在该对象的类型中的实现。</p><h2 id="more-about-calling-interface-methods"><a class="anchor" href="#more-about-calling-interface-methods">#</a> More About Calling Interface Methods</h2><blockquote><p>The FCL’s <code>System.String</code> type inherits <code>System.Object</code> ’s method signatures and their implementations. In addition, the String type also implements several interfaces: <code>IComparable</code> , <code>ICloneable</code> , <code>IConvertible</code> , <code>IEnumerable</code> , <code>IComparable</code> , <code>IEnumerable</code> , and <code>IEquatable</code> . This means that the String type isn’t required to implement (or override) the methods its Object base type offers. However, the String type must implement the methods declared in all of the interfaces.</p></blockquote><blockquote><p>The CLR allows you to define field, parameter, or local variables that are of an interface type. Using a variable of an interface type allows you to call methods defined by that interface. In addition, the CLR will allow you to call methods defined by Object because all classes inherit Object’s methods. The following code demonstrates this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// The s variable refers to a String object. </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"Jeffrey"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// Using s, I can call any method defined in </span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// String, Object, IComparable, ICloneable, IConvertible, IEnumerable, etc. </span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// The cloneable variable refers to the same String object </span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token class-name">ICloneable</span> cloneable <span class="token operator">=</span> s<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// Using cloneable, I can call any method declared by the </span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// ICloneable interface (or any method defined by Object) only. </span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// The comparable variable refers to the same String object </span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token class-name">IComparable</span> comparable <span class="token operator">=</span> s<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">// Using comparable, I can call any method declared by the </span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment">// IComparable interface (or any method defined by Object) only. </span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment">// The enumerable variable refers to the same String object </span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token comment">// At run time, you can cast a variable from one interface to another as </span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">// long as the object's type implements both interfaces. </span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token class-name">IEnumerable</span> enumerable <span class="token operator">=</span> <span class="token punctuation">(</span>IEnumerable<span class="token punctuation">)</span> comparable<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token comment">// Using enumerable, I can call any method declared by the </span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token comment">// IEnumerable interface (or any method defined by Object) only.</span></pre></td></tr></table></figure><blockquote><p>In this code, all of the variables refer to the same “Jeffrey” String object that is in the managed heap, and therefore, any method that I call while using any of these variables applies to the one “Jeffrey” String object. However, the type of the variable indicates the action that I can perform on the object. The s variable is of type String, and therefore, I can use s to call any members defined by the String type (such as the Length property). I can also use the variable s to call any methods inherited from Object (such as <code>GetType</code> ).</p></blockquote><blockquote><p>The cloneable variable is of the <code>ICloneable</code> interface type, and therefore, using the cloneable variable, I can call the Clone method defined by this interface. In addition, I can call any method defined by Object (such as <code>GetType</code> ) because the CLR knows that all types derive from Object. However, using the cloneable variable, I cannot call public methods defined by String itself or any methods defined by any other interface that String implements. Similarly, using the comparable variable, I can call <code>CompareTo</code> or any method defined by Object, but no other methods are callable using this variable.</p></blockquote><p>💡重要提示：和引用类型相似，值类型可实现零个或多个接口。但值类型的实例在转换为接口类型时必须装箱。这是由于接口变量是引用，必须指向堆上的对象，使 CLR 能检查对象的类型对象的类型对象指针，从而判断对象的确切类型。调用已装箱值类型的接口方法时，CLR 会跟随对象的类型对象指针找到类型对象的方法表，从而调用正确的方法。</p><p>💡小结：CLR 允许定义接口类型的字段、参数或局部变量。使用接口类型的变量可以调用该接口定义的方法。此外，CLR 允许调用 Object 定义的方法，因为所有类都继承了 Object 的方法。</p><h2 id="implicit-and-explicit-interface-method-implementations-whats-happening-behind-the-scenes"><a class="anchor" href="#implicit-and-explicit-interface-method-implementations-whats-happening-behind-the-scenes">#</a> Implicit and Explicit Interface Method Implementations (What’s Happening Behind the Scenes)</h2><blockquote><p>When a type is loaded into the CLR, a method table is created and initialized for the type (as discussed in Chapter 1, “The CLR’s Execution Model”). This method table contains one entry for every new method introduced by the type as well as entries for any virtual methods inherited by the type. Inherited virtual methods include methods defined by the base types in the inheritance hierarchy as well as any methods defined by the interface types. So if you have a simple type defined like this:</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SimpleType</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IDisposable</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Dispose"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>the type’s method table contains entries for the following:</p><ul><li><p>All the virtual instance methods defined by Object, the implicitly inherited base class.</p></li><li><p>All the interface methods defined by <code>IDisposable</code> , the inherited interface. In this example, there is only one method, Dispose, because the <code>IDisposable</code> interface defines just one method.</p></li><li><p>The new method, Dispose, introduced by <code>SimpleType</code> .</p></li></ul></blockquote><blockquote><p>To make things simple for the programmer, the C# compiler assumes that the Dispose method introduced by <code>SimpleType</code> is the implementation for <code>IDisposable</code> ’s Dispose method. The C# compiler makes this assumption because the method is public, and the signatures of the interface method and the newly introduced method are identical. That is, the methods have the same parameter and return types. By the way, if the new Dispose method were marked as virtual, the C# compiler would still consider this method to be a match for the interface method.</p></blockquote><blockquote><p>When the C# compiler matches a new method to an interface method, it emits metadata indicating that both entries in <code>SimpleType</code> ’s method table should refer to the same implementation. To help make this clearer, here is some code that demonstrates how to call the class’s public Dispose method as well as how to call the class’s implementation of <code>IDisposable</code> ’s Dispose method.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">SimpleType</span> st <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SimpleType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// This calls the public Dispose method implementation </span></pre></td></tr><tr><td data-num="5"></td><td><pre> st<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// This calls IDisposable's Dispose method implementation </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token class-name">IDisposable</span> d <span class="token operator">=</span> st<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> d<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In the first call to Dispose, the Dispose method defined by SimpleType is called. Then I define a variable, d, which is of the IDisposable interface type. I initialize the d variable to refer to the SimpleType object. Now when I call d.Dispose(), I am calling the IDisposable interface’s Dispose method. Because C# requires the public Dispose method to also be the implementation for IDisposable’s Dispose method, the same code will execute, and, in this example, you can’t see any observable difference. The output is as follows.</p></blockquote><pre><code>Dispose 
Dispose
</code></pre><blockquote><p>Now, let me rewrite the preceding SimpleType so that you can see an observable difference.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SimpleType</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IDisposable</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"public Dispose"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token return-type class-name"><span class="token keyword">void</span></span> IDisposable<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"IDisposable Dispose"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Without changing the Main method shown earlier, if we just recompile and rerun the program, the output will be the following.</p></blockquote><pre><code>public Dispose 
IDisposable Dispose
</code></pre><blockquote><p>In C#, when you prefix the name of a method with the name of the interface that defines the method (IDisposable.Dispose as in this example), you are creating an explicit interface method implementation (EIMI). Note that when you define an explicit interface method in C#, you are not allowed to specify any accessibility (such as public or private). However, when the compiler generates the metadata for the method, its accessibility is set to private, preventing any code using an instance of the class from simply calling the interface method. The only way to call the interface method is through a variable of the interface’s type.</p></blockquote><blockquote><p>Also note that an EIMI method cannot be marked as virtual and therefore cannot be overridden. This is because the EIMI method is not really part of the type’s object model; it’s a way of attaching an interface (set of behaviors or methods) onto a type without making the behaviors/methods obvious. If all of this seems a bit kludgy to you, you are understanding it correctly—this is all a bit kludgy. Later in this chapter, I’ll show some valid reasons for using EIMIs.</p></blockquote><p>💡小结：类型加载到 CLR 中时，会为该类型创建并初始化一个方法表。在这个方法表中，类型引入的每个新方法都有对应的记录项；另外，还为该类型继承的所有虚方法添加了记录项。记录的虚方法既有继承层次结构中的各个基类型定义的，也有接口类型定义的。在上面的例子中，我们在 <code>SimpleType</code> 中定义了 <code>Dispose</code> 方法，为简化编程，C# 编译器假定 <code>SimpleType</code> 引入的 <code>Dispose</code> 方法是对 <code>IDisposable</code> 的 <code>Dispose</code> 方法的实现。之所以这样假定，是由于 <code>Dispose</code> 方法的可访问性是 public，而接口方法的签名和新引入的方法完全一致。如果新的 <code>Dispose</code> 方法被标记为 virtual，C# 编译器仍然认为该方法匹配接口方法。C# 编译器将新方法和接口方法匹配起来之后，会生成元数据，指明 <code>SimpleType</code> 类型的方法表中的两个记录项应引用同一个实现。由于 C# 要求公共 <code>Dispose</code> 方法同时是 <code>IDisposable</code> 的 <code>Dispose</code> 方法的实现，所以会执行相同的代码。在 C# 中，将定义方法的那个接口的名称作为作为方法名前缀（例如 <code>IDisposable.Dispose</code> ），就会创建显式接口方法实现（Explicit Interface Method Implementation，EIMI）。注意，C# 中不允许在定义显式接口方法时指定可访问性（比如 public 或 private）。但是，编译器生成方法的元数据时，可访问行会自动设为 private，防止其他代码在使用类的实例时直接调用接口方法。只有通过接口类型的变量才能调用接口方法。还要注意，EIMI 方法不能标记为 virtual，所以不能被重写。这是由于 EIMI 方法并非真的是类型的对象模型的一部分，它只是将接口（一组行为或方法）和类型联系起来，同时避免公开行为 / 方法。</p><h2 id="generic-interfaces"><a class="anchor" href="#generic-interfaces">#</a> Generic Interfaces</h2><blockquote><p>C#’s and the CLR’s support of generic interfaces offers many great features for developers. In this section, I’d like to discuss the benefits offered when using generic interfaces.</p></blockquote><blockquote><p>First, generic interfaces offer great compile-time type safety. Some interfaces (such as the nongeneric IComparable interface) define methods that have Object parameters or return types. When code calls these interface methods, a reference to an instance of any type can be passed. But this is usually not desired. The following code demonstrates.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SomeMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">IComparable</span> c <span class="token operator">=</span> x<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// CompareTo expects an Object; passing y (an Int32) is OK </span></pre></td></tr><tr><td data-num="5"></td><td><pre> c<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// y is boxed here </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// CompareTo expects an Object; passing "2" (a String) compiles </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// but an ArgumentException is thrown at runtime </span></pre></td></tr><tr><td data-num="8"></td><td><pre> c<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Obviously, it is preferable to have the interface method strongly typed, and this is why the FCL includes a generic IComparable interface.</p></blockquote><blockquote><p>Here is the new version of the code revised by using the generic interface.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SomeMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">IComparable<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">></span></span> c <span class="token operator">=</span> x<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// CompareTo expects an Int32; passing y (an Int32) is OK </span></pre></td></tr><tr><td data-num="5"></td><td><pre> c<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// y is not boxed here </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// CompareTo expects an Int32; passing "2" (a String) results </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// in a compiler error indicating that String cannot be cast to an Int32 </span></pre></td></tr><tr><td data-num="8"></td><td><pre> c<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The second benefit of generic interfaces is that much less boxing will occur when working with value types. Notice in SomeMethod1 that the non-generic IComparable interface’s CompareTo method expects an Object; passing y (an Int32 value type) causes the value in y to be boxed. However, in SomeMethod2, the generic IComparable interface’s CompareTo method expects an Int32; passing y causes it to be passed by value, and no boxing is necessary.</p></blockquote><p>💡注意 FCL 定义了 <code>IComparable</code> ， <code>ICollection</code> ， <code>IList</code> 和 <code>IDictionary</code> 等接口的泛型和非泛型版本。定义类型时要实现其中任何接口，一般应实现泛型版本。FCL 保留非泛型版本是为了向后兼容，照顾在 .NET Framework 支持泛型之前写的代码。非泛型版本还允许用户以较常规的、类型较不安全 (more general,less type-safe) 的方式处理数据。</p><p>有的泛型接口继承了非泛型版本，所以必须同时实现接口的泛型和非泛型版本。例如，泛型 <code>IEnumerable&lt;out T&gt;</code> 接口继承了非泛型 <code>IEnumerable</code> 接口，所以实现 <code>IEnumerable&lt;out T&gt;</code> 就必须实现 <code>IEnumerable</code> 。</p><p>和其他代码集成时，有时必须实现非泛型接口，因为接口的泛型版本并不存在。这时，如果接口的任何方法获取或返回 <code>Object</code> ，就会失去编译时的类型安全性，而且值类型将发生装箱。可利用本章 13.9 节 “用显式接口方法实现来增强编译时类型安全性” 介绍的技术来缓解该问题。</p><blockquote><p>The third benefit of generic interfaces is that a class can implement the same interface multiple times as long as different type parameters are used.</p></blockquote><blockquote><p>The following code shows an example of how useful this could be.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// This class implements the generic IComparable&lt;T> interface twice </span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Number</span><span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IComparable<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">></span></span><span class="token punctuation">,</span> <span class="token class-name">IComparable<span class="token punctuation">&lt;</span>String<span class="token punctuation">></span></span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_val <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// This method implements IComparable&lt;Int32>'s CompareTo </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">return</span> m_val<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// This method implements IComparable&lt;String>'s CompareTo </span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">return</span> m_val<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>Int32<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token class-name">Number</span> n <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Number</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token comment">// Here, I compare the value in n with an Int32 (5) </span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token class-name">IComparable<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">></span></span> cInt32 <span class="token operator">=</span> n<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token class-name">Int32</span> result <span class="token operator">=</span> cInt32<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token comment">// Here, I compare the value in n with a String ("5") </span></pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token class-name">IComparable<span class="token punctuation">&lt;</span>String<span class="token punctuation">></span></span> cString <span class="token operator">=</span> n<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="22"></td><td><pre> result <span class="token operator">=</span> cString<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token string">"5"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>An interface’s generic type parameters can also be marked as contra-variant and covariant, which allows even more flexibility for using generic interfaces. For more about contra-variance and covariance, see the “Delegate and Interface Contra-variant and Covariant Generic Type Arguments” section in Chapter 12.</p></blockquote><p>💡小结：C# 和 CLR 所支持的泛型接口为开发人员提供了需要非常出色的功能。首先，泛型接口提供了出色的编译时类型安全性。接口方法理想情况下应该使用强类型。这正是 FCL 为什么包含众多泛型接口的原因。泛型接口的第二个好处在于，处理值类型时装箱次数会少很多。泛型接口的第三个好处在于，类可以实现同一个接口若干次，只要每次使用不同的类型参数。接口的泛型类型参数可标记为逆变和协变，为泛型接口的使用提供更大的灵活性。</p><h2 id="generics-and-interface-constraints"><a class="anchor" href="#generics-and-interface-constraints">#</a> Generics and Interface Constraints</h2><blockquote><p>In the previous section, I discussed the benefits of using generic interfaces. In this section, I’ll discuss the benefits of constraining generic type parameters to interfaces.</p></blockquote><blockquote><p>The first benefit is that you can constrain a single generic type parameter to multiple interfaces. When you do this, the type of parameter you are passing in must implement all of the interface constraints.</p></blockquote><blockquote><p>Here is an example.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">Guid</span> g <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Guid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// This call to M compiles fine because </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Int32 implements IComparable AND IConvertible </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token function">M</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// This call to M causes a compiler error because </span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// Guid implements IComparable but it does not implement IConvertible </span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token function">M</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// M's type parameter, T, is constrained to work only with types that </span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token comment">// implement both the IComparable AND IConvertible interfaces </span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token generic-method"><span class="token function">M</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token keyword">where</span> <span class="token class-name">T</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IComparable</span><span class="token punctuation">,</span> <span class="token class-name">IConvertible</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token range operator">..</span><span class="token punctuation">.</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>This is actually quite cool! When you define a method’s parameters, each parameter’s type indicates that the argument passed must be of the parameter’s type or be derived from it. If the parameter type is an interface, this indicates that the argument can be of any class type as long as the class implements the interface. Using multiple interface constraints actually lets the method indicate that the passed argument must implement multiple interfaces.</p></blockquote><blockquote><p>In fact, if we constrained T to a class and two interfaces, we are saying that the type of argument passed must be of the specified base class (or derived from it), and it must also implement the two interfaces. This flexibility allows the method to really dictate what callers can pass, and compiler errors will be generated if callers do not meet these constraints.</p></blockquote><blockquote><p>The second benefit of interface constraints is reduced boxing when passing instances of value types. In the previous code fragment, the M method was passed x (an instance of an Int32, which is a value type). No boxing will occur when x is passed to M. If code inside M does call t.CompareTo(...), still no boxing occurs to make the call (boxing may still happen for arguments passed to CompareTo).</p></blockquote><blockquote><p>On the other hand, if M had been declared like this:</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token function">M</span><span class="token punctuation">(</span><span class="token class-name">IComparable</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token range operator">..</span><span class="token punctuation">.</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>then in order to pass x to M, x would have to be boxed.</p></blockquote><blockquote><p>For interface constraints, the C# compiler emits certain Intermediate Language (IL) instructions that result in calling the interface method on the value type directly without boxing it. Aside from using interface constraints, there is no other way to get the C# compiler to emit these IL instructions, and therefore, calling an interface method on a value type always causes boxing.</p></blockquote><p>💡小结：将泛型类型参数约束为接口有两个好处。第一个好处在于，可将泛型类型参数约束为多个接口。这样一来，传递的参数的类型必须实现全部接口约束。如果将 T 约束为一个类和两个接口，就表示传递的实参类型必须是指定的基类（或者它的派生类），而且必须实现两个接口。这种灵活性使方法能细致地约束调用者能传递的内容。调用者不满足这些约束，就会产生编译错误。接口约束的第二个好处是传递值类型的实例时减少装箱。C# 编译器为接口约束生成特殊 IL 指令，导致直接在值类型上调用接口方法而不装箱。不用接口约束便没有其他办法让 C# 编译器生成这些 IL 指令。如此一来，在值类型上调用接口方法总是发生装箱。一个例外是如果值类型实现了一个接口方法，在值类型的实例上调用这个方法不会造成值类型的实例装箱。</p><h2 id="implementing-multiple-interfaces-that-have-the-same-method-name-and-signature"><a class="anchor" href="#implementing-multiple-interfaces-that-have-the-same-method-name-and-signature">#</a> Implementing Multiple Interfaces That Have the Same Method Name and Signature</h2><blockquote><p>Occasionally, you might find yourself defining a type that implements multiple interfaces that define methods with the same name and signature. For example, imagine that there are two interfaces defined as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IWindow</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token return-type class-name">Object</span> <span class="token function">GetMenu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IRestaurant</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token return-type class-name">Object</span> <span class="token function">GetMenu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Let’s say that you want to define a type that implements both of these interfaces. You’d have to implement the type’s members by using explicit interface method implementations as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// This type is derived from System.Object and </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// implements the IWindow and IRestaurant interfaces. </span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">MarioPizzeria</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IWindow</span><span class="token punctuation">,</span> <span class="token class-name">IRestaurant</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// This is the implementation for IWindow's GetMenu method. </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token return-type class-name">Object</span> IWindow<span class="token punctuation">.</span><span class="token function">GetMenu</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// This is the implementation for IRestaurant's GetMenu method. </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token return-type class-name">Object</span> IRestaurant<span class="token punctuation">.</span><span class="token function">GetMenu</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// This (optional method) is a GetMenu method that has nothing </span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// to do with an interface. </span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Object</span> <span class="token function">GetMenu</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Because this type must implement multiple and separate GetMenu methods, you need to tell the C# compiler which GetMenu method contains the implementation for a particular interface.</p></blockquote><blockquote><p>Code that uses a MarioPizzeria object must cast to the specific interface to call the desired method. The following code demonstrates.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">MarioPizzeria</span> mp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">MarioPizzeria</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// This line calls MarioPizzeria's public GetMenu method </span></pre></td></tr><tr><td data-num="3"></td><td><pre>mp<span class="token punctuation">.</span><span class="token function">GetMenu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// These lines call MarioPizzeria's IWindow.GetMenu method </span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token class-name">IWindow</span> window <span class="token operator">=</span> mp<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre>window<span class="token punctuation">.</span><span class="token function">GetMenu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// These lines call MarioPizzeria's IRestaurant.GetMenu method </span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token class-name">IRestaurant</span> restaurant <span class="token operator">=</span> mp<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre>restaurant<span class="token punctuation">.</span><span class="token function">GetMenu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>💡小结：定义实现多个接口的类型时，这些接口可能定义了具有相同名称和签名的方法。要定义实现这两个接口的类型，必须使用 “显式接口方法实现” 来实现这个类型的成员，并在使用对应接口的方法时需要将其转换为具体的接口才能调用所需的方法。</p><h2 id="improving-compile-time-type-safety-with-explicit-interface-method-implementations"><a class="anchor" href="#improving-compile-time-type-safety-with-explicit-interface-method-implementations">#</a> Improving Compile-Time Type Safety with Explicit Interface Method Implementations</h2><blockquote><p>Interfaces are great because they define a standard way for types to communicate with each other. Earlier, I talked about generic interfaces and how they improve compile-time type safety and reduce boxing. Unfortunately, there may be times when you need to implement a non-generic interface because a generic version doesn’t exist. If any of the interface’s method(s) accept parameters of type System.Object or return a value whose type is System.Object, you will lose compile-time type safety, and you will get boxing. In this section, I’ll show you how you can use EIMI to improve this situation somewhat.</p></blockquote><blockquote><p>Look at the very common IComparable interface.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IComparable</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token return-type class-name">Int32</span> <span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token class-name">Object</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>This interface defines one method that accepts a parameter of type System.Object. If I define my own type that implements this interface, the type definition might look like the following.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">struct</span> <span class="token class-name">SomeValueType</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IComparable</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_x<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token function">SomeValueType</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> m_x <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token class-name">Object</span> other<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">return</span><span class="token punctuation">(</span>m_x <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>SomeValueType<span class="token punctuation">)</span> other<span class="token punctuation">)</span><span class="token punctuation">.</span>m_x<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Using SomeValueType, I can now write the following code.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">SomeValueType</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SomeValueType</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Object</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">Int32</span> n <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Undesired boxing </span></pre></td></tr><tr><td data-num="5"></td><td><pre> n <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// InvalidCastException </span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>There are two characteristics of this code that are not ideal.</p><ul><li><p>Undesired boxing When v is passed as an argument to the CompareTo method, it must be boxed because CompareTo expects an Object.</p></li><li><p>The lack of type safety This code compiles, but an InvalidCastException is thrown inside the CompareTo method when it attempts to cast o to SomeValueType.</p></li></ul></blockquote><blockquote><p>Both of these issues can be fixed by using EIMIs. Here’s a modified version of SomeValueType that has an EIMI added to it.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">struct</span> <span class="token class-name">SomeValueType</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IComparable</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_x<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token function">SomeValueType</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> m_x <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token class-name">SomeValueType</span> other<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">return</span><span class="token punctuation">(</span>m_x <span class="token operator">-</span> other<span class="token punctuation">.</span>m_x<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// NOTE: No public/private used on the next line </span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token return-type class-name">Int32</span> IComparable<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token class-name">Object</span> other<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">return</span> <span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token punctuation">(</span>SomeValueType<span class="token punctuation">)</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Notice several changes in this new version. First, it now has two CompareTo methods. The first CompareTo method no longer takes an Object as a parameter; it now takes a SomeValueType instead. Because this parameter has changed, the code that casts other to SomeValueType is no longer necessary and has been removed. Second, changing the first CompareTo method to make it type-safe means that SomeValueType no longer adheres to the contract placed on it by implementing the IComparable interface. So SomeValueType must implement a CompareTo method that satisfies the IComparable contract. This is the job of the second IComparable.CompareTo method, which is an EIMI.</p></blockquote><blockquote><p>Having made these two changes means that we now get compile-time type safety and no boxing.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">SomeValueType</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SomeValueType</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Object</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">Int32</span> n <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// No boxing </span></pre></td></tr><tr><td data-num="5"></td><td><pre> n <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// compile-time error </span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>If, however, we define a variable of the interface type, we will lose compile-time type safety and experience undesired boxing again.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">SomeValueType</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SomeValueType</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">IComparable</span> c <span class="token operator">=</span> v<span class="token punctuation">;</span> <span class="token comment">// Boxing! </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">Object</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token class-name">Int32</span> n <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Undesired boxing </span></pre></td></tr><tr><td data-num="6"></td><td><pre> n <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// InvalidCastException </span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In fact, as mentioned earlier in this chapter, when casting a value type instance to an interface type, the CLR must box the value type instance. Because of this fact, two boxings will occur in the previous Main method.</p></blockquote><blockquote><p>EIMIs are frequently used when implementing interfaces such as IConvertible, ICollection, IList, and IDictionary. They let you create type-safe versions of these interfaces’ methods, and they enable you to reduce boxing operations for value types.</p></blockquote><p>💡小结：有时由于不存在泛型版本的接口，所以仍需实现非泛型接口。接口的任何方法接口 <code>System.Object</code> 类型的参数或返回 <code>System.Object</code> 类型的值，就会失去编译时的类型安全性，装箱也会发生。这两个问题都可以用 EIMI 解决。不过，定义接口类型的变量会再次失去编译时的类型安全性，而且会再次发生装箱。实现 <code>IConvertible</code> ， <code>ICollection</code> ， <code>IList</code> 和 <code>IDictionary</code> 等接口时 EIMI 很有用。可利用它为这些接口的方法创建类型安全的版本，并减少值类型的装箱。</p><h2 id="be-careful-with-explicit-interface-method-implementations"><a class="anchor" href="#be-careful-with-explicit-interface-method-implementations">#</a> Be Careful with Explicit Interface Method Implementations</h2><blockquote><p>It is critically important for you to understand some ramifications that exist when using EIMIs. And because of these ramifications, you should try to avoid EIMIs as much as possible. Fortunately, generic interfaces help you avoid EIMIs quite a bit. But there may still be times when you will need to use them (such as implementing two interface methods with the same name and signature). Here are the big problems with EIMIs:</p><ul><li><p>There is no documentation explaining how a type specifically implements an EIMI method, and there is no Microsoft Visual Studio IntelliSense support.</p></li><li><p>Value type instances are boxed when cast to an interface.</p></li><li><p>An EIMI cannot be called by a derived type.</p></li></ul></blockquote><blockquote><p>Let’s take a closer look at these problems.</p></blockquote><blockquote><p>When examining the methods for a type in the .NET Framework reference documentation, explicit interface method implementations are listed, but no type-specific help exists; you can just read the general help about the interface methods. For example, the documentation for the Int32 type shows that it implements all of <code>IConvertible</code> interface’s methods. This is good because developers know that these methods exist; however, this has been very confusing to developers because you can’t call an <code>IConvertible</code> method on an Int32 directly. For example, the following method won’t compile.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Single</span> s <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">ToSingle</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Trying to call an IConvertible method </span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When compiling this method, the C# compiler produces the following message: messagepil17: 'int' does not contain a definition for ' <code>ToSingle</code> '. This error message confuses the developer because it’s clearly stating that the Int32 type doesn’t define a <code>ToSingle</code> method when, in fact, it does.</p></blockquote><blockquote><p>To call <code>oSingle</code> on an Int32, you must first cast the Int32 to an <code>IConvertible</code> , as shown in the following method.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Single</span> s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>IConvertible<span class="token punctuation">)</span> x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToSingle</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Requiring this cast isn’t obvious at all, and many developers won’t figure this out on their own. But an even more troublesome problem exists: casting the Int32 value type to an <code>IConvertible</code> also boxes the value type, wasting memory and hurting performance. This is the second of the big problems I mentioned at the beginning of this section.</p></blockquote><blockquote><p>The third and perhaps the biggest problem with EIMIs is that they cannot be called by a derived class. Here is an example.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IComparable</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Explicit Interface Method Implementation </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token return-type class-name">Int32</span> IComparable<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Base's CompareTo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Base</span><span class="token punctuation">,</span> <span class="token class-name">IComparable</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// A public method that is also the interface implementation </span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Derived's CompareTo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// This attempt to call the base class's EIMI causes a compiler error: </span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token comment">// error CS0117: 'Base' does not contain a definition for 'CompareTo' </span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In <code>Derived</code> ’s <code>CompareTo</code> method, I try to call <code>base.CompareTo</code> , but this causes the C# compiler to issue an error. The problem is that the Base class doesn’t offer a public or protected <code>CompareTo</code> method that can be called; it offers a <code>CompareTo</code> method that can be called only by using a variable that is of the <code>IComparable</code> type. I could modify <code>Derived</code> ’s <code>CompareTo</code> method so that it looks like the following.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// A public method that is also the interface implementation </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Derived's CompareTo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// This attempt to call the base class's EIMI causes infinite recursion </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token class-name">IComparable</span> c <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> c<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In this version, I am casting this to an <code>IComparable</code> variable, c. And then, I use c to call <code>CompareTo</code> . However, the <code>Derived</code> ’s public <code>CompareTo</code> method serves as the implementation for <code>Derived</code> ’s <code>IComparableCompareTo</code> method, and therefore, infinite recursion occurs. This could be fixed by declaring the Derived class without the <code>IComparable</code> interface, like the following.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Base</span></span> <span class="token comment">/*, IComparable */</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Now the previous <code>CompareTo</code> method will call the <code>CompareTo</code> method in Base. But sometimes you cannot simply remove the interface from the type because you want the derived type to implement an interface method. The best way to fix this is for the base class to provide a virtual method in addition to the interface method that it has chosen to implement explicitly. Then the Derived class can override the virtual method. Here is the correct way to define the Base and Derived classes.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IComparable</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Explicit Interface Method Implementation </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token return-type class-name">Int32</span> IComparable<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Base's IComparable CompareTo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">return</span> <span class="token function">CompareTo</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// This now calls the virtual method </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// Virtual method for derived classes (this method could have any name) </span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token return-type class-name">Int32</span> <span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Base's virtual CompareTo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Base</span><span class="token punctuation">,</span> <span class="token class-name">IComparable</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token comment">// A public method that is also the interface implementation </span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name">Int32</span> <span class="token function">CompareTo</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Derived's CompareTo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token comment">// Now, we can call Base's virtual method </span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token keyword">return</span> <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Note that I have defined the virtual method above as a public method, but in some cases, you will prefer to make the method protected instead. It is fine to make this method protected instead of public, but that will necessitate other minor changes. This discussion clearly shows you that EIMIs should be used with great care. When many developers first learn about EIMIs, they think that they’re cool and they start using them whenever possible. Don’t do this! EIMIs are useful in some circumstances, but you should avoid them whenever possible because they make using a type much more difficult.</p></blockquote><p>💡小结：使用 EIMI 也可能造成一些严重后果，所以应该尽量避免使用 EIMI。EIMI 最主要的问题如下：没有文档解释类型具体如何实现一个 EIMI 方法；值类型的实例在转换成接口时装箱；EIMI 不能由派生类型调用。解决派生类调用问题的最佳方法是在基类中除了提供一个被选为显式实现的接口方法，还要提供一个虚方法。</p><h2 id="design-base-class-or-interface"><a class="anchor" href="#design-base-class-or-interface">#</a> Design: Base Class or Interface?</h2><blockquote><p>I often hear the question, “Should I design a base type or an interface?” The answer isn’t always clearcut. Here are some guidelines that might help you:</p><ul><li><p>IS-A vs. CAN-DO relationship A type can inherit only one implementation. If the derived type can’t claim an IS-A relationship with the base type, don’t use a base type; use an interface. Interfaces imply a CAN-DO relationship. If the CAN-DO functionality appears to belong with various object types, use an interface. For example, a type can convert instances of itself to another type (IConvertible), a type can serialize an instance of itself (ISerializable), etc. Note that value types must be derived from System.ValueType, and therefore, they cannot be derived from an arbitrary base class. In this case, you must use a CAN-DO relationship and define an interface.</p></li><li><p>Ease of use It’s generally easier for you as a developer to define a new type derived from a base type than to implement all of the methods of an interface. The base type can provide a lot of functionality, so the derived type probably needs only relatively small modifications to its behavior. If you supply an interface, the new type must implement all of the members.</p></li><li><p>Consistent implementation No matter how well an interface contract is documented, it’s very unlikely that everyone will implement the contract 100 percent correctly. In fact, COM suffers from this very problem, which is why some COM objects work correctly only with Microsoft Word or with Windows Internet Explorer. By providing a base type with a good default implementation, you start off using a type that works and is well tested; you can then modify parts that need modification.</p></li><li><p>Versioning If you add a method to the base type, the derived type inherits the new method, you start off using a type that works, and the user’s source code doesn’t even have to be recompiled. Adding a new member to an interface forces the inheritor of the interface to change its source code and recompile.</p></li></ul></blockquote><blockquote><p>In the FCL, the classes related to streaming data use an implementation inheritance design. The System.IO.Stream class is the abstract base class. It provides a bunch of methods, such as Read and Write. Other classes—System.IO.FileStream, System.IO.MemoryStream, and <span class="exturl" data-url="aHR0cDovL1N5c3RlbS5OZXQ=">System.Net</span>. Sockets.NetworkStream—are derived from Stream. Microsoft chose an IS-A relationship between each of these three classes and the Stream class because it made implementing the concrete classes easier. For example, the derived classes need to implement only synchronous I/O operations; they inherit the ability to perform asynchronous I/O operations from the Stream base class.</p></blockquote><blockquote><p>Admittedly, choosing to use inheritance for the stream classes isn’t entirely clear-cut; the Stream base class actually provides very little implementation. However, if you consider the Windows Forms control classes, in which Button, CheckBox, ListBox, and all of the other controls are derived from System.Windows.Forms.Control, it’s easy to imagine all of the code that Control implements, which the various control classes simply inherit to function correctly.</p></blockquote><blockquote><p>By contrast, Microsoft designed the FCL collections to be interface based. The System.Collections.Generic namespace defines several collection-related interfaces: IEnumerable, ICollection, IList, and IDictionary. Then Microsoft provided a number of classes, such as List, Dictionary, Queue, Stack, and so on, that implement combinations of these interfaces. Here the designers chose a CAN-DO relationship between the classes and the interfaces because the implementations of these various collection classes are radically different from one another. In other words, there isn’t a lot of sharable code between a List, a Dictionary, and a Queue.</p></blockquote><blockquote><p>The operations these collection classes offer are, nevertheless, pretty consistent. For example, they all maintain a set of elements that can be enumerated, and they all allow adding and removing of elements. If you have a reference to an object whose type implements the IList interface, you can write code to insert elements, remove elements, and search for an element without having to know exactly what type of collection you’re working with. This is a very powerful mechanism.</p></blockquote><blockquote><p>Finally, it should be pointed out that you can actually do both: define an interface and provide a base class that implements the interface. For example, the FCL defines the IComparer interface and any type can choose to implement this interface. In addition, the FCL provides an abstract base class, Comparer, which implements this interface and provides a default implementation for the non-generic IComparer’s Compare method. Having both an interface definition and a base class offers great flexibility because developers can now choose whichever they prefer.</p></blockquote><p>💡小结：选择基类还是接口可以从几个方面来考虑：1.IS-A 对比 CAN-DO 关系，如果派生类型和基类型建立不起 IS-A 关系，就不用基类而用接口。接口意味着 CAN-DO 关系。如果多种对象类型都 “能” 做某事，就为它们创建接口。2. 易用性，基类型可提供大量功能，所以派生类型可能只需稍微做改动。而提供接口的话，新类型必须实现所有成员。3. 一致性实现，无论接口协定（contract）订立得有多好，都无法保证所有人百分之百正确实现它。而如果为基类型提供良好的默认实现，那么一开始得到的就是能正常工作并经过良好测试的类型。以后根据需要修改就可以了。4. 版本控制，向基类型添加一个方法，派生类型将继承新方法。一开始使用的就是一个能正常工作的类型，用户的源代码甚至不需要重新编译。而向接口添加新成员，会强迫接口的继承者更改其源代码并重新编译。</p><div class="tags"><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 读书笔记</a> <a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C#</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2022-11-05 16:07:30" itemprop="dateModified" datetime="2022-11-05T16:07:30+08:00">2022-11-05</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Sakupinera WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Sakupinera Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Sakupinera PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Sakupinera <i class="ic i-at"><em>@</em></i>Sakupinera</li><li class="link"><strong>Post link: </strong><a href="http://sakupinera.github.io/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/" title="CLR via C# - Chapter 13 Interfaces">http://sakupinera.github.io/2022/11/04/csharp/clr-via-csharp/Chapter 13 Interfaces/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;03&#x2F;08&#x2F;iXZtNJQI2kjGuqS.jpg" title="CLR via C# - Chapter 12 Generics"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 12 Generics</h3></a></div><div class="item right"><a href="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;03&#x2F;08&#x2F;dhkXYZz7ENHoCeL.png" title="CLR via C# - Chapter 14 Chars, Strings, and Working with Text"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 14 Chars, Strings, and Working with Text</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-13-interfaces"><span class="toc-number">1.</span> <span class="toc-text">Chapter 13 Interfaces</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#class-and-interface-inheritance"><span class="toc-number">1.1.</span> <span class="toc-text">Class and Interface Inheritance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#defining-an-interface"><span class="toc-number">1.2.</span> <span class="toc-text">Defining an Interface</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inheriting-an-interface"><span class="toc-number">1.3.</span> <span class="toc-text">Inheriting an Interface</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#more-about-calling-interface-methods"><span class="toc-number">1.4.</span> <span class="toc-text">More About Calling Interface Methods</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#implicit-and-explicit-interface-method-implementations-whats-happening-behind-the-scenes"><span class="toc-number">1.5.</span> <span class="toc-text">Implicit and Explicit Interface Method Implementations (What’s Happening Behind the Scenes)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#generic-interfaces"><span class="toc-number">1.6.</span> <span class="toc-text">Generic Interfaces</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#generics-and-interface-constraints"><span class="toc-number">1.7.</span> <span class="toc-text">Generics and Interface Constraints</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#implementing-multiple-interfaces-that-have-the-same-method-name-and-signature"><span class="toc-number">1.8.</span> <span class="toc-text">Implementing Multiple Interfaces That Have the Same Method Name and Signature</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#improving-compile-time-type-safety-with-explicit-interface-method-implementations"><span class="toc-number">1.9.</span> <span class="toc-text">Improving Compile-Time Type Safety with Explicit Interface Method Implementations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#be-careful-with-explicit-interface-method-implementations"><span class="toc-number">1.10.</span> <span class="toc-text">Be Careful with Explicit Interface Method Implementations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#design-base-class-or-interface"><span class="toc-number">1.11.</span> <span class="toc-text">Design: Base Class or Interface?</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"><ul><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/" rel="bookmark" title="CLR via C# - Chapter 1 The CLR’s Execution Model">CLR via C# - Chapter 1 The CLR’s Execution Model</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/" rel="bookmark" title="CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types">CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%203%20Shared%20Assemblies%20and%20Strongly%20Named%20Assemblies/" rel="bookmark" title="CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies">CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies</a></li><li><a href="/2022/09/27/csharp/clr-via-csharp/Chapter%204%20Type%20Fundamentals/" rel="bookmark" title="CLR via C# - Chapter 4 Type Fundamentals">CLR via C# - Chapter 4 Type Fundamentals</a></li><li><a href="/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/" rel="bookmark" title="CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals">CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals</a></li><li><a href="/2022/10/21/csharp/clr-via-csharp/Chapter%206%20Type%20and%20Member%20Basics/" rel="bookmark" title="CLR via C# - Chapter 6 Type and Member Basics">CLR via C# - Chapter 6 Type and Member Basics</a></li><li><a href="/2022/10/24/csharp/clr-via-csharp/Chapter%207%20Constants%20and%20Fields/" rel="bookmark" title="CLR via C# - Chapter 7 Constants and Fields">CLR via C# - Chapter 7 Constants and Fields</a></li><li><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" rel="bookmark" title="CLR via C# - Chapter 8 Methods">CLR via C# - Chapter 8 Methods</a></li><li><a href="/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/" rel="bookmark" title="CLR via C# - Chapter 9 Parameters">CLR via C# - Chapter 9 Parameters</a></li><li><a href="/2022/10/28/csharp/clr-via-csharp/Chapter%2010%20Properties/" rel="bookmark" title="CLR via C# - Chapter 10 Properties">CLR via C# - Chapter 10 Properties</a></li><li><a href="/2022/10/29/csharp/clr-via-csharp/Chapter%2011%20Events/" rel="bookmark" title="CLR via C# - Chapter 11 Events">CLR via C# - Chapter 11 Events</a></li><li><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" rel="bookmark" title="CLR via C# - Chapter 12 Generics">CLR via C# - Chapter 12 Generics</a></li><li class="active"><a href="/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/" rel="bookmark" title="CLR via C# - Chapter 13 Interfaces">CLR via C# - Chapter 13 Interfaces</a></li><li><a href="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/" rel="bookmark" title="CLR via C# - Chapter 14 Chars, Strings, and Working with Text">CLR via C# - Chapter 14 Chars, Strings, and Working with Text</a></li><li><a href="/2022/11/17/csharp/clr-via-csharp/Chapter%2015%20Enumerated%20Types%20and%20Bit%20Flags/" rel="bookmark" title="CLR via C# - Chapter 15 Enumerated Types and Bit Flags">CLR via C# - Chapter 15 Enumerated Types and Bit Flags</a></li><li><a href="/2022/11/19/csharp/clr-via-csharp/Chapter%2016%20Arrays/" rel="bookmark" title="CLR via C# - Chapter 16 Arrays">CLR via C# - Chapter 16 Arrays</a></li><li><a href="/2022/11/21/csharp/clr-via-csharp/Chapter%2017%20Delegates/" rel="bookmark" title="CLR via C# - Chapter 17 Delegates">CLR via C# - Chapter 17 Delegates</a></li><li><a href="/2022/11/22/csharp/clr-via-csharp/Chapter%2018%20Custom%20Attributes/" rel="bookmark" title="CLR via C# - Chapter 18 Custom Attributes">CLR via C# - Chapter 18 Custom Attributes</a></li><li><a href="/2022/11/23/csharp/clr-via-csharp/Chapter%2019%20Nullable%20Value%20Types/" rel="bookmark" title="CLR via C# - Chapter 19 Nullable Value Types">CLR via C# - Chapter 19 Nullable Value Types</a></li><li><a href="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/" rel="bookmark" title="CLR via C# - Chapter 20 Exceptions and State Management">CLR via C# - Chapter 20 Exceptions and State Management</a></li><li><a href="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/" rel="bookmark" title="CLR via C# - Chapter 21 The Managed Heap and Garbage  Collection">CLR via C# - Chapter 21 The Managed Heap and Garbage Collection</a></li><li><a href="/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/" rel="bookmark" title="CLR via C# - Chapter 22 CLR Hosting and AppDomains">CLR via C# - Chapter 22 CLR Hosting and AppDomains</a></li><li><a href="/2022/11/29/csharp/clr-via-csharp/Chapter%2023%20Assembly%20Loading%20and%20Reflection/" rel="bookmark" title="CLR via C# - Chapter 23 Assembly Loading and Reflection">CLR via C# - Chapter 23 Assembly Loading and Reflection</a></li><li><a href="/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/" rel="bookmark" title="CLR via C# - Chapter 24 Runtime Serialization">CLR via C# - Chapter 24 Runtime Serialization</a></li><li><a href="/2022/12/06/csharp/clr-via-csharp/Chapter%2025%20Interoperating%20with%20WinRT%20%20Components/" rel="bookmark" title="CLR via C# - Chapter 25 Interoperating with WinRT Components">CLR via C# - Chapter 25 Interoperating with WinRT Components</a></li><li><a href="/2023/02/06/csharp/clr-via-csharp/Chapter%2026%20Thread%20Basics/" rel="bookmark" title="CLR via C# - Chapter 26 Thread Basics">CLR via C# - Chapter 26 Thread Basics</a></li><li><a href="/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations">CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations</a></li><li><a href="/2023/02/08/csharp/clr-via-csharp/Chapter%2028%20IO-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 28 IO-Bound Asynchronous Operations">CLR via C# - Chapter 28 IO-Bound Asynchronous Operations</a></li><li><a href="/2023/02/09/csharp/clr-via-csharp/Chapter%2029%20Primitive%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 29 Primitive Thread Synchronization">CLR via C# - Chapter 29 Primitive Thread Synchronization</a></li><li><a href="/2023/02/10/csharp/clr-via-csharp/Chapter%2030%20Hybrid%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 30 Hybrid Thread Synchronization">CLR via C# - Chapter 30 Hybrid Thread Synchronization</a></li></ul></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sakupinera" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Sakupinera</p><div class="description" itemprop="description">保持你的决心！</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">86</span> <span class="name">posts</span></a></div><div class="item categories"><a href="/categories/"><span class="count">13</span> <span class="name">categories</span></a></div><div class="item tags"><a href="/tags/"><span class="count">6</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nha3VwaW5lcmE=" title="https:&#x2F;&#x2F;github.com&#x2F;sakupinera"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9zYWt1cGluZXJh" title="https:&#x2F;&#x2F;twitter.com&#x2F;sakupinera"><i class="ic i-twitter"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQwNzIyOTA3MQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;407229071"><i class="ic i-cloud-music"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMjIzMDczOTg/c3BtX2lkX2Zyb209MzMzLjEwMDcuMC4w" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;22307398?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li><li class="item"><a href="/games/" rel="section"><i class="ic i-flag"></i>Games</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-person"></i>About</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/08/28/linux/learn-linux/%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/" title="LearnLinux - 用户和用户组管理">LearnLinux - 用户和用户组管理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" title="CLR via C# - Chapter 8 Methods">CLR via C# - Chapter 8 Methods</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/09/05/linux/learn-linux/%E5%90%AF%E5%8A%A8%E7%AE%A1%E7%90%86/" title="LearnLinux - 启动管理">LearnLinux - 启动管理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Network/" title="In Network">Network</a></div><span><a href="/2023/03/21/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">计算机网络</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/" title="CLR via C# - Chapter 14 Chars, Strings, and Working with Text">CLR via C# - Chapter 14 Chars, Strings, and Working with Text</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/08/28/linux/learn-linux/Linux%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/" title="LearnLinux - Linux系统简介">LearnLinux - Linux系统简介</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/08/28/linux/learn-linux/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/" title="LearnLinux - 权限管理">LearnLinux - 权限管理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/08/28/linux/learn-linux/Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/" title="LearnLinux - Linux系统安装">LearnLinux - Linux系统安装</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CSharp-in-a-Nutshell/" title="In CSharp-in-a-Nutshell">CSharp-in-a-Nutshell</a></div><span><a href="/2022/08/29/csharp/csharp-in-a-nutshell/%E7%AC%AC3%E7%AB%A0%20%E5%9C%A8CSharp%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%9E%8B/" title="C# in a Nutshell - 第3章 在C#中创建类型">C# in a Nutshell - 第3章 在C#中创建类型</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/" title="CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types">CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Sakupinera @ Hanamai Sora</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="Symbols count total">2.2m words</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="Reading time total">33:30</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/11/04/csharp/clr-via-csharp/Chapter 13 Interfaces/",favicon:{show:"（●´3｀●）Goooood",hide:"(´Д｀)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/shifuku.model.json"},display:{position:"left",width:250,height:500},mobile:{show:!1},react:{opacity:.9},log:!1})</script></body></html>