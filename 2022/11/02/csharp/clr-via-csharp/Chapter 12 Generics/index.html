<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sakupinera" href="http://sakupinera.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sakupinera" href="http://sakupinera.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sakupinera" href="http://sakupinera.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="è¯»ä¹¦ç¬”è®°,C#"><link rel="canonical" href="http://sakupinera.github.io/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/"><title>CLR via C# - Chapter 12 Generics - CLR-via-CSharp - CSharp | Hanamai Sora = Sakupinera</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">CLR via C# - Chapter 12 Generics</h1><div class="meta"><span class="item" title="Created: 2022-11-02 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2022-11-02T00:00:00+08:00">2022-11-02</time> </span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">Symbols count in article</span> <span>60k</span> <span class="text">words</span> </span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">Reading time</span> <span>54 mins.</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hanamai Sora</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s2.loli.net/2023/03/08/OQq9sc7VlKfnvGL.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/tNhsmAqoTDncM1b.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/mOQfkxXNYp8VGng.png"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/y7LRpQIrAdzbUek.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/wi84uPUELq2rcnD.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/3J2uz5ejLcmstkD.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/" itemprop="item" rel="index" title="In CSharp"><span itemprop="name">CSharp</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/CLR-via-CSharp/" itemprop="item" rel="index" title="In CLR-via-CSharp"><span itemprop="name">CLR-via-CSharp</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://sakupinera.github.io/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Sakupinera"><meta itemprop="description" content=", ä¿æŒä½ çš„å†³å¿ƒï¼"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakupinera"></span><div class="body md" itemprop="articleBody"><h1 id="chapter-12-generics"><a class="anchor" href="#chapter-12-generics">#</a> Chapter 12 Generics</h1><blockquote><p>Developers who are familiar with object-oriented programming know the benefits it offers. One of the big benefits that make developers extremely productive is code reuse, which is the ability to derive a class that inherits all of the capabilities of a base class. The derived class can simply override virtual methods or add some new methods to customize the behavior of the base class to meet the developerâ€™s needs. Generics is another mechanism offered by the common language runtime (CLR) and programming languages that provides one more form of code reuse: algorithm reuse.</p></blockquote><blockquote><p>Basically, one developer defines an algorithm such as sorting, searching, swapping, comparing, or converting. However, the developer defining the algorithm doesnâ€™t specify what data type(s) the algorithm operates on; the algorithm can be generically applied to objects of different types. Another developer can then use this existing algorithm as long as he or she indicates the specific data type(s) the algorithm should operate on, for example, a sorting algorithm that operates on Int32s, Strings, etc., or a comparing algorithm that operates on DateTimes, Versions, etc.</p></blockquote><blockquote><p>Most algorithms are encapsulated in a type, and the CLR allows the creation of generic reference types as well as generic value types, but it does not allow the creation of generic enumerated types. In addition, the CLR allows the creation of generic interfaces and generic delegates. Occasionally, a single method can encapsulate a useful algorithm, and therefore, the CLR allows the creation of generic methods that are defined in a reference type, value type, or interface.</p></blockquote><blockquote><p>Letâ€™s look at a quick example. The Framework Class Library (FCL) defines a generic list algorithm that knows how to manage a set of objects; the data type of these objects is not specified by the generic algorithm. Someone wanting to use the generic list algorithm can specify the exact data type to use with it later.</p></blockquote><blockquote><p>The FCL class that encapsulates the generic list algorithm is called List (pronounced List of Tee), and this class is defined in the System.Collections.Generic namespace. Here is what this class definition looks like (the code is severely abbreviated).</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Serializable</span></span><span class="token punctuation">]</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">List<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IList<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span><span class="token punctuation">,</span> <span class="token class-name">ICollection<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span><span class="token punctuation">,</span> <span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span><span class="token punctuation">,</span> </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">IList</span><span class="token punctuation">,</span> <span class="token class-name">ICollection</span><span class="token punctuation">,</span> <span class="token class-name">IEnumerable</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token function">List</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token class-name">T</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token function">BinarySearch</span><span class="token punctuation">(</span><span class="token class-name">T</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Boolean</span> <span class="token function">Contains</span><span class="token punctuation">(</span><span class="token class-name">T</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token function">IndexOf</span><span class="token punctuation">(</span><span class="token class-name">T</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Boolean</span> <span class="token function">Remove</span><span class="token punctuation">(</span><span class="token class-name">T</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Sort</span><span class="token punctuation">(</span><span class="token class-name">IComparer<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> comparer<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Sort</span><span class="token punctuation">(</span><span class="token class-name">Comparison<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> comparison<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">T<span class="token punctuation">[</span><span class="token punctuation">]</span></span> <span class="token function">ToArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> Count <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">T</span> <span class="token keyword">this</span><span class="token punctuation">[</span><span class="token class-name">Int32</span> index<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The programmer who defined the generic List class indicates that it works with an unspecified data type by placing the immediately after the class name. When defining a generic type or method, any variables it specifies for types (such as T) are called type parameters. T is a variable name that can be used in source code anywhere a data type can be used. For example, in the List class definition, you see T being used for method parameters (the Add method accepts a parameter of type T) and return types (the ToArray method returns a single-dimension array of type T). Another example is the indexer method (called this in C#). The indexer has a get accessor method that returns a value of type T and a set accessor method that accepts a parameter of type T. Because the T variable can be used anywhere that a data type can be specified, it is also possible to use T when defining local variables inside a method or when defining fields inside a type.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šæ ¹æ® Microsoft çš„è®¾è®¡åŸåˆ™ï¼Œæ³›å‹å‚æ•°å˜é‡è¦ä¹ˆç§°ä¸º <code>T</code> ï¼Œè¦ä¹ˆè‡³å°‘ä»¥å¤§å†™ <code>T</code> å¼€å¤´ (å¦‚ <code>TKey</code> å’Œ <code>TValue</code> )ã€‚å¤§å†™ <code>T</code> ä»£è¡¨ç±»å‹ (Type)ï¼Œå°±åƒå¤§å†™ <code>I</code> ä»£è¡¨æ¥å£ (interface) ä¸€æ ·ï¼Œæ¯”å¦‚ <code>IComparable</code> ã€‚</p><blockquote><p>Now that the generic List type has been defined, other developers can use this generic algorithm by specifying the exact data type they would like the algorithm to operate on. When using a generic type or method, the specified data types are referred to as type arguments. For example, a developer might want to work with the List algorithm by specifying a DateTime type argument.</p></blockquote><blockquote><p>Here is some code that shows this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SomeMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Construct a List that operates on DateTime objects </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">List<span class="token punctuation">&lt;</span>DateTime<span class="token punctuation">></span></span> dtList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">List<span class="token punctuation">&lt;</span>DateTime<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// Add a DateTime object to the list </span></pre></td></tr><tr><td data-num="5"></td><td><pre> dtList<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// No boxing </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Add another DateTime object to the list </span></pre></td></tr><tr><td data-num="7"></td><td><pre> dtList<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>DateTime<span class="token punctuation">.</span>MinValue<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// No boxing </span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Attempt to add a String object to the list </span></pre></td></tr><tr><td data-num="9"></td><td><pre> dtList<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">"1/1/2004"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Compile-time error </span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// Extract a DateTime object out of the list </span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token class-name">DateTime</span> dt <span class="token operator">=</span> dtList<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// No cast required </span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Generics provide the following big benefits to developers as exhibited by the code just shown:</p><ul><li><p>Source code protection The developer using a generic algorithm doesnâ€™t need to have access to the algorithmâ€™s source code. With C++ templates, however, the algorithmâ€™s source code must be available to the developer who is using the algorithm.</p></li><li><p>Type safety When a generic algorithm is used with a specific type, the compiler and the CLR understand this and ensure that only objects compatible with the specified data type are used with the algorithm. Attempting to use an object of an incompatible type will result in either a compiler error or a run-time exception being thrown. In the example, attempting to pass a String object to the Add method results in the compiler issuing an error.</p></li><li><p>Cleaner code Because the compiler enforces type safety, fewer casts are required in your source code, meaning that your code is easier to write and maintain. In the last line of SomeMethod, a developer doesnâ€™t need to use a (DateTime) cast to put the result of the indexer (querying element at index 0) into the dt variable.</p></li><li><p>Better performance Before generics, the way to define a generalized algorithm was to define all of its members to work with the Object data type. If you wanted to use the algorithm with value type instances, the CLR had to box the value type instance prior to calling the members of the algorithm. As discussed in Chapter 5, â€œPrimitive, Reference, and Value Types,â€ boxing causes memory allocations on the managed heap, which causes more frequent garbage collections, which, in turn, hurt an applicationâ€™s performance. Because a generic algorithm can now be created to work with a specific value type, the instances of the value type can be passed by value, and the CLR no longer has to do any boxing. In addition, because casts are not necessary (see the previous bullet), the CLR doesnâ€™t have to check the type safety of the attempted cast, and this results in faster code too.</p></li></ul></blockquote><blockquote><p>To drive home the performance benefits of generics, I wrote a program that tests the performance of the generic List algorithm against the FCLâ€™s non-generic ArrayList algorithm. In fact, I tested the performance of these two algorithms by using both value type objects and reference type objects. Here is the program itself.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Collections</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>Generic</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Diagnostics</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token function">ValueTypePerfTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token function">ReferenceTypePerfTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ValueTypePerfTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">const</span> <span class="token class-name">Int32</span> count <span class="token operator">=</span> <span class="token number">100000000</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">OperationTimer</span><span class="token punctuation">(</span><span class="token string">"List&lt;Int32>"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token class-name">List<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">></span></span> l <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">List<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> l<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// No boxing</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token class-name">Int32</span> x <span class="token operator">=</span> l<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// No unboxing</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="18"></td><td><pre> l <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// Make sure this gets garbage collected </span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">OperationTimer</span><span class="token punctuation">(</span><span class="token string">"ArrayList of Int32"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token class-name">ArrayList</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="23"></td><td><pre> a<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Boxing</span></pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token punctuation">(</span>Int32<span class="token punctuation">)</span> a<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Unboxing</span></pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="26"></td><td><pre> a <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// Make sure this gets garbage collected </span></pre></td></tr><tr><td data-num="27"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="28"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="29"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ReferenceTypePerfTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="30"></td><td><pre> <span class="token keyword">const</span> <span class="token class-name">Int32</span> count <span class="token operator">=</span> <span class="token number">100000000</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="31"></td><td><pre> <span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">OperationTimer</span><span class="token punctuation">(</span><span class="token string">"List&lt;String>"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="32"></td><td><pre> <span class="token class-name">List<span class="token punctuation">&lt;</span>String<span class="token punctuation">></span></span> l <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">List<span class="token punctuation">&lt;</span>String<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="33"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="34"></td><td><pre> l<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">"X"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Reference copy</span></pre></td></tr><tr><td data-num="35"></td><td><pre> <span class="token class-name">String</span> x <span class="token operator">=</span> l<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Reference copy</span></pre></td></tr><tr><td data-num="36"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="37"></td><td><pre> l <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// Make sure this gets garbage collected </span></pre></td></tr><tr><td data-num="38"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="39"></td><td><pre> <span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">OperationTimer</span><span class="token punctuation">(</span><span class="token string">"ArrayList of String"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="40"></td><td><pre> <span class="token class-name">ArrayList</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="41"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="42"></td><td><pre> a<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">"X"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Reference copy</span></pre></td></tr><tr><td data-num="43"></td><td><pre> <span class="token class-name">String</span> x <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> a<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Cast check &amp; reference copy</span></pre></td></tr><tr><td data-num="44"></td><td><pre>  <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="45"></td><td><pre> a <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// Make sure this gets garbage collected </span></pre></td></tr><tr><td data-num="46"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="47"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="48"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="49"></td><td><pre><span class="token comment">// This class is useful for doing operation performance timing </span></pre></td></tr><tr><td data-num="50"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">OperationTimer</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IDisposable</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="51"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Stopwatch</span> m_stopwatch<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="52"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">String</span> m_text<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="53"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_collectionCount<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="54"></td><td><pre> <span class="token keyword">public</span> <span class="token function">OperationTimer</span><span class="token punctuation">(</span><span class="token class-name">String</span> text<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="55"></td><td><pre> <span class="token function">PrepareForOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="56"></td><td><pre> m_text <span class="token operator">=</span> text<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="57"></td><td><pre> m_collectionCount <span class="token operator">=</span> GC<span class="token punctuation">.</span><span class="token function">CollectionCount</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="58"></td><td><pre> </pre></td></tr><tr><td data-num="59"></td><td><pre> <span class="token comment">// This should be the last statement in this </span></pre></td></tr><tr><td data-num="60"></td><td><pre> <span class="token comment">// method to keep timing as accurate as possible </span></pre></td></tr><tr><td data-num="61"></td><td><pre> m_stopwatch <span class="token operator">=</span> Stopwatch<span class="token punctuation">.</span><span class="token function">StartNew</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="62"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="63"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="64"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"&#123;0&#125; (GCs=&#123;1,3&#125;) &#123;2&#125;"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>m_stopwatch<span class="token punctuation">.</span>Elapsed<span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="65"></td><td><pre> GC<span class="token punctuation">.</span><span class="token function">CollectionCount</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">-</span> m_collectionCount<span class="token punctuation">,</span> m_text<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="66"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="67"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">PrepareForOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="68"></td><td><pre> GC<span class="token punctuation">.</span><span class="token function">Collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="69"></td><td><pre> GC<span class="token punctuation">.</span><span class="token function">WaitForPendingFinalizers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="70"></td><td><pre> GC<span class="token punctuation">.</span><span class="token function">Collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="71"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="72"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When I compile and run a release build (with optimizations turned on) of this program on my computer, I get the following output.</p></blockquote><pre><code>00:00:01.6246959 (GCs= 6) List&lt;Int32&gt;
00:00:10.8555008 (GCs=390) ArrayList of Int32
00:00:02.5427847 (GCs= 4) List&lt;String&gt;
00:00:02.7944831 (GCs= 7) ArrayList of String
</code></pre><blockquote><p>The output here shows that using the generic List algorithm with the Int32 type is much faster than using the non-generic ArrayList algorithm with Int32. In fact, the difference is phenomenal: 1.6 seconds versus almost 11 seconds. Thatâ€™s ~7 times faster! In addition, using a value type (Int32) with ArrayList causes a lot of boxing operations to occur, which results in 390 garbage collections. Meanwhile, the List algorithm required 6 garbage collections.</p></blockquote><blockquote><p>The result of the test using reference types is not as momentous. Here we see that the times and number of garbage collections are about the same. So it doesnâ€™t appear that the generic List algorithm is of any benefit here. However, keep in mind that when using a generic algorithm, you also get cleaner code and compile-time type safety. So although the performance improvement is not huge, the other benefits you get when using a generic algorithm are usually an improvement.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šåº”è¯¥æ„è¯†åˆ°ï¼Œé¦–æ¬¡ä¸ºç‰¹å®šæ•°æ®ç±»å‹è°ƒç”¨æ–¹æ³•æ—¶ï¼ŒCLR éƒ½ä¼šä¸ºè¿™ä¸ªæ–¹æ³•ç”Ÿæˆæœ¬æœºä»£ç ã€‚è¿™ä¼šå¢å¤§åº”ç”¨ç¨‹åºçš„å·¥ä½œé›† (working set) å¤§å°ï¼Œä»è€ŒæŸå®³æ€§èƒ½ã€‚12.2 â€œæ³›å‹åŸºç¡€ç»“æ„â€ å°†è¿›ä¸€æ­¥æ¢è®¨è¿™ä¸ªé—®é¢˜ã€‚</p><p>ğŸ’¡å°ç»“ï¼šæ³›å‹ï¼ˆgenericï¼‰æ˜¯ CLR å’Œç¼–ç¨‹è¯­è¨€æä¾›çš„ä¸€ç§ç‰¹æ®Šæœºåˆ¶ï¼Œå®ƒæ”¯æŒå¦ä¸€ç§å½¢å¼çš„ä»£ç é‡ç”¨ï¼Œå³ â€œç®—æ³•é‡ç”¨â€ã€‚å¤§å¤šæ•°ç®—æ³•éƒ½å°è£…åœ¨ä¸€ä¸ªç±»å‹ä¸­ï¼ŒCLR å…è®¸åˆ›å»ºæ³›å‹å¼•ç”¨ç±»å‹å’Œæ³›å‹å€¼ç±»å‹ï¼Œä½†ä¸å…è®¸åˆ›å»ºæ³›å‹æšä¸¾ç±»å‹ã€‚æ­¤å¤–ï¼ŒCLR è¿˜å…è®¸åˆ›å»ºæ³›å‹æ¥å£å’Œæ³›å‹å§”æ‰˜ã€‚å®šä¹‰æ³›å‹ç±»å‹æˆ–æ–¹æ³•æ—¶ï¼Œä¸ºç±»å‹æŒ‡å®šçš„ä»»ä½•å˜é‡ï¼ˆæ¯”å¦‚ Tï¼‰éƒ½ç§°ä¸ºç±»å‹å‚æ•°ï¼ˆtype parameterï¼‰ã€‚T æ˜¯å˜é‡åï¼Œæºä»£ç ä½¿ç”¨æ•°æ®ç±»å‹çš„ä»»ä½•åœ°æ–¹éƒ½èƒ½ä½¿ç”¨ Tã€‚ä½¿ç”¨æ³›å‹ç±»å‹æˆ–æ–¹æ³•æ—¶æŒ‡å®šçš„å…·ä½“æ•°æ®ç±»å‹ç§°ä¸ºç±»å‹å®å‚ï¼ˆtype argumentï¼‰ã€‚æ³›å‹ä¸ºå¼€å‘äººå‘˜æä¾›äº†ä¸€äº›ä¼˜åŠ¿ï¼šæºä»£ç ä¿æŠ¤ï¼Œä½¿ç”¨æ³›å‹ç®—æ³•çš„å¼€å‘äººå‘˜ä¸éœ€è¦è®¿é—®ç®—æ³•çš„æºä»£ç ï¼ˆä½¿ç”¨ C++ æ¨¡æ¿çš„æ³›å‹æŠ€æœ¯æ—¶ï¼Œç®—æ³•çš„æºä»£ç å¿…é¡»æä¾›ç»™å‡†å¤‡ä½¿ç”¨ç®—æ³•çš„ç”¨æˆ·ï¼‰ã€‚ç±»å‹å®‰å…¨ï¼Œå°†æ³›å‹ç®—æ³•åº”ç”¨ä¸ä¸€ä¸ªå…·ä½“ç±»å‹æ—¶ï¼Œç¼–è¯‘å™¨å’Œ CLR èƒ½ç†è§£å¼€å‘äººå‘˜çš„æ„å›¾ï¼Œå¹¶ä¿è¯åªæœ‰ä¸æŒ‡å®šæ•°æ®ç±»å‹å…¼å®¹çš„å¯¹è±¡æ‰èƒ½ç”¨äºç®—æ³•ã€‚æ›´æ¸…æ™°çš„ä»£ç ï¼Œç”±äºç¼–è¯‘å™¨å¼ºåˆ¶ç±»å‹å®‰å…¨æ€§ï¼Œæ‰€ä»¥å‡å°‘äº†æºä»£ç ä¸­å¿…é¡»è¿›è¡Œå¼ºåˆ¶ç±»å‹è½¬æ¢æ¬¡æ•°ï¼Œä½¿ä»£ç æ›´å®¹æ˜“ç¼–å†™å’Œç»´æŠ¤ã€‚æ›´ä½³çš„æ€§èƒ½ï¼Œç”±äºç°åœ¨èƒ½åˆ›å»ºä¸€ä¸ªæ³›å‹ç®—æ³•æ¥æ“ä½œä¸€ç§å…·ä½“çš„å€¼ç±»å‹ï¼Œæ‰€ä»¥å€¼ç±»å‹çš„å®ä¾‹èƒ½ä»¥ä¼ å€¼æ–¹å¼ä¼ é€’ï¼ŒCLR ä¸åœ¨éœ€è¦æ‰§è¡Œä»»ä½•è£…ç®±æ“ä½œã€‚æ­¤å¤–ï¼Œç”±äºä¸å†éœ€è¦è¿›è¡Œå¼ºåˆ¶ç±»å‹è½¬æ¢ï¼Œæ‰€ä»¥ CLR æ— éœ€éªŒè¯è¿™ç§è½¬å‹æ˜¯å¦ç±»å‹å®‰å…¨ï¼Œè¿™åŒæ ·æé«˜äº†ä»£ç çš„è¿è¡Œé€Ÿåº¦ã€‚</p><h2 id="generics-in-the-framework-class-library"><a class="anchor" href="#generics-in-the-framework-class-library">#</a> Generics in the Framework Class Library</h2><blockquote><p>Certainly, the most obvious use of generics is with collection classes, and the FCL defines several generic collection classes available for your use. Most of these classes can be found in the System. Collections.Generic namespace and the System.Collections.ObjectModel namespace. There are also thread-safe generic collection classes available in the System.Collections.Concurrent namespace. Microsoft recommends that programmers use the generic collection classes and now discourages use of the non-generic collection classes for several reasons. First, the non-generic collection classes are not generic, and so you donâ€™t get the type safety, cleaner code, and better performance that you get when you use generic collection classes. Second, the generic classes have a better object model than the non-generic classes. For example, fewer methods are virtual, resulting in better performance, and new members have been added to the generic collections to provide new functionality.</p></blockquote><blockquote><p>The collection classes implement many interfaces, and the objects that you place into the collections can implement interfaces that the collection classes use for operations such as sorting and searching. The FCL ships with many generic interface definitions so that the benefits of generics can be realized when working with interfaces as well. The commonly used interfaces are contained in the System.Collections.Generic namespace.</p></blockquote><blockquote><p>The new generic interfaces are not a replacement for the old non-generic interfaces; in many scenarios, you will have to use both. The reason is backward compatibility. For example, if the List class implemented only the IList interface, no code could consider a List object an IList.</p></blockquote><blockquote><p>I should also point out that the System.Array class, the base class of all array types, offers many static generic methods, such as AsReadOnly, BinarySearch, ConvertAll, Exists, Find, FindAll, FindIndex, FindLast, FindLastIndex, ForEach, IndexOf, LastIndexOf, Resize, Sort, and TrueForAll. Here are examples showing what some of these methods look like.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Array</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">ICloneable</span><span class="token punctuation">,</span> <span class="token class-name">IList</span><span class="token punctuation">,</span> <span class="token class-name">ICollection</span><span class="token punctuation">,</span> <span class="token class-name">IEnumerable</span><span class="token punctuation">,</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">IStructuralComparable</span><span class="token punctuation">,</span> <span class="token class-name">IStructuralEquatable</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">Sort</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">T<span class="token punctuation">[</span><span class="token punctuation">]</span></span> array<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">Sort</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">T<span class="token punctuation">[</span><span class="token punctuation">]</span></span> array<span class="token punctuation">,</span> <span class="token class-name">IComparer<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> comparer<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token generic-method"><span class="token function">BinarySearch</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">T<span class="token punctuation">[</span><span class="token punctuation">]</span></span> array<span class="token punctuation">,</span> <span class="token class-name">T</span> <span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Int32</span> <span class="token generic-method"><span class="token function">BinarySearch</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">T<span class="token punctuation">[</span><span class="token punctuation">]</span></span> array<span class="token punctuation">,</span> <span class="token class-name">T</span> <span class="token keyword">value</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token class-name">IComparer<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> comparer<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token range operator">..</span><span class="token punctuation">.</span> </pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Here is code that demonstrates how to use some of these methods.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Create &amp; initialize a byte array </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Byte<span class="token punctuation">[</span><span class="token punctuation">]</span></span> byteArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Byte<span class="token punctuation">[</span><span class="token punctuation">]</span></span> <span class="token punctuation">&#123;</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// Call Byte[] sort algorithm </span></pre></td></tr><tr><td data-num="5"></td><td><pre> Array<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Sort</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>Byte<span class="token punctuation">></span></span></span><span class="token punctuation">(</span>byteArray<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Call Byte[] binary search algorithm </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token class-name">Int32</span> i <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">BinarySearch</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>Byte<span class="token punctuation">></span></span></span><span class="token punctuation">(</span>byteArray<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "0" </span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>ğŸ’¡å°ç»“ï¼šMicrosoft å»ºè®®ä½¿ç”¨æ³›å‹é›†åˆç±»ï¼Œä¸å»ºè®®ä½¿ç”¨éæ³›å‹é›†åˆç±»ã€‚è¿™æ˜¯å‡ºäºå‡ æ–¹é¢çš„è€ƒè™‘ã€‚é¦–å…ˆï¼Œä½¿ç”¨éæ³›å‹é›†åˆç±»ï¼Œæ— æ³•åƒä½¿ç”¨æ³›å‹é›†åˆç±»é‚£æ ·è·å¾—ç±»å‹å®‰å…¨æ€§ã€æ›´æ¸…æ™°çš„ä»£ç ä»¥åŠæ›´ä½³çš„æ€§èƒ½ã€‚å…¶æ¬¡ï¼Œæ³›å‹ç±»å…·æœ‰æ¯”éæ³›å‹æ›´å¥½çš„å¯¹è±¡æ¨¡å‹ã€‚ä¾‹å¦‚ï¼Œè™šæ–¹æ³•æ•°é‡æ˜¾è‘—å˜å°‘ï¼Œæ€§èƒ½æ›´å¥½ã€‚å¦å¤–ï¼Œæ³›å‹é›†åˆç±»å¢æ·»äº†ä¸€äº›æ–°æˆå‘˜ï¼Œä¸ºå¼€å‘äººå‘˜æä¾›äº†æ–°çš„åŠŸèƒ½ã€‚é›†åˆç±»å®ç°äº†è®¸å¤šæ¥å£ï¼Œæ”¾å…¥é›†åˆä¸­çš„å¯¹è±¡å¯å®ç°æ¥å£æ¥æ‰§è¡Œæ’åºå’Œæœç´¢ç­‰æ“ä½œã€‚å¸¸ç”¨æ¥å£åœ¨ <code>System.Collections.Generic</code> å‘½åç©ºé—´ä¸­æä¾›ã€‚æ–°çš„æ³›å‹æ¥å£ä¸æ˜¯ä¸ºäº†æ›¿ä»£æ—§çš„éæ³›å‹æ¥å£ã€‚è®¸å¤šæ—¶å€™ä¸¤è€…éƒ½è¦ä½¿ç”¨ï¼ˆä¸ºäº†å‘åå…¼å®¹ï¼‰ã€‚</p><h2 id="generics-infrastructure"><a class="anchor" href="#generics-infrastructure">#</a> Generics Infrastructure</h2><blockquote><p>Generics were added to version 2.0 of the CLR, and it was a major task that required many people working for quite some time. Specifically, to make generics work, Microsoft had to do the following:</p><ul><li><p>Create new Intermediate Language (IL) instructions that are aware of type arguments.</p></li><li><p>Modify the format of existing metadata tables so that type names and methods with generic parameters could be expressed.</p></li><li><p>Modify the various programming languages (C#, Microsoft Visual Basic .NET, etc.) to support the new syntax, allowing developers to define and reference generic types and methods.</p></li><li><p>Modify the compilers to emit the new IL instructions and the modified metadata format.</p></li><li><p>Modify the just-in-time (JIT) compiler to process the new type-argumentâ€“aware IL instructions that produce the correct native code.</p></li><li><p>Create new reflection members so that developers can query types and members to determine if they have generic parameters. Also, new reflection emit members had to be defined so that developers could create generic type and method definitions at run time.</p></li><li><p>Modify the debugger to show and manipulate generic types, members, fields, and local variables.</p></li><li><p>Modify the Microsoft Visual Studio IntelliSense feature to show specific member prototypes when using a generic type or a method with a specific data type.</p></li></ul></blockquote><blockquote><p>Now letâ€™s spend some time discussing how the CLR handles generics internally. This information could impact how you architect and design a generic algorithm. It could also impact your decision to use an existing generic algorithm or not.</p></blockquote><h3 id="open-and-closed-types"><a class="anchor" href="#open-and-closed-types">#</a> Open and Closed Types</h3><blockquote><p>In various chapters throughout this book, I have discussed how the CLR creates an internal data structure for each and every type in use by an application. These data structures are called type objects. Well, a type with generic type parameters is still considered a type, and the CLR will create an internal type object for each of these. This applies to reference types (classes), value types (structs), interface types, and delegate types. However, a type with generic type parameters is called an open type, and the CLR does not allow any instance of an open type to be constructed (similar to how the CLR prevents an instance of an interface type from being constructed).</p></blockquote><blockquote><p>When code references a generic type, it can specify a set of generic type arguments. If actual data types are passed in for all of the type arguments, the type is called a closed type, and the CLR does allow instances of a closed type to be constructed. However, it is possible for code referencing a generic type to leave some generic type arguments unspecified. This creates a new open type object in the CLR, and instances of this type cannot be created. The following code should make this clear.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>Generic</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// A partially specified open type </span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">DictionaryStringKey<span class="token punctuation">&lt;</span>TValue<span class="token punctuation">></span></span> <span class="token punctuation">:</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token type-list"><span class="token class-name">Dictionary<span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> TValue<span class="token punctuation">></span></span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token class-name">Object</span> o <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// Dictionary&lt;,> is an open type having 2 type parameters </span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token class-name">Type</span> t <span class="token operator">=</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">Dictionary<span class="token punctuation">&lt;</span><span class="token punctuation">,</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// Try to create an instance of this type (fails) </span></pre></td></tr><tr><td data-num="13"></td><td><pre> o <span class="token operator">=</span> <span class="token function">CreateInstance</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// DictionaryStringKey&lt;> is an open type having 1 type parameter </span></pre></td></tr><tr><td data-num="16"></td><td><pre> t <span class="token operator">=</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">DictionaryStringKey<span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token comment">// Try to create an instance of this type (fails) </span></pre></td></tr><tr><td data-num="18"></td><td><pre> o <span class="token operator">=</span> <span class="token function">CreateInstance</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token comment">// DictionaryStringKey&lt;Guid> is a closed type </span></pre></td></tr><tr><td data-num="21"></td><td><pre> t <span class="token operator">=</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">DictionaryStringKey<span class="token punctuation">&lt;</span>Guid<span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token comment">// Try to create an instance of this type (succeeds) </span></pre></td></tr><tr><td data-num="23"></td><td><pre> o <span class="token operator">=</span> <span class="token function">CreateInstance</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token comment">// Prove it actually worked </span></pre></td></tr><tr><td data-num="25"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Object type="</span> <span class="token operator">+</span> o<span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="27"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name">Object</span> <span class="token function">CreateInstance</span><span class="token punctuation">(</span><span class="token class-name">Type</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="28"></td><td><pre> <span class="token class-name">Object</span> o <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="29"></td><td><pre> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="30"></td><td><pre> o <span class="token operator">=</span> Activator<span class="token punctuation">.</span><span class="token function">CreateInstance</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="31"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token string">"Created instance of &#123;0&#125;"</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="32"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="33"></td><td><pre> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ArgumentException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="34"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>Message<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="35"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="36"></td><td><pre> <span class="token keyword">return</span> o<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="37"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="38"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When I compile the preceding code and run it, I get the following output.</p></blockquote><pre><code>Cannot create an instance of System.Collections.Generic. 
Dictionary`2[TKey,TValue] because Type.ContainsGenericParameters is true. 

Cannot create an instance of DictionaryStringKey`1[TValue] because 
Type.ContainsGenericParameters is true. 

Created instance of DictionaryStringKey`1[System.Guid] 
Object type=DictionaryStringKey`1[System.Guid]
</code></pre><blockquote><p>As you can see, Activatorâ€™s CreateInstance method throws an ArgumentException when you ask it to construct an instance of an open type. In fact, the exceptionâ€™s string message indicates that the type still contains some generic parameters.</p></blockquote><blockquote><p>In the output, youâ€™ll notice that the type names end with a backtick (`) followed by a number. The number indicates the typeâ€™s arity, which indicates the number of type parameters required by the type. For example, the Dictionary class has an arity of 2 because it requires that types be specified for TKey and TValue. The DictionaryStringKey class has an arity of 1 because it requires just one type to be specified for TValue.</p></blockquote><blockquote><p>I should also point out that the CLR allocates a typeâ€™s static fields inside the type object (as discussed in Chapter 4, â€œType Fundamentalsâ€). So each closed type has its own static fields. In other words, if List defined any static fields, these fields are not shared between a List and a List; each closed type object has its own static fields. Also, if a generic type defines a static constructor (discussed in Chapter 8, â€œMethodsâ€), this constructor will execute once per closed type. Sometimes people define a static constructor on a generic type to ensure that the type arguments will meet certain criteria. For example, if you wanted to define a generic type that can be used only with enumerated types, you could do the following.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">GenericTypeThatRequiresAnEnum<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">static</span> <span class="token function">GenericTypeThatRequiresAnEnum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">T</span><span class="token punctuation">)</span><span class="token punctuation">.</span>IsEnum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ArgumentException</span><span class="token punctuation">(</span><span class="token string">"T must be an enumerated type"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The CLR has a feature called constraints that offers a better way for you to define a generic type indicating what type arguments are valid for it. Iâ€™ll discuss constraints later in this chapter. Unfortunately, constraints do not support the ability to limit a type argument to enumerated types only, which is why the previous example requires a static constructor to ensure that the type is an enumerated type.</p></blockquote><h3 id="generic-types-and-inheritance"><a class="anchor" href="#generic-types-and-inheritance">#</a> Generic Types and Inheritance</h3><blockquote><p>A generic type is a type, and as such, it can be derived from any other type. When you use a generic type and specify type arguments, you are defining a new type object in the CLR, and the new type object is derived from whatever type the generic type was derived from. In other words, because List is derived from Object, List and List are also derived from Object. Similarly, because DictionaryStringKey is derived from Dictionary, DictionaryStringKey is also derived from Dictionary. Understanding that specifying type arguments doesnâ€™t have anything to do with inheritance hierarchies will help you to recognize what kind of casting you can and canâ€™t do.</p></blockquote><blockquote><p>For example, if a linked-list node class is defined like this:</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Node<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name">T</span> m_data<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name">Node<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> m_next<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token class-name">T</span> data<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token class-name">T</span> data<span class="token punctuation">,</span> <span class="token class-name">Node<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> m_data <span class="token operator">=</span> data<span class="token punctuation">;</span> m_next <span class="token operator">=</span> next<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name">String</span> <span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">return</span> m_data<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">(</span><span class="token punctuation">(</span>m_next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">?</span> m_next<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> String<span class="token punctuation">.</span>Empty<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>then I can write some code to build up a linked list that would look something like the following.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SameDataLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Node<span class="token punctuation">&lt;</span>Char<span class="token punctuation">></span></span> head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Node<span class="token punctuation">&lt;</span>Char<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token char">'C'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Node<span class="token punctuation">&lt;</span>Char<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token char">'B'</span><span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Node<span class="token punctuation">&lt;</span>Char<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token char">'A'</span><span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Displays "ABC"</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In the Node class just shown, the m_next field must refer to another node that has the same kind of data type in its m_data field. This means that the linked list must contain nodes in which all data items are of the same type (or derived type). For example, I canâ€™t use the Node class to create a linked list in which one element contains a Char, another element contains a DateTime, and another element contains a String. Well, I could if I use Node everywhere, but then I would lose compile-time type safety, and value types would get boxed.</p></blockquote><blockquote><p>So a better way to go would be to define a non-generic Node base class and then define a generic TypedNode class (using the Node class as a base class). Now, I can have a linked list in which each node can be of a specific data type (not Object), get compile-time type safety, and avoid the boxing of value types. Here are the new class definitions.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">protected</span> <span class="token class-name">Node</span> m_next<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token class-name">Node</span> next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> m_next <span class="token operator">=</span> next<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">TypedNode<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Node</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name">T</span> m_data<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">public</span> <span class="token function">TypedNode</span><span class="token punctuation">(</span><span class="token class-name">T</span> data<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">public</span> <span class="token function">TypedNode</span><span class="token punctuation">(</span><span class="token class-name">T</span> data<span class="token punctuation">,</span> <span class="token class-name">Node</span> next<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">base</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> m_data <span class="token operator">=</span> data<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name">String</span> <span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token keyword">return</span> m_data<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token punctuation">(</span><span class="token punctuation">(</span>m_next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">?</span> m_next<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> String<span class="token punctuation">.</span>Empty<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>I can now write code to create a linked list in which each node is a different data type. The code could look something like the following.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">DifferentDataLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Node</span> head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">TypedNode<span class="token punctuation">&lt;</span>Char<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token char">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">TypedNode<span class="token punctuation">&lt;</span>DateTime<span class="token punctuation">></span></span><span class="token punctuation">(</span>DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">TypedNode<span class="token punctuation">&lt;</span>String<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token string">"Today is "</span><span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="generic-type-identity"><a class="anchor" href="#generic-type-identity">#</a> Generic Type Identity</h3><blockquote><p>Sometimes generic syntax confuses developers. After all, there can be a lot of less-than (&lt;) and greater-than (&gt;) signs sprinkled throughout your source code, and this hurts readability. To improve syntax, some developers define a new non-generic class type that is derived from a generic type and that specifies all of the type arguments. For example, to simplify code like this:</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">List<span class="token punctuation">&lt;</span>DateTime<span class="token punctuation">></span></span> dtl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">List<span class="token punctuation">&lt;</span>DateTime<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>some developers might first define a class like the following.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">DateTimeList</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">List<span class="token punctuation">&lt;</span>DateTime<span class="token punctuation">></span></span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// No need to put any code in here! </span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Now, the code that creates a list can be rewritten more simply (without less-than and greater-than signs) like the following.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">DateTimeList</span> dtl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">DateTimeList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>Although this seems like a convenience, especially if you use the new type for parameters, local variables, and fields, you should never define a new class explicitly for the purpose of making your source code easier to read. The reason is because you lose type identity and equivalence, as you can see in the following code.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Boolean</span> sameType <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">List<span class="token punctuation">&lt;</span>DateTime<span class="token punctuation">></span></span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">DateTimeList</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>When the preceding code runs, sameType will be initialized to false because you are comparing two different type objects. This also means that a method prototyped as accepting a DateTimeList will not be able to have a List passed to it. However, a method prototyped as accepting a List can have a DateTimeList passed to it because DateTimeList is derived from List. Programmers may become easily confused by all of this.</p></blockquote><blockquote><p>Fortunately, C# does offer a way to use simplified syntax to refer to a generic closed type while not affecting type equivalence at all; you can use the good-old using directive at the top of your source code file. Here is an example.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token class-name">DateTimeList</span> <span class="token operator">=</span> <span class="token class-name">System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>Generic<span class="token punctuation">.</span>List<span class="token punctuation">&lt;</span>System<span class="token punctuation">.</span>DateTime<span class="token punctuation">></span></span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>Here, the using directive is really just defining a symbol called DateTimeList. As the code compiles, the compiler substitutes all occurrences of DateTimeList with System.Collections. Generic.List. This just allows developers to use a simplified syntax without affecting the actual meaning of the code, and therefore, type identity and equivalence are maintained. So now, when the following line executes, sameType will be initialized to true.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Boolean</span> sameType <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">List<span class="token punctuation">&lt;</span>DateTime<span class="token punctuation">></span></span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">DateTimeList</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>As another convenience, you can use C#â€™s implicitly typed local variable feature, where the compiler infers the type of a methodâ€™s local variable from the type of the expression you are assigning to it.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>Generic</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> SomeMethod <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Compiler infers that dtl is of type</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// System.Collections.Generic.List&lt;System.DateTime></span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> dtl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">List<span class="token punctuation">&lt;</span>DateTime<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="code-explosion"><a class="anchor" href="#code-explosion">#</a> Code Explosion</h3><blockquote><p>When a method that uses generic type parameters is JIT-compiled, the CLR takes the methodâ€™s IL, substitutes the specified type arguments, and then creates native code that is specific to that method operating on the specified data types. This is exactly what you want and is one of the main features of generics. However, there is a downside to this: the CLR keeps generating native code for every method/type combination. This is referred to as code explosion. This can end up increasing the applicationâ€™s working set substantially, thereby hurting performance.</p></blockquote><blockquote><p>Fortunately, the CLR has some optimizations built into it to reduce code explosion. First, if a method is called for a particular type argument, and later, the method is called again using the same type argument, the CLR will compile the code for this method/type combination just once. So if one assembly uses List, and a completely different assembly (loaded in the same AppDomain) also uses List, the CLR will compile the methods for List just once. This reduces code explosion substantially.</p></blockquote><blockquote><p>The CLR has another optimization: the CLR considers all reference type arguments to be identical, and so again, the code can be shared. For example, the code compiled by the CLR for Listâ€™s methods can be used for Listâ€™s methods, because String and Stream are both reference types. In fact, for any reference type, the same code will be used. The CLR can perform this optimization because all reference type arguments or variables are really just pointers (all 32 bits on a 32-bit Windows system and 64 bits on a 64-bit Windows system) to objects on the heap, and object pointers are all manipulated in the same way.</p></blockquote><blockquote><p>But if any type argument is a value type, the CLR must produce native code specifically for that value type. The reason is because value types can vary in size. And even if two value types are the same size (such as Int32 and UInt32, which are both 32 bits), the CLR still canâ€™t share the code because different native CPU instructions can be used to manipulate these values.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šæ³›å‹åœ¨ CLR2.0 ä¸­åŠ å…¥ã€‚ä¸ºäº†ä½¿æ³›å‹èƒ½å¤Ÿå·¥ä½œï¼ŒMicrosoft åšäº†å¤§é‡çš„å·¥ä½œã€‚ä¾‹å¦‚ï¼Œåˆ›å»ºæ–°çš„ IL æŒ‡ä»¤ï¼Œä½¿ä¹‹èƒ½å¤Ÿè¯†åˆ«ç±»å‹å®å‚ï¼›ä¿®æ”¹ç°æœ‰å…ƒæ•°æ®è¡¨çš„æ ¼å¼ï¼Œä»¥ä¾¿è¡¨ç¤ºå…·æœ‰æ³›å‹å‚æ•°çš„ç±»å‹åç§°å’Œæ–¹æ³•ï¼›ä¿®æ”¹ç¼–è¯‘å™¨å’Œ JIT ç¼–è¯‘å™¨ï¼›åˆ›å»ºæ–°çš„åå°„æˆå‘˜ç­‰ç­‰ã€‚å…·æœ‰åå°„ç±»å‹å‚æ•°çš„ç±»å‹ä»ç„¶æ˜¯ç±»å‹ï¼ŒCLR åŒæ ·ä¼šä¸ºå®ƒåˆ›å»ºå†…éƒ¨çš„ç±»å‹å¯¹è±¡ã€‚è¿™ä¸€ç‚¹é€‚åˆå¼•ç”¨ç±»å‹ï¼ˆç±»ï¼‰ã€å€¼ç±»å‹ï¼ˆç»“æ„ï¼‰ã€æ¥å£ç±»å‹å’Œå§”æ‰˜ç±»å‹ã€‚ç„¶è€Œï¼Œå…·æœ‰æ³›å‹ç±»å‹å‚æ•°çš„ç±»å‹ç§°ä¸ºå¼€æ”¾ç±»å‹ï¼ŒCLR ç¦æ­¢æ„é€ å¼€æ”¾ç±»å‹çš„ä»»ä½•å®ä¾‹ã€‚è¿™ç±»ä¼¼äº CLR ç¦æ­¢æ„é€ æ¥å£ç±»å‹çš„å®ä¾‹ã€‚ä»£ç å¼•ç”¨æ³›å‹ç±»å‹æ—¶å¯æŒ‡å®šä¸€ç»„æ³›å‹ç±»å‹å®å‚ã€‚ä¸ºæ‰€æœ‰ç±»å‹å‚æ•°éƒ½ä¼ é€’äº†å®é™…çš„æ•°æ®ç±»å‹ï¼Œç±»å‹å°±æˆä¸ºå°é—­ç±»å‹ã€‚CLR å…è®¸æ„é€ å°é—­ç±»å‹çš„å®ä¾‹ã€‚ç„¶è€Œï¼Œä»£ç å¼•ç”¨æ³›å‹ç±»å‹çš„æ—¶å€™ï¼Œå¯èƒ½ç•™ä¸‹ä¸€äº›æ³›å‹ç±»å‹å®å‚æœªæŒ‡å®šã€‚è¿™ä¼šåœ¨ CLR ä¸­åˆ›å»ºæ–°çš„å¼€æ”¾ç±»å‹å¯¹è±¡ï¼Œè€Œä¸”ä¸èƒ½åˆ›å»ºè¯¥ç±»å‹çš„å®ä¾‹ã€‚è‹¥å¼€æ”¾ç±»å‹ä¸­å®šä¹‰äº†é™æ€å­—æ®µï¼Œé‚£ä¹ˆæ¯ä¸ªå°é—­ç±»å‹éƒ½æœ‰è‡ªå·±çš„é™æ€å­—æ®µã€‚å¦å¤–ï¼Œå‡å¦‚æ³›å‹ç±»å‹å®šä¹‰äº†é™æ€æ„é€ å™¨ï¼Œé‚£ä¹ˆé’ˆå¯¹æ¯ä¸ªå°é—­ç±»å‹ï¼Œè¿™ä¸ªæ„é€ å™¨éƒ½ä¼šæ‰§è¡Œä¸€æ¬¡ã€‚æ³›å‹ç±»å‹å®šä¹‰é™æ€æ„é€ å™¨çš„ç›®çš„æ˜¯ä¿è¯ä¼ é€’çš„ç±»å‹å®å‚æ»¡è¶³ç‰¹å®šæ¡ä»¶ã€‚CLR æä¾›äº†åä¸ºçº¦æŸçš„åŠŸèƒ½ï¼Œå¯ä»¥æ›´å¥½åœ°æŒ‡å®šæœ‰æ•ˆçš„ç±»å‹å®å‚ã€‚é—æ†¾çš„æ˜¯ï¼Œçº¦æŸæ— æ³•å°†ç±»å‹å®å‚é™åˆ¶ä¸º â€œä»…æšä¸¾ç±»å‹â€ã€‚æ­£æ˜¯å› ä¸ºè¿™ä¸ªåŸå› ï¼Œæ‰€ä»¥ä¸Šä¾‹éœ€è¦ç”¨é™æ€æ„é€ å™¨æ¥ä¿è¯ç±»å‹æ˜¯ä¸€ä¸ªæšä¸¾ç±»å‹ã€‚æŒ‡å®šç±»å‹å®å‚ä¸å½±å“ç»§æ‰¿å±‚æ¬¡ç»“æ„ â€”â€” ç†è§£è¿™ä¸€ç‚¹ï¼Œæœ‰åŠ©äºä½ åˆ¤æ–­å“ªäº›å¼ºåˆ¶ç±»å‹è½¬æ¢æ˜¯å…è®¸çš„ï¼Œå“ªäº›ä¸å…è®¸ã€‚æ³›å‹è¯­æ³•æœ‰æ—¶ä¼šå°†å¼€å‘äººå‘˜å¼„ç³Šæ¶‚ï¼Œå› ä¸ºæºä»£ç ä¸­å¯èƒ½æ•£å¸ƒç€å¤§é‡ â€œ&lt;â€ å’Œ â€œ&gt;â€ ç¬¦å·ï¼Œè¿™æœ‰æŸå¯è¯»æ€§ã€‚C# å…è®¸ä½¿ç”¨ç®€åŒ–çš„è¯­æ³•æ¥å¼•ç”¨æ³›å‹å°é—­ç±»å‹ï¼ŒåŒæ—¶ä¸ä¼šå½±å“ç±»å‹çš„ç›¸ç­‰æ€§ã€‚è¿™ä¸ªè¯­æ³•è¦æ±‚åœ¨æºæ–‡ä»¶é¡¶éƒ¨ä½¿ç”¨ä¼ ç»Ÿçš„ using æŒ‡ä»¤ã€‚ä½¿ç”¨æ³›å‹ç±»å‹å‚æ•°çš„æ–¹æ³•åœ¨è¿›è¡Œ JIT ç¼–è¯‘æ—¶ï¼ŒCLR è·å–æ–¹æ³•çš„ ILï¼Œç”¨æŒ‡å®šçš„ç±»å‹å®å‚æ›¿æ¢ï¼Œç„¶ååˆ›å»ºæ°å½“çš„æœ¬æœºä»£ç ã€‚ä½†è¿™æ ·åšæœ‰ä¸€ä¸ªç¼ºç‚¹ï¼šCLR è¦ä¸ºæ¯ç§ä¸åŒçš„æ–¹æ³• / ç±»å‹ç»„åˆç”Ÿæˆæœ¬æœºä»£ç ã€‚æˆ‘ä»¬å°†è¿™ç§ç°è±¡ç§°ä¸ºä»£ç çˆ†ç‚¸ã€‚å®ƒå¯èƒ½é€ æˆåº”ç”¨ç¨‹åºçš„å·¥ä½œé›†æ˜¾è‘—å¢å¤§ï¼Œä»è€ŒæŸå®³æ€§èƒ½ã€‚å¹¸å¥½ï¼ŒCLR å†…å»ºäº†ä¸€äº›ä¼˜åŒ–æªæ–½èƒ½ç¼“è§£ä»£ç çˆ†ç‚¸ã€‚é¦–å…ˆï¼ŒåŠ å…¥ä¸ºç‰¹å®šçš„ç±»å‹å®å‚è°ƒç”¨äº†ä¸€ä¸ªæ–¹æ³•ï¼Œä»¥åå†ç”¨ç›¸åŒçš„ç±»å‹å®å‚è°ƒç”¨è¿™ä¸ªæ–¹æ³•ï¼ŒCLR åªä¼šä¸ºè¿™ä¸ªæ–¹æ³• / ç±»å‹ç»„åˆç¼–è¯‘ä¸€æ¬¡ä»£ç ã€‚CLR è¿˜æœ‰å¦ä¸€ä¸ªä¼˜åŒ–ï¼Œå®ƒè®¤ä¸ºæ‰€æœ‰å¼•ç”¨ç±»å‹å®å‚éƒ½å®Œå…¨ç›¸åŒï¼Œæ‰€ä»¥ä»£ç èƒ½å¤Ÿå…±äº«ã€‚äº‹å®ä¸Šï¼Œå¯¹äºä»»ä½•å¼•ç”¨ç±»å‹ï¼Œéƒ½ä¼šä½¿ç”¨ç›¸åŒçš„ä»£ç ã€‚CLR ä¹‹æ‰€ä»¥èƒ½æ‰§è¡Œè¿™ä¸ªä¼˜åŒ–ï¼Œæ˜¯å› ä¸ºæ‰€æœ‰å¼•ç”¨ç±»å‹çš„å®å‚æˆ–å˜é‡å®é™…åªæ˜¯æŒ‡å‘å †ä¸Šå¯¹è±¡çš„æŒ‡é’ˆï¼ˆ32 ä½ Windows ç³»ç»Ÿä¸Šæ˜¯ 32 ä½æŒ‡é’ˆï¼›64 ä½ Windows ç³»ç»Ÿä¸Šå°±æ˜¯ 64 ä½æŒ‡é’ˆï¼‰ï¼Œè€Œæ‰€æœ‰å¯¹è±¡éƒ½ä»¥ç›¸åŒæ–¹å¼æ“çºµã€‚ä½†æ˜¯ï¼Œå‡å¦‚æŸä¸ªç±»å‹å®å‚æ˜¯å€¼ç±»å‹ï¼ŒCLR å°±å¿…é¡»ä¸“é—¨ä¸ºé‚£ä¸ªå€¼ç±»å‹ç”Ÿæˆæœ¬æœºä»£ç ã€‚</p><h2 id="generic-interfaces"><a class="anchor" href="#generic-interfaces">#</a> Generic Interfaces</h2><blockquote><p>Obviously, the ability to define generic reference and value types was the main feature of generics. However, it was critical for the CLR to also allow generic interfaces. Without generic interfaces, any time you tried to manipulate a value type by using a non-generic interface (such as IComparable), boxing and a loss of compile-time type safety would happen again. This would severely limit the usefulness of generic types. And so the CLR does support generic interfaces. A reference or value type can implement a generic interface by specifying type arguments, or a type can implement a generic interface by leaving the type arguments unspecified. Letâ€™s look at some examples.</p></blockquote><blockquote><p>Here is the definition of a generic interface that ships as part of the FCL (in the System.Collections.Generic namespace).</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IEnumerator<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IDisposable</span><span class="token punctuation">,</span> <span class="token class-name">IEnumerator</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token return-type class-name">T</span> Current <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Here is an example of a type that implements this generic interface and that specifies type arguments. Notice that a Triangle object can enumerate a set of Point objects. Also note that the Current property is of the Point data type.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Triangle</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IEnumerator<span class="token punctuation">&lt;</span>Point<span class="token punctuation">></span></span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Point<span class="token punctuation">[</span><span class="token punctuation">]</span></span> m_vertices<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// IEnumerator&lt;Point>'s Current property is of type Point </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Point</span> Current <span class="token punctuation">&#123;</span> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Now letâ€™s look at an example of a type that implements the same generic interface but with the type arguments left unspecified.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">ArrayEnumerator<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IEnumerator<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">T<span class="token punctuation">[</span><span class="token punctuation">]</span></span> m_array<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// IEnumerator&lt;T>'s Current property is of type T </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">T</span> Current <span class="token punctuation">&#123;</span> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Notice that an ArrayEnumerator object can enumerate a set of T objects (where T is unspecified allowing code using the generic ArrayEnumerator type to specify a type for T later). Also note that the Current property is now of the unspecified data type T. Much more information about generic interfaces is presented in Chapter 13, â€œInterfaces.â€</p></blockquote><p>ğŸ’¡å°ç»“ï¼šæ˜¾ç„¶ï¼Œæ³›å‹çš„ä¸»è¦ä½œç”¨å°±æ˜¯å®šä¹‰æ³›å‹çš„å¼•ç”¨ç±»å‹å’Œå€¼ç±»å‹ã€‚ç„¶è€Œï¼Œå¯¹æ³›å‹æ¥å£çš„æ”¯æŒå¯¹ CLR æ¥è¯´ä¹Ÿå¾ˆé‡è¦ã€‚æ²¡æœ‰æ³›å‹æ¥å£ï¼Œæ¯æ¬¡ç”¨éæ³›å‹æ¥å£ï¼ˆå¦‚ <code>IComparable</code> ï¼‰æ¥æ“çºµå€¼ç±»å‹éƒ½ä¼šå‘ç”Ÿè£…ç®±ï¼Œè€Œä¸”ä¼šå¤±å»ç¼–è¯‘æ—¶çš„ç±»å‹å®‰å…¨æ€§ã€‚è¿™å°†ä¸¥é‡åˆ¶çº¦æ³›å‹ç±»å‹çš„åº”ç”¨èŒƒå›´ã€‚å› æ­¤ï¼ŒCLR æä¾›äº†å¯¹æ³›å‹æ¥å£çš„æ”¯æŒã€‚å¼•ç”¨ç±»å‹æˆ–å€¼ç±»å‹å¯æŒ‡å®šç±»å‹å®å‚å®ç°æ³›å‹æ¥å£ã€‚ä¹Ÿå¯ä¿æŒç±»å‹å®å‚çš„æœªæŒ‡å®šçŠ¶æ€æ¥å®ç°æ³›å‹æ¥å£ã€‚</p><h2 id="generic-delegates"><a class="anchor" href="#generic-delegates">#</a> Generic Delegates</h2><blockquote><p>The CLR supports generic delegates to ensure that any type of object can be passed to a callback method in a type-safe way. Furthermore, generic delegates allow a value type instance to be passed to a callback method without any boxing. As discussed in Chapter 17, â€œDelegates,â€ a delegate is really just a class definition with four methods: a constructor, an <code>Invoke</code> method, a <code>BeginInvoke</code> method, and an <code>EndInvoke</code> method. When you define a delegate type that specifies type parameters, the compiler defines the delegate classâ€™s methods, and the type parameters are applied to any methods having parameters/return types of the specified type parameter.</p></blockquote><blockquote><p>For example, if you define a generic delegate like this:</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">delegate</span> <span class="token return-type class-name">TReturn</span> <span class="token generic-method"><span class="token function">CallMe</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>TReturn<span class="token punctuation">,</span> TKey<span class="token punctuation">,</span> TValue<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">TKey</span> key<span class="token punctuation">,</span> <span class="token class-name">TValue</span> <span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>the compiler turns that into a class that logically looks like the following.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">CallMe<span class="token punctuation">&lt;</span>TReturn<span class="token punctuation">,</span> TKey<span class="token punctuation">,</span> TValue<span class="token punctuation">></span></span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">MulticastDelegate</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token function">CallMe</span><span class="token punctuation">(</span>Object <span class="token keyword">object</span><span class="token punctuation">,</span> <span class="token class-name">IntPtr</span> method<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token return-type class-name">TReturn</span> <span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token class-name">TKey</span> key<span class="token punctuation">,</span> <span class="token class-name">TValue</span> <span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token return-type class-name">IAsyncResult</span> <span class="token function">BeginInvoke</span><span class="token punctuation">(</span><span class="token class-name">TKey</span> key<span class="token punctuation">,</span> <span class="token class-name">TValue</span> <span class="token keyword">value</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token class-name">AsyncCallback</span> callback<span class="token punctuation">,</span> Object <span class="token keyword">object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token return-type class-name">TReturn</span> <span class="token function">EndInvoke</span><span class="token punctuation">(</span><span class="token class-name">IAsyncResult</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>ğŸ’¡æ³¨æ„ï¼šå»ºè®®å°½é‡ä½¿ç”¨ FCL é¢„å®šä¹‰çš„æ³›å‹ <code>Action</code> å’Œ <code>Func</code> å§”æ‰˜ã€‚è¿™äº›å§”æ‰˜çš„è¯¦æƒ…å°†åœ¨ 17.6 èŠ‚ â€œå§”æ‰˜å®šä¹‰ä¸è¦å¤ªå¤š (æ³›å‹å§”æ‰˜)â€ è®²è¿°ã€‚</p><p>ğŸ’¡å°ç»“ï¼šCLR æ”¯æŒæ³›å‹å§”æ‰˜ï¼Œç›®çš„æ˜¯ä¿è¯ä»»ä½•ç±»å‹çš„å¯¹è±¡éƒ½èƒ½ä»¥ç±»å‹å®‰å…¨çš„æ–¹å¼ä¼ ç»™å›è°ƒæ–¹æ³•ã€‚æ­¤å¤–ï¼Œæ³›å‹å§”æ‰˜å…è®¸å€¼ç±»å‹å®ä¾‹åœ¨ä¼ ç»™å›è°ƒæ–¹æ³•æ—¶ä¸è¿›è¡Œä»»ä½•è£…ç®±ã€‚</p><h2 id="delegate-and-interface-contra-variant-and-covariant-generic-type-arguments"><a class="anchor" href="#delegate-and-interface-contra-variant-and-covariant-generic-type-arguments">#</a> Delegate and Interface Contra-variant and Covariant Generic Type Arguments</h2><blockquote><p>Each of a delegateâ€™s generic type parameters can be marked as covariant or contra-variant. This feature allows you to cast a variable of a generic delegate type to the same delegate type where the generic parameter types differ. A generic type parameter can be any one of the following:</p><ul><li><p>Invariant Meaning that the generic type parameter cannot be changed. I have shown only invariant generic type parameters so far in this chapter.</p></li><li><p>Contra-variant Meaning that the generic type parameter can change from a class to a class derived from it. In C#, you indicate contra-variant generic type parameters with the in keyword. Contra-variant generic type parameters can appear only in input positions such as a methodâ€™s argument.</p></li><li><p>Covariant Meaning that the generic type argument can change from a class to one of its base classes. In C#, you indicate covariant generic type parameters with the out keyword. Covariant generic type parameters can appear only in output positions such as a methodâ€™s return type.</p></li></ul></blockquote><blockquote><p>For example, letâ€™s say that the following delegate type definition exists (which, by the way, it does).</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">delegate</span> <span class="token return-type class-name">TResult</span> <span class="token generic-method"><span class="token function">Func</span><span class="token generic class-name"><span class="token punctuation">&lt;</span><span class="token keyword">in</span> T<span class="token punctuation">,</span> <span class="token keyword">out</span> TResult<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">T</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>Here, the generic type parameter T is marked with the in keyword, making it contra-variant; and the generic type parameter TResult is marked with the out keyword, making it covariant.</p></blockquote><blockquote><p>So now, if I have a variable declared as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Func<span class="token punctuation">&lt;</span>Object<span class="token punctuation">,</span> ArgumentException<span class="token punctuation">></span></span> fn1 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>I can cast it to another Func type, where the generic type parameters are different.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>Func<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Exception<span class="token operator">></span>fn2 <span class="token operator">=</span> fn1<span class="token punctuation">;</span> <span class="token comment">// No explicit cast is required here</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Exception</span> e <span class="token operator">=</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>What this is saying is that fn1 refers to a function that accepts an Object and returns an ArgumentException. The fn2 variable wants to refer to a method that takes a String and returns an Exception. Because you can pass a String to a method that wants an Object (because String is derived from Object), and because you can take the result of a method that returns an ArgumentException and treat it as an Exception (because Exception is a base class of ArgumentException), the code above compiles and is known at compile time to preserve type safety.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šåªæœ‰ç¼–è¯‘å™¨èƒ½éªŒè¯ç±»å‹ä¹‹é—´å­˜åœ¨å¼•ç”¨è½¬æ¢ï¼Œè¿™äº›å¯å˜æ€§æ‰æœ‰ç”¨ã€‚æ¢è¨€ä¹‹ï¼Œç”±äºéœ€è¦è£…ç®±ï¼Œæ‰€ä»¥å€¼ç±»å‹ä¸å…·æœ‰è¿™ç§å¯å˜æ€§ã€‚æˆ‘ä¸ªäººè®¤ä¸ºæ­£æ˜¯å› ä¸ºå­˜åœ¨è¿™ä¸ªé™åˆ¶ï¼Œè¿™äº›å¯å˜æ€§çš„ç”¨å¤„ä¸æ˜¯ç‰¹åˆ«å¤§ã€‚ä¾‹å¦‚ï¼Œå‡å®šå®šä¹‰ä»¥ä¸‹æ–¹æ³•ï¼š</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ProcessCollection</span><span class="token punctuation">(</span><span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span>Object<span class="token punctuation">></span></span> collection<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>æˆ‘ä¸èƒ½åœ¨è°ƒç”¨å®ƒæ—¶ä¼ é€’ä¸€ä¸ª <code>List&lt;DateTime&gt;</code> å¯¹è±¡å¼•ç”¨ï¼Œå› ä¸º <code>DateTime</code> å€¼ç±»å‹å’Œ <code>Object</code> ä¹‹é—´ä¸å­˜åœ¨å¼•ç”¨è½¬æ¢ â€”â€” è™½ç„¶ <code>DateTime</code> æ˜¯ä» <code>Object</code> æ´¾ç”Ÿçš„ï¼Œä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå¯åƒä¸‹é¢è¿™æ ·å£°æ˜ <code>ProcessCollection</code> :</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">ProcessCollection</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span>Object<span class="token punctuation">></span></span> collection<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>å¦å¤–ï¼Œ <code>ProcessColleciton(IEnumerable&lt;Object&gt; collection)</code> æœ€å¤§çš„å¥½å¤„æ˜¯ JIT ç¼–è¯‘å¾—åˆ°çš„ä»£ç åªæœ‰ä¸€ä¸ªç‰ˆæœ¬ã€‚ä½†å¦‚æœä½¿ç”¨ <code>ProcessCollection&lt;T&gt;(IEnumerable&lt;T&gt; collection)</code> ï¼Œé‚£ä¹ˆåªæœ‰åœ¨ <code>T</code> æ˜¯å¼•ç”¨ç±»å‹çš„å‰æä¸‹ï¼Œæ‰å¯å…±äº«åŒä¸€ä¸ªç‰ˆæœ¬çš„ JIT ç¼–è¯‘ä»£ç ï¼›ä¸è¿‡ï¼Œèµ·ç èƒ½åœ¨è°ƒç”¨æ–¹æ³•æ—¶ä¼ é€’ä¸€ä¸ªå€¼ç±»å‹ç»“åˆäº†ã€‚</p><p>å¦å¤–ï¼Œå¯¹äºæ³›å‹ç±»å‹å‚æ•°ï¼Œå¦‚æœè¦å°†è¯¥ç±»å‹çš„å®å‚ä¼ ç»™ä½¿ç”¨ <code>out</code> æˆ– <code>ref</code> å…³é”®å­—çš„æ–¹æ³•ï¼Œä¾¿ä¸å…è®¸å¯å˜æ€§ã€‚ä¾‹å¦‚ï¼Œä»¥ä¸‹ä»£ç ä¼šé€ æˆç¼–è¯‘å™¨æŠ¥å‘Šé”™è¯¯æ¶ˆæ¯ï¼š <code>æ— æ•ˆçš„å¯å˜æ€§ï¼šç±»å‹å‚æ•°â€œTâ€åœ¨â€œSomeDelegate&lt;T&gt;.Invoke(ref T)â€ä¸­å¿…é¡»æ˜¯ä¸å˜é‡ã€‚ç°åœ¨çš„â€œTâ€œæ˜¯é€†å˜é‡ã€‚</code></p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">delegate</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">SomeDelegate</span><span class="token generic class-name"><span class="token punctuation">&lt;</span><span class="token keyword">in</span> T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>When using delegates that take generic arguments and return types, it is recommended to always specify the in and out keywords for contra-variance and covariance whenever possible, because doing this has no ill effects and enables your delegate to be used in more scenarios.</p></blockquote><blockquote><p>Like delegates, an interface with generic type parameters can have its type parameters be contravariant or covariant. Here is an example of an interface with a covariant generic type parameter.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IEnumerator<span class="token punctuation">&lt;</span><span class="token keyword">out</span> T<span class="token punctuation">></span></span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IEnumerator</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token return-type class-name">Boolean</span> <span class="token function">MoveNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token return-type class-name">T</span> Current <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Because T is covariant, it is possible to have the following code compile and run successfully.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// This method accepts an IEnumerable of any reference type</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token return-type class-name">Int32</span> <span class="token function">Count</span><span class="token punctuation">(</span><span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span>Object<span class="token punctuation">></span></span> collection<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// The call below passes an IEnumerable&lt;String> to Count</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token class-name">Int32</span> c <span class="token operator">=</span> <span class="token function">Count</span><span class="token punctuation">(</span><span class="token keyword">new</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span> <span class="token string">"Grant"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>ğŸ’¡é‡è¦æç¤ºï¼šå¼€å‘äººå‘˜æœ‰æ—¶ä¼šé—®ï¼šâ€ ä¸ºä»€ä¹ˆå¿…é¡»æ˜¾å¼ç”¨ <code>in</code> æˆ– <code>out</code> æ ‡è®°æ³›å‹ç±»å‹å‚æ•°ï¼Ÿâ€œä»–ä»¬è®¤ä¸ºç¼–è¯‘å™¨åº”è¯¥èƒ½æ£€æŸ¥å§”æ‰˜æˆ–æ¥å£å£°æ˜ï¼Œå¹¶è‡ªåŠ¨æ£€æµ‹å“ªäº›æ³›å‹ç±»å‹å‚æ•°èƒ½å¤Ÿé€†å˜å’Œåå˜ã€‚è™½ç„¶ç¼–è¯‘å™¨ç¡®å®èƒ½ï¼Œä½† C# å›¢é˜Ÿè®¤ä¸ºå¿…é¡»ç”±ä½ è®¢ç«‹åå®š (contract)ï¼Œæ˜ç¡®è¯´æ˜æƒ³å…è®¸ä»€ä¹ˆã€‚ä¾‹å¦‚ï¼Œå‡å®šç¼–è¯‘å™¨åˆ¤æ–­ä¸€ä¸ªæ³›å‹ç±»å‹å‚æ•°æ˜¯é€†å˜é‡ (ç”¨åœ¨è¾“å…¥ä½ç½®)ï¼Œä½†ä½ å°†æ¥å‘æŸä¸ªæ¥å£æ·»åŠ äº†æˆå‘˜ï¼Œå¹¶å°†ç±»å‹å‚æ•°ç”¨åœ¨äº†è¾“å‡ºä½ç½®ã€‚ä¸‹æ¬¡ç¼–è¯‘æ—¶ï¼Œç¼–è¯‘å™¨å°†è®¤ä¸ºè¯¥ç±»å‹å‚æ•°æ˜¯ä¸å˜é‡ã€‚ä½†åœ¨å¼•ç”¨äº†å…¶ä»–æˆå‘˜çš„æ‰€æœ‰åœ°æ–¹ï¼Œåªè¦è¿˜ä»¥ä¸ºâ€ ç±»å‹å‚æ•°æ˜¯é€†å˜é‡ â€œå°±å¯èƒ½å‡ºé”™ã€‚</p><p>å› æ­¤ï¼Œç¼–è¯‘å™¨å›¢é˜Ÿå†³å®šï¼Œåœ¨å£°æ˜æ³›å‹ç±»å‹å‚æ•°æ—¶ï¼Œå¿…é¡»ç”±ä½ æ˜¾ä½¿ç”¨ <code>in</code> æˆ– <code>out</code> æ¥æ ‡è®°å¯å˜æ€§ã€‚ä»¥åä½¿ç”¨è¿™ä¸ªç±»å‹å‚æ•°æ—¶ï¼Œå‡å¦‚ç”¨æ³•ä¸å£°æ˜æ—¶æŒ‡å®šçš„ä¸ç¬¦ï¼Œç¼–è¯‘å™¨å°±ä¼šæŠ¥é”™ï¼Œæé†’ä½ è¿åäº†è‡ªå·±è®¢ç«‹çš„åå®šã€‚å¦‚æœä¸ºæ³›å‹ç±»å‹å‚æ•°æ·»åŠ  <code>in</code> æˆ– <code>out</code> æ¥æ‰“ç ´åŸæ¥çš„åå®šï¼Œå°±å¿…é¡»ä¿®æ”¹ä½¿ç”¨æ—§åå®šçš„ä»£ç ã€‚</p><p>ğŸ’¡å°ç»“ï¼šå§”æ‰˜çš„æ¯ä¸ªæ³›å‹ç±»å‹å‚æ•°éƒ½å¯æ ‡è®°ä¸ºåå˜é‡æˆ–é€†å˜é‡ã€‚åˆ©ç”¨è¿™ä¸ªåŠŸèƒ½ï¼Œå¯å°†æ³›å‹å§”æ‰˜ç±»å‹çš„å˜é‡è½¬æ¢ä¸ºç›¸åŒçš„å§”æ‰˜ç±»å‹ï¼ˆä½†æ³›å‹å‚æ•°ç±»å‹ä¸åŒï¼‰ã€‚æ³›å‹ç±»å‹å‚æ•°å¯ä»¥æ˜¯ä¸å˜é‡ï¼ˆinvariantï¼‰ï¼Œæ„å‘³ç€æ³›å‹ç±»å‹å‚æ•°ä¸èƒ½æ›´æ”¹ï¼›é€†å˜é‡ï¼ˆcontravariantï¼‰ï¼Œæ„å‘³ç€æ³›å‹ç±»å‹å‚æ•°å¯ä»¥ä»ä¸€ä¸ªç±»æ›´æ”¹ä¸ºå®ƒçš„æŸä¸ªæ´¾ç”Ÿç±»ã€‚åœ¨ C# æ˜¯ç”¨ in å…³é”®å­—æ ‡è®°é€†å˜é‡å½¢å¼çš„æ³›å‹ç±»å‹å‚æ•°ã€‚é€†å˜é‡æ³›å‹ç±»å‹å‚æ•°åªå‡ºç°åœ¨è¾“å…¥ä½ç½®ï¼Œæ¯”å¦‚ä½œä¸ºæ–¹æ³•çš„å‚æ•°ï¼›åå˜é‡ï¼ˆconvariantï¼‰æ„å‘³ç€æ³›å‹ç±»å‹å‚æ•°å¯ä»¥ä»ä¸€ä¸ªç±»æ›´æ”¹ä¸ºå®ƒçš„æŸä¸ªåŸºç±»ã€‚C# æ˜¯ç”¨ out å…³é”®å­—æ ‡è®°åå˜é‡å½¢å¼çš„æ³›å‹ç±»å‹å‚æ•°ã€‚åå˜é‡æ³›å‹ç±»å‹å‚æ•°åªèƒ½å‡ºç°åœ¨è¾“å‡ºä½ç½®ï¼Œæ¯”å¦‚ä½œä¸ºæ–¹æ³•çš„è¿”å›ç±»å‹ã€‚å‡å®š A å¯ä»¥è½¬æ¢ä¸º Bï¼Œå¦‚æœ X&lt;A&gt; å¯ä»¥è½¬æ¢ä¸º X&lt;B&gt;ï¼Œé‚£ä¹ˆç§° X æœ‰ä¸€ä¸ªåå˜ç±»å‹å‚æ•°ã€‚è€Œé€†å˜çš„è½¬æ¢æ–¹å‘æ­£å¥½ç›¸åï¼Œå³ä» X&lt;B &gt; è½¬æ¢åˆ° X&lt;A&gt;ã€‚ç”±äº C# æœ‰åå˜ï¼ˆcovarianceï¼‰å’Œé€†å˜ï¼ˆcontravariantï¼‰çš„æ¦‚å¿µï¼Œæ‰€ä»¥ â€œå¯è½¬æ¢â€ æ„å‘³ç€å¯ä»¥é€šè¿‡éšå¼å¼•ç”¨è½¬åŒ–è¿›è¡Œç±»å‹è½¬æ¢ã€‚ä½¿ç”¨è¦è·å–æ³›å‹å‚æ•°å’Œè¿”å›å€¼çš„å§”æ‰˜æ—¶ï¼Œå»ºè®®å°½é‡ä¸ºé€†å˜é‡å’Œåå˜é‡æŒ‡å®š in å’Œ out å…³é”®å­—ã€‚è¿™æ ·åšä¸ä¼šæœ‰ä¸è‰¯ååº”ï¼Œå¹¶ä½¿ä½ çš„å§”æ‰˜èƒ½åœ¨æ›´å¤šçš„æƒ…å½¢ä¸­ä½¿ç”¨ã€‚å’Œå§”æ‰˜ç›¸ä¼¼ï¼Œå…·æœ‰æ³›å‹ç±»å‹å‚æ•°çš„æ¥å£ä¹Ÿå¯å°†ç±»å‹å‚æ•°æ ‡è®°ä¸ºé€†å˜é‡å’Œåå˜é‡ã€‚ç®€è€Œè¨€ä¹‹ï¼Œåå˜æ€§æŒ‡å®šè¿”å›ç±»å‹çš„å…¼å®¹æ€§ï¼Œè€Œé€†å˜æ€§æŒ‡å®šå‚æ•°çš„å…¼å®¹æ€§ã€‚</p><h2 id="generic-methods"><a class="anchor" href="#generic-methods">#</a> Generic Methods</h2><blockquote><p>When you define a generic class, struct, or interface, any methods defined in these types can refer to a type parameter specified by the type. A type parameter can be used as a methodâ€™s parameter, a methodâ€™s return type, or as a local variable defined inside the method. However, the CLR also supports the ability for a method to specify its very own type parameters. And these type parameters can also be used for parameters, return types, or local variables.</p></blockquote><blockquote><p>Here is a somewhat contrived example of a type that defines a type parameter and a method that has its very own type parameter.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">GenericType<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">T</span> m_value<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token function">GenericType</span><span class="token punctuation">(</span><span class="token class-name">T</span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> m_value <span class="token operator">=</span> <span class="token keyword">value</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">TOutput</span> <span class="token generic-method"><span class="token function">Converter</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>TOutput<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token class-name">TOutput</span> result <span class="token operator">=</span> <span class="token punctuation">(</span>TOutput<span class="token punctuation">)</span> Convert<span class="token punctuation">.</span><span class="token function">ChangeType</span><span class="token punctuation">(</span>m_value<span class="token punctuation">,</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">TOutput</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">return</span> result<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In this example, you can see that the GenericType class defines its own type parameter (T), and the Converter method defines its own type parameter (TOutput). This allows a GenericType to be constructed to work with any type. The Converter method can convert the object referred to by the m_value field to various types depending on what type argument is passed to it when called. The ability to have type parameters and method parameters allows for phenomenal flexibility.</p></blockquote><blockquote><p>A reasonably good example of a generic method is the Swap method.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">Swap</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token class-name">T</span> o1<span class="token punctuation">,</span> <span class="token keyword">ref</span> <span class="token class-name">T</span> o2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">T</span> temp <span class="token operator">=</span> o1<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> o1 <span class="token operator">=</span> o2<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> o2 <span class="token operator">=</span> temp<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Code can now call Swap like as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">CallingSwap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Int32</span> n1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> n2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"n1=&#123;0&#125;, n2=&#123;1&#125;"</span><span class="token punctuation">,</span> n1<span class="token punctuation">,</span> n2<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token generic-method"><span class="token function">Swap</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>Int32<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token keyword">ref</span> n1<span class="token punctuation">,</span> <span class="token keyword">ref</span> n2<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"n1=&#123;0&#125;, n2=&#123;1&#125;"</span><span class="token punctuation">,</span> n1<span class="token punctuation">,</span> n2<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token string">"Aidan"</span><span class="token punctuation">,</span> s2 <span class="token operator">=</span> <span class="token string">"Grant"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"s1=&#123;0&#125;, s2=&#123;1&#125;"</span><span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token generic-method"><span class="token function">Swap</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>String<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token keyword">ref</span> s1<span class="token punctuation">,</span> <span class="token keyword">ref</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"s1=&#123;0&#125;, s2=&#123;1&#125;"</span><span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Using generic types with methods that take out and ref parameters can be particularly interesting because the variable you pass as an out/ref argument must be the same type as the methodâ€™s parameter to avoid a potential type safety exploit. This issue related to out/ref parameters is discussed toward the end of the â€œPassing Parameters by Reference to a Methodâ€ section in Chapter 9, â€œParameters.â€ In fact, the Interlocked classâ€™s Exchange and CompareExchange methods offer generic overloads for precisely this reason.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Interlocked</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">T</span> <span class="token generic-method"><span class="token function">Exchange</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token class-name">T</span> location1<span class="token punctuation">,</span> <span class="token class-name">T</span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token keyword">where</span> <span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token type-list"><span class="token keyword">class</span></span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">T</span> <span class="token generic-method"><span class="token function">CompareExchange</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">ref</span> <span class="token class-name">T</span> location1<span class="token punctuation">,</span> <span class="token class-name">T</span> <span class="token keyword">value</span><span class="token punctuation">,</span> <span class="token class-name">T</span> comparand<span class="token punctuation">)</span> <span class="token keyword">where</span> <span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token type-list"><span class="token keyword">class</span></span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="generic-methods-and-type-inference"><a class="anchor" href="#generic-methods-and-type-inference">#</a> Generic Methods and Type Inference</h3><blockquote><p>For many developers, the C# generic syntax can be confusing with all of its less-than and greaterthan signs. To help improve code creation, readability, and maintainability, the C# compiler offers type inference when calling a generic method. Type inference means that the compiler attempts to determine (or infer) the type to use automatically when calling a generic method. Here is some code that demonstrates type inference.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">CallingSwapUsingInference</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Int32</span> n1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> n2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">ref</span> n1<span class="token punctuation">,</span> <span class="token keyword">ref</span> n2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Calls Swap&lt;Int32></span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token string">"Aidan"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token class-name">Object</span> s2 <span class="token operator">=</span> <span class="token string">"Grant"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">ref</span> s1<span class="token punctuation">,</span> <span class="token keyword">ref</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Error, type can't be inferred </span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In this code, notice that the calls to Swap do not specify type arguments in less-than/greater-than signs. In the first call to Swap, the C# compiler was able to infer that n1 and n2 are Int32s, and therefore, it should call Swap by using an Int32 type argument.</p></blockquote><blockquote><p>When performing type inference, C# uses the variableâ€™s data type, not the actual type of the object referred to by the variable. So in the second call to Swap, C# sees that s1 is a String and s2 is an Object (even though it happens to refer to a String). Because s1 and s2 are variables of different data types, the compiler canâ€™t accurately infer the type to use for Swapâ€™s type argument, and it issues the following message: error CS0411: The type arguments for method 'Program. Swap(ref T, ref T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.</p></blockquote><blockquote><p>A type can define multiple methods with one of its methods taking a specific data type and another taking a generic type parameter, as in the following example.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Display</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">Display</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">T</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token function">Display</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Calls Display(String) </span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>Here are some ways to call the <span class="token return-type class-name">Display</span> method<span class="token punctuation">.</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token function">Display</span><span class="token punctuation">(</span><span class="token string">"Jeff"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Calls Display(String) </span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token function">Display</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Calls Display&lt;T>(T) </span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token generic-method"><span class="token function">Display</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>String<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token string">"Aidan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Calls Display&lt;T>(T)</span></pre></td></tr></table></figure><blockquote><p>n the first call, the compiler could actually call either the Display method that takes a String or the generic Display method (replacing T with String). However, the C# compiler always prefers a more explicit match over a generic match, and therefore, it generates a call to the nongeneric Display method that takes a String. For the second call, the compiler canâ€™t call the non-generic Display method that takes a String, so it must call the generic Display method. By the way, it is fortunate that the compiler always prefers the more explicit match; if the compiler had preferred the generic method, because the generic Display method calls Display again (but with a String returned by ToString), there would have been infinite recursion.</p></blockquote><blockquote><p>The third call to Display specifies a generic type argument, String. This tells the compiler not to try to infer type arguments but instead to use the type arguments that I explicitly specified. In this case, the compiler also assumes that I must really want to call the generic Display method, so the generic Display will be called. Internally, the generic Display method will call ToString on the passed-in string, which results in a string that is then passed to the non-generic Display method.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šå®šä¹‰æ³›å‹ç±»ã€ç»“æ„æˆ–æ¥å£æ—¶ï¼Œç±»å‹ä¸­å®šä¹‰çš„ä»»ä½•æ–¹æ³•éƒ½å¯å¼•ç”¨ç±»å‹æŒ‡å®šçš„ç±»å‹å‚æ•°ã€‚ç±»å‹å‚æ•°å¯ä½œä¸ºæ–¹æ³•å‚æ•°ã€æ–¹æ³•è¿”å›å€¼æˆ–æ–¹æ³•å†…éƒ¨å®šä¹‰çš„å±€éƒ¨å˜é‡çš„ç±»å‹ä½¿ç”¨ã€‚ç„¶è€Œï¼ŒCLR è¿˜å…è®¸æ–¹æ³•å®šä¹‰å®ƒè‡ªå·±çš„ç±»å‹å‚æ•°ã€‚è¿™äº›å‚æ•°ä¹Ÿå¯ä½œä¸ºå‚æ•°ã€è¿”å›å€¼æˆ–å±€éƒ¨å˜é‡çš„ç±»å‹ä½¿ç”¨ã€‚ä¸ºäº†æ”¹è¿›ä»£ç çš„åˆ›å»ºï¼Œå¢å¼ºå¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§ï¼ŒC# ç¼–è¯‘å™¨æ”¯æŒåœ¨è°ƒç”¨æ³›å‹æ–¹æ³•æ—¶è¿›è¡Œç±»å‹æ¨æ–­ã€‚è¿™æ„å‘³ç€ç¼–è¯‘å™¨ä¼šåœ¨è°ƒç”¨æ³›å‹æ–¹æ³•æ—¶è‡ªåŠ¨åˆ¤æ–­ï¼ˆæˆ–è€…è¯´æ¨æ–­ï¼‰è¦ä½¿ç”¨çš„ç±»å‹ã€‚æ¨æ–­ç±»å‹æ—¶ï¼ŒC# ä½¿ç”¨å˜é‡çš„æ•°æ®ç±»å‹ï¼Œè€Œä¸æ˜¯å˜é‡å¼•ç”¨çš„å¯¹è±¡çš„å®é™…ç±»å‹ã€‚ç±»å‹å¯å®šä¹‰å¤šä¸ªæ–¹æ³•ï¼Œè®©å…¶ä¸­ä¸€ä¸ªæ–¹æ³•æ¥å—å…·ä½“æ•°æ®ç±»å‹ï¼Œè®©å¦ä¸€ä¸ªæ¥å—æ³›å‹ç±»å‹å‚æ•°ã€‚C# ç¼–è¯‘å™¨çš„ç­–ç•¥æ˜¯å…ˆè€ƒè™‘è¾ƒæ˜ç¡®çš„åŒ¹é…ï¼Œå†è€ƒè™‘æ³›å‹åŒ¹é…ã€‚</p><h2 id="generics-and-other-members"><a class="anchor" href="#generics-and-other-members">#</a> Generics and Other Members</h2><blockquote><p>In C#, properties, indexers, events, operator methods, constructors, and finalizers cannot themselves have type parameters. However, they can be defined within a generic type, and the code in these members can use the typeâ€™s type parameters.</p></blockquote><blockquote><p>C# doesnâ€™t allow these members to specify their own generic type parameters because Microsoftâ€™s C# team believes that developers would rarely have a need to use these members as generic. Furthermore, the cost of adding generic support to these members would be quite high in terms of designing adequate syntax into the language. For example, when you use a + operator in code, the compiler could call an operator overload method. There is no way to indicate any type arguments in your code along with the + operator.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šåœ¨ C# ä¸­ï¼Œå±æ€§ã€ç´¢å¼•å™¨ã€äº‹ä»¶ã€æ“ä½œç¬¦æ–¹æ³•ã€æ„é€ å™¨å’Œç»ˆç»“å™¨æœ¬èº«ä¸èƒ½æœ‰ç±»å‹å‚æ•°ã€‚ä½†å®ƒä»¬èƒ½åœ¨æ³›å‹ç±»å‹ä¸­å®šä¹‰ï¼Œè€Œä¸”è¿™äº›æˆå‘˜ä¸­çš„ä»£ç èƒ½ä½¿ç”¨ç±»å‹çš„ç±»å‹å‚æ•°ã€‚</p><h2 id="verifiability-and-constraints"><a class="anchor" href="#verifiability-and-constraints">#</a> Verifiability and Constraints</h2><blockquote><p>When compiling generic code, the C# compiler analyzes it and ensures that the code will work for any type that exists today or that may be defined in the future. Letâ€™s look at the following method.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name">Boolean</span> <span class="token generic-method"><span class="token function">MethodTakingAnyType</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">T</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">T</span> temp <span class="token operator">=</span> o<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">Boolean</span> b <span class="token operator">=</span> temp<span class="token punctuation">.</span><span class="token function">Equals</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">return</span> b<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>This method declares a temporary variable (temp) of type T, and then the method performs a couple of variable assignments and a few method calls. This method works for any type. If T is a reference type, it works. If T is a value or enumeration type, it works. If T is an interface or delegate type, it works. This method works for all types that exist today or that will be defined tomorrow because every type supports assignment and calls to methods defined by Object (such as ToString and Equals).</p></blockquote><blockquote><p>Now look at the following method.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name">T</span> <span class="token generic-method"><span class="token function">Min</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">T</span> o1<span class="token punctuation">,</span> <span class="token class-name">T</span> o2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>o1<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>o2<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> o1<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">return</span> o2<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The Min method attempts to use the o1 variable to call the CompareTo method. But there are lots of types that do not offer a CompareTo method, and therefore, the C# compiler canâ€™t compile this code and guarantee that this method would work for all types. If you attempt to compile the above code, the compiler issues the following message: error CS1061: 'T' does not contain a definition for 'CompareTo' accepting a first argument of type 'T' could be found (are you missing a using directive or an assembly reference?)</p></blockquote><blockquote><p>So it would seem that when using generics, you can declare variables of a generic type, perform some variable assignments, call methods defined by Object, and thatâ€™s about it! This makes generics practically useless. Fortunately, compilers and the CLR support a mechanism called constraints that you can take advantage of to make generics useful again.</p></blockquote><blockquote><p>A constraint is a way to limit the number of types that can be specified for a generic argument. Limiting the number of types allows you to do more with those types. Here is a new version of the Min method that specifies a constraint (in bold).</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">T</span> <span class="token generic-method"><span class="token function">Min</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">T</span> o1<span class="token punctuation">,</span> <span class="token class-name">T</span> o2<span class="token punctuation">)</span> <span class="token keyword">where</span> <span class="token class-name">T</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IComparable<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>o1<span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>o2<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> o1<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">return</span> o2<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The C# where token tells the compiler that any type specified for T must implement the generic IComparable interface of the same type (T). Because of this constraint, the compiler now allows the method to call the CompareTo method because this method is defined by the IComparable interface.</p></blockquote><blockquote><p>Now, when code references a generic type or method, the compiler is responsible for ensuring that a type argument that meets the constraints is specified. For example, the following code causes the compiler to issue the following message: error CS0311: The type 'object' cannot be used as type parameter 'T' in the generic type or method 'SomeType.Min(T, T)'. There is no implicit reference conversion from 'object' to 'System. IComparable'.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">CallMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Object</span> o1 <span class="token operator">=</span> <span class="token string">"Jeff"</span><span class="token punctuation">,</span> o2 <span class="token operator">=</span> <span class="token string">"Richter"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Object</span> oMin <span class="token operator">=</span> <span class="token generic-method"><span class="token function">Min</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>Object<span class="token punctuation">></span></span></span><span class="token punctuation">(</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error CS0311</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The compiler issues the error because System.Object doesnâ€™t implement the IComparableÂ­ interface. In fact, System.Object doesnâ€™t implement any interfaces at all.</p></blockquote><blockquote><p>Now that you have a sense of what constraints are and how they work, weâ€™ll start to look a little deeper into them. Constraints can be applied to a generic typeâ€™s type parameters as well as to a generic methodâ€™s type parameters (as shown in the Min method). The CLR doesnâ€™t allow overloading based on type parameter names or constraints; you can overload types or methods based only on arity. The following examples show what I mean.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// It is OK to define the following types: </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">AType</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">AType<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">AType<span class="token punctuation">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// Error: conflicts with AType&lt;T> that has no constraints </span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">AType<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token keyword">where</span> <span class="token class-name">T</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IComparable<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// Error: conflicts with AType&lt;T1, T2></span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">AType<span class="token punctuation">&lt;</span>T3<span class="token punctuation">,</span> T4<span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">AnotherType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// It is OK to define the following methods: </span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">M</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">M</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">M</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token comment">// Error: conflicts with M&lt;T> that has no constraints </span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">M</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">where</span> <span class="token class-name">T</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IComparable<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token comment">// Error: conflicts with M&lt;T1, T2></span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">M</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T3<span class="token punctuation">,</span> T4<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When overriding a virtual generic method, the overriding method must specify the same number of type parameters, and these type parameters will inherit the constraints specified on them by the base classâ€™s method. In fact, the overriding method is not allowed to specify any constraints on its type parameters at all. However, it can change the names of the type parameters. Similarly, when implementing an interface method, the method must specify the same number of type parameters as the interface method, and these type parameters will inherit the constraints specified on them by the interfaceâ€™s method. Here is an example that demonstrates this rule by using virtual methods.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">M</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">where</span> <span class="token class-name">T1</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token keyword">struct</span></span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">where</span> <span class="token class-name">T2</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token keyword">class</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Base</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">M</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T3<span class="token punctuation">,</span> T4<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">where</span> <span class="token class-name">T3</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">EventArgs</span></span> <span class="token comment">// Error </span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">where</span> <span class="token class-name">T4</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token keyword">class</span></span> <span class="token comment">// Error </span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Attempting to compile the preceding code causes the compiler to issue the following message: error CS0460: Constraints for override and explicit interface implementation methods are inherited from the base method, so they cannot be specified directly. If we remove the two where lines from the Derived classâ€™s M method, the code will compile just fine. Notice that you can change the names of the type parameters (as in the example: from T1 to T3 and T2 to T4); however, you cannot change (or even specify) constraints.</p></blockquote><blockquote><p>Now letâ€™s talk about the different kinds of constraints the compiler/CLR allows you to apply to a type parameter. A type parameter can be constrained by using a primary constraint, a secondary constraint, and/or a constructor constraint. Iâ€™ll talk about these three kinds of constraints in the next three sections.</p></blockquote><h3 id="primary-constraints"><a class="anchor" href="#primary-constraints">#</a> Primary Constraints</h3><blockquote><p>A type parameter can specify zero primary constraints or one primary constraint. A primary constraint can be a reference type that identifies a class that is not sealed. You cannot specify one of the following special reference types: System.Object, System.Array, System.Delegate, System.MulticastDelegate, System.ValueType, System.Enum, or System.Void.</p></blockquote><blockquote><p>When specifying a reference type constraint, you are promising the compiler that a specified type argument will either be of the same type or of a type derived from the constraint type. For example, see the following generic class.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">PrimaryConstraintOfStream<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token keyword">where</span> <span class="token class-name">T</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Stream</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">M</span><span class="token punctuation">(</span><span class="token class-name">T</span> stream<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> stream<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// OK </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In this class definition, the type parameter T has a primary constraint of Stream (defined in the <span class="exturl" data-url="aHR0cDovL1N5c3RlbS5JTw==">System.IO</span> namespace). This tells the compiler that code using PrimaryConstraintOfStream must specify a type argument of Stream or a type derived from Stream (such as FileStream). If a type parameter doesnâ€™t specify a primary constraint, System.Object is assumed. However, the C# compiler issues an error message (error CS0702: Constraint cannot be special class 'object') if you explicitly specify System.Object in your source code.</p></blockquote><blockquote><p>There are two special primary constraints: class and struct. The class constraint promises the compiler that a specified type argument will be a reference type. Any class type, interface type, delegate type, or array type satisfies this constraint. For example, see the following generic class.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">PrimaryConstraintOfClass<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token keyword">where</span> <span class="token class-name">T</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token keyword">class</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">M</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">T</span> temp <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">// Allowed because T must be a reference type </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In this example, setting temp to null is legal because T is known to be a reference type, and all reference type variables can be set to null. If T were unconstrained, the preceding code would not compile because T could be a value type, and value type variables cannot be set to null.</p></blockquote><blockquote><p>The struct constraint promises the compiler that a specified type argument will be a value type. Any value type, including enumerations, satisfies this constraint. However, the compiler and the CLR treat any System.Nullable value type as a special type, and nullable types do not satisfy this constraint. The reason is because the Nullable type constrains its type parameter to struct, and the CLR wants to prohibit a recursive type such as Nullable&gt;. Nullable types are discussed in Chapter 19, â€œNullable Value Types.â€</p></blockquote><blockquote><p>Here is an example class that constrains its type parameter by using the struct constraint.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">PrimaryConstraintOfStruct<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token keyword">where</span> <span class="token class-name">T</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token keyword">struct</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">T</span> <span class="token function">Factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// Allowed because all value types implicitly </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// have a public, parameterless constructor </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In this example, newing up a T is legal because T is known to be a value type, and all value types implicitly have a public, parameterless constructor. If T were unconstrained, constrained to a reference type, or constrained to class, the above code would not compile because some reference types do not have public, parameterless constructors.</p></blockquote><h3 id="secondary-constraints"><a class="anchor" href="#secondary-constraints">#</a> Secondary Constraints</h3><blockquote><p>A type parameter can specify zero or more secondary constraints where a secondary constraint represents an interface type. When specifying an interface type constraint, you are promising the compiler that a specified type argument will be a type that implements the interface. And because you can specify multiple interface constraints, the type argument must specify a type that implements all of the interface constraints (and all of the primary constraints too, if specified). Chapter 13 discusses interface constraints in detail.</p></blockquote><blockquote><p>There is another kind of secondary constraint called a type parameter constraint (sometimes referred to as a naked type constraint). This kind of constraint is used much less often than an interface constraint. It allows a generic type or method to indicate that there must be a relationship between specified type arguments. A type parameter can have zero or more type constraints applied to it. Here is a generic method that demonstrates the use of a type parameter constraint.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name">List<span class="token punctuation">&lt;</span>TBase<span class="token punctuation">></span></span> <span class="token generic-method"><span class="token function">ConvertIList</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">,</span> TBase<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">IList<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> list<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">where</span> <span class="token class-name">T</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">TBase</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">List<span class="token punctuation">&lt;</span>TBase<span class="token punctuation">></span></span> baseList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">List<span class="token punctuation">&lt;</span>TBase<span class="token punctuation">></span></span><span class="token punctuation">(</span>list<span class="token punctuation">.</span>Count<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> list<span class="token punctuation">.</span>Count<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> baseList<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>list<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">return</span> baseList<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The <code>ConvertIList</code> method specifies two type parameters in which the T parameter is constrained by the <code>TBase</code> type parameter. This means that whatever type argument is specified for T, the type argument must be compatible with whatever type argument is specified for <code>TBase</code> . Here is a method showing some legal and illegal calls to <code>ConvertIList</code> .</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">CallingConvertIList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Construct and initialize a List&lt;String> (which implements IList&lt;String>) </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">IList<span class="token punctuation">&lt;</span>String<span class="token punctuation">></span></span> ls <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">List<span class="token punctuation">&lt;</span>String<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> ls<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">"A String"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// Convert the IList&lt;String> to an IList&lt;Object></span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token class-name">IList<span class="token punctuation">&lt;</span>Object<span class="token punctuation">></span></span> lo <span class="token operator">=</span> <span class="token generic-method"><span class="token function">ConvertIList</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token punctuation">></span></span></span><span class="token punctuation">(</span>ls<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// Convert the IList&lt;String> to an IList&lt;IComparable></span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token class-name">IList<span class="token punctuation">&lt;</span>IComparable<span class="token punctuation">></span></span> lc <span class="token operator">=</span> <span class="token generic-method"><span class="token function">ConvertIList</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> IComparable<span class="token punctuation">></span></span></span><span class="token punctuation">(</span>ls<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// Convert the IList&lt;String> to an IList&lt;IComparable&lt;String>></span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token class-name">IList<span class="token punctuation">&lt;</span>IComparable<span class="token punctuation">&lt;</span>String<span class="token punctuation">></span><span class="token punctuation">></span></span> lcs <span class="token operator">=</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token generic-method"><span class="token function">ConvertIList</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> IComparable<span class="token punctuation">&lt;</span>String<span class="token punctuation">></span><span class="token punctuation">></span></span></span><span class="token punctuation">(</span>ls<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// Convert the IList&lt;String> to an IList&lt;String></span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token class-name">IList<span class="token punctuation">&lt;</span>String<span class="token punctuation">></span></span> ls2 <span class="token operator">=</span> <span class="token generic-method"><span class="token function">ConvertIList</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> String<span class="token punctuation">></span></span></span><span class="token punctuation">(</span>ls<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token comment">// Convert the IList&lt;String> to an IList&lt;Exception></span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token class-name">IList<span class="token punctuation">&lt;</span>Exception<span class="token punctuation">></span></span> le <span class="token operator">=</span> <span class="token generic-method"><span class="token function">ConvertIList</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> Exception<span class="token punctuation">></span></span></span><span class="token punctuation">(</span>ls<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Error </span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In the first call to <code>ConvertIList</code> , the compiler ensures that String is compatible with Object. Because String is derived from Object, the first call adheres to the type parameter constraint. In the second call to <code>ConvertIList</code> , the compiler ensures that String is compatible with <code>IComparable</code> . Because String implements the <code>IComparable</code> interface, the second call adheres to the type parameter constraint. In the third call to <code>ConvertIList</code> , the compiler ensures that String is compatible with <code>IComparable</code> . Because String implements the <code>IComparable</code> interface, the third call adheres to the type parameter constraint. In the fourth call to <code>ConvertIList</code> , the compiler knows that String is compatible with itself. In the fifth call to <code>ConvertIList</code> , the compiler ensures that String is compatible with Exception. Because String is not compatible with Exception, the fifth call doesnâ€™t adhere to the type parameter constraint, and the compiler issues the following message: error CS0311: The type 'string' cannot be used as type parameter 'T' in the generic type or method <code>Program.ConvertIList(System.Collections.Generic.IList)</code> '. There is no implicit reference conversion from 'string' to ' <code>System.Exception</code> '.</p></blockquote><h3 id="constructor-constraints"><a class="anchor" href="#constructor-constraints">#</a> Constructor Constraints</h3><blockquote><p>A type parameter can specify zero constructor constraints or one constructor constraint. When specifying a constructor constraint, you are promising the compiler that a specified type argument will be a non-abstract type that implements a public, parameterless constructor. Note that the C# compiler considers it an error to specify a constructor constraint with the struct constraint because it is redundant; all value types implicitly offer a public, parameterless constructor. Here is an example class that constrains its type parameter by using the constructor constraint.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">ConstructorConstraint<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token keyword">where</span> <span class="token class-name">T</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">T</span> <span class="token function">Factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// Allowed because all value types implicitly </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// have a public, parameterless constructor and because </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// the constraint requires that any specified reference </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// type also have a public, parameterless constructor </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In this example, newing up a T is legal because T is known to be a type that has a public, parameterless constructor. This is certainly true of all value types, and the constructor constraint requires that it be true of any reference type specified as a type argument.</p></blockquote><blockquote><p>Sometimes developers would like to declare a type parameter by using a constructor constraint whereby the constructor takes various parameters itself. As of now, the CLR (and therefore the C# compiler) supports only parameterless constructors. Microsoft feels that this will be good enough for almost all scenarios, and I agree.</p></blockquote><h3 id="other-verifiability-issues"><a class="anchor" href="#other-verifiability-issues">#</a> Other Verifiability Issues</h3><blockquote><p>In the remainder of this section, Iâ€™d like to point out a few other code constructs that have unexpected behavior when used with generics due to verifiability issues and how constraints can be used to make the code verifiable again.</p></blockquote><h3 id="casting-a-generic-type-variable"><a class="anchor" href="#casting-a-generic-type-variable">#</a> Casting a Generic Type Variable</h3><blockquote><p>Casting a generic type variable to another type is illegal unless you are casting to a type compatible with a constraint.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">CastingAGenericTypeVariable1</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">T</span> obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token punctuation">(</span>Int32<span class="token punctuation">)</span> obj<span class="token punctuation">;</span> <span class="token comment">// Error </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> obj<span class="token punctuation">;</span> <span class="token comment">// Error </span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The compiler issues an error on both lines above because T could be any type, and there is no guarantee that the casts will succeed. You can modify this code to get it to compile by casting to Object first.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">CastingAGenericTypeVariable2</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">T</span> obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token punctuation">(</span>Int32<span class="token punctuation">)</span> <span class="token punctuation">(</span>Object<span class="token punctuation">)</span> obj<span class="token punctuation">;</span> <span class="token comment">// No error </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> <span class="token punctuation">(</span>Object<span class="token punctuation">)</span> obj<span class="token punctuation">;</span> <span class="token comment">// No error </span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Although this code will now compile, it is still possible for the CLR to throw an <code>InvalidCastException</code> at run time.</p></blockquote><blockquote><p>If you are trying to cast to a reference type, you can also use the C# as operator. Here is code modified to use the as operator with String (because Int32 is a value type).</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">CastingAGenericTypeVariable3</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">T</span> obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">String</span> s <span class="token operator">=</span> obj <span class="token keyword">as</span> <span class="token class-name">String</span><span class="token punctuation">;</span> <span class="token comment">// No error </span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="setting-a-generic-type-variable-to-a-default-value"><a class="anchor" href="#setting-a-generic-type-variable-to-a-default-value">#</a> Setting a Generic Type Variable to a Default Value</h3><blockquote><p>Setting a generic type variable to null is illegal unless the generic type is constrained to a reference type.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">SettingAGenericTypeVariableToNull</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">T</span> temp <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// CS0403 â€“ Cannot convert null to type parameter 'T' because it could</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// be a non-nullable value type. Consider using 'default(T)' instead</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Because T is unconstrained, it could be a value type, and setting a variable of a value type to null is not possible. If T were constrained to a reference type, setting temp to null would compile and run just fine.</p></blockquote><blockquote><p>Microsoftâ€™s C# team felt that it would be useful to give developers the ability to set a variable to a default value. So the C# compiler allows you to use the default keyword to accomplish this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">SettingAGenericTypeVariableToDefaultValue</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">T</span> temp <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">(</span><span class="token type-expression class-name">T</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK </span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The use of the default keyword above tells the C# compiler and the CLRâ€™s JIT compiler to produce code to set temp to null if T is a reference type and to set temp to all-bits-zero if T is a value type.</p></blockquote><h3 id="comparing-a-generic-type-variable-with-null"><a class="anchor" href="#comparing-a-generic-type-variable-with-null">#</a> Comparing a Generic Type Variable with null</h3><blockquote><p>Comparing a generic type variable to null by using the == or != operator is legal regardless of whether the generic type is constrained.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">ComparingAGenericTypeVariableWithNull</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">T</span> obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* Never executes for a value type */</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Because T is unconstrained, it could be a reference type or a value type. If T is a value type, obj can never be null. Normally, youâ€™d expect the C# compiler to issue an error because of this. However, the C# compiler does not issue an error; instead, it compiles the code just fine. When this method is called using a type argument that is a value type, the JIT compiler sees that the if statement can never be true, and the JIT compiler will not emit the native code for the if test or the code in the braces. If I had used the != operator, the JIT compiler would not emit the code for the if test (because it is always true), and it will emit the code inside the ifâ€™s braces.</p></blockquote><blockquote><p>By the way, if T had been constrained to a struct, the C# compiler would issue an error because you shouldnâ€™t be writing code that compares a value type variable with null because the result is always the same.</p></blockquote><h3 id="comparing-two-generic-type-variables-with-each-other"><a class="anchor" href="#comparing-two-generic-type-variables-with-each-other">#</a> Comparing Two Generic Type Variables with Each Other</h3><blockquote><p>Comparing two variables of the same generic type is illegal if the generic type parameter is not known to be a reference type.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">ComparingTwoGenericTypeVariables</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">T</span> o1<span class="token punctuation">,</span> <span class="token class-name">T</span> o2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>o1 <span class="token operator">==</span> o2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// Error </span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In this example, T is unconstrained, and whereas it is legal to compare two reference type variables with one another, it is not legal to compare two value type variables with one another unless the value type overloads the == operator. If T were constrained to class, this code would compile, and the == operator would return true if the variables referred to the same object, checking for exact identity. Note that if T were constrained to a reference type that overloaded the operator == method, the compiler would emit calls to this method when it sees the == operator. Obviously, this whole discussion applies to uses of the != operator too.</p></blockquote><blockquote><p>When you write code to compare the primitive value typesâ€”Byte, Int32, Single, Decimal, etc.â€”the C# compiler knows how to emit the right code. However, for non-primitive value types, the C# compiler doesnâ€™t know how to emit the code to do comparisons. So if <code>ComparingTwoGenericTypeVariables</code> methodâ€™s T were constrained to struct, the compiler would issue an error. And youâ€™re not allowed to constrain a type parameter to a specific value type because it is implicitly sealed, and therefore no types exist that are derived from the value type. Allowing this would make the generic method constrained to a specific type, and the C# compiler doesnâ€™t allow this because it is more efficient to just make a non-generic method.</p></blockquote><h3 id="using-generic-type-variables-as-operands"><a class="anchor" href="#using-generic-type-variables-as-operands">#</a> Using Generic Type Variables as Operands</h3><blockquote><p>Finally, it should be noted that there are a lot of issues about using operators with generic type operands. In Chapter 5, I talked about C# and how it handles its primitive types: Byte, Int16, Int32, Int64, Decimal, and so on. In particular, I mentioned that C# knows how to interpret operators (such as +, -, *, and /) when applied to the primitive types. Well, these operators canâ€™t be applied to variables of a generic type because the compiler doesnâ€™t know the type at compile time. This means that you canâ€™t use any of these operators with variables of a generic type. So it is impossible to write a mathematical algorithm that works on an arbitrary numeric data type. Here is an example of a generic method that Iâ€™d like to write.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name">T</span> <span class="token generic-method"><span class="token function">Sum</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">T</span> num<span class="token punctuation">)</span> <span class="token keyword">where</span> <span class="token class-name">T</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token keyword">struct</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">T</span> sum <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">(</span><span class="token type-expression class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">T</span> n <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">(</span><span class="token type-expression class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> n <span class="token operator">&lt;</span> num <span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> sum <span class="token operator">+=</span> n<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">return</span> sum<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Iâ€™ve done everything possible to try to get this method to compile. Iâ€™ve constrained T to struct, and Iâ€™m using default(T) to initialize sum and n to 0. But when I compile this code, I get the following three errors.</p><ul><li><p>error CS0019: Operator '&lt;' cannot be applied to operands of type 'T' and 'T'</p></li><li><p>error CS0023: Operator '++' cannot be applied to operand of type 'T'</p></li><li><p>error CS0019: Operator '+=' cannot be applied to operands of type 'T' and 'T'</p></li></ul></blockquote><blockquote><p>This is a severe limitation on the CLRâ€™s generic support, and many developers (especially in the scientific, financial, and mathematical world) are very disappointed by this limitation. Many people have tried to come up with techniques to work around this limitation by using reflection (see Chapter 23, â€œAssembly Loading and Reflectionâ€), the dynamic primitive type (see Chapter 5), operator overloading, and so on. But all of these cause a severe performance penalty or hurt readability of the code substantially. Hopefully, this is an area that Microsoft will address in a future version of the CLR and the compilers.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šC# çš„æ³›å‹å’Œ C++ çš„æ¨¡æ¿åœ¨åº”ç”¨ç¨‹åºä¸­å¾ˆç›¸ä¼¼ï¼Œä½†æ˜¯å®ƒä»¬çš„å·¥ä½œåŸç†å´å¤§ä¸ç›¸åŒã€‚ä¸¤è€…éƒ½å‘ç”Ÿäº†ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…çš„å…³è”ï¼Œä¸”ç”Ÿäº§è€…çš„å ä½ç¬¦å°†è¢«æ¶ˆè´¹è€…å¡«å……ã€‚ä½†æ˜¯åœ¨ C# æ³›å‹ä¸­ï¼Œç”Ÿäº§è€…çš„ç±»å‹ï¼ˆå¼€æ”¾ç±»å‹ï¼Œå¦‚ Listï¼‰å¯ä»¥ç¼–è¯‘åˆ°ç¨‹åºåº“ï¼ˆå¦‚ mscorlib.dllï¼‰ä¸­ã€‚è¿™æ˜¯å› ä¸ºç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…è¿›è¡Œå…³è”ç”Ÿæˆå°é—­ç±»å‹æ˜¯åœ¨è¿è¡Œæ—¶å‘ç”Ÿçš„ã€‚è€Œ C++ æ¨¡æ¿ä¸­ï¼Œè¿™ä¸€å…³è”æ˜¯åœ¨ç¼–è¯‘æ—¶è¿›è¡Œçš„ã€‚è¿™æ„å‘³ç€ C++ ä¸èƒ½å°†æ¨¡æ¿åº“éƒ¨ç½²ä¸º .dllï¼Œå®ƒä»¬åªå­˜åœ¨äºæºä»£ç ä¸­ã€‚å›åˆ° C#ï¼Œä»è¡¨é¢çœ‹ï¼Œä½¿ç”¨æ³›å‹ä¼¼ä¹åšä¸äº†å¤ªå¤šäº‹æƒ…ã€‚åªèƒ½å£°æ˜æ³›å‹ç±»å‹çš„å˜é‡ï¼Œæ‰§è¡Œå˜é‡èµ‹å€¼ï¼Œåœ¨è°ƒç”¨ Object å®šä¹‰çš„æ–¹æ³•ã€‚å‡å¦‚æ³›å‹åªèƒ½è¿™ä¹ˆç”¨ï¼Œå¯ä»¥è¯´å®ƒå‡ ä¹æ²¡æœ‰ä»»ä½•ç”¨ã€‚ç¼–è¯‘å™¨å’Œ CLR æ”¯æŒç§°ä¸ºçº¦æŸçš„æœºåˆ¶ï¼Œå¯é€šè¿‡å®ƒä½¿æ³›å‹å˜å¾—çœŸæ­£æœ‰ç”¨ã€‚C# çš„ where å…³é”®å­—å‘Šè¯‰ç¼–è¯‘å™¨ï¼Œä¸º T æŒ‡å®šçš„ä»»ä½•ç±»å‹éƒ½å¿…é¡»å®ç°æ»¡è¶³ç›¸åº”çš„çº¦æŸã€‚çº¦æŸå¯åº”ç”¨äºæ³›å‹ç±»å‹çš„ç±»å‹å‚æ•°ï¼Œä¹Ÿå¯åº”ç”¨äºæ³›å‹æ–¹æ³•çš„ç±»å‹å‚æ•°ã€‚CLR ä¸å…è®¸åŸºäºç±»å‹å‚æ•°åç§°æˆ–çº¦æŸè¿›è¡Œé‡è½½ï¼›åªèƒ½åŸºäºå…ƒæ•°ï¼ˆç±»å‹å‚æ•°ä¸ªæ•°ï¼‰å¯¹ç±»å‹æˆ–æ–¹æ³•è¿›è¡Œé‡è½½ã€‚é‡è½½è™šæ³›å‹æ–¹æ³•æ—¶ï¼Œé‡å†™çš„æ–¹æ³•å¿…é¡»æŒ‡å®šç›¸åŒæ•°é‡çš„ç±»å‹å‚æ•°ï¼Œè€Œä¸”è¿™äº›ç±»å‹å‚æ•°ä¼šç»§æ‰¿åœ¨åŸºç±»æ–¹æ³•ä¸ŠæŒ‡å®šçš„çº¦æŸã€‚äº‹å®ä¸Šï¼Œæ ¹æœ¬ä¸å…è®¸ä¸ºé‡å†™æ–¹æ³•çš„ç±»å‹å‚æ•°æŒ‡å®šä»»ä½•çº¦æŸã€‚ä½†ç±»å‹å‚æ•°çš„åç§°æ˜¯å¯ä»¥æ”¹å˜çš„ã€‚ç±»ä¼¼åœ°ï¼Œå®ç°æ¥å£æ–¹æ³•æ—¶ï¼Œæ–¹æ³•å¿…é¡»æŒ‡å®šä¸æ¥å£æ–¹æ³•ç­‰é‡çš„ç±»å‹å‚æ•°ï¼Œè¿™äº›ç±»å‹å‚æ•°å°†ç»§æ‰¿ç”±æ¥å£æ–¹æ³•æŒ‡å®šçš„çº¦æŸã€‚ç¼–è¯‘å™¨ / CLR å…è®¸å‘ç±»å‹å‚æ•°åº”ç”¨å„ç§çº¦æŸã€‚å¯ç”¨ä¸€ä¸ªä¸»è¦çº¦æŸã€ä¸€ä¸ªæ¬¡è¦çº¦æŸä»¥åŠ / æˆ–è€…ä¸€ä¸ªæ„é€ å™¨çº¦æŸæ¥çº¦æŸç±»å‹å‚æ•°ã€‚ç±»å‹å‚æ•°å¯ä»¥æŒ‡å®šé›¶ä¸ªæˆ–è€…ä¸€ä¸ªä¸»è¦çº¦æŸã€‚ä¸»è¦çº¦æŸå¯ä»¥æ˜¯ä»£è¡¨éå¯†å°ç±»çš„ä¸€ä¸ªå¼•ç”¨ç±»å‹ã€‚ä½†æœ‰äº›ç‰¹æ®Šå¼•ç”¨ç±»å‹ä¸èƒ½æŒ‡å®šã€‚æŒ‡å®šå¼•ç”¨ç±»å‹çº¦æŸæ—¶ï¼Œç›¸å½“äºå‘ç¼–è¯‘å™¨æ‰¿è¯ºï¼šä¸€ä¸ªæŒ‡å®šçš„ç±»å‹å®å‚è¦ä¹ˆæ˜¯ä¸çº¦æŸç±»å‹ç›¸åŒçš„ç±»å‹ï¼Œè¦ä¹ˆæ˜¯ä»çº¦æŸç±»å‹æ´¾ç”Ÿçš„ç±»å‹ã€‚å¦‚æœç±»å‹å‚æ•°æ²¡æœ‰æŒ‡å®šä¸»è¦çº¦æŸï¼Œå°±é»˜è®¤ä¸º <code>System.Object</code> ã€‚ä½†å¦‚æœåœ¨æºä»£ç ä¸­æ˜¾å¼æŒ‡å®š <code>System.Object</code> ï¼ŒC# ä¼šæŠ¥é”™ã€‚æœ‰ä¸¤ä¸ªç‰¹æ®Šçš„ä¸»è¦çº¦æŸï¼šclass å’Œ structã€‚å…¶ä¸­ï¼Œclass çº¦æŸå‘ç¼–è¯‘å™¨æ‰¿è¯ºç±»å‹å®å‚æ˜¯å¼•ç”¨ç±»å‹ã€‚ä»»ä½•ç±»ç±»å‹ã€æ¥å£ç±»å‹ã€å§”æ‰˜ç±»å‹æˆ–è€…æ•°ç»„ç±»å‹éƒ½æ»¡è¶³è¿™ä¸ªçº¦æŸã€‚struct çº¦æŸé¡¹ç¼–è¯‘å™¨æ‰¿è¯ºç±»å‹å®å‚æ˜¯å€¼ç±»å‹ã€‚ä½†ç¼–è¯‘å™¨å’Œ CLR å°† <code>System.Nullable&lt;T&gt;</code> å€¼ç±»å‹è§†ä¸ºç‰¹æ®Šç±»å‹ï¼Œä¸æ»¡è¶³è¿™ä¸ª struct çº¦æŸã€‚åŸå› æ˜¯ <code>Nullable&lt;T&gt;</code> ç±»å‹å°†å®ƒçš„ç±»å‹å‚æ•°çº¦æŸä¸º structï¼Œè€Œ CLR å¸Œæœ›ç¦æ­¢åƒ <code>Nullable&lt;Nullable&lt;T&gt;&gt;</code> è¿™æ ·çš„é€’å½’ç±»å‹ã€‚ç±»å‹å‚æ•°å¯ä»¥æŒ‡å®šé›¶ä¸ªæˆ–è€…å¤šä¸ªæ¬¡è¦çº¦æŸï¼Œæ¬¡è¦çº¦æŸä»£è¡¨æ¥å£ç±»å‹ã€‚å¦‚æœèƒ½æŒ‡å®šå¤šä¸ªæ¥å£çº¦æŸï¼Œæ‰€ä»¥ç±»å‹å®å‚å¿…é¡»å®ç°äº†æ‰€æœ‰æ¥å£çº¦æŸï¼ˆä»¥åŠä¸»è¦çº¦æŸï¼Œå¦‚æœæœ‰çš„è¯ï¼‰ã€‚è¿˜æœ‰ä¸€ç§æ¬¡è¦çº¦æŸç§°ä¸ºç±»å‹å‚æ•°çº¦æŸï¼Œåˆæ˜¯ä¹Ÿç§°ä¸ºè£¸ç±»å‹çº¦æŸã€‚è¿˜æœ‰ä¸€ç§æ¬¡è¦çº¦æŸç§°ä¸ºç±»å‹å‚æ•°çº¦æŸï¼Œæœ‰æ—¶ä¹Ÿç§°ä¸ºè£¸ç±»å‹çº¦æŸã€‚å®ƒå…è®¸ä¸€ä¸ªæ³›å‹ç±»å‹æˆ–æ–¹æ³•è§„å®šï¼šæŒ‡å®šçš„ç±»å‹å®å‚è¦ä¹ˆå°±æ˜¯çº¦æŸçš„ç±»å‹ï¼Œè¦ä¹ˆæ˜¯çº¦æŸçš„ç±»å‹çš„æ´¾ç”Ÿç±»ã€‚ç±»å‹å‚æ•°å¯æŒ‡å®šé›¶ä¸ªæˆ–ä¸€ä¸ªæ„é€ å™¨çº¦æŸï¼Œå®ƒé¡¹æ„é€ å™¨æ‰¿è¯ºç±»å‹å®å‚æ˜¯å®ç°äº†å…¬å…±æ— å‚æ„é€ å™¨çš„éæŠ½è±¡ç±»å‹ã€‚æ³¨æ„ï¼Œå¦‚æœåŒæ—¶ä½¿ç”¨æ„é€ å™¨çº¦æŸå’Œ struct çº¦æŸï¼ŒC# ç¼–è¯‘å™¨ä¼šè®¤ä¸ºè¿™æ˜¯ä¸€ä¸ªé”™è¯¯ï¼Œè®¤ä¸ºè¿™æ˜¯å¤šä½™çš„ï¼›æ‰€æœ‰å€¼ç±»å‹éƒ½éšå¼æä¾›äº†å…¬å…±æ— å‚æ„é€ å™¨ï¼ˆCLRï¼ˆä»¥åŠ C# ç¼–è¯‘å™¨ï¼‰åªæ”¯æŒæ— å‚æ„é€ å™¨ï¼‰ã€‚å°†æ³›å‹ç±»å‹çš„å˜é‡è½¬å‹ä¸ºå…¶ä»–ç±»å‹æ˜¯éæ³•çš„ï¼Œé™¤éè½¬å‹ä¸ºä¸çº¦æŸå…¼å®¹çš„ç±»å‹ã€‚Microsoft çš„ C# å›¢é˜Ÿè®¤ä¸ºæœ‰å¿…è¦å…è®¸å¼€å‘äººå‘˜å°†å˜é‡è®¾ä¸ºå®ƒçš„é»˜è®¤å€¼ï¼Œå¹¶ä¸“é—¨ä¸ºæ­¤æä¾›äº† default å…³é”®å­—ã€‚default å…³é”®å­—å‘Šè¯‰ C# ç¼–è¯‘å™¨å’Œ CLR çš„ JIT ç¼–è¯‘å™¨ï¼Œå¦‚æœ T æ˜¯å¼•ç”¨ç±»å‹ï¼Œå°±å°†å˜é‡è®¾ä¸º nullï¼›å¦‚æœæ˜¯å€¼ç±»å‹ï¼Œå°±å°†å˜é‡çš„æ‰€æœ‰ä½è®¾ä¸º 0ã€‚æ— è®ºæ³›å‹ç±»å‹æ˜¯å¦è¢«çº¦æŸï¼Œä½¿ç”¨ == æˆ–ï¼= æ“ä½œç¬¦å°†æ³›å‹ç±»å‹å˜é‡ä¸ null è¿›è¡Œæ¯”è¾ƒéƒ½æ˜¯åˆæ³•çš„ã€‚å¦‚æœæ³›å‹å˜é‡å‚æ•°ä¸èƒ½è‚¯å®šæ˜¯å¼•ç”¨ç±»å‹ï¼Œå¯¹åŒä¸€ä¸ªæ³›å‹ç±»å‹çš„ä¸¤ä¸ªå˜é‡è¿›è¡Œæ¯”è¾ƒæ˜¯éæ³•çš„ã€‚è™½ç„¶ä¸¤ä¸ªå¼•ç”¨ç±»å‹çš„å˜é‡ç›¸äº’æ¯”è¾ƒæ˜¯åˆæ³•çš„ï¼Œä½†ä¸¤ä¸ªå€¼ç±»å‹çš„å˜é‡äº’ç›¸æ¯”è¾ƒæ˜¯éæ³•çš„ï¼Œé™¤éå€¼ç±»å‹é‡è½½äº† == æ“ä½œç¬¦ã€‚ä¸å…è®¸å°†ç±»å‹å‚æ•°çº¦æŸæˆå…·ä½“çš„å€¼ç±»å‹ï¼Œå› ä¸ºå€¼ç±»å‹éšå¼å¯†å°ï¼Œä¸å¯èƒ½å­˜åœ¨ä»å€¼ç±»å‹æ´¾ç”Ÿçš„ç±»å‹ã€‚æœ€åè¦æ³¨æ„ï¼Œå°†æ“ä½œç¬¦åº”ç”¨äºæ³›å‹ç±»å‹çš„æ“ä½œæ•°ä¼šå‡ºç°å¤§é‡é—®é¢˜ã€‚ç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶ç¡®å®šä¸äº†ç±»å‹ï¼Œæ‰€ä»¥ä¸èƒ½å‘æ³›å‹ç±»å‹çš„å˜é‡åº”ç”¨ä»»ä½•æ“ä½œç¬¦ã€‚è¿™æ˜¯ CLR çš„æ³›å‹æ”¯æŒä½“ç³»çš„ä¸€ä¸ªä¸¥é‡é™åˆ¶ï¼Œè®¸å¤šäººå°è¯•ç”¨å„ç§æŠ€æœ¯æ¥é¿å¼€è¿™ä¸€é™åˆ¶ï¼Œå…¶ä¸­åŒ…æ‹¬åå°„ã€dynamic åŸºå…ƒç±»å‹å’Œæ“ä½œç¬¦é‡è½½ç­‰ã€‚ä½†æ‰€æœ‰è¿™äº›æŠ€æœ¯éƒ½ä¼šä¸¥é‡æŸå®³æ€§èƒ½æˆ–è€…å½±å“ä»£ç çš„å¯è¯»æ€§ã€‚</p><div class="tags"><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> è¯»ä¹¦ç¬”è®°</a> <a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C#</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2022-11-03 20:32:49" itemprop="dateModified" datetime="2022-11-03T20:32:49+08:00">2022-11-03</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(ï¿£â–½ï¿£)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Sakupinera WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Sakupinera Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Sakupinera PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Sakupinera <i class="ic i-at"><em>@</em></i>Sakupinera</li><li class="link"><strong>Post link: </strong><a href="http://sakupinera.github.io/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" title="CLR via C# - Chapter 12 Generics">http://sakupinera.github.io/2022/11/02/csharp/clr-via-csharp/Chapter 12 Generics/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;03&#x2F;08&#x2F;cNIvjwsl174ibOo.png" title="GAMES101 - Cameras, Lenses and Light Fieldsï¼ˆç›¸æœºï¼Œé€é•œå’Œå…‰åœºï¼‰"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i> GAMES101</span><h3>GAMES101 - Cameras, Lenses and Light Fieldsï¼ˆç›¸æœºï¼Œé€é•œå’Œå…‰åœºï¼‰</h3></a></div><div class="item right"><a href="/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;03&#x2F;08&#x2F;EXaiHD39BF7QWok.jpg" title="CLR via C# - Chapter 13 Interfaces"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 13 Interfaces</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-12-generics"><span class="toc-number">1.</span> <span class="toc-text">Chapter 12 Generics</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#generics-in-the-framework-class-library"><span class="toc-number">1.1.</span> <span class="toc-text">Generics in the Framework Class Library</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#generics-infrastructure"><span class="toc-number">1.2.</span> <span class="toc-text">Generics Infrastructure</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#open-and-closed-types"><span class="toc-number">1.2.1.</span> <span class="toc-text">Open and Closed Types</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#generic-types-and-inheritance"><span class="toc-number">1.2.2.</span> <span class="toc-text">Generic Types and Inheritance</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#generic-type-identity"><span class="toc-number">1.2.3.</span> <span class="toc-text">Generic Type Identity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#code-explosion"><span class="toc-number">1.2.4.</span> <span class="toc-text">Code Explosion</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#generic-interfaces"><span class="toc-number">1.3.</span> <span class="toc-text">Generic Interfaces</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#generic-delegates"><span class="toc-number">1.4.</span> <span class="toc-text">Generic Delegates</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#delegate-and-interface-contra-variant-and-covariant-generic-type-arguments"><span class="toc-number">1.5.</span> <span class="toc-text">Delegate and Interface Contra-variant and Covariant Generic Type Arguments</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#generic-methods"><span class="toc-number">1.6.</span> <span class="toc-text">Generic Methods</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#generic-methods-and-type-inference"><span class="toc-number">1.6.1.</span> <span class="toc-text">Generic Methods and Type Inference</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#generics-and-other-members"><span class="toc-number">1.7.</span> <span class="toc-text">Generics and Other Members</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#verifiability-and-constraints"><span class="toc-number">1.8.</span> <span class="toc-text">Verifiability and Constraints</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#primary-constraints"><span class="toc-number">1.8.1.</span> <span class="toc-text">Primary Constraints</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#secondary-constraints"><span class="toc-number">1.8.2.</span> <span class="toc-text">Secondary Constraints</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constructor-constraints"><span class="toc-number">1.8.3.</span> <span class="toc-text">Constructor Constraints</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#other-verifiability-issues"><span class="toc-number">1.8.4.</span> <span class="toc-text">Other Verifiability Issues</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#casting-a-generic-type-variable"><span class="toc-number">1.8.5.</span> <span class="toc-text">Casting a Generic Type Variable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setting-a-generic-type-variable-to-a-default-value"><span class="toc-number">1.8.6.</span> <span class="toc-text">Setting a Generic Type Variable to a Default Value</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#comparing-a-generic-type-variable-with-null"><span class="toc-number">1.8.7.</span> <span class="toc-text">Comparing a Generic Type Variable with null</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#comparing-two-generic-type-variables-with-each-other"><span class="toc-number">1.8.8.</span> <span class="toc-text">Comparing Two Generic Type Variables with Each Other</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#using-generic-type-variables-as-operands"><span class="toc-number">1.8.9.</span> <span class="toc-text">Using Generic Type Variables as Operands</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"><ul><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/" rel="bookmark" title="CLR via C# - Chapter 1 The CLRâ€™s Execution Model">CLR via C# - Chapter 1 The CLRâ€™s Execution Model</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/" rel="bookmark" title="CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types">CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%203%20Shared%20Assemblies%20and%20Strongly%20Named%20Assemblies/" rel="bookmark" title="CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies">CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies</a></li><li><a href="/2022/09/27/csharp/clr-via-csharp/Chapter%204%20Type%20Fundamentals/" rel="bookmark" title="CLR via C# - Chapter 4 Type Fundamentals">CLR via C# - Chapter 4 Type Fundamentals</a></li><li><a href="/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/" rel="bookmark" title="CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals">CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals</a></li><li><a href="/2022/10/21/csharp/clr-via-csharp/Chapter%206%20Type%20and%20Member%20Basics/" rel="bookmark" title="CLR via C# - Chapter 6 Type and Member Basics">CLR via C# - Chapter 6 Type and Member Basics</a></li><li><a href="/2022/10/24/csharp/clr-via-csharp/Chapter%207%20Constants%20and%20Fields/" rel="bookmark" title="CLR via C# - Chapter 7 Constants and Fields">CLR via C# - Chapter 7 Constants and Fields</a></li><li><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" rel="bookmark" title="CLR via C# - Chapter 8 Methods">CLR via C# - Chapter 8 Methods</a></li><li><a href="/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/" rel="bookmark" title="CLR via C# - Chapter 9 Parameters">CLR via C# - Chapter 9 Parameters</a></li><li><a href="/2022/10/28/csharp/clr-via-csharp/Chapter%2010%20Properties/" rel="bookmark" title="CLR via C# - Chapter 10 Properties">CLR via C# - Chapter 10 Properties</a></li><li><a href="/2022/10/29/csharp/clr-via-csharp/Chapter%2011%20Events/" rel="bookmark" title="CLR via C# - Chapter 11 Events">CLR via C# - Chapter 11 Events</a></li><li class="active"><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" rel="bookmark" title="CLR via C# - Chapter 12 Generics">CLR via C# - Chapter 12 Generics</a></li><li><a href="/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/" rel="bookmark" title="CLR via C# - Chapter 13 Interfaces">CLR via C# - Chapter 13 Interfaces</a></li><li><a href="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/" rel="bookmark" title="CLR via C# - Chapter 14 Chars, Strings, and Working with Text">CLR via C# - Chapter 14 Chars, Strings, and Working with Text</a></li><li><a href="/2022/11/17/csharp/clr-via-csharp/Chapter%2015%20Enumerated%20Types%20and%20Bit%20Flags/" rel="bookmark" title="CLR via C# - Chapter 15 Enumerated Types and Bit Flags">CLR via C# - Chapter 15 Enumerated Types and Bit Flags</a></li><li><a href="/2022/11/19/csharp/clr-via-csharp/Chapter%2016%20Arrays/" rel="bookmark" title="CLR via C# - Chapter 16 Arrays">CLR via C# - Chapter 16 Arrays</a></li><li><a href="/2022/11/21/csharp/clr-via-csharp/Chapter%2017%20Delegates/" rel="bookmark" title="CLR via C# - Chapter 17 Delegates">CLR via C# - Chapter 17 Delegates</a></li><li><a href="/2022/11/22/csharp/clr-via-csharp/Chapter%2018%20Custom%20Attributes/" rel="bookmark" title="CLR via C# - Chapter 18 Custom Attributes">CLR via C# - Chapter 18 Custom Attributes</a></li><li><a href="/2022/11/23/csharp/clr-via-csharp/Chapter%2019%20Nullable%20Value%20Types/" rel="bookmark" title="CLR via C# - Chapter 19 Nullable Value Types">CLR via C# - Chapter 19 Nullable Value Types</a></li><li><a href="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/" rel="bookmark" title="CLR via C# - Chapter 20 Exceptions and State Management">CLR via C# - Chapter 20 Exceptions and State Management</a></li><li><a href="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/" rel="bookmark" title="CLR via C# - Chapter 21 The Managed Heap and Garbage  Collection">CLR via C# - Chapter 21 The Managed Heap and Garbage Collection</a></li><li><a href="/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/" rel="bookmark" title="CLR via C# - Chapter 22 CLR Hosting and AppDomains">CLR via C# - Chapter 22 CLR Hosting and AppDomains</a></li><li><a href="/2022/11/29/csharp/clr-via-csharp/Chapter%2023%20Assembly%20Loading%20and%20Reflection/" rel="bookmark" title="CLR via C# - Chapter 23 Assembly Loading and Reflection">CLR via C# - Chapter 23 Assembly Loading and Reflection</a></li><li><a href="/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/" rel="bookmark" title="CLR via C# - Chapter 24 Runtime Serialization">CLR via C# - Chapter 24 Runtime Serialization</a></li><li><a href="/2022/12/06/csharp/clr-via-csharp/Chapter%2025%20Interoperating%20with%20WinRT%20%20Components/" rel="bookmark" title="CLR via C# - Chapter 25 Interoperating with WinRT Components">CLR via C# - Chapter 25 Interoperating with WinRT Components</a></li><li><a href="/2023/02/06/csharp/clr-via-csharp/Chapter%2026%20Thread%20Basics/" rel="bookmark" title="CLR via C# - Chapter 26 Thread Basics">CLR via C# - Chapter 26 Thread Basics</a></li><li><a href="/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations">CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations</a></li><li><a href="/2023/02/08/csharp/clr-via-csharp/Chapter%2028%20IO-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 28 IO-Bound Asynchronous Operations">CLR via C# - Chapter 28 IO-Bound Asynchronous Operations</a></li><li><a href="/2023/02/09/csharp/clr-via-csharp/Chapter%2029%20Primitive%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 29 Primitive Thread Synchronization">CLR via C# - Chapter 29 Primitive Thread Synchronization</a></li><li><a href="/2023/02/10/csharp/clr-via-csharp/Chapter%2030%20Hybrid%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 30 Hybrid Thread Synchronization">CLR via C# - Chapter 30 Hybrid Thread Synchronization</a></li></ul></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sakupinera" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Sakupinera</p><div class="description" itemprop="description">ä¿æŒä½ çš„å†³å¿ƒï¼</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">86</span> <span class="name">posts</span></a></div><div class="item categories"><a href="/categories/"><span class="count">13</span> <span class="name">categories</span></a></div><div class="item tags"><a href="/tags/"><span class="count">6</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nha3VwaW5lcmE=" title="https:&#x2F;&#x2F;github.com&#x2F;sakupinera"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9zYWt1cGluZXJh" title="https:&#x2F;&#x2F;twitter.com&#x2F;sakupinera"><i class="ic i-twitter"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQwNzIyOTA3MQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;407229071"><i class="ic i-cloud-music"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMjIzMDczOTg/c3BtX2lkX2Zyb209MzMzLjEwMDcuMC4w" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;22307398?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li><li class="item"><a href="/games/" rel="section"><i class="ic i-flag"></i>Games</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-person"></i>About</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/10/31/computer-graphics/games101/%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%E5%92%8C%E5%85%89%E5%9C%BA/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2023/08/20/computer-graphics/games101/%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/" title="GAMES101 - Color and Perceptionï¼ˆé¢œè‰²ä¸æ„ŸçŸ¥ï¼‰">GAMES101 - Color and Perceptionï¼ˆé¢œè‰²ä¸æ„ŸçŸ¥ï¼‰</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/" title="CLR via C# - Chapter 21 The Managed Heap and Garbage  Collection">CLR via C# - Chapter 21 The Managed Heap and Garbage Collection</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" title="CLR via C# - Chapter 12 Generics">CLR via C# - Chapter 12 Generics</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/" title="CLR via C# - Chapter 24 Runtime Serialization">CLR via C# - Chapter 24 Runtime Serialization</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/09/22/computer-graphics/games101/%E5%85%89%E6%A0%85%E5%8C%96/" title="GAMES101 - Rasterizationï¼ˆå…‰æ …åŒ–ï¼‰">GAMES101 - Rasterizationï¼ˆå…‰æ …åŒ–ï¼‰</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CSharp-in-a-Nutshell/" title="In CSharp-in-a-Nutshell">CSharp-in-a-Nutshell</a></div><span><a href="/2022/08/29/csharp/csharp-in-a-nutshell/%E7%AC%AC2%E7%AB%A0%20%E5%9C%A8CSharp%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%9E%8B/" title="C# in a Nutshell - ç¬¬2ç«  C#è¯­è¨€åŸºç¡€">C# in a Nutshell - ç¬¬2ç«  C#è¯­è¨€åŸºç¡€</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CSharp-in-a-Nutshell/" title="In CSharp-in-a-Nutshell">CSharp-in-a-Nutshell</a></div><span><a href="/2022/08/29/csharp/csharp-in-a-nutshell/%E7%AC%AC4%E7%AB%A0%20CSharp%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/" title="C# in a Nutshell - ç¬¬4ç«  C#çš„é«˜çº§ç‰¹æ€§">C# in a Nutshell - ç¬¬4ç«  C#çš„é«˜çº§ç‰¹æ€§</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CMake/" title="In CMake">CMake</a></div><span><a href="/2022/08/28/cmake/CMake/" title="CMake">CMake</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/08/28/linux/learn-linux/Linux%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/" title="LearnLinux - Linuxç³»ç»Ÿç®€ä»‹">LearnLinux - Linuxç³»ç»Ÿç®€ä»‹</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2023/02/08/csharp/clr-via-csharp/Chapter%2028%20IO-Bound%20Asynchronous%20Operations/" title="CLR via C# - Chapter 28 IO-Bound Asynchronous Operations">CLR via C# - Chapter 28 IO-Bound Asynchronous Operations</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 â€“ <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Sakupinera @ Hanamai Sora</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="Symbols count total">2.2m words</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="Reading time total">33:30</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/11/02/csharp/clr-via-csharp/Chapter 12 Generics/",favicon:{show:"ï¼ˆâ—Â´3ï½€â—ï¼‰Goooood",hide:"(Â´Ğ”ï½€)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/shifuku.model.json"},display:{position:"left",width:250,height:500},mobile:{show:!1},react:{opacity:.9},log:!1})</script></body></html>