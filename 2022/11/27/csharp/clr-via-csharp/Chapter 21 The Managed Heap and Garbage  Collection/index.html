<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sakupinera" href="http://sakupinera.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sakupinera" href="http://sakupinera.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sakupinera" href="http://sakupinera.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="è¯»ä¹¦ç¬”è®°,C#"><link rel="canonical" href="http://sakupinera.github.io/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/"><title>CLR via C# - Chapter 21 The Managed Heap and Garbage Collection - CLR-via-CSharp - CSharp | Hanamai Sora = Sakupinera</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">CLR via C# - Chapter 21 The Managed Heap and Garbage Collection</h1><div class="meta"><span class="item" title="Created: 2022-11-27 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2022-11-27T00:00:00+08:00">2022-11-27</time> </span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">Symbols count in article</span> <span>105k</span> <span class="text">words</span> </span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">Reading time</span> <span>1:35</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hanamai Sora</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s2.loli.net/2023/03/08/wi84uPUELq2rcnD.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/GkbQv5EIRZBXgDn.png"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/hr2Sybs5CRvjFdI.png"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/nishJ3GEKoDLIbw.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/DFUCvo21fTb5mwG.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/Y2t3E6QUohFwG1R.png"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/" itemprop="item" rel="index" title="In CSharp"><span itemprop="name">CSharp</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/CLR-via-CSharp/" itemprop="item" rel="index" title="In CLR-via-CSharp"><span itemprop="name">CLR-via-CSharp</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://sakupinera.github.io/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Sakupinera"><meta itemprop="description" content=", ä¿æŒä½ çš„å†³å¿ƒï¼"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakupinera"></span><div class="body md" itemprop="articleBody"><h1 id="chapter-21-the-managed-heap-and-garbage-collection"><a class="anchor" href="#chapter-21-the-managed-heap-and-garbage-collection">#</a> Chapter 21 The Managed Heap and Garbage Collection</h1><h2 id="managed-heap-basics"><a class="anchor" href="#managed-heap-basics">#</a> Managed Heap Basics</h2><blockquote><p>Every program uses resources of one sort or another, be they files, memory buffers, screen space, network connections, database resources, and so on. In fact, in an object-oriented environment, every type identifies some resource available for a programâ€™s use. To use any of these resources requires memory to be allocated to represent the type. The following steps are required to access a resource:</p><ol><li>Allocate memory for the type that represents the resource (usually accomplished by using C#â€™s new operator).</li><li>Initialize the memory to set the initial state of the resource and to make the resource usable. The typeâ€™s instance constructor is responsible for setting this initial state.</li><li>Use the resource by accessing the typeâ€™s members (repeating as necessary).</li><li>Tear down the state of a resource to clean up.</li><li>Free the memory. The garbage collector is solely responsible for this step.</li></ol></blockquote><blockquote><p>This seemingly simple paradigm has been one of the major sources of problems for programmers that must manually manage their memory; for example, native C++ developers. Programmers responsible for managing their own memory routinely forget to free memory, which causes a memory leak. In addition, these programmers frequently use memory after having released it, causing their program to experience memory corruption resulting in bugs and security holes. Furthermore, these two bugs are worse than most others because you canâ€™t predict the consequences or the timing of them. For other bugs, when you see your application misbehaving, you just fix the line of code that is not working.</p></blockquote><blockquote><p>As long as you are writing verifiably type-safe code (avoiding C#â€™s unsafe keyword), then it is impossible for your application to experience memory corruption. It is still possible for your application to leak memory but it is not the default behavior. Memory leaks typically occur because your application is storing objects in a collection and never removes objects when they are no longer needed.</p></blockquote><blockquote><p>To simplify things even more, most types that developers use quite regularly do not require Step 4 (tear down the state of the resource to clean up). And so, the managed heap, in addition to abolishing the bugs I mentioned, also provides developers with a simple programming model: allocate and initialize a resource and use it as desired. For most types, there is no need to clean up the resource and the garbage collector will free the memory.</p></blockquote><blockquote><p>When consuming instances of types that require special cleanup, the programming model remains as simple as Iâ€™ve just described. However, sometimes, you want to clean up a resource as soon as possible, rather than waiting for a GC to kick in. In these classes, you can call one additional method (called Dispose) in order to clean up the resource on your schedule. On the other hand, implementing a type that requires special cleanup is quite involved. I describe the details of all this in the â€œWorking with Types Requiring Special Cleanupâ€ section later in this chapter. Typically, types that require special cleanup are those that wrap native resources like files, sockets, or database connections.</p></blockquote><h3 id="allocating-resources-from-the-managed-heap"><a class="anchor" href="#allocating-resources-from-the-managed-heap">#</a> Allocating Resources from the Managed Heap</h3><blockquote><p>The CLR requires that all objects be allocated from the managed heap. When a process is initialized, the CLR allocates a region of address space for the managed heap. The CLR also maintains a pointer, which Iâ€™ll call NextObjPtr. This pointer indicates where the next object is to be allocated within the heap. Initially, NextObjPtr is set to the base address of the address space region.</p></blockquote><blockquote><p>As region fills with non-garbage objects, the CLR allocates more regions and continues to do this until the whole processâ€™s address space is full. So, your applicationâ€™s memory is limited by the processâ€™s virtual address space. In a 32-bit process, you can allocate close to 1.5 gigabytes (GB) and in a 64-bit process, you can allocate close to 8 terabytes.</p></blockquote><blockquote><p>C#â€™s new operator causes the CLR to perform the following steps:</p><ol><li>Calculate the number of bytes required for the typeâ€™s fields (and all the fields it inherits from its base types).</li><li>Add the bytes required for an objectâ€™s overhead. Each object has two overhead fields: a type object pointer and a sync block index. For a 32-bit application, each of these fields requires 32 bits, adding 8 bytes to each object. For a 64-bit application, each field is 64 bits, adding 16 bytes to each object.</li><li>The CLR then checks that the bytes required to allocate the object are available in the region. If there is enough free space in the managed heap, the object will fit, starting at the address pointed to by NextObjPtr, and these bytes are zeroed out. The typeâ€™s constructor is called (passing NextObjPtr for the this parameter), and the new operator returns a reference to the object. Just before the reference is returned, NextObjPtr is advanced past the object and now points to the address where the next object will be placed in the heap.</li></ol></blockquote><blockquote><p>Figure 21-1 shows a managed heap consisting of three objects: A, B, and C. If another object were to be allocated, it would be placed where NextObjPtr points to (immediately after object C).</p></blockquote><p><img data-src="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/image-20221127172059249-1670068866559-1.png" alt="image-20221127172059249"></p><blockquote><p>For the managed heap, allocating an object simply means adding a value to a pointerâ€”this is blazingly fast. In many applications, objects allocated around the same time tend to have strong relationships to each other and are frequently accessed around the same time. For example, itâ€™s very common to allocate a FileStream object immediately before a BinaryWriter object is created. Then the application would use the BinaryWriter object, which internally uses the FileStream object. Because the managed heap allocates these objects next to each other in memory, you get excellent performance when accessing these objects due to locality of reference. Specifically, this means that your processâ€™s working set is small, which means your application runs fast with less memory. Itâ€™s also likely that the objects your code is accessing can all reside in the CPUâ€™s cache. The result is that your application will access these objects with phenomenal speed because the CPU will be able to perform most of its manipulations without having cache misses that would force slower access to RAM.</p></blockquote><blockquote><p>So far, it sounds like the managed heap provides excellent performance characteristics. However, what I have just described is assuming that memory is infinite and that the CLR can always allocate new objects at the end. However, memory is not infinite and so the CLR employs a technique known as garbage collection (GC) to â€œdeleteâ€ objects in the heap that your application no longer requires access to.</p></blockquote><h3 id="the-garbage-collection-algorithm"><a class="anchor" href="#the-garbage-collection-algorithm">#</a> The Garbage Collection Algorithm</h3><blockquote><p>When an application calls the new operator to create an object, there might not be enough address space left in the region to allocate the object. If insufficient space exists, then the CLR performs a GC.</p></blockquote><p>ğŸ’¡é‡è¦æç¤ºï¼šå‰é¢çš„æè¿°è¿‡äºç®€å•ã€‚äº‹å®ä¸Šï¼Œåƒåœ¾å›æ”¶æ—¶åœ¨ç¬¬ 0 ä»£æ»¡çš„æ—¶å€™å‘ç”Ÿçš„ã€‚æœ¬ç« åé¢ä¼šè§£é‡Š â€œä»£â€ã€‚åœ¨æ­¤ä¹‹å‰ï¼Œå…ˆå‡è®¾å †æ»¡å°±å‘ç”Ÿæ¥åŠå›æ”¶ã€‚</p><blockquote><p>For managing the lifetime of objects, some systems use a reference counting algorithm. In fact, Microsoftâ€™s own Component Object Model (COM) uses reference counting. With a reference counting system, each object on the heap maintains an internal field indicating how many â€œpartsâ€ of the program are currently using that object. As each â€œpartâ€ gets to a place in the code where it no longer requires access to an object, it decrements that objectâ€™s count field. When the count field reaches 0, the object deletes itself from memory. The big problem with many reference counting systems is that they do not handle circular references well. For example, in a GUI application, a window will hold a reference to a child UI element. And the child UI element will hold a reference to its parent window. These references prevent the two objectsâ€™ counters from reaching 0, so both objects will never be deleted even if the application itself no longer has a need for the window.</p></blockquote><blockquote><p>Due to this problem with reference counting garbage collector algorithms, the CLR uses a referencing tracking algorithm instead. The reference tracking algorithm cares only about reference type variables, because only these variables can refer to an object on the heap; value type variables contain the value type instance directly. Reference type variables can be used in many contexts: static and instance fields within a class or a methodâ€™s arguments or local variables. We refer to all reference type variables as roots.</p></blockquote><blockquote><p>When the CLR starts a GC, the CLR first suspends all threads in the process. This prevents threads from accessing objects and changing their state while the CLR examines them. Then, the CLR performs what is called the marking phase of the GC. First, it walks through all the objects in the heap setting a bit (contained in the sync block index field) to 0. This indicates that all objects should be deleted. Then, the CLR looks at all active roots to see which objects they refer to. This is what makes the CLRâ€™s GC a reference tracking GC. If a root contains null, the CLR ignores the root and moves on to examine the next root.</p></blockquote><blockquote><p>Any root referring to an object on the heap causes the CLR to mark that object. Marking an object means that the CLR sets the bit in the objectâ€™s sync block index to 1. When an object is marked, the CLR examines the roots inside that object and marks the objects they refer to. If the CLR is about to mark an already-marked object, then it does not examine the objectâ€™s fields again. This prevents an infinite loop from occurring in the case where you have a circular reference.</p></blockquote><blockquote><p>Figure 21-2 shows a heap containing several objects. In this example, the application roots refer directly to objects A, C, D, and F. All of these objects are marked. When marking object D, the garbage collector notices that this object contains a field that refers to object H, causing object H to be marked as well. The marking phase continues until all the application roots have been examined.</p></blockquote><blockquote><p>Once complete, the heap contains some marked and some unmarked objects. The marked objects must survive the collection because there is at least one root that refers to the object; we say that the object is reachable because application code can reach (or access) the object by way of the variable that still refers to it. Unmarked objects are unreachable because there is no root existing in the application that would allow for the object to ever be accessed again.</p></blockquote><p><img data-src="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/image-20221127172335755-1670068866560-2.png" alt="image-20221127172335755"></p><blockquote><p>Now that the CLR knows which objects must survive and which objects can be deleted, it begins the GCâ€™s compacting phase. During the compacting phase, the CLR shifts the memory consumed by the marked objects down in the heap, compacting all the surviving objects together so that they are contiguous in memory. This serves many benefits. First, all the surviving objects will be next to each other in memory; this restores locality of reference reducing your applicationâ€™s working set size, thereby improving the performance of accessing these objects in the future. Second, the free space is all contiguous as well, so this region of address space can be freed, allowing other things to use it. Finally, compaction means that there are no address space fragmentation issues with the managed heap as is known to happen with native heaps.</p></blockquote><blockquote><p>When compacting memory, the CLR is moving objects around in memory. This is a problem because any root that referred to a surviving object now refers to where that object was in memory; not where the object has been relocated to. When the applicationâ€™s threads eventually get resumed, they would access the old memory locations and corrupt memory. Clearly, this canâ€™t be allowed and so, as part of the compacting phase, the CLR subtracts from each root the number of bytes that the object it referred to was shifted down in memory. This ensures that every root refers to the same object it did before; itâ€™s just that the object is at a different location in memory.</p></blockquote><blockquote><p>After the heap memory is compacted, the managed heapâ€™s NextObjPtr pointer is set to point to a location just after the last surviving object. This is where the next allocated object will be placed in memory. Figure 21-3 shows the managed heap after the compaction phase. After the compaction phase is complete, the CLR resumes all the applicationâ€™s threads and they continue to access the objects as if the GC never happened at all.</p></blockquote><p><img data-src="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/image-20221127172415439-1670068866560-3.png" alt="image-20221127172415439"></p><blockquote><p>If the CLR is unable to reclaim any memory after a GC and if there is no address space left in the processes to allocate a new GC segment, then there is just no more memory available for this process. In this case, the new operator that attempted to allocate more memory ends up throwing an OutOfMemoryException. Your application can catch this and recover from it but most applications do not attempt to do so; instead, the exception becomes an unhandled exception, Windows terminates the process, and then Windows reclaims all the memory that the process was using.</p></blockquote><blockquote><p>As a programmer, notice how the two bugs described at the beginning of this chapter no longer exist. First, itâ€™s not possible to leak objects because any object not accessible from your applicationâ€™s roots will be collected at some point. Second, itâ€™s not possible to corrupt memory by accessing an object that was freed because references can only refer to living objects, because this is what keeps the objects alive anyway.</p></blockquote><p>ğŸ’¡é‡è¦æç¤ºï¼šé™æ€å­—æ®µå¼•ç”¨çš„å¯¹è±¡ä¸€ç›´å­˜åœ¨ï¼Œç›´åˆ°ç”¨äºåŠ è½½ç±»å‹çš„ AppDomain å¸è½½ä¸ºæ­¢ã€‚å†…å­˜æ³„æ¼çš„ä¸€ä¸ªå¸¸è§åŸå› å°±æ˜¯è®©é™æ€å­—æ®µå¼•ç”¨æŸä¸ªé›†åˆå¯¹è±¡ï¼Œç„¶åä¸åœåœ°å‘é›†åˆæ·»åŠ æ•°æ®é¡¹ã€‚é™æ€å­—æ®µä½¿é›†åˆå¯¹è±¡ä¸€ç›´å­˜æ´»ï¼Œè€Œé›†åˆå¯¹è±¡ä½¿æ‰€æœ‰æ•°æ®é¡¹ä¸€ç›´å­˜æ´»ã€‚å› æ­¤ï¼Œåº”å°½é‡é¿å…ä½¿ç”¨é™æ€å­—æ®µã€‚</p><h3 id="garbage-collections-and-debugging"><a class="anchor" href="#garbage-collections-and-debugging">#</a> Garbage Collections and Debugging</h3><blockquote><p>As soon as a root goes out of scope, the object it refers to is unreachable and subject to having its memory reclaimed by a GC; objects arenâ€™t guaranteed to live throughout a methodâ€™s lifetime. This can have an interesting impact on your application. For example, examine the following code.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Threading</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// Create a Timer object that knows to call our TimerCallback </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// method once every 2000 milliseconds. </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token class-name">Timer</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Timer</span><span class="token punctuation">(</span>TimerCallback<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Wait for the user to hit &lt;Enter>. </span></pre></td></tr><tr><td data-num="9"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">TimerCallback</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// Display the date/time when this method got called. </span></pre></td></tr><tr><td data-num="13"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"In TimerCallback: "</span> <span class="token operator">+</span> DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token comment">// Force a garbage collection to occur for this demo. </span></pre></td></tr><tr><td data-num="15"></td><td><pre> GC<span class="token punctuation">.</span><span class="token function">Collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Compile this code from the command prompt without using any special compiler switches. When you run the resulting executable file, youâ€™ll see that the TimerCallback method is called just once!</p></blockquote><blockquote><p>From examining the preceding code, youâ€™d think that the TimerCallback method would get called once every 2,000 milliseconds. After all, a Timer object is created, and the variable t refers to this object. As long as the timer object exists, the timer should keep firing. But youâ€™ll notice in the TimerCallback method that I force a garbage collection to occur by calling GC.Collect().</p></blockquote><blockquote><p>When the collection starts, it first assumes that all objects in the heap are unreachable (garbage); this includes the Timer object. Then, the collector examines the applicationâ€™s roots and sees that Main doesnâ€™t use the t variable after the initial assignment to it. Therefore, the application has no variable referring to the Timer object, and the garbage collection reclaims the memory for it; this stops the timer and explains why the TimerCallback method is called just once.</p></blockquote><blockquote><p>Letâ€™s say that youâ€™re using a debugger to step through Main, and a garbage collection just happens to occur just after t is assigned the address of the new Timer object. Then, letâ€™s say that you try to view the object that t refers to by using the debuggerâ€™s Quick Watch window. What do you think will happen? The debugger canâ€™t show you the object because it was just garbage collected. This behavior would be considered very unexpected and undesirable by most developers, so Microsoft has come up with a solution.</p></blockquote><blockquote><p>When you compile your assembly by using the C# compilerâ€™s /debug switch, the compiler applies a System.Diagnostics.DebuggableAttribute with its DebuggingModesâ€™ DisableOptimizations flag set into the resulting assembly. At run time, when compiling a method, the JIT compiler sees this flag set, and artificially extends the lifetime of all roots to the end of the method. For my example, the JIT compiler tricks itself into believing that the t variable in Main must live until the end of the method. So, if a garbage collection were to occur, the garbage collector now thinks that t is still a root and that the Timer object that t refers to will continue to be reachable. The Timer object will survive the collection, and the TimerCallback method will get called repeatedly until Console. ReadLine returns and Main exits.</p></blockquote><blockquote><p>To see this, just recompile the program from a command prompt, but this time, specify the C# compilerâ€™s /debug switch. When you run the resulting executable file, youâ€™ll now see that the TimerCallback method is called repeatedly! Note, the C# compilerâ€™s /optimize+ compiler switch turns optimizations back on, so this compiler switch should not be specified when performing this experiment.</p></blockquote><blockquote><p>The JIT compiler does this to help you with JIT debugging. You may now start your application normally (without a debugger), and if the method is called, the JIT compiler will artificially extend the lifetime of the variables to the end of the method. Later, if you decide to attach a debugger to the process, you can put a breakpoint in a previously compiled method and examine the root variables.</p></blockquote><blockquote><p>So now you know how to build a program that works in a debug build but doesnâ€™t work correctly when you make a release build! Because no developer wants a program that works only when debugging it, there should be something we can do to the program so that it works all of the time regardless of the type of build.</p></blockquote><blockquote><p>You could try modifying the Main method to the following.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Create a Timer object that knows to call our TimerCallback </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// method once every 2000 milliseconds. </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">Timer</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Timer</span><span class="token punctuation">(</span>TimerCallback<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// Wait for the user to hit &lt;Enter>. </span></pre></td></tr><tr><td data-num="6"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// Refer to t after ReadLine (this gets optimized away) </span></pre></td></tr><tr><td data-num="8"></td><td><pre> t <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>However, if you compile this (without the /debug+ switch) and run the resulting executable file, youâ€™ll see that the TimerCallback method is still called just once. The problem here is that the JIT compiler is an optimizing compiler, and setting a local variable or parameter variable to null is the same as not referencing the variable at all. In other words, the JIT compiler optimizes the t = null; line out of the code completely, and therefore, the program still does not work as we desire. The correct way to modify the Main method is as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Create a Timer object that knows to call our TimerCallback </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// method once every 2000 milliseconds. </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">Timer</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Timer</span><span class="token punctuation">(</span>TimerCallback<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// Wait for the user to hit &lt;Enter>. </span></pre></td></tr><tr><td data-num="6"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// Refer to t after ReadLine (t will survive GCs until Dispose returns) </span></pre></td></tr><tr><td data-num="8"></td><td><pre> t<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Now, if you compile this code (without the /debug+ switch) and run the resulting executable file, youâ€™ll see that the TimerCallback method is called multiple times, and the program is fixed. Whatâ€™s happening here is that the object t is required to stay alive so that the Dispose instance method can be called on it. (The value in t needs to be passed as the this argument to Dispose.) Itâ€™s ironic: by explicitly indicating where you want the timer to be disposed, it must remain alive up to that point.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šè¯»å®Œæœ¬èŠ‚çš„å†…å®¹åï¼Œä¸å¿…æ‹…å¿ƒå¯¹è±¡è¢«è¿‡æ—©å›æ”¶è¿™ä¸ªé—®é¢˜ã€‚è¿™é‡Œè®¨è®ºä¹‹æ‰€ä»¥ä½¿ç”¨ <code>Timer</code> ç±»ï¼Œæ˜¯å› ä¸ºå®ƒå…·æœ‰å…¶ä»–ç±»ä¸å…·æœ‰çš„ç‰¹æ®Šè¡Œä¸ºã€‚ <code>Timer</code> ç±»çš„ç‰¹ç‚¹ (å’Œé—®é¢˜) åœ¨äºï¼Œå †ä¸­å­˜åœ¨çš„ä¸€ä¸ª <code>Timer</code> å¯¹è±¡ä¼šé€ æˆåˆ«çš„äº‹æƒ…çš„å‘ç”Ÿï¼šä¸€ä¸ªçº¿ç¨‹æ± ç¨‹åºæœŸè°ƒç”¨ä¸€ä¸ªæ–¹æ³•ã€‚å…¶ä»–ä»»ä½•ç±»å‹éƒ½ä¸å…·æœ‰è¿™ä¸ªè¡Œä¸ºã€‚ä¾‹å¦‚ï¼Œå†…å­˜ä¸­å­˜åœ¨çš„ä¸€ä¸ª <code>String</code> å¯¹è±¡ä¸ä¼šé€ æˆåˆ«çš„äº‹æƒ…çš„å‘ç”Ÿï¼›å­—ç¬¦ä¸²å°±é‚£ä¹ˆ â€œå‚»å‚»åœ°å‘†åœ¨é‚£é‡Œâ€ã€‚æ‰€ä»¥ï¼Œæˆ‘ç”¨ <code>Timer</code> å±•ç¤ºæ ¹çš„å·¥ä½œåŸç†ä»¥åŠå¯¹è±¡ç”Ÿå­˜æœŸä¸è°ƒè¯•å™¨çš„å…³ç³»ï¼Œè®¨è®ºçš„é‡ç‚¹å¹¶ä¸æ˜¯å¦‚ä½•ä¿æŒå¯¹è±¡çš„å­˜æ´»ã€‚æ‰€æœ‰é <code>Timer</code> çš„å¯¹è±¡éƒ½ä¼šæ ¹æ®åº”ç”¨ç¨‹åºå¯¹çš„éœ€è¦è€Œè‡ªåŠ¨å­˜æ´»ã€‚</p><p>ğŸ’¡å°ç»“ï¼šCLR è¦æ±‚æ‰€æœ‰å¯¹è±¡éƒ½ä»æ‰˜ç®¡å †åˆ†é…ã€‚è¿›ç¨‹åˆå§‹åŒ–æ—¶ï¼ŒCLR åˆ’å‡ºä¸€ä¸ªåœ°å€ç©ºé—´åŒºåŸŸä½œä¸ºæ‰˜ç®¡å †ã€‚CLR è¿˜è¦ç»´æŠ¤ä¸€ä¸ªæŒ‡é’ˆï¼Œè¯¥æŒ‡é’ˆæŒ‡å‘ä¸‹ä¸€ä¸ªå¯¹è±¡åœ¨å †ä¸­çš„åˆ†é…ä½ç½®ã€‚åœ¨ä¸€å¼€å§‹çš„æ—¶å€™ï¼Œè¯¥æŒ‡é’ˆè®¾ä¸ºåœ°å€ç©ºé—´åŒºåŸŸçš„åŸºåœ°å€ã€‚ä¸€ä¸ªåŒºåŸŸè¢«éåƒåœ¾å¯¹è±¡å¡«æ»¡åï¼ŒCLR ä¼šåˆ†é…æ›´å¤šçš„åŒºåŸŸã€‚è¿™ä¸ªè¿‡ç¨‹ä¸€ç›´é‡å¤ï¼Œç›´åˆ°æ•´ä¸ªè¿›ç¨‹åœ°å€ç©ºé—´éƒ½è¢«å¡«æ»¡ã€‚æ‰€ä»¥ï¼Œä½ çš„åº”ç”¨ç¨‹åºçš„å†…å­˜å—è¿›ç¨‹çš„è™šæ‹Ÿåœ°å€ç©ºé—´çš„é™åˆ¶ã€‚32 ä½è¿›ç¨‹æœ€å¤šèƒ½åˆ†é… 1.5GBï¼Œ64 ä½è¿›ç¨‹æœ€å¤šèƒ½åˆ†é… 8TBã€‚å¯¹äºæ‰˜ç®¡å †ï¼Œåˆ†é…å¯¹è±¡åªéœ€åœ¨æŒ‡é’ˆä¸ŠåŠ ä¸€ä¸ªå€¼ â€”â€” é€Ÿåº¦ç›¸å½“å¿«ã€‚åœ¨è®¸å¤šåº”ç”¨ç¨‹åºä¸­ï¼Œå·®ä¸å¤šåŒæ—¶åˆ†é…çš„å¯¹è±¡å½¼æ­¤é—´æœ‰è¾ƒå¼ºçš„è”ç³»ï¼Œè€Œä¸”ç»å¸¸å·®ä¸å¤šåœ¨åŒä¸€æ—¶é—´è®¿é—®ã€‚ä¾‹å¦‚ï¼Œç»å¸¸åœ¨åˆ†é…ä¸€ä¸ª <code>BinaryWriter</code> å¯¹è±¡ä¹‹å‰åˆ†é…ä¸€ä¸ª <code>FileStream</code> å¯¹è±¡ã€‚ç„¶åï¼Œåº”ç”¨ç¨‹åºä½¿ç”¨ <code>BinaryWriter</code> å¯¹è±¡ï¼Œè€Œåè€…åœ¨å†…éƒ¨ä½¿ç”¨ <code>FileStream</code> å¯¹è±¡ã€‚ç”±äºæ‰˜ç®¡å †åœ¨å†…å­˜ä¸­è¿ç»­åˆ†é…è¿™äº›å¯¹è±¡ï¼Œæ‰€ä»¥ä¼šå› ä¸ºå¼•ç”¨çš„ â€œå±€éƒ¨åŒ–â€ï¼ˆlocalityï¼‰è€Œè·å¾—æ€§æ€§èƒ½ä¸Šçš„æå‡ã€‚å…·ä½“åœ°è¯´ï¼Œè¿™æ„å‘³ç€è¿›ç¨‹çš„å·¥ä½œé›†ä¼šéå¸¸å°ï¼Œåº”ç”¨ç¨‹åºåªéœ€ä½¿ç”¨å¾ˆå°‘çš„å†…å­˜ï¼Œä»è€Œæé«˜äº†é€Ÿåº¦ã€‚è¿˜æ„å‘³ç€ä»£ç ä½¿ç”¨çš„å¯¹è±¡å¯ä»¥å…¨éƒ¨é©»ç•™åœ¨ CPU çš„ç¼“å­˜ä¸­ã€‚ç»“æœæ˜¯åº”ç”¨ç¨‹åºèƒ½ä»¥æƒŠäººçš„é€Ÿåº¦è®¿é—®è¿™äº›å¯¹è±¡ï¼Œå› ä¸º CPU åœ¨æ‰§è¡Œå¤§å¤šæ•°æ“ä½œæ—¶ï¼Œä¸ä¼šå› ä¸º â€œç¼“å­˜æœªå‘½ä¸­â€(cache miss) è€Œè¢«è¿«è®¿é—®è¾ƒæ…¢çš„ RAMã€‚è‡³äºå¯¹è±¡ç”Ÿå­˜æœŸçš„ç®¡ç†ï¼Œæœ‰çš„ç³»ç»Ÿé‡‡ç”¨çš„æ˜¯æŸç§å¼•ç”¨è®¡æ•°ç®—æ³•ã€‚äº‹å®ä¸Šï¼ŒMicrosoft è‡ªå·±çš„ â€œç»„ä»¶å¯¹è±¡æ¨¡å‹â€(Component Object Model, COM) ç”¨çš„å°±æ˜¯å¼•ç”¨è®¡æ•°ã€‚åœ¨è¿™ç§ç³»ç»Ÿä¸­ï¼Œå †ä¸Šçš„æ¯ä¸ªå¯¹è±¡éƒ½ç»´æŠ¤ç€ä¸€ä¸ªå†…å­˜å­—æ®µæ¥ç»Ÿè®¡ç¨‹åºä¸­å¤šå°‘ &quot;éƒ¨åˆ†&quot; æ­£åœ¨ä½¿ç”¨å¯¹è±¡ã€‚éšç€æ¯ä¸€ â€œéƒ¨åˆ†â€ åˆ°è¾¾ä»£ç ä¸­æŸä¸ªä¸å†éœ€è¦å¯¹è±¡çš„åœ°æ–¹ï¼Œå°±é€’å‡å¯¹è±¡çš„è®¡æ•°å­—æ®µã€‚è®¡æ•°å­—æ®µå˜æˆ 0ï¼Œå¯¹è±¡å°±å¯ä»¥ä»å†…å­˜ä¸­åˆ é™¤äº†ã€‚è®¸å¤šå¼•ç”¨è®¡æ•°ç³»ç»Ÿæœ€å¤§çš„é—®é¢˜æ˜¯å¤„ç†ä¸å¥½å¾ªç¯å¼•ç”¨ã€‚é‰´äºå¼•ç”¨è®¡æ•°åƒåœ¾å›æ”¶å™¨ç®—æ³•å­˜åœ¨çš„é—®é¢˜ï¼ŒCLR æ”¹ä¸ºä½¿ç”¨ä¸€ç§å¼•ç”¨è·Ÿè¸ªç®—æ³•ã€‚å¼•ç”¨è·Ÿè¸ªç®—æ³•åªå…³å¿ƒå¼•ç”¨ç±»å‹çš„å˜é‡ï¼Œå› ä¸ºåªæœ‰è¿™ç§å˜é‡æ‰èƒ½å¼•ç”¨å †ä¸Šçš„å¯¹è±¡ï¼›å€¼ç±»å‹å˜é‡ç›´æ¥åŒ…å«å€¼ç±»å‹å®ä¾‹ã€‚å¼•ç”¨ç±»å‹å˜é‡å¯åœ¨è®¸å¤šåœºåˆä½¿ç”¨ï¼ŒåŒ…æ‹¬ç±»çš„é™æ€å’Œå®ä¾‹å­—æ®µï¼Œæˆ–è€…æ–¹æ³•çš„å‚æ•°å’Œå±€éƒ¨å˜é‡ã€‚æˆ‘ä»¬å°†æ‰€æœ‰å¼•ç”¨ç±»å‹çš„å˜é‡éƒ½ç§°ä¸ºæ ¹ã€‚CLR å¼€å§‹ GC æ—¶ï¼Œé¦–å…ˆæš‚åœè¿›ç¨‹ä¸­çš„æ‰€æœ‰çº¿ç¨‹ã€‚è¿™æ ·å¯ä»¥é˜²æ­¢çº¿ç¨‹åœ¨ CLR æ£€æŸ¥æœŸé—´è®¿é—®å¯¹è±¡å¹¶æ›´æ”¹å…¶çŠ¶æ€ã€‚ç„¶åï¼ŒCLR è¿›å…¥ GC çš„ æ ‡è®°é˜¶æ®µã€‚åœ¨è¿™ä¸ªé˜¶æ®µï¼ŒCLR éå†å †ä¸­çš„æ‰€æœ‰å¯¹è±¡ï¼Œå°†åŒæ­¥å—ç´¢å¼•å­—æ®µä¸­çš„ä¸€ä½è®¾ä¸º 0ã€‚è¿™è¡¨æ˜æ‰€æœ‰å¯¹è±¡éƒ½åº”åˆ é™¤ã€‚ç„¶åï¼ŒCLR æ£€æŸ¥æ‰€æœ‰æ´»åŠ¨æ ¹ã€‚æŸ¥çœ‹å®ƒä»¬å¼•ç”¨äº†å“ªäº›å¯¹è±¡ã€‚è¿™æ­£æ˜¯ CLR çš„ GC ç§°ä¸ºå¼•ç”¨è·Ÿè¸ª GC çš„åŸå› ã€‚å¦‚æœä¸€ä¸ªæ ¹åŒ…å« nullï¼Œ CLR å¿½ç•¥è¿™ä¸ªæ ¹å¹¶ç»§ç»­æ£€æŸ¥ä¸‹ä¸ªæ ¹ã€‚ä»»ä½•æ ¹å¦‚æœå¼•ç”¨äº†å †ä¸Šçš„å¯¹è±¡ï¼ŒCLR éƒ½ä¼šæ ‡è®°é‚£ä¸ªå¯¹è±¡ï¼Œä¹Ÿå°±æ˜¯å°†è¯¥å¯¹è±¡çš„åŒæ­¥å—ç´¢å¼•ä¸­å¯¹çš„ä½è®¾ä¸º 1ã€‚ä¸€ä¸ªå¯¹è±¡è¢«æ ‡è®°åï¼Œ CLR ä¼šæ£€æŸ¥é‚£ä¸ªå¯¹è±¡ä¸­çš„æ ¹ï¼Œæ ‡è®°å®ƒä»¬å¼•ç”¨çš„å¯¹è±¡ã€‚å¦‚æœå‘ç°å¯¹è±¡å·²ç»æ ‡è®°ï¼Œå°±ä¸é‡æ–°æ£€æŸ¥å¯¹è±¡çš„å­—æ®µã€‚è¿™å°±é¿å…äº†å› ä¸ºå¾ªç¯å¼•ç”¨è€Œäº§ç”Ÿæ­»å¾ªç¯ã€‚æ£€æŸ¥å®Œæ¯•åï¼Œå †ä¸­çš„å¯¹è±¡è¦ä¹ˆå·²æ ‡è®°ï¼Œè¦ä¹ˆæœªæ ‡è®°ã€‚å·²æ ‡è®°çš„å¯¹è±¡ä¸èƒ½è¢«åƒåœ¾å›æ”¶ï¼Œå› ä¸ºè‡³å°‘æœ‰ä¸€ä¸ªæ ¹åœ¨å¼•ç”¨å®ƒã€‚æˆ‘ä»¬è¯´è¿™ç§å¯¹è±¡çš„å¯è¾¾ (reachable) çš„ï¼Œå› ä¸ºåº”ç”¨ç¨‹åºä»£ç å¯é€šè¿‡ä»åœ¨å¼•ç”¨å®ƒçš„å˜é‡æŠµè¾¾ (æˆ–è®¿é—®) å®ƒã€‚æœªæ ‡è®°çš„å¯¹è±¡æ˜¯ä¸å¯è¾¾ (unreachable) çš„ï¼Œå› ä¸ºåº”ç”¨ç¨‹åºä¸­ä¸å­˜åœ¨ä½¿å¯¹è±¡èƒ½è¢«å†æ¬¡è®¿é—®çš„æ ¹ã€‚CLR çŸ¥é“å“ªäº›å¯¹è±¡å¯ä»¥å¹¸å­˜ï¼Œå“ªäº›å¯ä»¥åˆ é™¤åï¼Œå°±è¿›å…¥ GC çš„å‹ç¼© (compact) é˜¶æ®µã€‚å‹ç¼©æ„å‘³ç€æ‰˜ç®¡å †è§£å†³äº†æœ¬æœº (åŸç”Ÿ) å †çš„æ§ä»¶ç¢ç‰‡åŒ–é—®é¢˜ã€‚å¦‚æœ CLR åœ¨ä¸€æ¬¡ GC ä¹‹åå›æ”¶ä¸äº†å†…å­˜ï¼Œè€Œä¸”è¿›ç¨‹ä¸­æ²¡æœ‰ç©ºé—´æ¥åˆ†é…æ–°çš„ GC åŒºåŸŸï¼Œå°±è¯´æ˜è¯¥è¿›ç¨‹çš„å†…å­˜å·²è€—å°½ã€‚æ­¤æ—¶ï¼Œè¯•å›¾åˆ†é…æ›´å¤šå†…å­˜çš„ <code>new</code> æ“ä½œç¬¦ä¼šæŠ›å‡º <code>OutOfMemoryException</code> ã€‚åº”ç”¨ç¨‹åºå¯æ•æ‰è¯¥å¼‚å¸¸å¹¶ä»ä¸­æ¢å¤ã€‚ä½†å¤§å¤šæ•°åº”ç”¨ç¨‹åºéƒ½ä¸ä¼šè¿™ä¹ˆåšï¼›ç›¸åï¼Œå¼‚å¸¸ä¼šæˆä¸ºæœªå¤„ç†å¼‚å¸¸ï¼ŒWindows å°†ç»ˆæ­¢è¿›ç¨‹å¹¶å›æ”¶è¿›ç¨‹ä½¿ç”¨çš„å…¨éƒ¨å†…å­˜ã€‚</p><h2 id="generations-improving-performance"><a class="anchor" href="#generations-improving-performance">#</a> Generations: Improving Performance</h2><blockquote><p>The CLRâ€™s GC is a generational garbage collector (also known as an ephemeral garbage collector, although I donâ€™t use the latter term in this book). A generational GC makes the following assumptions about your code:</p><ul><li><p>The newer an object is, the shorter its lifetime will be.</p></li><li><p>The older an object is, the longer its lifetime will be.</p></li><li><p>Collecting a portion of the heap is faster than collecting the whole heap.</p></li></ul></blockquote><blockquote><p>Numerous studies have demonstrated the validity of these assumptions for a very large set of existing applications, and these assumptions have influenced how the garbage collector is implemented. In this section, Iâ€™ll describe how generations work.</p></blockquote><blockquote><p>When initialized, the managed heap contains no objects. Objects added to the heap are said to be in generation 0. Stated simply, objects in generation 0 are newly constructed objects that the garbage collector has never examined. Figure 21-4 shows a newly started application with five objects allocated (A through E). After a while, objects C and E become unreachable.</p></blockquote><p><img data-src="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/image-20221127172823035-1670068866560-4.png" alt="image-20221127172823035"></p><blockquote><p>When the CLR initializes, it selects a budget size (in kilobytes) for generation 0. So if allocating a new object causes generation 0 to surpass its budget, a garbage collection must start. Letâ€™s say that objects A through E fill all of generation 0. When object F is allocated, a garbage collection must start. The garbage collector will determine that objects C and E are garbage and will compact object D, causing it to be adjacent to object B. The objects that survive the garbage collection (objects A, B, and D) are said to be in generation 1. Objects in generation 1 have been examined by the garbage collector once. The heap now looks like Figure 21-5.</p></blockquote><p><img data-src="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/image-20221127172849992-1670068866560-5.png" alt="image-20221127172849992"></p><blockquote><p>After a garbage collection, generation 0 contains no objects. As always, new objects will be allocated in generation 0. Figure 21-6 shows the application running and allocating objects F through K. In addition, while the application was running, objects B, H, and J became unreachable and should have their memory reclaimed at some point.</p></blockquote><p><img data-src="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/image-20221127172919254-1670068866560-6.png" alt="image-20221127172919254"></p><blockquote><p>Now letâ€™s say that attempting to allocate object L would put generation 0 over its budget. Because generation 0 has reached its budget, a garbage collection must start. When starting a garbage collection, the garbage collector must decide which generations to examine. Earlier, I said that when the CLR initializes, it selects a budget for generation 0. Well, it also selects a budget for generation 1.</p></blockquote><blockquote><p>When starting a garbage collection, the garbage collector also sees how much memory is occupied by generation 1. In this case, generation 1 occupies much less than its budget, so the garbage collector examines only the objects in generation 0. Look again at the assumptions that the generational garbage collector makes. The first assumption is that newly created objects have a short lifetime. So generation 0 is likely to have a lot of garbage in it, and collecting generation 0 will therefore reclaim a lot of memory. The garbage collector will just ignore the objects in generation 1, which will speed up the garbage collection process.</p></blockquote><blockquote><p>Obviously, ignoring the objects in generation 1 improves the performance of the garbage collector. However, the garbage collector improves performance more because it doesnâ€™t traverse every object in the managed heap. If a root or an object refers to an object in an old generation, the garbage collector can ignore any of the older objectsâ€™ inner references, decreasing the amount of time required to build the graph of reachable objects. Of course, itâ€™s possible that an old objectâ€™s field refers to a new object. To ensure that the updated fields of these old objects are examined, the garbage collector uses a mechanism internal to the JIT compiler that sets a bit when an objectâ€™s reference field changes. This support lets the garbage collector know which old objects (if any) have been written to because the last collection. Only old objects that have had fields change need to be examined to see whether they refer to any new object in generation 0.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šMicrosoft çš„æ€§èƒ½æµ‹è¯•è¡¨æ˜ï¼Œå¯¹ç¬¬ 0 ä»£æ‰§è¡Œä¸€æ¬¡åƒåœ¾å›æ”¶ï¼Œæ‰€èŠ±çš„æ—¶é—´ä¸è¶…è¿‡ 1 æ¯«ç§’ã€‚Microsoft çš„ç›®æ ‡æ˜¯ä½¿åƒåœ¾å›æ”¶æ‰€èŠ±çš„æ—¶é—´ä¸è¶…è¿‡ä¸€æ¬¡æ™®é€šçš„å†…å­˜é¡µé¢é”™è¯¯ (page fault) çš„æ—¶é—´ã€‚</p><blockquote><p>A generational garbage collector also assumes that objects that have lived a long time will continue to live. So itâ€™s likely that the objects in generation 1 will continue to be reachable from the application. Therefore, if the garbage collector were to examine the objects in generation 1, it probably wouldnâ€™t find a lot of garbage. As a result, it wouldnâ€™t be able to reclaim much memory. So it is likely that collecting generation 1 is a waste of time. If any garbage happens to be in generation 1, it just stays there. The heap now looks like Figure 21-7.</p></blockquote><p><img data-src="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/image-20221127173038594-1670068866560-7.png" alt="image-20221127173038594"></p><blockquote><p>As you can see, all of the generation 0 objects that survived the collection are now part of generation 1. Because the garbage collector didnâ€™t examine generation 1, object B didnâ€™t have its memory reclaimed even though it was unreachable at the time of the last garbage collection. Again, after a collection, generation 0 contains no objects and is where new objects will be placed. In fact, letâ€™s say that the application continues running and allocates objects L through O. And while running, the application stops using objects G, L, and M, making them all unreachable. The heap now looks like Figure 21-8.</p></blockquote><p><img data-src="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/image-20221127173101096-1670068866560-8.png" alt="image-20221127173101096"></p><blockquote><p>Letâ€™s say that allocating object P causes generation 0 to exceed its budget, causing a garbage collection to occur. Because the memory occupied by all of the objects in generation 1 is less than its budget, the garbage collector again decides to collect only generation 0, ignoring the unreachable objects in generation 1 (objects B and G). After the collection, the heap looks like Figure 21-9.</p></blockquote><p><img data-src="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/image-20221127173127959-1670068866560-9.png" alt="image-20221127173127959"></p><blockquote><p>In Figure 21-9, you see that generation 1 keeps growing slowly. In fact, letâ€™s say that generation 1 has now grown to the point in which all of the objects in it occupy its full budget. At this point, the application continues running (because a garbage collection just finished) and starts allocating objects P through S, which fill generation 0 up to its budget. The heap now looks like Figure 21-10.</p></blockquote><p><img data-src="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/image-20221127173152883-1670068866560-10.png" alt="image-20221127173152883"></p><blockquote><p>When the application attempts to allocate object T, generation 0 is full, and a garbage collection must start. This time, however, the garbage collector sees that the objects in generation 1 are occupying so much memory that generation 1â€™s budget has been reached. Over the several generation 0 collections, itâ€™s likely that a number of objects in generation 1 have become unreachable (as in our example). So this time, the garbage collector decides to examine all of the objects in generation 1 and generation 0. After both generations have been garbage collected, the heap now looks like Figure 21-11.</p></blockquote><p><img data-src="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/image-20221127173218007-1670068866560-11.png" alt="image-20221127173218007"></p><blockquote><p>As before, any objects that were in generation 0 that survived the garbage collection are now in generation 1; any objects that were in generation 1 that survived the collection are now in generation 2. As always, generation 0 is empty immediately after a garbage collection and is where new objects will be allocated. Objects in generation 2 are objects that the garbage collector has examined two or more times. There might have been several collections, but the objects in generation 1 are examined only when generation 1 reaches its budget, which usually requires several garbage collections of generation 0.</p></blockquote><blockquote><p>The managed heap supports only three generations: generation 0, generation 1, and generation 2; there is no generation 3.3 When the CLR initializes, it selects budgets for all three generations. However, the CLRâ€™s garbage collector is a self-tuning collector. This means that the garbage collector learns about your applicationâ€™s behavior whenever it performs a garbage collection. For example, if your application constructs a lot of objects and uses them for a very short period of time, itâ€™s possible that garbage collecting generation 0 will reclaim a lot of memory. In fact, itâ€™s possible that the memory for all objects in generation 0 can be reclaimed.</p></blockquote><blockquote><p>If the garbage collector sees that there are very few surviving objects after collecting generation 0, it might decide to reduce the budget of generation 0. This reduction in the allotted space will mean that garbage collections occur more frequently but will require less work for the garbage collector, so your processâ€™s working set will be small. In fact, if all objects in generation 0 are garbage, a garbage collection doesnâ€™t have to compact any memory; it can simply set NextObjPtr back to the beginning of generation 0, and then the garbage collection is performed. Wow, this is a fast way to reclaim memory!</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šå¦‚æœåº”ç”¨ç¨‹åºçš„ä¸€äº›çº¿ç¨‹å¤§å¤šæ•°æ—¶å€™éƒ½åœ¨æ ˆé¡¶é—²ç½®ï¼Œåƒåœ¾å›æ”¶å™¨å·¥ä½œèµ·æ¥å°±å°¤å…¶ â€œå¾—å¿ƒåº”æ‰‹â€ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œçº¿ç¨‹æœ‰äº‹åšå°±ä¼šè¢«å”¤é†’ï¼Œåˆ›å»ºä¸€ç»„çŸ­æœŸå­˜æ´»çš„å¯¹è±¡ï¼Œè¿”å›ï¼Œç„¶åç»§ç»­ç¡çœ ã€‚è®¸å¤šåº”ç”¨ç¨‹åºéƒ½æ˜¯è¿™æ ·å»ºæ„çš„ã€‚ä¾‹å¦‚ï¼ŒGUI åº”ç”¨ç¨‹åºå¤§å¤šæ•°æ—¶å€™éƒ½è®© GUI çº¿ç¨‹å¤„åœ¨ä¸€ä¸ªæ¶ˆæ¯å¾ªç¯ä¸­ã€‚ç”¨æˆ·å¶å°”äº§ç”Ÿä¸€äº›è¾“å…¥ (è§¦æ‘¸ã€é¼ æ ‡æˆ–é”®ç›˜äº‹ä»¶)ï¼Œçº¿ç¨‹è¢«å”¤é†’ï¼Œå¤„ç†è¾“å…¥å¹¶å›åˆ°æ¶ˆæ¯æ³µã€‚ç„¶åï¼Œä¸ºäº†å¤„ç†è¾“å…¥è€Œåˆ›å»ºçš„å¤§å¤šæ•°å¯¹è±¡éƒ½ä¼šæˆä¸ºåƒåœ¾ã€‚</p><p>ç±»ä¼¼åœ°ï¼Œå¯¹äºæœåŠ¡å™¨åº”ç”¨ç¨‹åºï¼Œçº¿ç¨‹åœ¨æ± é‡Œå‘†ç€ï¼Œç­‰ç€å®¢æˆ·ç«¯è¯·æ±‚è¿›å…¥ã€‚æœ‰å®¢æˆ·ç«¯è¯·æ±‚è¿›å…¥åï¼Œçº¿ç¨‹åˆ›å»ºæ–°å¯¹è±¡ï¼Œä»£è¡¨å®¢æˆ·ç«¯æ‰§è¡Œå·¥ä½œã€‚ç»“æœå‘å›å®¢æˆ·ç«¯åï¼Œçº¿ç¨‹å°†å›åˆ°çº¿ç¨‹æ± ï¼Œåˆ›å»ºçš„æ‰€æœ‰å¯¹è±¡ç°åœ¨éƒ½æˆäº†åƒåœ¾ã€‚</p><blockquote><p>On the other hand, if the garbage collector collects generation 0 and sees that there are a lot of surviving objects, not a lot of memory was reclaimed in the garbage collection. In this case, the garbage collector will grow generation 0â€™s budget. Now, fewer collections will occur, but when they do, a lot more memory should be reclaimed. By the way, if insufficient memory has been reclaimed after a collection, the garbage collector will perform a full collection before throwing an OutOfMemoryException</p></blockquote><blockquote><p>Throughout this discussion, Iâ€™ve been talking about how the garbage collector dynamically modifies generation 0â€™s budget after every collection. But the garbage collector also modifies the budgets of generation 1 and generation 2 by using similar heuristics. When these generations are garbage collected, the garbage collector again sees how much memory is reclaimed and how many objects survived. Based on the garbage collectorâ€™s findings, it might grow or shrink the thresholds of these generations as well to improve the overall performance of the application. The end result is that the garbage collector fine-tunes itself automatically based on the memory load required by your applicationâ€”this is very cool!</p></blockquote><blockquote><p>The following GCNotification class raises an event whenever a generation 0 or generation 2 collection occurs. With these events, you could have the computer beep whenever a collection occurs or you calculate how much time passes between collections, how much memory is allocated between collections, and more. With this class, you could easily instrument your application to get a better understanding of how your application uses memory.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">GCNotification</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Action<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">></span></span> s_gcDone <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// The event's field</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">event</span> <span class="token return-type class-name">Action<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">></span></span> GCDone <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">add</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// If there were no registered delegates before, start reporting notifications now</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>s_gcDone <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">GenObject</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">GenObject</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> s_gcDone <span class="token operator">+=</span> <span class="token keyword">value</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">remove</span> <span class="token punctuation">&#123;</span> s_gcDone <span class="token operator">-=</span> <span class="token keyword">value</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">GenObject</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Int32</span> m_generation<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">public</span> <span class="token function">GenObject</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> generation<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> m_generation <span class="token operator">=</span> generation<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token operator">~</span><span class="token function">GenObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// This is the Finalize method</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// If this object is in the generation we want (or higher), </span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token comment">// notify the delegates that a GC just completed</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>GC<span class="token punctuation">.</span><span class="token function">GetGeneration</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token operator">>=</span> m_generation<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token class-name">Action<span class="token punctuation">&lt;</span>Int32<span class="token punctuation">></span></span> temp <span class="token operator">=</span> Volatile<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span><span class="token keyword">ref</span> s_gcDone<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token function">temp</span><span class="token punctuation">(</span>m_generation<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token comment">// Keep reporting notifications if there is at least one delegate registered,</span></pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token comment">// the AppDomain isn't unloading, and the process isnâ€™t shutting down</span></pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s_gcDone <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>AppDomain<span class="token punctuation">.</span>CurrentDomain<span class="token punctuation">.</span><span class="token function">IsFinalizingForUnload</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>Environment<span class="token punctuation">.</span>HasShutdownStarted<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token comment">// For Gen 0, create a new object; for Gen 2, resurrect the object </span></pre></td></tr><tr><td data-num="27"></td><td><pre> <span class="token comment">// &amp; let the GC call Finalize again the next time Gen 2 is GC'd</span></pre></td></tr><tr><td data-num="28"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>m_generation <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">GenObject</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre> <span class="token keyword">else</span> GC<span class="token punctuation">.</span><span class="token function">ReRegisterForFinalize</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre> <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* Let the objects go away */</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="garbage-collection-triggers"><a class="anchor" href="#garbage-collection-triggers">#</a> Garbage Collection Triggers</h3><blockquote><p>As you know, the CLR triggers a GC when it detects that generation 0 has filled its budget. This is the most common trigger of a GC; however, there are additional GC triggers as listed here:</p><ul><li><p>Code explicitly calls System.GCâ€™s static Collect method Code can explicitly request that the CLR perform a collection. Although Microsoft strongly discourages such requests, at times it might make sense for an application to force a collection. I discuss this more in the â€œForcing Garbage Collectionsâ€ section later in this chapter.</p></li><li><p>Windows is reporting low memory conditions The CLR internally uses the Win32 CreateMemoryResourceNotification and QueryMemoryResourceNotification functions to monitor system memory overall. If Windows reports low memory, the CLR will force a garbage collection in an effort to free up dead objects to reduce the size of a processâ€™s working set.</p></li><li><p>The CLR is unloading an AppDomain When an AppDomain unloads, the CLR considers nothing in the AppDomain to be a root, and a garbage collection consisting of all generations is performed. Iâ€™ll discuss AppDomains in Chapter 22, â€œCLR Hosting and AppDomains.â€</p></li><li><p>The CLR is shutting down The CLR shuts down when a process terminates normally (as opposed to an external shutdown via Task Manager, for example). During this shutdown, the CLR considers nothing in the process to be a root; it allows objects a chance to clean up but the CLR does not attempt to compact or free memory because the whole process is terminating, and Windows will reclaim all of the processesâ€™ memory.</p></li></ul></blockquote><h3 id="large-objects"><a class="anchor" href="#large-objects">#</a> Large Objects</h3><blockquote><p>There is one more performance improvement you might want to be aware of. The CLR considers each single object to be either a small object or a large object. So far, in this chapter, Iâ€™ve been focusing on small objects. Today, a large object is 85,000 bytes or more in size.4 The CLR treats large objects slightly differently than how it treats small objects:</p><ul><li><p>Large objects are not allocated within the same address space as small objects; they are allocated elsewhere within the processâ€™ address space.</p></li><li><p>Today, the GC doesnâ€™t compact large objects because of the time it would require to move them in memory. For this reason, address space fragmentation can occur between large objects within the process leading to an OutOfMemoryException being thrown. In a future version of the CLR, large objects may participate in compaction.</p></li><li><p>Large objects are immediately considered to be part of generation 2; they are never in generation 0 or 1. So, you should create large objects only for resources that you need to keep alive for a long time. Allocating short-lived large objects will cause generation 2 to be collected more frequently, hurting performance. Usually large objects are large strings (like XML or JSON) or byte arrays that you use for I/O operations, such as reading bytes from a file or network into a buffer so you can process it.</p></li></ul></blockquote><blockquote><p>For the most part, large objects are transparent to you; you can simply ignore that they exist and that they get special treatment until you run into some unexplained situation in your program (like why youâ€™re getting address space fragmentation).</p></blockquote><h3 id="garbage-collection-modes"><a class="anchor" href="#garbage-collection-modes">#</a> Garbage Collection Modes</h3><blockquote><p>When the CLR starts, it selects a GC mode, and this mode cannot change during the lifetime of the process. There are two basic GC modes:</p><ul><li><p>Workstation This mode fine-tunes the garbage collector for client-side applications. It is optimized to provide for low-latency GCs in order to minimize the time an applicationâ€™s threads are suspended so as not to frustrate the end user. In this mode, the GC assumes that other applications are running on the machine and does not hog CPU resources.</p></li><li><p>Server This mode fine-tunes the garbage collector for server-side applications. It is optimized for throughput and resource utilization. In this mode, the GC assumes no other applications (client or server) are running on the machine, and it assumes that all the CPUs on the machine are available to assist with completing the GC. This GC mode causes the managed heap to be split into several sections, one per CPU. When a garbage collection is initiated, the garbage collector dedicates one special thread per CPU; each thread collects its own section in parallel with the other threads. Parallel collections work well for server applications in which the worker threads tend to exhibit uniform behavior. This feature requires the application to be running on a computer with multiple CPUs so that the threads can truly be working simultaneously to attain a performance improvement.</p></li></ul></blockquote><blockquote><p>By default, applications run with the Workstation GC mode. A server application (such as <span class="exturl" data-url="aHR0cDovL0FTUC5ORVQ=">ASP.NET</span> or Microsoft SQL Server) that hosts the CLR can request the CLR to load the Server GC. However, if the server application is running on a uniprocessor machine, then the CLR will always use Workstation GC mode. A stand-alone application can tell the CLR to use the Server GC mode by creating a configuration file (as discussed in Chapter 2, â€œBuilding, Packaging, Deploying, and Administering Applications and Types,â€ and Chapter 3, â€œShared Assemblies and Strongly Named Assembliesâ€) that contains a gcServer element for the application. Hereâ€™s an example of a configuration file.</p></blockquote><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>runtime</span><span class="token punctuation">></span></span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>gcServer</span> <span class="token attr-name">enabled</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>runtime</span><span class="token punctuation">></span></span> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span></pre></td></tr></table></figure><blockquote><p>When an application is running, it can ask the CLR if it is running in the Server GC mode by querying the GCSettings classâ€™s IsServerGC read-only Boolean property.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Runtime</span><span class="token punctuation">;</span> <span class="token comment">// GCSettings is in this namespace </span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Application is running with server GC="</span> <span class="token operator">+</span> GCSettings<span class="token punctuation">.</span>IsServerGC<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In addition to the two modes, the GC can run in two sub-modes: concurrent (the default) or nonconcurrent. In concurrent mode, the GC has an additional background thread that marks objects concurrently while the application runs. When a thread allocates an object that pushes generation 0 over its budget, the GC first suspends all threads and then determines which generations to collect. If the garbage collector needs to collect generation 0 or 1, it proceeds as normal. However, if generation 2 needs collecting, the size of generation 0 will be increased beyond its budget to allocate the new object, and then the applicationâ€™s threads are resumed.</p></blockquote><blockquote><p>While the applicationâ€™s threads are running, the garbage collector has a normal priority background thread that finds unreachable objects. Once found, the garbage collector suspends all threads again and decides whether to compact memory. If the garbage collector decides to compact memory, memory is compacted, root references are fixed up, and the applicationâ€™s threads are resumed. This garbage collection takes less time than usual because the set of unreachable objects has already been built. However, the garbage collector might decide not to compact memory; in fact, the garbage collector favors this approach. If you have a lot of free memory, the garbage collector wonâ€™t compact the heap; this improves performance but grows your applicationâ€™s working set. When using the concurrent garbage collector, youâ€™ll typically find that your application is consuming more memory than it would with the non-concurrent garbage collector.</p></blockquote><blockquote><p>You can tell the CLR not to use the concurrent collector by creating a configuration file for the application that contains a gcConcurrent element. Hereâ€™s an example of a configuration file.</p></blockquote><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>runtime</span><span class="token punctuation">></span></span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>gcConcurrent</span> <span class="token attr-name">enabled</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>runtime</span><span class="token punctuation">></span></span> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span></pre></td></tr></table></figure><blockquote><p>The GC mode is configured for a process and it cannot change while the process runs. However, your application can have some control over the garbage collection by using the GCSettings classâ€™s GCLatencyMode property. This read/write property can be set to any of the values in the GCLatencyMode enumerated type, as shown in Table 21-1.</p></blockquote><blockquote><p>The LowLatency mode requires some additional explanation. Typically, you would set this mode, perform a short-term, time-sensitive operation, and then set the mode back to either Batch or Interactive. While the mode is set to LowLatency, the GC will really avoid doing any generation 2 collections because these could take a long time. Of course, if you call GC.Collect(), then generation 2 still gets collected. Also, the GC will perform a generation 2 collection if Windows tells the CLR that system memory is low (see the â€œGarbage Collection Triggersâ€ section earlier in this chapter).</p></blockquote><p><img data-src="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/image-20221127173821580-1670068866560-12.png" alt="image-20221127173821580"></p><blockquote><p>Under LowLatency mode, it is more likely that your application could get an OutOfMemoryException thrown. Therefore, stay in this mode for as short a time as possible, avoid allocating many objects, avoid allocating large objects, and set the mode back to Batch or Interactive by using a constrained execution region (CER), as discussed in Chapter 20, â€œExceptions and State Management.â€ Also, remember that the latency mode is a process-wide setting and threads may be running concurrently. These other threads could even change this setting while another thread is using it, so you may want to update some kind of counter (manipulated via Interlocked methods) when you have multiple threads manipulating this setting. Here is some code showing how to use the LowLatency mode.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">LowLatencyDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">GCLatencyMode</span> oldMode <span class="token operator">=</span> GCSettings<span class="token punctuation">.</span>LatencyMode<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> System<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>CompilerServices<span class="token punctuation">.</span>RuntimeHelpers<span class="token punctuation">.</span><span class="token function">PrepareConstrainedRegions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> GCSettings<span class="token punctuation">.</span>LatencyMode <span class="token operator">=</span> GCLatencyMode<span class="token punctuation">.</span>LowLatency<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Run your code here...</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> GCSettings<span class="token punctuation">.</span>LatencyMode <span class="token operator">=</span> oldMode<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="forcing-garbage-collections"><a class="anchor" href="#forcing-garbage-collections">#</a> Forcing Garbage Collections</h3><blockquote><p>The System.GC type allows your application some direct control over the garbage collector. For starters, you can query the maximum generation supported by the managed heap by reading the GC.MaxGeneration property; this property always returns 2.</p></blockquote><blockquote><p>You can also force the garbage collector to perform a collection by calling GC classâ€™s Collect method, optionally passing in a generation to collect up to, a GCCollectionMode, and a Boolean ndicating whether you want to perform a blocking (non-current) or background (concurrent) collection. Here is the signature of the most complex overload of the Collect method.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Collect</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> generation<span class="token punctuation">,</span> <span class="token class-name">GCCollectionMode</span> mode<span class="token punctuation">,</span> <span class="token class-name">Boolean</span> blocking<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>The GCCollectionMode type is an enum whose values are described in Table 21-2.</p></blockquote><p><img data-src="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/image-20221127173946803-1670068866560-13.png" alt="image-20221127173946803"></p><blockquote><p><strong>Under most circumstances, you should avoid calling any of the Collect methods</strong>; itâ€™s best just to let the garbage collector run on its own accord and fine-tune its generation budgets based on actual application behavior. However, if youâ€™re writing a console user interface (CUI) or GUI application, your application code owns the process and the CLR in that process. For these application types, you might want to suggest a garbage collection to occur at certain times using a GCCollectionMode of Optimized. Normally, modes of Default and Forced are used for debugging, testing, and looking for memory leaks.</p></blockquote><blockquote><p>For example, you might consider calling the Collect method if some non-recurring event has just occurred that has likely caused a lot of old objects to die. The reason that calling Collect in such a circumstance may not be so bad is that the GCâ€™s predictions of the future based on the past are not likely to be accurate for non-recurring events. For example, it might make sense for your application to force a full GC of all generations after your application initializes or after the user saves a data file. Because calling Collect causes the generation budgets to adjust, do not call Collect to try to improve your applicationâ€™s response time; call it to reduce your processâ€™s working set.</p></blockquote><blockquote><p>For some applications (especially server applications that tend to keep a lot of objects in memory), the time required for the GC to do a full collection that includes generation 2 can be excessive. In fact, if the collection takes a very long time to complete, then client requests might time out. To help these kinds of applications, the GC class offers a RegisterForFullGCNotification method. Using this method and some additional helper methods (WaitForFullGCApproach, WaitForFullGCComplete, and CancelFullGCNotification), an application can now be notified when the garbage collector is getting close to performing a full collection. The application can then call GC.Collect to force a collection at a more opportune time, or the application could communicate with another server to better load balance the client requests. For more information, examine these methods and the â€œGarbage Collection Notificationsâ€ topic in the Microsoft .NET Framework SDK documentation. Note that you should always call the WaitForFullGCApproach and WaitForFullGCComplete methods in pairs because the CLR handles them as pairs internally.</p></blockquote><h3 id="monitoring-your-applications-memory-usage"><a class="anchor" href="#monitoring-your-applications-memory-usage">#</a> Monitoring Your Applicationâ€™s Memory Usage</h3><blockquote><p>Within a process, there are a few methods that you can call to monitor the garbage collector. Specifically, the GC class offers the following static methods, which you can call to see how many collections have occurred of a specific generation or how much memory is currently being used by objects in the managed heap.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token return-type class-name">Int32</span> <span class="token function">CollectionCount</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> generation<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token return-type class-name">Int64</span> <span class="token function">GetTotalMemory</span><span class="token punctuation">(</span><span class="token class-name">Boolean</span> forceFullCollection<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>To profile a particular code block, I have frequently written code to call these methods before and after the code block and then calculate the difference. This gives me a very good indication of how my code block has affected my processâ€™s working set and indicates how many garbage collections occurred while executing the code block. If the numbers are high, I know to spend more time tuning the algorithms in my code block.</p></blockquote><blockquote><p>You can also see how much memory is being used by individual AppDomains as opposed to the whole process. For more information about this, see the â€œAppDomain Monitoringâ€ section in Chapter 22.</p></blockquote><blockquote><p>When you install the .NET Framework, it installs a set of performance counters that offer a lot of real-time statistics about the CLRâ€™s operations. These statistics are visible via the PerfMon.exe tool or the System Monitor ActiveX control that ships with Windows. The easiest way to access the System Monitor control is to run PerfMon.exe and click the + toolbar button, which causes the Add Counters dialog box shown in Figure 21-12 to appear.</p></blockquote><p><img data-src="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/image-20221129100443706-1670068866560-15.png" alt="image-20221129100443706"></p><p><strong>FIGURE 21-12</strong> PerfMon.exe showing the .NET CLR Memory counters.</p><blockquote><p>To monitor the CLRâ€™s garbage collector, select the .NET CLR Memory performance object. Then select a specific application from the instance list box. Finally, select the set of counters that youâ€™re interested in monitoring, click Add, and then click OK. At this point, the System Monitor will graph the selected real-time statistics. For an explanation of a particular counter, select the desired counter and then select the Show Description check box.</p></blockquote><blockquote><p>Another great tool for analyzing the memory and performance of your application is PerfView. This tool can collect Event Tracing for Windows (ETW) logs and process them. The best way to acquire this tool is for you to search the web for PerfView. Finally, you should look into using the SOS Debugging Extension (SOS.dll), which can often offer great assistance when debugging memory problems and other CLR problems. For memory-related actions, the SOS Debugging Extension allows you to see how much memory is allocated within the process to the managed heap, displays all objects registered for finalization in the finalization queue, displays the entries in the GCHandle table per AppDomain or for the entire process, shows the roots that are keeping an object alive in the heap, and more.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šCLR çš„ GC æ˜¯åŸºäºä»£çš„åƒåœ¾å›æ”¶å™¨ (generational garbage collector)ï¼Œå®ƒå¯¹ä½ çš„ä»£ç åšå‡ºäº†ä»¥ä¸‹å‡ ç‚¹å‡è®¾ï¼šå¯¹è±¡è¶Šæ–°ï¼Œç”Ÿå­˜æœŸè¶ŠçŸ­ï¼›å¯¹è±¡è¶Šè€ï¼Œç”Ÿå­˜æœŸè¶Šé•¿ï¼›å›æ”¶å †çš„ä¸€éƒ¨åˆ†ï¼Œé€Ÿåº¦å¿«äºå›æ”¶æ•´ä¸ªå †ã€‚æ‰˜ç®¡å †åœ¨åˆå§‹åŒ–æ—¶ä¸åŒ…å«å¯¹è±¡ã€‚æ·»åŠ åˆ°å †çš„å¯¹è±¡ç§°ä¸ºç¬¬ 0 ä»£å¯¹è±¡ã€‚ç®€å•åœ°è¯´ï¼Œç¬¬ 0 ä»£å¯¹è±¡å°±æ˜¯é‚£äº›æ–°æ„é€ çš„å¯¹è±¡ï¼Œåƒåœ¾å›æ”¶å™¨ä»æœªæ£€æŸ¥è¿‡å®ƒä»¬ã€‚CLR åˆå§‹åŒ–æ—¶ä¸ºç¬¬ 0 ä»£å¯¹è±¡é€‰æ‹©ä¸€ä¸ªé¢„ç®—å®¹é‡ (ä»¥ KB ä¸ºå•ä½)ã€‚å¦‚æœåˆ†é…ä¸€ä¸ªæ–°å¯¹è±¡é€ æˆç¬¬ 0 ä»£è¶…è¿‡é¢„ç®—ï¼Œå°±å¿…é¡»å¯åŠ¨ä¸€æ¬¡åƒåœ¾å›æ”¶ã€‚å¼€å§‹ä¸€æ¬¡åƒåœ¾å›æ”¶æ—¶ï¼Œåƒåœ¾å›æ”¶å™¨è¿˜ä¼šæ£€æŸ¥ç¬¬ 1 ä»£å ç”¨äº†å¤šå°‘å†…å­˜ã€‚å¦‚æœç¬¬ 1 ä»£å ç”¨çš„å†…å­˜è¿œå°‘äºé¢„ç®—ï¼Œæ‰€ä»¥åƒåœ¾å›æ”¶å™¨åªæ£€æŸ¥ç¬¬ 0 ä»£ä¸­çš„å¯¹è±¡ã€‚å›é¡¾ä¸€ä¸‹åŸºäºä»£çš„åƒåœ¾å›æ”¶å™¨åšå‡ºçš„å‡è®¾ã€‚ç¬¬ä¸€ä¸ªå‡è®¾æ˜¯è¶Šæ–°çš„å¯¹è±¡æ´»å¾—è¶ŠçŸ­ã€‚å› æ­¤ï¼Œç¬¬ 0 ä»£åŒ…å«æ›´å¤šåƒåœ¾çš„å¯èƒ½æ€§å¾ˆå¤§ï¼Œèƒ½å›æ”¶æ›´å¤šçš„å†…å­˜ã€‚ç”±äºå¿½ç•¥äº†ç¬¬ 1 ä»£ä¸­çš„å¯¹è±¡ï¼Œæ‰€ä»¥åŠ å¿«äº†åƒåœ¾å›æ”¶é€Ÿåº¦ã€‚æ˜¾ç„¶ï¼Œå¿½ç•¥ç¬¬ 1 ä»£ä¸­çš„å¯¹è±¡èƒ½æå‡åƒåœ¾å›æ”¶å™¨çš„æ€§èƒ½ã€‚ä½†å¯¹æ€§èƒ½æœ‰æ›´å¤§ææŒ¯ä½œç”¨çš„æ˜¯ç°åœ¨ä¸å¿…éå†æ‰˜ç®¡å †ä¸­çš„æ¯ä¸ªå¯¹è±¡ã€‚å¦‚æœæ ¹æˆ–å¯¹è±¡å¼•ç”¨äº†è€ä¸€ä»£çš„æŸä¸ªå¯¹è±¡ï¼Œåƒåœ¾å›æ”¶å™¨å°±å¯ä»¥å¿½ç•¥è€å¯¹è±¡å†…éƒ¨çš„æ‰€æœ‰å¼•ç”¨ï¼Œèƒ½åœ¨æ›´çŸ­çš„æ—¶é—´å†…æ„é€ å¥½å¯è¾¾å¯¹è±¡å›¾ (graph of reachable object)ã€‚å½“ç„¶ï¼Œè€å¯¹è±¡çš„å­—æ®µä¹Ÿæœ‰å¯èƒ½å¼•ç”¨æ–°å¯¹è±¡ã€‚ä¸ºäº†ç¡®ä¿å¯¹è€å¯¹è±¡çš„å·²æ›´æ–°å­—æ®µè¿›è¡Œæ£€æŸ¥ï¼Œåƒåœ¾å›æ”¶å™¨åˆ©ç”¨äº† JIT ç¼–è¯‘å™¨å†…éƒ¨çš„ä¸€ä¸ªæœºåˆ¶ã€‚è¿™ä¸ªæœºåˆ¶åœ¨å¯¹è±¡çš„å¼•ç”¨å­—æ®µå‘ç”Ÿå˜åŒ–æ—¶ï¼Œä¼šè®¾ç½®ä¸€ä¸ªå¯¹åº”çš„ä½æ ‡å¿—ã€‚è¿™æ ·ï¼Œåƒåœ¾å›æ”¶å™¨å°±çŸ¥é“è‡ªä¸Šä¸€æ¬¡åƒåœ¾å›æ”¶ä»¥æ¥ï¼Œå“ªäº›è€å¯¹è±¡ (å¦‚æœæœ‰çš„è¯) å·²è¢«å†™å…¥ã€‚åªæœ‰å­—æ®µå‘ç”Ÿå˜åŒ–çš„è€å¯¹è±¡æ‰éœ€æ£€æŸ¥æ˜¯å¦å¼•ç”¨äº†ç¬¬ 0 ä»£ä¸­çš„ä»»ä½•æ–°å¯¹è±¡ã€‚å½“åƒåœ¾å›æ”¶å™¨å‘ç°ç¬¬ 1 ä»£å ç”¨äº†å¤ªå¤šå†…å­˜ï¼Œä»¥è‡³äºç”¨å®Œäº†é¢„ç®—ã€‚åœ¨å‰å‡ æ¬¡å¯¹ç¬¬ 0 ä»£è¿›è¡Œå›æ”¶æ—¶ï¼Œç¬¬ 1 ä»£å¯èƒ½å·²ç»æœ‰è®¸å¤šå¯¹è±¡å˜å¾—ä¸å¯è¾¾ã€‚æ‰€ä»¥è¿™æ—¶åƒåœ¾å›æ”¶å™¨å°±ä¼šå†³å®šæ£€æŸ¥ç¬¬ 1 ä»£å’Œç¬¬ 0 ä»£ä¸­çš„æ‰€æœ‰å¯¹è±¡ã€‚æ‰˜ç®¡å †åªæ”¯æŒä¸‰ä»£ï¼šç¬¬ 0 ä»£ã€ç¬¬ 1 ä»£å’Œç¬¬ 2 ä»£ã€‚æ²¡æœ‰ç¬¬ 3 ä»£ã€‚CLR åˆå§‹åŒ–æ—¶ï¼Œä¼šä¸ºæ¯ä¸€ä»£é€‰æ‹©é¢„ç®—ã€‚ç„¶è€Œï¼ŒCLR çš„åƒåœ¾å›æ”¶å™¨æ˜¯è‡ªè°ƒèŠ‚çš„ã€‚è¿™æ„å‘³ç€åƒåœ¾å›æ”¶å™¨ä¼šåœ¨æ‰§è¡Œåƒåœ¾å›æ”¶çš„è¿‡ç¨‹ä¸­äº†è§£åº”ç”¨ç¨‹åºçš„è¡Œä¸ºã€‚å¦‚æœåƒåœ¾å›æ”¶å™¨å‘ç°åœ¨å›æ”¶ 0 ä»£åå­˜æ´»ä¸‹æ¥çš„å¯¹è±¡å¾ˆå°‘ï¼Œå°±å¯èƒ½å‡å°‘ç¬¬ 0 ä»£çš„é¢„ç®—ã€‚å·²åˆ†é…ç©ºé—´çš„å‡å°‘æ„å‘³ç€åƒåœ¾å›æ”¶å°†æ›´é¢‘ç¹åœ°å‘ç”Ÿï¼Œä½†åƒåœ¾å›æ”¶å™¨æ¯æ¬¡åšçš„äº‹æƒ…ä¹Ÿå‡å°‘äº†ï¼Œè¿™å‡å°äº†è¿›ç¨‹çš„å·¥ä½œé›†ã€‚å¦ä¸€æ–¹é¢ï¼Œå¦‚æœåƒåœ¾å›æ”¶å™¨å›æ”¶äº†ç¬¬ 0 ä»£ï¼Œå‘ç°è¿˜æœ‰å¾ˆå¤šå¯¹è±¡å­˜æ´»ï¼Œæ²¡æœ‰å¤šå°‘å†…å­˜è¢«å›æ”¶ï¼Œå°±ä¼šå¢å¤§ç¬¬ 0 ä»£çš„é¢„ç®—ã€‚ç°åœ¨ï¼Œåƒåœ¾å›æ”¶çš„æ¬¡æ•°å°†å‡å°‘ï¼Œä½†æ¯æ¬¡è¿›è¡Œåƒåœ¾å›æ”¶æ—¶ï¼Œå›æ”¶çš„å†…å­˜è¦å¤šå¾—å¤šã€‚é¡ºä¾¿è¯´ä¸€å¥ï¼Œå¦‚æœæ²¡æœ‰å›æ”¶åˆ°è¶³å¤Ÿçš„å†…å­˜ï¼Œåƒåœ¾å›æ”¶å™¨ä¼šæ‰§è¡Œä¸€æ¬¡å®Œæ•´å›æ”¶ã€‚å¦‚æœè¿˜æ˜¯ä¸å¤Ÿï¼Œå°±æŠ›å‡º <code>OutOfMemoryException</code> å¼‚å¸¸ã€‚åˆ°ç›®å‰ä¸ºæ­¢ï¼Œåªæ˜¯è®¨è®ºäº†æ¯æ¬¡åƒåœ¾å›æ”¶åå¦‚ä½•åŠ¨æ€ä»£ç”¨ç¬¬ 0 ä»£çš„é¢„ç®—ã€‚ä½†åƒåœ¾å›æ”¶å™¨è¿˜ä¼šç”¨ç±»ä¼¼çš„å¯å‘å¼ç®—æ³•è°ƒæ•´ç¬¬ 1 ä»£å’Œç¬¬ 2 ä»£çš„é¢„ç®—ã€‚è¿™äº›ä»£ç åƒåœ¾å›æ”¶æ—¶ï¼Œåƒåœ¾å›æ”¶å™¨ä¼šæ£€æŸ¥æœ‰å¤šå°‘å†…å­˜è¢«å›æ”¶ï¼Œä»¥åŠæœ‰å¤šå°‘å¯¹è±¡å¹¸å­˜ã€‚åŸºäºè¿™äº›ç»“æœï¼Œåƒåœ¾å›æ”¶å™¨å¯èƒ½å¢å¤§æˆ–å‡å°è¿™äº›ä»£çš„é¢„ç®—ï¼Œä»è€Œæå‡åº”ç”¨ç¨‹åºçš„æ€»ä½“æ€§èƒ½ã€‚æœ€ç»ˆçš„ç»“æœæ˜¯ï¼Œåƒåœ¾å›æ”¶å™¨ä¼šæ ¹æ®åº”ç”¨ç¨‹åºè¦æ±‚çš„å†…å­˜è´Ÿè½½æ¥è‡ªåŠ¨ä¼˜åŒ–ã€‚å‰é¢è¯´è¿‡ï¼ŒCLR åœ¨æ£€æµ‹ç¬¬ 0 ä»£è¶…è¿‡é¢„ç®—æ—¶è§¦å‘ä¸€æ¬¡ GCã€‚è¿™æ˜¯ GC æœ€å¸¸è§çš„è§¦å‘æ¡ä»¶ï¼Œåœ¨å…¶ä»–ä¸€äº›æ¡ä»¶ä¸‹ä¹Ÿä¼šè§¦å‘ï¼šä»£ç æ˜¾å¼è°ƒç”¨ <code>System.GC</code> çš„é™æ€ <code>Collect</code> æ–¹æ³•ï¼›Windows æŠ¥å‘Šä½å†…å­˜æƒ…å†µï¼›CLR æ­£åœ¨å¸è½½ AppDomainï¼›CLR æ­£åœ¨å…³é—­ã€‚è¿˜æœ‰å¦ä¸€ä¸ªæ€§èƒ½æå‡ä¸¾æªå€¼å¾—æ³¨æ„ã€‚CLR å°†å¯¹è±¡åˆ†ä¸ºå¤§å¯¹è±¡å’Œå°å¯¹è±¡ã€‚ç›®å‰è®¤ä¸º 85000 å­—èŠ‚æˆ–æ›´å¤§çš„å¯¹è±¡æ˜¯å¤§å¯¹è±¡ã€‚CLR ä»¥ä¸åŒæ–¹å¼å¯¹å¾…å¤§å°å¯¹è±¡ã€‚å¤§å¯¹è±¡ä¸æ˜¯åœ¨å°å¯¹è±¡çš„åœ°å€ç©ºé—´åˆ†é…ï¼Œè€Œæ˜¯åœ¨è¿›ç¨‹åœ°å€ç©ºé—´çš„å…¶ä»–åœ°æ–¹åˆ†é…ã€‚å‰ç‰ˆæœ¬çš„ GC ä¸å‹ç¼©å¤§å¯¹è±¡ï¼Œå› ä¸ºåœ¨å†…å­˜ä¸­ç§»åŠ¨å®ƒä»¬ä»£ä»·è¿‡é«˜ã€‚ä½†è¿™å¯èƒ½åœ¨è¿›ç¨‹ä¸­çš„å¤§å¯¹è±¡ä¹‹é—´é€ æˆåœ°å€ç©ºé—´çš„ç¢ç‰‡åŒ–ï¼Œä»¥è‡³äºæŠ›å‡º <code>OutOfMemoryException</code> ã€‚å¤§å¯¹è±¡æ€»æ˜¯ç¬¬ 2 ä»£ï¼Œç»ä¸å¯èƒ½æ˜¯ç¬¬ 0 ä»£æˆ– ç¬¬ 1 ä»£ã€‚æ‰€ä»¥åªèƒ½ä¸ºéœ€è¦é•¿æ—¶é—´å­˜æ´»çš„èµ„æºåˆ›å»ºå¤§å¯¹è±¡ã€‚åˆ†é…çŸ­æ—¶é—´å­˜æ´»çš„å¤§å¯¹è±¡ã€‚åˆ†é…çŸ­æ—¶é—´å­˜æ´»çš„å¤§å¯¹è±¡ä¼šå¯¼è‡´ç¬¬ 2 ä»£è¢«æ›´é¢‘ç¹åœ°å›æ”¶ï¼Œä¼šæŸå®³æ€§èƒ½ã€‚å¤§å¯¹è±¡ä¸€èˆ¬æ˜¯å¤§å­—ç¬¦ä¸² (æ¯”å¦‚ XML æˆ– JSON) æˆ–è€…ç”¨äº I/O æ“ä½œçš„å­—èŠ‚æ•°ç»„ (æ¯”å¦‚ä»æ–‡ä»¶æˆ–ç½‘ç»œå°†å­—èŠ‚è¯»å…¥ç¼“å†²åŒºä»¥ä¾¿å¤„ç†)ã€‚CLR å¯åŠ¨æ—¶ä¼šé€‰æ‹©ä¸€ä¸ª GC æ¨¡å¼ï¼Œè¿›ç¨‹ç»ˆæ­¢å‰è¯¥æ¨¡å¼ä¸ä¼šæ”¹å˜ã€‚æœ‰ä¸¤ä¸ªåŸºæœ¬ GC æ¨¡å¼ã€‚å®ƒä»¬åˆ†åˆ«æ˜¯å·¥ä½œç«™æ¨¡å¼å’ŒæœåŠ¡å™¨æ¨¡å¼ã€‚åº”ç”¨ç¨‹åºé»˜è®¤ä»¥ â€œå·¥ä½œç«™â€ GC æ¨¡å¼è¿è¡Œã€‚å¯„å®¿äº† CLR çš„æœåŠ¡å™¨åº”ç”¨ç¨‹åº (æ¯”å¦‚ <span class="exturl" data-url="aHR0cDovL0FTUC5ORVQ=">ASP.NET</span> æˆ– Microsoft SQL Server) å¯è¯·æ±‚ CLR åŠ è½½ â€œæœåŠ¡å™¨â€ GCã€‚ä½†å¦‚æœæœåŠ¡å™¨åº”ç”¨ç¨‹åºåœ¨å•å¤„ç†å™¨è®¡ç®—æœºä¸Šè¿è¡Œï¼ŒCLR å°†æ€»æ˜¯ä½¿ç”¨ â€œå·¥ä½œç«™â€ GC æ¨¡å¼ã€‚é™¤äº†è¿™ä¸¤ç§ä¸»è¦æ¨¡å¼ï¼ŒGC è¿˜æ”¯æŒä¸¤ç§å­æ¨¡å¼ï¼šå¹¶å‘ (é»˜è®¤) æˆ–éå¹¶å‘ã€‚åœ¨å¹¶å‘æ–¹å¼ä¸­ï¼Œåƒåœ¾å›æ”¶å™¨æœ‰ä¸€ä¸ªé¢å¤–çš„åå°çº¿ç¨‹ï¼Œå®ƒèƒ½åœ¨åº”ç”¨ç¨‹åºè¿è¡Œæ—¶å¹¶å‘æ ‡è®°å¯¹è±¡ã€‚åº”ç”¨ç¨‹åºçº¿ç¨‹è¿è¡Œæ—¶ï¼Œåƒåœ¾å›æ”¶å™¨è¿è¡Œä¸€ä¸ªæ™®é€šä¼˜å…ˆçº§çš„åå°çº¿ç¨‹æ¥æŸ¥æ‰¾ä¸å¯è¾¾å¯¹è±¡ã€‚æ‰¾åˆ°ä¹‹åï¼Œåƒåœ¾å›æ”¶å™¨å†æ¬¡æŒ‚èµ·æ‰€æœ‰çº¿ç¨‹ï¼Œåˆ¤æ–­æ˜¯å¦è¦å‹ç¼© (ç§»åŠ¨) å†…å­˜ã€‚å¦‚å†³å®šå‹ç¼©ï¼Œå†…å­˜ä¼šè¢«å‹ç¼©ï¼Œæ ¹å¼•ç”¨ä¼šè¢«ä¿®æ­£ï¼Œåº”ç”¨ç¨‹åºçº¿ç¨‹æ¢å¤è¿è¡Œã€‚è¿™ä¸€æ¬¡åƒåœ¾å›æ”¶èŠ±è´¹çš„æ—¶é—´æ¯”å¹³å¸¸å°‘ï¼Œå› ä¸ºä¸å¯è¾¾å¯¹è±¡é›†åˆå·²æ„é€ å¥½äº†ã€‚ä½†åƒåœ¾å›æ”¶å™¨ä¹Ÿå¯èƒ½å†³å®šä¸å‹ç¼©å†…å­˜ï¼›äº‹å®ä¸Šï¼Œåƒåœ¾å›æ”¶å™¨æ›´å€¾å‘äºé€‰æ‹©ä¸å‹ç¼©ã€‚å¯ç”¨å†…å­˜å¤šï¼Œåƒåœ¾å›æ”¶å™¨ä¾¿ä¸ä¼šå‹ç¼©å †ï¼›è¿™æœ‰åˆ©äºå¢å¼ºæ€§èƒ½ï¼Œä½†ä¼šå¢å¤§åº”ç”¨ç¨‹åºçš„å·¥ä½œé›†ã€‚ä½¿ç”¨å¹¶å‘åƒåœ¾å›æ”¶å™¨ï¼Œåº”ç”¨ç¨‹åºæ¶ˆè€—çš„å†…å­˜é€šå¸¸æ¯”ä½¿ç”¨å¹¶å‘åƒåœ¾å›æ”¶å™¨å¤šã€‚GC æ¨¡å¼æ˜¯é’ˆå¯¹è¿›ç¨‹é…ç½®çš„ï¼Œè¿›ç¨‹è¿è¡ŒæœŸé—´ä¸èƒ½æ›´æ”¹ã€‚ä½†æ˜¯ï¼Œä½ çš„åº”ç”¨ç¨‹åºå¯ä»¥ä½¿ç”¨ <code>GCSettings</code> ç±»çš„ <code>GCLatencyMode</code> å±æ€§å¯¹åƒåœ¾å›æ”¶è¿›è¡ŒæŸç§ç¨‹åº¦çš„æ§åˆ¶ã€‚åœ¨æ¨¡å¼è®¾ä¸º <code>LowLatency</code> æœŸé—´ï¼Œåƒåœ¾å›æ”¶å™¨ä¼šå…¨åŠ›é¿å…ä»»ä½•ç¬¬ 2 ä»£å›æ”¶ï¼Œå› ä¸ºé‚£æ ·èŠ±è´¹çš„æ—¶é—´è¾ƒå¤šã€‚å½“ç„¶ï¼Œè°ƒç”¨ <code>GC.Collect()</code> ä»ä¼šå›æ”¶ç¬¬ 2 ä»£ã€‚åœ¨ <code>LowLatency</code> æ¨¡å¼ä¸­ï¼Œåº”ç”¨ç¨‹åºæŠ›å‡º <code>OutOfMemoryException</code> çš„æœºç‡ä¼šå¤§ä¸€äº›ã€‚æ‰€ä»¥ï¼Œå‡ºäºè¯¥æ¨¡å¼çš„æ—¶é—´åº”å°½é‡çŸ­ï¼Œé¿å…åˆ†é…å¤ªå¤šå¯¹è±¡ï¼Œé¿å…åˆ†é…å¤§å¯¹è±¡ï¼Œå¹¶ç”¨ä¸€ä¸ªçº¦æŸæ‰§è¡ŒåŒºåŸŸ (CER) å°†æ¨¡å¼è®¾å› <code>Batch</code> æˆ– <code>Interactive</code> ã€‚å¦å¤–æ³¨æ„ï¼Œå»¶è¿Ÿæ¨¡å¼æ˜¯è¿›ç¨‹çº§çš„è®¾ç½®ï¼Œè€Œå¯èƒ½æœ‰å¤šä¸ªçº¿ç¨‹å¹¶å‘è¿è¡Œã€‚å¤§å¤šæ—¶å€™éƒ½è¦é¿å…è°ƒç”¨ä»»ä½• <code>Collect</code> æ–¹æ³•ï¼šæœ€å¥½è®©åƒåœ¾å›æ”¶å™¨è‡ªå·±æ–Ÿé…Œæ‰§è¡Œï¼Œè®©å®ƒæ ¹æ®åº”ç”¨ç¨‹åºçš„è¡Œä¸ºè°ƒæ•´å„ä¸ªä»£çš„é¢„ç®—ã€‚ä½†å‡å¦‚åˆšæ‰å‘ç”Ÿäº†æŸä¸ªéé‡å¤æ€§çš„äº‹ä»¶ï¼Œå¹¶å¯¼è‡´å¤§é‡æ—§å¯¹è±¡æ­»äº¡ï¼Œå°±å¯è€ƒè™‘æ‰‹åŠ¨è°ƒç”¨ä¸€æ¬¡ <code>Collect</code> æ–¹æ³•ã€‚ç”±äºæ˜¯éé‡å¤æ€§äº‹ä»¶ï¼Œåƒåœ¾å›æ”¶å™¨åŸºäºå†å²çš„é¢„æµ‹å¯èƒ½å˜å¾—ä¸å‡†ç¡®ã€‚æ‰€ä»¥ï¼Œè¿™æ—¶è°ƒç”¨ <code>Collect</code> æ–¹æ³•æ˜¯åˆé€‚çš„ã€‚</p><h2 id="working-with-types-requiring-special-cleanup"><a class="anchor" href="#working-with-types-requiring-special-cleanup">#</a> Working with Types Requiring Special Cleanup</h2><blockquote><p>At this point, you should have a basic understanding of garbage collection and the managed heap, including how the garbage collector reclaims an objectâ€™s memory. Fortunately for us, most types need only memory to operate. However, some types require more than just memory to be useful; some types require the use of a native resource in addition to memory.</p></blockquote><blockquote><p>The System.IO.FileStream type, for example, needs to open a file (a native resource) and store the fileâ€™s handle. Then the typeâ€™s Read and Write methods use this handle to manipulate the file. Similarly, the System.Threading.Mutex type opens a Windows mutex kernel object (a native resource) and stores its handle, using it when the Mutexâ€™s methods are called.</p></blockquote><blockquote><p>If a type wrapping a native resource gets GCâ€™d, the GC will reclaim the memory used by the object in the managed heap; but the native resource, which the GC doesnâ€™t know anything about, will be leaked. This is clearly not desirable, so the CLR offers a mechanism called finalization. Finalization allows an object to execute some code after the object has been determined to be garbage but before the objectâ€™s memory is reclaimed from the managed heap. All types that wrap a native resourceâ€” such as a file, network connection, socket, or mutexâ€”support finalization. When the CLR determines that one of these objects is no longer reachable, the object gets to finalize itself, releasing the native resource it wraps, and then, later, the GC will reclaim the object from the managed heap.</p></blockquote><blockquote><p>System.Object, the base class of everything, defines a protected and virtual method called Finalize. When the garbage collector determines that an object is garbage, it calls the objectâ€™s Finalize method (if it is overridden). Microsoftâ€™s C# team felt that Finalize methods were a special kind of method requiring special syntax in the programming language (similar to how C# requires special syntax to define a constructor). So, in C#, you must define a Finalize method by placing a tilde symbol (~) in front of the class name, as shown in the following code sample.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// This is the Finalize method </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token operator">~</span><span class="token function">SomeType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// The code here is inside the Finalize method </span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>If you were to compile this code and examine the resulting assembly with ILDasm.exe, youâ€™d see that the C# compiler did, in fact, emit a protected override method named Finalize into the moduleâ€™s metadata. If you examined the Finalize methodâ€™s IL code, youâ€™d also see that the code inside the methodâ€™s body is emitted into a try block, and that a call to base.Finalize is emitted into a finally block.</p></blockquote><p>ğŸ’¡é‡è¦æç¤º å¦‚æœç†Ÿæ‚‰ C++ï¼Œä¼šå‘ç° C# <code>Finalize</code> æ–¹æ³•çš„ç‰¹æ®Šè¯­æ³•éå¸¸ç±»ä¼¼äº C++ ææ„å™¨ã€‚äº‹å®ä¸Šï¼Œåœ¨ C# ç¼–ç¨‹è¯­è¨€è§„èŒƒçš„æ—©æœŸç‰ˆæœ¬ä¸­ï¼ŒçœŸçš„æ˜¯å°†è¯¥æ–¹æ³•ç§°ä¸ºææ„å™¨ã€‚ä½† <code>Finalize</code> æ–¹æ³•çš„å·¥ä½œæ–¹å¼å’Œ C++ ææ„å™¨å®Œå…¨ä¸åŒï¼Œè¿™ä¼šä½¿ä»ä¸€ç§è¯­è¨€è¿ç§»åˆ°å¦ä¸€ç§è¯­è¨€çš„å¼€å‘äººå‘˜äº§ç”Ÿæ··æ·†ã€‚</p><p>é—®é¢˜åœ¨äºï¼Œè¿™äº›å¼€å‘äººå‘˜å¯èƒ½é”™è¯¯åœ°ä»¥ä¸ºä½¿ç”¨ C# ææ„å™¨è¯­æ³•æ„å‘³ç€ç±»å‹çš„å®ä¾‹ä¼šè¢«ç¡®å®šæ€§ææ„ï¼Œå°±åƒåœ¨ C++ ä¸­é‚£æ ·ã€‚ä½† CLR ä¸æ”¯æŒç¡®å®šæ€§ææ„ï¼Œè€Œä½œä¸ºé¢å‘ CLR çš„è¯­è¨€ï¼ŒC# ä¹Ÿæ— æ³•æä¾›è¿™ç§æœºåˆ¶ã€‚</p><blockquote><p>Finalize methods are called at the completion of a garbage collection on objects that the GC has determined to be garbage. This means that the memory for these objects cannot be reclaimed right away because the Finalize method might execute code that accesses a field. Because a finalizable object must survive the collection, it gets promoted to another generation, forcing the object to live much longer than it should. This is not ideal in terms of memory consumption and is why you should avoid finalization when possible. To make matters worse, when finalizable objects get promoted, any object referred to by its fields also get promoted because they must continue to live too. So, try to avoid defining finalizable objects with reference type fields.</p></blockquote><blockquote><p>Furthermore, be aware of the fact that you have no control over when the Finalize method will execute. Finalize methods run when a garbage collection occurs, which may happen when your application requests more memory. Also, the CLR doesnâ€™t make any guarantees as to the order in which Finalize methods are called. So, you should avoid writing a Finalize method that accesses other objects whose type defines a Finalize method; those other objects could have been finalized already. However, it is perfectly OK to access value type instances or reference type objects that do not define a Finalize method. You also need to be careful when calling static methods because these methods can internally access objects that have been finalized, causing the behavior of the static method to become unpredictable.</p></blockquote><blockquote><p>The CLR uses a special, high-priority dedicated thread to call Finalize methods to avoid some deadlock scenarios that could occur otherwise.5 If a Finalize method blocks (for example, enters an infinite loop or waits for an object that is never signaled), this special thread canâ€™t call any more Finalize methods. This is a very bad situation because the application will never be able to reclaim the memory occupied by the finalizable objectsâ€”the application will leak memory as long as it runs. If a Finalize method throws an unhandled exception, then the process terminates; there is no way to catch this exception.</p></blockquote><blockquote><p>So, as you can see, there are a lot of caveats related to Finalize methods and they must be used with caution. Specifically, they are designed for releasing native resources. To simplify working with them, it is highly recommended that developers avoid overriding Objectâ€™s Finalize method; instead, use helper classes that Microsoft now provides in the Framework Class Library (FCL). The helper classes override Finalize and add some special CLR magic Iâ€™ll talk about as we go on. You will then derive your own classes from the helper classes and inherit the CLR magic.</p></blockquote><blockquote><p>If you are creating a managed type that wraps a native resource, you should first derive a class from a special base class called System.Runtime.InteropServices.SafeHandle, which looks like the following (Iâ€™ve added comments in the methods to indicate what they do).</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">SafeHandle</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">CriticalFinalizerObject</span><span class="token punctuation">,</span> <span class="token class-name">IDisposable</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// This is the handle to the native resource </span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">protected</span> <span class="token class-name">IntPtr</span> handle<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">protected</span> <span class="token function">SafeHandle</span><span class="token punctuation">(</span><span class="token class-name">IntPtr</span> invalidHandleValue<span class="token punctuation">,</span> <span class="token class-name">Boolean</span> ownsHandle<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">this</span><span class="token punctuation">.</span>handle <span class="token operator">=</span> invalidHandleValue<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// If ownsHandle is true, then the native resource is closed when </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// this SafeHandle-derived object is collected </span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">protected</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SetHandle</span><span class="token punctuation">(</span><span class="token class-name">IntPtr</span> handle<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">this</span><span class="token punctuation">.</span>handle <span class="token operator">=</span> handle<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// You can explicitly release the resource by calling Dispose</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token comment">// This is the IDisposable interfaceâ€™s Dispose method </span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// The default Dispose implementation (shown here) is exactly what you want.</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token comment">// Overriding this method is strongly discouraged. </span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token keyword">protected</span> <span class="token keyword">virtual</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token class-name">Boolean</span> disposing<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token comment">// The default implementation ignores the disposing argument.</span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token comment">// If resource already released, return </span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token comment">// If ownsHandle is false, return </span></pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token comment">// Set flag indicating that this resource has been released </span></pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token comment">// Call virtual ReleaseHandle method </span></pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token comment">// Call GC.SuppressFinalize(this) to prevent Finalize from being called </span></pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token comment">// If ReleaseHandle returned true, return </span></pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token comment">// If we get here, fire ReleaseHandleFailed Managed Debugging Assistant (MDA) </span></pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="27"></td><td><pre> <span class="token comment">// The default Finalize implementation (shown here) is exactly what you want.</span></pre></td></tr><tr><td data-num="28"></td><td><pre> <span class="token comment">// Overriding this method is very strongly discouraged. </span></pre></td></tr><tr><td data-num="29"></td><td><pre> <span class="token operator">~</span><span class="token function">SafeHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="30"></td><td><pre> <span class="token comment">// A derived class overrides this method to implement the code that releases the resource </span></pre></td></tr><tr><td data-num="31"></td><td><pre> <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token return-type class-name">Boolean</span> <span class="token function">ReleaseHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="32"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SetHandleAsInvalid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="33"></td><td><pre> <span class="token comment">// Set flag indicating that this resource has been released </span></pre></td></tr><tr><td data-num="34"></td><td><pre> <span class="token comment">// Call GC.SuppressFinalize(this) to prevent Finalize from being called </span></pre></td></tr><tr><td data-num="35"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="36"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Boolean</span> IsClosed <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="37"></td><td><pre> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="38"></td><td><pre> <span class="token comment">// Returns flag indicating whether resource was released </span></pre></td></tr><tr><td data-num="39"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="40"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="41"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token return-type class-name">Boolean</span> IsInvalid <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="42"></td><td><pre> <span class="token comment">// A derived class overrides this property.</span></pre></td></tr><tr><td data-num="43"></td><td><pre> <span class="token comment">// The implementation should return true if the handle's value doesn't</span></pre></td></tr><tr><td data-num="44"></td><td><pre> <span class="token comment">// represent a resource (this usually means that the handle is 0 or -1)</span></pre></td></tr><tr><td data-num="45"></td><td><pre> <span class="token keyword">get</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="47"></td><td><pre> <span class="token comment">// These three methods have to do with security and reference counting; </span></pre></td></tr><tr><td data-num="48"></td><td><pre> <span class="token comment">// I'll talk about them at the end of this section</span></pre></td></tr><tr><td data-num="49"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">DangerousAddRef</span><span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token class-name">Boolean</span> success<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="50"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">IntPtr</span> <span class="token function">DangerousGetHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="51"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">DangerousRelease</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="52"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The first thing to notice about the SafeHandle class is that it is derived from CriticalFinalizerObject, which is defined in the System.Runtime.ConstrainedExecution namespace. The CLR treats this class and classes derived from it in a very special manner. In particular, the CLR endows this class with three cool features:</p><ul><li><p>The first time an object of any CriticalFinalizerObject-derived type is constructed, the CLR immediately JIT-compiles all of the Finalize methods in the inheritance hierarchy. Compiling these methods upon object construction guarantees that the native resource will be released when the object is determined to be garbage. Without this eager compiling of the Finalize method, it would be possible to allocate the native resource and use it, but not to get rid of it. Under low memory conditions, the CLR might not be able to find enough memory to compile the Finalize method, which would prevent it from executing, causing the native resource to leak. Or the resource might not be freed if the Finalize method contained code that referred to a type in another assembly, and the CLR failed to locate this other assembly.</p></li><li><p>The CLR calls the Finalize method of CriticalFinalizerObject-derived types after calling the Finalize methods of nonâ€“CriticalFinalizerObject-derived types. This ensures that managed resource classes that have a Finalize method can access CriticalFinalizerObject-derived objects within their Finalize methods successfully. For example, the FileStream classâ€™s Finalize method can flush data from a memory buffer to an underlying disk with confidence that the disk file has not been closed yet.</p></li><li><p>The CLR calls the Finalize method of CriticalFinalizerObject-derived types if an AppDomain is rudely aborted by a host application (such as SQL Server or <span class="exturl" data-url="aHR0cDovL0FTUC5ORVQ=">ASP.NET</span>). This also is part of ensuring that the native resource is released even in a case in which a host application no longer trusts the managed code running inside of it.</p></li></ul></blockquote><blockquote><p>The second thing to notice about SafeHandle is that the class is abstract; it is expected that another class will be derived from SafeHandle, and this class will provide a constructor that invokes the protected constructor, the abstract method ReleaseHandle, and the abstract IsInvalid property get accessor method.</p></blockquote><blockquote><p>Most native resources are manipulated with handles (32-bit values on a 32-bit system and 64-bit values on a 64-bit system). So the SafeHandle class defines a protected IntPtr field called handle. In Windows, most handles are invalid if they have a value of 0 or -1. The Microsoft.Win32.SafeHandles namespace contains another helper class called SafeHandleZeroOrMinusOneIsInvalid, which looks like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">SafeHandleZeroOrMinusOneIsInvalid</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">SafeHandle</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">protected</span> <span class="token function">SafeHandleZeroOrMinusOneIsInvalid</span><span class="token punctuation">(</span><span class="token class-name">Boolean</span> ownsHandle<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token punctuation">:</span> <span class="token keyword">base</span><span class="token punctuation">(</span>IntPtr<span class="token punctuation">.</span>Zero<span class="token punctuation">,</span> ownsHandle<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name">Boolean</span> IsInvalid <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">base</span><span class="token punctuation">.</span>handle <span class="token operator">==</span> IntPtr<span class="token punctuation">.</span>Zero<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">base</span><span class="token punctuation">.</span>handle <span class="token operator">==</span> <span class="token punctuation">(</span>IntPtr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Again, youâ€™ll notice that the SafeHandleZeroOrMinusOneIsInvalid class is abstract, and therefore, another class must be derived from this one to override the protected constructor and the abstract method ReleaseHandle. The .NET Framework provides just a few public classes derived from SafeHandleZeroOrMinusOneIsInvalid, including SafeFileHandle, SafeRegistryHandle, SafeWaitHandle, and SafeMemoryMappedViewHandle. Here is what the SafeFileHandle class looks like.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SafeFileHandle</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">SafeHandleZeroOrMinusOneIsInvalid</span></span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token function">SafeFileHandle</span><span class="token punctuation">(</span><span class="token class-name">IntPtr</span> preexistingHandle<span class="token punctuation">,</span> <span class="token class-name">Boolean</span> ownsHandle<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token punctuation">:</span> <span class="token keyword">base</span><span class="token punctuation">(</span>ownsHandle<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">SetHandle</span><span class="token punctuation">(</span>preexistingHandle<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">protected</span> <span class="token keyword">override</span> <span class="token return-type class-name">Boolean</span> <span class="token function">ReleaseHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// Tell Windows that we want the native resource closed. </span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">return</span> Win32Native<span class="token punctuation">.</span><span class="token function">CloseHandle</span><span class="token punctuation">(</span><span class="token keyword">base</span><span class="token punctuation">.</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The SafeWaitHandle class is implemented similarly to the SafeFileHandle class just shown. The only reason why there are different classes with similar implementations is to achieve type safety; the compiler wonâ€™t let you use a file handle as an argument to a method that expects a wait handle, and vice versa. The SafeRegistryHandle classâ€™s ReleaseHandle method calls the Win32 RegCloseKey function.</p></blockquote><blockquote><p>It would be nice if the .NET Framework included additional classes that wrap various native resources. For example, one could imagine classes such as SafeProcessHandle, SafeThreadHandle, SafeTokenHandle, SafeLibraryHandle (its ReleaseHandle method would call the Win32 FreeLibrary function), SafeLocalAllocHandle (its ReleaseHandle method would call the Win32 LocalFree function), and so on.</p></blockquote><blockquote><p>All of the classes just listed (and more) actually do ship with the Framework Class Library (FCL). However, these classes are not publicly exposed; they are all internal to the assemblies that define them. Microsoft didnâ€™t expose these classes publicly because they didnâ€™t want to document them and do full testing of them. However, if you need any of these classes for your own work, Iâ€™d recommend that you use a tool such as ILDasm.exe or some IL decompiler tool to extract the code for these classes and integrate that code into your own projectâ€™s source code. All of these classes are trivial to implement, and writing them yourself from scratch would also be quite easy.</p></blockquote><blockquote><p>The SafeHandle-derived classes are extremely useful because they ensure that the native resource is freed when a GC occurs. In addition to what weâ€™ve already discussed, SafeHandle offers two more capabilities. First, the CLR gives SafeHandle-derived types special treatment when used in scenarios in which you are interoperating with native code. For example, letâ€™s examine the following code.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>InteropServices</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">Microsoft<span class="token punctuation">.</span>Win32<span class="token punctuation">.</span>SafeHandles</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">DllImport</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token string">"Kernel32"</span><span class="token punctuation">,</span> CharSet<span class="token operator">=</span>CharSet<span class="token punctuation">.</span>Unicode<span class="token punctuation">,</span> EntryPoint<span class="token operator">=</span><span class="token string">"CreateEvent"</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// This prototype is not robust </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">extern</span> <span class="token return-type class-name">IntPtr</span> <span class="token function">CreateEventBad</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token class-name">IntPtr</span> pSecurityAttributes<span class="token punctuation">,</span> <span class="token class-name">Boolean</span> manualReset<span class="token punctuation">,</span> <span class="token class-name">Boolean</span> initialState<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// This prototype is robust </span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">[</span><span class="token function">DllImport</span><span class="token punctuation">(</span><span class="token string">"Kernel32"</span><span class="token punctuation">,</span> CharSet<span class="token operator">=</span>CharSet<span class="token punctuation">.</span>Unicode<span class="token punctuation">,</span> EntryPoint<span class="token operator">=</span><span class="token string">"CreateEvent"</span><span class="token punctuation">)</span><span class="token punctuation">]</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">extern</span> <span class="token return-type class-name">SafeWaitHandle</span> <span class="token function">CreateEventGood</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token class-name">IntPtr</span> pSecurityAttributes<span class="token punctuation">,</span> <span class="token class-name">Boolean</span> manualReset<span class="token punctuation">,</span> <span class="token class-name">Boolean</span> initialState<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SomeMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token class-name">IntPtr</span> handle <span class="token operator">=</span> <span class="token function">CreateEventBad</span><span class="token punctuation">(</span>IntPtr<span class="token punctuation">.</span>Zero<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token class-name">SafeWaitHandle</span> swh <span class="token operator">=</span> <span class="token function">CreateEventGood</span><span class="token punctuation">(</span>IntPtr<span class="token punctuation">.</span>Zero<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Youâ€™ll notice that the CreateEventBad method is prototyped as returning an IntPtr, which will return the handle back to managed code; however, interoperating with native code this way is not robust. You see, after CreateEventBad is called (which creates the native event resource), it is possible that a ThreadAbortException could be thrown prior to the handle being assigned to the handle variable. In the rare cases when this would happen, the managed code would leak the native resource. The only way to get the event closed is to terminate the whole process.</p></blockquote><blockquote><p>The SafeHandle class fixes this potential resource leak. Notice that the CreateEventGood method is prototyped as returning a SafeWaitHandle (instead of an IntPtr). When CreateEventGood is called, the CLR calls the Win32 CreateEvent function. As the CreateEvent function returns to managed code, the CLR knows that SafeWaitHandle is derived from SafeHandle, causing the CLR to automatically construct an instance of the SafeWaitHandle class on the managed heap, passing in the handle value returned from CreateEvent. The constructing of the SafeWaitHandle object and the assignment of the handle happen in native code now, which cannot be interrupted by a ThreadAbortException. Now, it is impossible for managed code to leak this native resource. Eventually, the SafeWaitHandle object will be garbage collected and its Finalize method will be called, ensuring that the resource is released.</p></blockquote><blockquote><p>One last feature of SafeHandle-derived classes is that they prevent someone from trying to exploit a potential security hole. The problem is that one thread could be trying to use a native resource while another thread tries to free the resource. This could manifest itself as a handle-recycling exploit. The SafeHandle class prevents this security vulnerability by using reference counting. Internally, the SafeHandle class defines a private field that maintains a count. When a SafeHandle-derived object is set to a valid handle, the count is set to 1. Whenever a SafeHandle-derived object is passed as an argument to a native method, the CLR knows to automatically increment the counter. Likewise, when the native method returns to managed code, the CLR knows to decrement the counter. For example, you would prototype the Win32 SetEvent function as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">DllImport</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token string">"Kernel32"</span><span class="token punctuation">,</span> ExactSpelling<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">extern</span> <span class="token return-type class-name">Boolean</span> <span class="token function">SetEvent</span><span class="token punctuation">(</span><span class="token class-name">SafeWaitHandle</span> swh<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>Now when you call this method passing in a reference to a SafeWaitHandle object, the CLR will increment the counter just before the call and decrement the counter just after the call. Of course, the manipulation of the counter is performed in a thread-safe fashion. How does this improve security? Well, if another thread tries to release the native resource wrapped by the SafeHandle object, the CLR knows that it cannot actually release it because the resource is being used by a native function. When the native function returns, the counter is decremented to 0, and the resource will be released.</p></blockquote><blockquote><p>If you are writing or calling code to manipulate a handle as an IntPtr, you can access it out of a SafeHandle object, but you should manipulate the reference counting explicitly. You accomplish this via SafeHandleâ€™s DangerousAddRef and DangerousRelease methods. You gain access to the raw handle via the DangerousGetHandle method.</p></blockquote><blockquote><p>I would be remiss if I didnâ€™t mention that the System.Runtime.InteropServices namespace also defines a CriticalHandle class. This class works exactly as the SafeHandle class in all ways except that it does not offer the reference-counting feature. The CriticalHandle class and the classes derived from it sacrifice security for better performance when you use it (because counters donâ€™t get manipulated). As does SafeHandle, the CriticalHandle class has two types derived from it: CriticalHandleMinusOneIsInvalid and CriticalHandleZeroOrMinusOneIsInvalid. Because Microsoft favors a more secure system over a faster system, the class library includes no types derived from either of these two classes. For your own work, I would recommend that you use CriticalHandle-derived types only if performance is an issue. If you can justify reducing security, you can switch to a CriticalHandle-derived type.</p></blockquote><h3 id="using-a-type-that-wraps-a-native-resource"><a class="anchor" href="#using-a-type-that-wraps-a-native-resource">#</a> Using a Type That Wraps a Native Resource</h3><blockquote><p>Now that you know how to define a SafeHandle-derived class that wraps a native resource, letâ€™s take a look at how a developer uses it. Letâ€™s start by talking about the common System.IO.FileStream class. The FileStream class offers the ability to open a file, read bytes from the file, write bytes to the file, and close the file. When a FileStream object is constructed, the Win32 CreateFile function is called, the returned handle is saved in a SafeFileHandle object, and a reference to this object is maintained via a private field in the FileStream object. The FileStream class also offers several additional properties (such as Length, Position, CanRead) and methods (such as Read, Write, Flush).</p></blockquote><blockquote><p>Letâ€™s say that you want to write some code that creates a temporary file, writes some bytes to the file, and then deletes the file. You might start writing the code like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>IO</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// Create the bytes to write to the temporary file. </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token class-name">Byte<span class="token punctuation">[</span><span class="token punctuation">]</span></span> bytesToWrite <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Byte<span class="token punctuation">[</span><span class="token punctuation">]</span></span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// Create the temporary file. </span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token class-name">FileStream</span> fs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">FileStream</span><span class="token punctuation">(</span><span class="token string">"Temp.dat"</span><span class="token punctuation">,</span> FileMode<span class="token punctuation">.</span>Create<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// Write the bytes to the temporary file. </span></pre></td></tr><tr><td data-num="10"></td><td><pre> fs<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>bytesToWrite<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> bytesToWrite<span class="token punctuation">.</span>Length<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// Delete the temporary file. </span></pre></td></tr><tr><td data-num="12"></td><td><pre> File<span class="token punctuation">.</span><span class="token function">Delete</span><span class="token punctuation">(</span><span class="token string">"Temp.dat"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Throws an IOException </span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Unfortunately, if you build and run this code, it might work, but most likely it wonâ€™t. The problem is that the call to Fileâ€™s static Delete method requests that Windows delete a file while it is still open. So Delete throws a System.IO.IOException exception with the following string message: The process cannot access the file &quot;Temp.dat&quot; because it is being used by another process.</p></blockquote><blockquote><p>Be aware that in some cases, the file might actually be deleted! If another thread somehow caused a garbage collection to start after the call to Write and before the call to Delete, the FileStreamâ€™s SafeFileHandle field would have its Finalize method called, which would close the file and allow Delete to work. The likelihood of this situation is extremely rare, however, and therefore the previous code will fail more than 99 percent of the time.</p></blockquote><blockquote><p>Classes that allow the consumer to control the lifetime of native resources it wraps implement the IDisposable interface, which looks like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IDisposable</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>ğŸ’¡é‡è¦æç¤ºï¼šå¦‚æœç±»å®šä¹‰çš„ä¸€ä¸ªå­—æ®µçš„ç±»å‹å®ç°äº† dispose æ¨¡å¼ï¼Œé‚£ä¹ˆç±»æœ¬èº«ä¹Ÿåº”å®ç° dispose æ¨¡å¼ï¼Œé‚£ä¹ˆç±»æœ¬èº«ä¹Ÿåº”å®ç° dispose æ¨¡å¼ã€‚ <code>Dispose</code> æ–¹æ³•åº” dispose å­—æ®µå¼•ç”¨çš„å¯¹è±¡ã€‚è¿™å°±å…è®¸ç±»çš„ä½¿ç”¨è€…åœ¨ç±»ä¸Šè°ƒç”¨ <code>Dispose</code> æ¥é‡Šæ”¾å¯¹è±¡è‡ªèº«ä½¿ç”¨çš„èµ„æºã€‚</p><blockquote><p>Fortunately, the FileStream class implements the IDisposable interface and its implementation internally calls Dispose on the FileStream objectâ€™s private SafeFileHandle field. Now, we can modify our code to explicitly close the file when we want to as opposed to waiting for some GC to happen in the future. Hereâ€™s the corrected source code.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>IO</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// Create the bytes to write to the temporary file. </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token class-name">Byte<span class="token punctuation">[</span><span class="token punctuation">]</span></span> bytesToWrite <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Byte<span class="token punctuation">[</span><span class="token punctuation">]</span></span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// Create the temporary file. </span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token class-name">FileStream</span> fs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">FileStream</span><span class="token punctuation">(</span><span class="token string">"Temp.dat"</span><span class="token punctuation">,</span> FileMode<span class="token punctuation">.</span>Create<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// Write the bytes to the temporary file. </span></pre></td></tr><tr><td data-num="10"></td><td><pre> fs<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>bytesToWrite<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> bytesToWrite<span class="token punctuation">.</span>Length<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// Explicitly close the file when finished writing to it. </span></pre></td></tr><tr><td data-num="12"></td><td><pre> fs<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token comment">// Delete the temporary file. </span></pre></td></tr><tr><td data-num="14"></td><td><pre> File<span class="token punctuation">.</span><span class="token function">Delete</span><span class="token punctuation">(</span><span class="token string">"Temp.dat"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// This always works now. </span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Now, when Fileâ€™s Delete method is called, Windows sees that the file isnâ€™t open and successfully deletes it.</p></blockquote><blockquote><p>Keep in mind that calling Dispose is not required to guarantee native resource cleanup. Native resource cleanup will always happen eventually; calling Dispose lets you control when that cleanup happens. Also, calling Dispose does not delete the managed object from the managed heap. The only way to reclaim memory in the managed heap is for a garbage collection to kick in. This means you can still call methods on the managed object even after you dispose of any native resources it may have been using.</p></blockquote><blockquote><p>The following code calls the Write method after the file is closed, attempting to write more bytes to the file. Obviously, the bytes canâ€™t be written, and when the code executes, the second call to the Write method throws a System.ObjectDisposedException exception with the following string message: Cannot access a closed file.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>IO</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// Create the bytes to write to the temporary file. </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token class-name">Byte<span class="token punctuation">[</span><span class="token punctuation">]</span></span> bytesToWrite <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Byte<span class="token punctuation">[</span><span class="token punctuation">]</span></span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// Create the temporary file. </span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token class-name">FileStream</span> fs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">FileStream</span><span class="token punctuation">(</span><span class="token string">"Temp.dat"</span><span class="token punctuation">,</span> FileMode<span class="token punctuation">.</span>Create<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// Write the bytes to the temporary file. </span></pre></td></tr><tr><td data-num="10"></td><td><pre> fs<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>bytesToWrite<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> bytesToWrite<span class="token punctuation">.</span>Length<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// Explicitly close the file when finished writing to it. </span></pre></td></tr><tr><td data-num="12"></td><td><pre> fs<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token comment">// Try to write to the file after closing it. </span></pre></td></tr><tr><td data-num="14"></td><td><pre> fs<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>bytesToWrite<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> bytesToWrite<span class="token punctuation">.</span>Length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Throws ObjectDisposedException</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// Delete the temporary file. </span></pre></td></tr><tr><td data-num="16"></td><td><pre> File<span class="token punctuation">.</span><span class="token function">Delete</span><span class="token punctuation">(</span><span class="token string">"Temp.dat"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Note that no memory corruption occurs here because the memory for the FileStream object still exists in the managed heap; itâ€™s just that the object canâ€™t successfully execute its methods after it is explicitly disposed.</p></blockquote><p>ğŸ’¡é‡è¦æç¤ºï¼šå®šä¹‰å®ç° <code>IDisposable</code> æ¥å£çš„ç±»å‹æ—¶ï¼Œåœ¨å®ƒçš„æ‰€æœ‰æ–¹æ³•å’Œå±æ€§ä¸­ï¼Œä¸€å®šè¦åœ¨å¯¹è±¡è¢«æ˜¾å¼æ¸…ç†ä¹‹åæŠ›å‡ºä¸€ä¸ª <code>System.ObjectDisposedException</code> ã€‚è€Œ <code>Dispose</code> æ–¹æ³•æ°¸è¿œä¸è¦æŠ›å‡º <code>ObjectDisposedException</code> ï¼›è¢«å¤šæ¬¡è°ƒç”¨å°±ç›´æ¥è¿”å›ã€‚</p><p>ğŸ’¡é‡è¦æç¤ºï¼šæˆ‘ä¸€èˆ¬ä¸èµæˆåœ¨ä»£ç ä¸­æ˜¾å¼è°ƒç”¨ <code>Dispose</code> ã€‚ç†ç”±æ˜¯ CLR çš„åƒåœ¾å›æ”¶å™¨å·²ç»å†™å¾—éå¸¸å¥½ï¼Œåº”è¯¥æ”¾å¿ƒåœ°æŠŠå·¥ä½œäº¤ç»™å®ƒã€‚åƒåœ¾å›æ”¶å™¨çŸ¥é“ä¸€ä¸ªå¯¹è±¡ä½•æ—¶ä¸å†ç”±åº”ç”¨ç¨‹åºä»£ç è®¿é—®ï¼Œè€Œä¸”åªæœ‰åˆ°é‚£æ—¶æ‰ä¼šå›æ”¶å¯¹è±¡ã€‚è€Œå½“åº”ç”¨ç¨‹åºä»£ç è°ƒç”¨ <code>Dispose</code> æ—¶ï¼Œå®é™…æ˜¯åœ¨ä¿¡èª“æ—¦æ—¦åœ°è¯´å®ƒçŸ¥é“åº”ç”¨ç¨‹åºåœ¨ä»€ä¹ˆæ—¶å€™ä¸éœ€è¦ä¸€ä¸ªå¯¹è±¡ã€‚ä½†è®¸å¤šåº”ç”¨ç¨‹åºéƒ½ä¸å¯èƒ½å‡†ç¡®çŸ¥é“ä¸€ä¸ªå¯¹è±¡åœ¨ä»€ä¹ˆæ—¶å€™ä¸éœ€è¦ã€‚<br>ä¾‹å¦‚ï¼Œå‡å®šåœ¨æ–¹æ³• A çš„ä»£ç ä¸­æ„é€ äº†ä¸€ä¸ªæ–°å¯¹è±¡ï¼Œç„¶åå°†å¯¹è¯¥å¯¹è±¡çš„å¼•ç”¨ä¼ ç»™æ–¹æ³• Bã€‚æ–¹æ³• B å¯èƒ½å°†å¯¹è¯¥å¯¹è±¡çš„å¼•ç”¨ä¿å­˜åˆ°æŸä¸ªå†…éƒ¨å­—æ®µå˜é‡ (ä¸€ä¸ªæ ¹) ä¸­ã€‚ä½†æ–¹æ³• A å¹¶ä¸çŸ¥é“è¿™ä¸ªæƒ…å†µï¼Œå®ƒå½“ç„¶å¯ä»¥è°ƒç”¨ <code>Dispose</code> ã€‚ä½†åœ¨æ­¤ä¹‹åï¼Œå…¶ä»–ä»£ç å¯èƒ½è¯•å›¾è®¿é—®è¯¥å¯¹è±¡ï¼Œé€ æˆæŠ›å‡ºä¸€ä¸ª <code>ObjectDisposedException</code> ã€‚å»ºè®®åªæœ‰åœ¨ç¡®å®šå¿…é¡»æ¸…ç†èµ„æº (ä¾‹å¦‚åˆ é™¤æ‰“å¼€çš„æ–‡ä»¶) æ—¶æ‰è°ƒç”¨ <code>Dispose</code> ã€‚<br>æœ‰å¯èƒ½å¤šä¸ªçº¿ç¨‹åŒæ—¶è°ƒç”¨ä¸€ä¸ªå¯¹è±¡çš„ <code>Dispose</code> ã€‚ä½† <code>Dispose</code> çš„è®¾è®¡è§„èŒƒæŒ‡å‡º <code>Dispose</code> ä¸ä¸€å®šè¦çº¿ç¨‹å®‰å…¨ã€‚åŸå› æ˜¯ä»£ç åªæœ‰åœ¨ç¡®å®šæ²¡æœ‰åˆ«çš„çº¿ç¨‹ä½¿ç”¨å¯¹è±¡æ—¶æ‰åº”è°ƒç”¨ <code>Dispose</code> ã€‚</p><blockquote><p>The previous code examples show how to explicitly call a typeâ€™s Dispose method. If you decide to call Dispose explicitly, I highly recommend that you place the call in an exception-handling finally block. This way, the cleanup code is guaranteed to execute. So it would be better to write the previous code example as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>IO</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// Create the bytes to write to the temporary file. </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token class-name">Byte<span class="token punctuation">[</span><span class="token punctuation">]</span></span> bytesToWrite <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Byte<span class="token punctuation">[</span><span class="token punctuation">]</span></span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// Create the temporary file. </span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token class-name">FileStream</span> fs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">FileStream</span><span class="token punctuation">(</span><span class="token string">"Temp.dat"</span><span class="token punctuation">,</span> FileMode<span class="token punctuation">.</span>Create<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// Write the bytes to the temporary file. </span></pre></td></tr><tr><td data-num="11"></td><td><pre> fs<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>bytesToWrite<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> bytesToWrite<span class="token punctuation">.</span>Length<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token comment">// Explicitly close the file when finished writing to it. </span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>fs <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> fs<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token comment">// Delete the temporary file. </span></pre></td></tr><tr><td data-num="18"></td><td><pre> File<span class="token punctuation">.</span><span class="token function">Delete</span><span class="token punctuation">(</span><span class="token string">"Temp.dat"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Adding the exception-handling code is the right thing to do, and you must have the diligence to do it. Fortunately, the C# language provides a using statement, which offers a simplified syntax that produces code identical to the code just shown. Hereâ€™s how the preceding code would be rewritten using C#â€™s using statement.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>IO</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// Create the bytes to write to the temporary file. </span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token class-name">Byte<span class="token punctuation">[</span><span class="token punctuation">]</span></span> bytesToWrite <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Byte<span class="token punctuation">[</span><span class="token punctuation">]</span></span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// Create the temporary file. </span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token class-name">FileStream</span> fs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">FileStream</span><span class="token punctuation">(</span><span class="token string">"Temp.dat"</span><span class="token punctuation">,</span> FileMode<span class="token punctuation">.</span>Create<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// Write the bytes to the temporary file. </span></pre></td></tr><tr><td data-num="10"></td><td><pre> fs<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>bytesToWrite<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> bytesToWrite<span class="token punctuation">.</span>Length<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// Delete the temporary file. </span></pre></td></tr><tr><td data-num="13"></td><td><pre> File<span class="token punctuation">.</span><span class="token function">Delete</span><span class="token punctuation">(</span><span class="token string">"Temp.dat"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In the using statement, you initialize an object and save its reference in a variable. Then you access the variable via code contained inside usingâ€™s braces. When you compile this code, the compiler automatically emits the try and finally blocks. Inside the finally block, the compiler emits code to cast the object to an IDisposable and calls the Dispose method. Obviously, the compiler allows the using statement to be used only with types that implement the IDisposable interface.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šC# çš„ <code>using</code> è¯­å¥æ”¯æŒåˆå§‹åŒ–å¤šä¸ªå˜é‡ï¼Œåªè¦è¿™äº›å˜é‡çš„ç±»å‹ç›¸åŒã€‚å¦å¤–ï¼Œ <code>using</code> è¯­å¥è¿˜å…è®¸åªä½¿ç”¨ä¸€ä¸ªå·²åˆå§‹åŒ–çš„å˜é‡ã€‚æ¬²çŸ¥è¯¦æƒ…ï¼Œè¯·å‚è§æ–‡æ¡£ä¸­çš„ â€œ <code>using</code> è¯­å¥â€ ä¸»é¢˜ã€‚</p><h3 id="an-interesting-dependency-issue"><a class="anchor" href="#an-interesting-dependency-issue">#</a> An Interesting Dependency Issue</h3><blockquote><p>The System.IO.FileStream type allows the user to open a file for reading and writing. To improve performance, the typeâ€™s implementation makes use of a memory buffer. Only when the buffer fills does the type flush the contents of the buffer to the file. A FileStream supports the writing of bytes only. If you want to write characters and strings, you can use a System.IO.StreamWriter, as is demonstrated in the following code.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">FileStream</span> fs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">FileStream</span><span class="token punctuation">(</span><span class="token string">"DataFile.dat"</span><span class="token punctuation">,</span> FileMode<span class="token punctuation">.</span>Create<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">StreamWriter</span> sw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">StreamWriter</span><span class="token punctuation">(</span>fs<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre>sw<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token string">"Hi there"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// The following call to Dispose is what you should do. </span></pre></td></tr><tr><td data-num="5"></td><td><pre>sw<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// NOTE: StreamWriter.Dispose closes the FileStream; </span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// the FileStream doesn't have to be explicitly closed.</span></pre></td></tr></table></figure><blockquote><p>Notice that the StreamWriterâ€™s constructor takes a reference to a Stream object as a parameter, allowing a reference to a FileStream object to be passed as an argument. Internally, the StreamWriter object saves the Streamâ€™s reference. When you write to a StreamWriter object, it internally buffers the data in its own memory buffer. When the buffer is full, the StreamWriter object writes the data to the Stream.</p></blockquote><blockquote><p>When youâ€™re finished writing data via the StreamWriter object, you should call Dispose. (Because the StreamWriter type implements the IDisposable interface, you can also use it with C#â€™s using statement.) This causes the StreamWriter object to flush its data to the Stream object and close the Stream object.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šä¸éœ€è¦åœ¨ <code>FileStream</code> å¯¹è±¡ä¸Šæ˜¾å¼è°ƒç”¨ <code>Dispose</code> ï¼Œå› ä¸º <code>StreamWriter</code> ä¼šå¸®ä½ è°ƒç”¨ã€‚ä½†å¦‚æœéè¦æ˜¾å¼è°ƒç”¨ <code>Dispose</code> ï¼Œ <code>FileStream</code> ä¼šå‘ç°å¯¹è±¡å·²ç»æ¸…ç†è¿‡äº†ï¼Œæ‰€ä»¥æ–¹æ³•ä»€ä¹ˆéƒ½ä¸åšè€Œç›´æ¥è¿”å›ã€‚</p><blockquote><p>What do you think would happen if there were no code to explicitly call Dispose? Well, at some point, the garbage collector would correctly detect that the objects were garbage and finalize them. But the garbage collector doesnâ€™t guarantee the order in which objects are finalized. So if the FileStream object were finalized first, it would close the file. Then when the StreamWriter object was finalized, it would attempt to write data to the closed file, throwing an exception. If, on the other hand, the StreamWriter object were finalized first, the data would be safely written to the file.</p></blockquote><blockquote><p>How was Microsoft to solve this problem? Making the garbage collector finalize objects in a specific order would have been impossible because objects could contain references to each other, and there would be no way for the garbage collector to correctly guess the order in which to finalize these objects. Here is Microsoftâ€™s solution: the StreamWriter type does not support finalization, and therefore it never flushes data in its buffer to the underlying FileStream object. This means that if you forget to explicitly call Dispose on the StreamWriter object, data is guaranteed to be lost. Microsoft expects developers to see this consistent loss of data and fix the code by inserting an explicit call to Dispose.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼š.NET Framework æ”¯æŒæ‰˜ç®¡è°ƒè¯•åŠ©æ‰‹ (Managed Debugging Assistantï¼ŒMDA) åŠŸèƒ½ã€‚å¯ç”¨ä¸€ä¸ª MDA åï¼Œ.NET Framework å°±ä¼šæŸ¥æ‰¾ç‰¹å®šç§ç±»çš„å¸¸è§ç¼–ç¨‹é”™è¯¯ï¼Œå¹¶æ¿€æ´»å¯¹åº”çš„ MDAã€‚åœ¨è°ƒè¯•å™¨ä¸­ï¼Œæ¿€æ´»ä¸€ä¸ª MDA æ„Ÿè§‰å°±åƒæ˜¯æŠ›å‡ºä¸€ä¸ªå¼‚å¸¸ã€‚æœ‰ä¸€ä¸ª MDA å¯ä»¥æ£€æµ‹ <code>StreamWriter</code> å¯¹è±¡æ²¡æœ‰æ˜¾å¼ dispose å°±ä½œä¸ºåƒåœ¾è¢«å›æ”¶çš„æƒ…å†µã€‚ä¸ºäº†åœ¨ Visual Studio ä¸­å¯ç”¨è¿™ä¸ª MDAï¼Œè¯·æ‰“å¼€ä½ çš„é¡¹ç›®ï¼Œé€‰æ‹© â€œè°ƒè¯• â€œ|â€ å¼‚å¸¸â€ã€‚åœ¨ â€œå¼‚å¸¸â€ å¯¹è¯æ¡†ä¸­ï¼Œå±•å¼€ â€œManaged Debugging Assistantsâ€ èŠ‚ç‚¹å¹¶æ»šåŠ¨åˆ°åº•éƒ¨ï¼Œæ‰¾åˆ°åä¸º <code>StreamWriterBufferedDataLost</code> çš„ MDAï¼Œå‹¾é€‰ â€œå¼•å‘â€ å³å¯è®© Visual Studio è°ƒè¯•å™¨åœ¨ <code>StreamWriter</code> å¯¹è±¡çš„æ•°æ®ä¸¢å¤±æ—¶åœæ­¢ã€‚</p><h3 id="other-gc-features-for-use-with-native-resources"><a class="anchor" href="#other-gc-features-for-use-with-native-resources">#</a> Other GC Features for Use with Native Resources</h3><blockquote><p>Sometimes, a native resource consumes a lot of memory, but the managed object wrapping that resource occupies very little memory. The quintessential example of this is the bitmap. A bitmap can occupy several megabytes of native memory, but the managed object is tiny because it contains only an HBITMAP (a 4-byte or 8-byte value). From the CLRâ€™s perspective, a process could allocate hundreds of bitmaps (using little managed memory) before performing a collection. But if the process is manipulating many bitmaps, the processâ€™s memory consumption will grow at a phenomenal rate. To fix this situation, the GC class offers the following two static methods.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">AddMemoryPressure</span><span class="token punctuation">(</span><span class="token class-name">Int64</span> bytesAllocated<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">RemoveMemoryPressure</span><span class="token punctuation">(</span><span class="token class-name">Int64</span> bytesAllocated<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>A class that wraps a potentially large native resource should use these methods to give the garbage collector a hint as to how much memory is really being consumed. Internally, the garbage collector monitors this pressure, and when it gets high, a garbage collection is forced.</p></blockquote><blockquote><p>There are some native resources that are fixed in number. For example, Windows formerly had a restriction that it could create only five device contexts. There had also been a restriction on the number of files that an application could open. Again, from the CLRâ€™s perspective, a process could allocate hundreds of objects (that use little memory) before performing a collection. But if the number of these native resources is limited, attempting to use more than are available will typically result in exceptions being thrown.</p></blockquote><blockquote><p>To fix this situation, the System.Runtime.InteropServices namespace offers the HandleCollector class.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">HandleCollector</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token function">HandleCollector</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">Int32</span> initialThreshold<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token function">HandleCollector</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">Int32</span> initialThreshold<span class="token punctuation">,</span> <span class="token class-name">Int32</span> maximumThreshold<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> Count <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> InitialThreshold <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> MaximumThreshold <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">String</span> Name <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>A class that wraps a native resource that has a limited quantity available should use an instance of this class to give the garbage collector a hint as to how many instances of the resource are really being consumed. Internally, this class object monitors the count, and when it gets high, a garbage collection is forced.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šåœ¨å†…éƒ¨ï¼Œ <code>GC.AddMemoryPressure</code> å’Œ <code>HandleCollector.Add</code> æ–¹æ³•ä¼šè°ƒç”¨ <code>GC.Collect</code> ï¼Œåœ¨ç¬¬ 0 ä»£è¶…è¿‡é¢„ç®—å‰å¼ºåˆ¶è¿›è¡Œ GCã€‚ä¸€èˆ¬éƒ½å¼ºçƒˆåå¯¹å¼ºåˆ¶å¼€å§‹ä¸€æ¬¡åƒåœ¾å›æ”¶ï¼Œå› ä¸ºå®ƒä¼šå¯¹åº”ç”¨ç¨‹åºæ€§èƒ½é€ æˆè´Ÿé¢å½±å“ã€‚ä½†æ˜¯ï¼Œç±»ä¹‹æ‰€ä»¥è°ƒç”¨è¿™äº›æ–¹æ³•ï¼Œæ˜¯ä¸ºäº†ä¿è¯åº”ç”¨ç¨‹åºæ€§èƒ½é€ æˆè´Ÿé¢å½±å“ã€‚ä½†æ˜¯ï¼Œç±»ä¹‹æ‰€ä»¥è°ƒç”¨è¿™äº›æ–¹æ³•ï¼Œæ˜¯ä¸ºäº†ä¿è¯åº”ç”¨ç¨‹åºèƒ½ç”¨ä¸Šæœ‰é™çš„æœ¬æœºèµ„æºã€‚æœ¬åœ°èµ„æºç”¨å…‰äº†ï¼Œåº”ç”¨ç¨‹åºå°±ä¼šå¤±è´¥ã€‚å¯¹äºå¤§å¤šæ•°åº”ç”¨ç¨‹åºï¼Œæ€§èƒ½é­å—ä¸€äº›æŸå¤±æ€»èƒœäºå®Œå…¨æ— æ³•è¿è¡Œã€‚</p><blockquote><p>Here is some code that demonstrates the use and effect of the memory pressure methods and the HandleCollector class.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>InteropServices</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token function">MemoryPressureDemo</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0 causes infrequent GCs</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token function">MemoryPressureDemo</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 10MB causes frequent GCs</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token function">HandleCollectorDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">MemoryPressureDemo</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"MemoryPressureDemo, size=&#123;0&#125;"</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// Create a bunch of objects specifying their logical size </span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> count <span class="token operator">&lt;</span> <span class="token number">15</span><span class="token punctuation">;</span> count<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">BigNativeResource</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token comment">// For demo purposes, force everything to be cleaned-up </span></pre></td></tr><tr><td data-num="17"></td><td><pre> GC<span class="token punctuation">.</span><span class="token function">Collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">BigNativeResource</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">Int32</span> m_size<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token keyword">public</span> <span class="token function">BigNativeResource</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="22"></td><td><pre> m_size <span class="token operator">=</span> size<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token comment">// Make the GC think the object is physically bigger </span></pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>m_size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> GC<span class="token punctuation">.</span><span class="token function">AddMemoryPressure</span><span class="token punctuation">(</span>m_size<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="25"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"BigNativeResource create."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="27"></td><td><pre> <span class="token operator">~</span><span class="token function">BigNativeResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="28"></td><td><pre> <span class="token comment">// Make the GC think the object released more memory </span></pre></td></tr><tr><td data-num="29"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>m_size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> GC<span class="token punctuation">.</span><span class="token function">RemoveMemoryPressure</span><span class="token punctuation">(</span>m_size<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="30"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"BigNativeResource destroy."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="31"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="32"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="33"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">HandleCollectorDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="34"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="35"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"HandleCollectorDemo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="36"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> count <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> count<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">LimitedResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="37"></td><td><pre> <span class="token comment">// For demo purposes, force everything to be cleaned-up </span></pre></td></tr><tr><td data-num="38"></td><td><pre> GC<span class="token punctuation">.</span><span class="token function">Collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="39"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="40"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">LimitedResource</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="41"></td><td><pre> <span class="token comment">// Create a HandleCollector telling it that collections should </span></pre></td></tr><tr><td data-num="42"></td><td><pre> <span class="token comment">// occur when two or more of these objects exist in the heap </span></pre></td></tr><tr><td data-num="43"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">readonly</span> <span class="token class-name">HandleCollector</span> s_hc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">HandleCollector</span><span class="token punctuation">(</span><span class="token string">"LimitedResource"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="44"></td><td><pre> <span class="token keyword">public</span> <span class="token function">LimitedResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="45"></td><td><pre> <span class="token comment">// Tell the HandleCollector a LimitedResource has been added to the heap </span></pre></td></tr><tr><td data-num="46"></td><td><pre> s_hc<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="47"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"LimitedResource create. Count=&#123;0&#125;"</span><span class="token punctuation">,</span> s_hc<span class="token punctuation">.</span>Count<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="48"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="49"></td><td><pre> <span class="token operator">~</span><span class="token function">LimitedResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="50"></td><td><pre> <span class="token comment">// Tell the HandleCollector a LimitedResource has been removed from the heap </span></pre></td></tr><tr><td data-num="51"></td><td><pre> s_hc<span class="token punctuation">.</span><span class="token function">Remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="52"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"LimitedResource destroy. Count=&#123;0&#125;"</span><span class="token punctuation">,</span> s_hc<span class="token punctuation">.</span>Count<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="53"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="54"></td><td><pre> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="55"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>If you compile and run the preceding code, your output will be similar to the following output.</p></blockquote><pre><code class="language-cmd">MemoryPressureDemo, size=0
BigNativeResource create.
BigNativeResource create.
BigNativeResource create.
BigNativeResource create.
BigNativeResource create.
BigNativeResource create.
BigNativeResource create.
BigNativeResource create.
BigNativeResource create.
BigNativeResource create.
BigNativeResource create.
BigNativeResource create.
BigNativeResource create.
BigNativeResource create.
BigNativeResource create.
BigNativeResource destroy.
BigNativeResource destroy.
BigNativeResource destroy.
BigNativeResource destroy.
BigNativeResource destroy.
BigNativeResource destroy.
BigNativeResource destroy.
BigNativeResource destroy.
BigNativeResource destroy.
BigNativeResource destroy.
BigNativeResource destroy.
BigNativeResource destroy.
BigNativeResource destroy.
BigNativeResource destroy.
BigNativeResource destroy.
MemoryPressureDemo, size=10485760
BigNativeResource create.
BigNativeResource create.
BigNativeResource create.
BigNativeResource create.
BigNativeResource create.
BigNativeResource create.
BigNativeResource create.
BigNativeResource create.
BigNativeResource create.
BigNativeResource create.
BigNativeResource create.
BigNativeResource create.
BigNativeResource destroy.
BigNativeResource destroy.
BigNativeResource destroy.
BigNativeResource destroy.
BigNativeResource destroy.
BigNativeResource destroy.
BigNativeResource destroy.
BigNativeResource create.
BigNativeResource create.
BigNativeResource create.
BigNativeResource destroy.
BigNativeResource destroy.
BigNativeResource destroy.
BigNativeResource destroy.
BigNativeResource destroy.
BigNativeResource destroy.
BigNativeResource destroy.
BigNativeResource destroy.
HandleCollectorDemo
LimitedResource create. Count=1
LimitedResource create. Count=2
LimitedResource create. Count=3
LimitedResource destroy. Count=3
LimitedResource destroy. Count=2
LimitedResource destroy. Count=1
LimitedResource create. Count=1
LimitedResource create. Count=2
LimitedResource create. Count=3
LimitedResource destroy. Count=2
LimitedResource create. Count=3
LimitedResource destroy. Count=3
LimitedResource destroy. Count=2
LimitedResource destroy. Count=1
LimitedResource create. Count=1
LimitedResource create. Count=2
LimitedResource create. Count=3
LimitedResource destroy. Count=2
LimitedResource destroy. Count=1
LimitedResource destroy. Count=0
</code></pre><h3 id="finalization-internals"><a class="anchor" href="#finalization-internals">#</a> Finalization Internals</h3><blockquote><p>On the surface, finalization seems pretty straightforward: you create an object and its Finalize method is called when it is collected. But after you dig in, finalization is more complicated than this.</p></blockquote><blockquote><p>When an application creates a new object, the new operator allocates the memory from the heap. If the objectâ€™s type defines a Finalize method, a pointer to the object is placed on the finalization list just before the typeâ€™s instance constructor is called. The finalization list is an internal data structure controlled by the garbage collector. Each entry in the list points to an object that should have its Finalize method called before the objectâ€™s memory can be reclaimed.</p></blockquote><blockquote><p>Figure 21-13 shows a heap containing several objects. Some of these objects are reachable from application roots, and some are not. When objects C, E, F, I, and J were created, the system detected that these objectsâ€™ types defined a Finalize method and so added references to these objects to the finalization list.</p></blockquote><p><img data-src="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/image-20221127180339865-1670068866560-14.png" alt="image-20221127180339865"></p><p>ğŸ’¡æ³¨æ„ï¼šè™½ç„¶ <code>System.Object</code> å®šä¹‰äº† <code>Finalize</code> æ–¹æ³•ï¼Œä½† CLR çŸ¥é“å¿½ç•¥å®ƒã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæ„é€ ç±»å‹çš„å®ä¾‹æ—¶ï¼Œå¦‚æœè¯¥ç±»å‹çš„ <code>Finalize</code> æ–¹æ³•æ˜¯ä» <code>System.Object</code> ç»§æ‰¿çš„ï¼Œå°±ä¸è®¤ä¸ºè¿™ä¸ªå¯¹è±¡æ˜¯ â€ å¯ç»ˆç»“ â€œ çš„ã€‚ç±»å‹å¿…é¡»é‡å†™ <code>Object</code> çš„ <code>Finalize</code> æ–¹æ³•ï¼Œè¿™ä¸ªç±»å‹åŠå…¶æ´¾ç”Ÿç±»å‹çš„å¯¹è±¡æ‰è¢«è®¤ä¸ºæ˜¯â€ å¯ç»ˆç»“ â€œçš„ã€‚</p><blockquote><p>When a garbage collection occurs, objects B, E, G, H, I, and J are determined to be garbage. The garbage collector scans the finalization list looking for references to these objects. When a reference is found, the reference is removed from the finalization list and appended to the freachable queue. The freachable queue (pronounced â€œF-reachableâ€) is another of the garbage collectorâ€™s internal data structures. Each reference in the freachable queue identifies an object that is ready to have its Finalize method called. After the collection, the managed heap looks like Figure 21-14.</p></blockquote><p><img data-src="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/image-20221127180434281-1670068866560-16.png" alt="image-20221127180434281"></p><blockquote><p>In this figure, you see that the memory occupied by objects B, G, and H has been reclaimed because these objects didnâ€™t have a Finalize method. However, the memory occupied by objects E, I, and J couldnâ€™t be reclaimed because their Finalize methods havenâ€™t been called yet.</p></blockquote><blockquote><p>A special high-priority CLR thread is dedicated to calling Finalize methods. A dedicated thread is used to avoid potential thread synchronization situations that could arise if one of the applicationâ€™s normal-priority threads were used instead. When the freachable queue is empty (the usual case), this thread sleeps. But when entries appear, this thread wakes, removes each entry from the queue, and then calls each objectâ€™s Finalize method. Because of the way this thread works, you shouldnâ€™t execute any code in a Finalize method that makes any assumptions about the thread thatâ€™s executing the code. For example, avoid accessing thread-local storage in the Finalize method.</p></blockquote><blockquote><p>In the future, the CLR may use multiple finalizer threads. So you should avoid writing any code that assumes that Finalize methods will be called serially. With just one finalizer thread, there could be performance and scalability issues in the scenario in which you have multiple CPUs allocating finalizable objects but only one thread executing Finalize methodsâ€”the one thread might not be able to keep up with the allocations.</p></blockquote><blockquote><p>The interaction between the finalization list and the freachable queue is fascinating. First, Iâ€™ll tell you how the freachable queue got its name. Well, the â€œfâ€ is obvious and stands for finalization; every entry in the freachable queue is a reference to an object in the managed heap that should have its Finalize method called. But the reachable part of the name means that the objects are reachable. To put it another way, the freachable queue is considered a root, just as static fields are roots. So a reference in the freachable queue keeps the object it refers to reachable and is not garbage.</p></blockquote><blockquote><p>In short, when an object isnâ€™t reachable, the garbage collector considers the object to be garbage. Then when the garbage collector moves an objectâ€™s reference from the finalization list to the freachable queue, the object is no longer considered garbage and its memory canâ€™t be reclaimed. When an object is garbage and then not garbage, we say that the object has been resurrected.</p></blockquote><blockquote><p>As freachable objects are marked, objects referred to by their reference type fields are also marked recursively; all these objects must get resurrected in order to survive the collection. At this point, the garbage collector has finished identifying garbage. Some of the objects identified as garbage have been resurrected. The garbage collector compacts the reclaimable memory, which promotes the resurrected object to an older generation (not ideal). And now, the special finalization thread empties the freachable queue, executing each objectâ€™s Finalize method.</p></blockquote><blockquote><p>The next time the garbage collector is invoked on the older generation, it will see that the finalized objects are truly garbage because the applicationâ€™s roots donâ€™t point to it and the freachable queue no longer points to it either. The memory for the object is simply reclaimed. The important point to get from all of this is that two garbage collections are required to reclaim memory used by objects that require finalization. In reality, more than two collections will be necessary because the objects get promoted to another generation. Figure 21-15 shows what the managed heap looks like after the second garbage collection.</p></blockquote><p><img data-src="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/image-20221127180542963-1670068866560-17.png" alt="image-20221127180542963"></p><p>ğŸ’¡å°ç»“ï¼šåŒ…å«æœ¬æœºèµ„æºçš„ç±»å‹è¢« GC æ—¶ï¼Œ GC ä¼šå›æ”¶å¯¹è±¡åœ¨æ‰˜ç®¡å †ä¸­ä½¿ç”¨çš„å†…å­˜ã€‚ä½†è¿™æ ·ä¼šé€ æˆæœ¬æœºèµ„æº (GC å¯¹å®ƒä¸€æ— æ‰€çŸ¥) çš„æ³„éœ²ï¼Œè¿™å½“ç„¶æ˜¯ä¸å…è®¸çš„ã€‚æ‰€ä»¥ï¼ŒCLR æä¾›äº†ç§°ä¸ºç»ˆç»“ (finalization) çš„æœºåˆ¶ï¼Œå…è®¸å¯¹è±¡åœ¨è¢«åˆ¤å®šä¸ºåƒåœ¾ä¹‹åï¼Œä½†åœ¨å¯¹è±¡å†…å­˜è¢«å›æ”¶ä¹‹å‰æ‰§è¡Œä¸€äº›ä»£ç ã€‚ä»»ä½•åŒ…è£…äº†æœ¬æœºèµ„æº (æ–‡ä»¶ã€ç½‘ç»œè¿æ¥ã€å¥—æ¥å­—ã€äº’æ–¥ä½“) çš„ç±»å‹éƒ½æ”¯æŒç»ˆç»“ã€‚CLR åˆ¤å®šä¸€ä¸ªå¯¹è±¡ä¸å¯è¾¾æ—¶ï¼Œå¯¹è±¡å°†ç»ˆç»“å®ƒè‡ªå·±ï¼Œé‡Šæ”¾å®ƒåŒ…è£…çš„æœ¬æœºèµ„æºã€‚ä¹‹åï¼ŒGC ä¼šä»æ‰˜ç®¡å †å›æ”¶å¯¹è±¡ã€‚ç»ˆæåŸºç±» <code>System.Object</code> å®šä¹‰äº†å—ä¿æŠ¤çš„è™šæ–¹æ³• <code>Finalize</code> ã€‚åƒåœ¾å›æ”¶å™¨åˆ¤å®šå¯¹è±¡æ˜¯åƒåœ¾åï¼Œä¼šè°ƒç”¨å¯¹è±¡çš„ <code>Finalize</code> æ–¹æ³• (å¦‚æœé‡å†™)ã€‚è¢«è§†ä¸ºåƒåœ¾çš„å¯¹è±¡åœ¨åƒåœ¾å›æ”¶å®Œæ¯•åæ‰è°ƒç”¨ <code>Finalize</code> æ–¹æ³•ï¼Œæ‰€ä»¥è¿™äº›å¯¹è±¡çš„å†…å­˜ä¸æ˜¯é©¬ä¸Šè¢«å›æ”¶çš„ï¼Œå› ä¸º <code>Finalize</code> æ–¹æ³•å¯èƒ½è¦æ‰§è¡Œè®¿é—®å­—æ®µçš„ä»£ç ã€‚å¯ç»ˆç»“å¯¹è±¡åœ¨å›æ”¶æ—¶å¿…é¡»å­˜æ´»ï¼Œé€ æˆå®ƒè¢«æå‡åˆ°å¦ä¸€ä»£ï¼Œä½¿å¯¹è±¡æ´»çš„æ¯”æ­£å¸¸æ—¶é—´é•¿ã€‚è¿™å¢å¤§äº†å†…å­˜è€—ç”¨ï¼Œæ‰€ä»¥åº”å°½å¯èƒ½é¿å…ç»ˆç»“ã€‚æ›´ç³Ÿçš„æ˜¯ï¼Œå¯ç»ˆç»“å¯¹è±¡è¢«æå‡æ—¶ï¼Œå…¶å­—æ®µå¼•ç”¨çš„æ‰€æœ‰å¯¹è±¡ä¹Ÿä¼šè¢«æå‡ï¼Œå› ä¸ºå®ƒä»¬ä¹Ÿå¿…é¡»ç»§ç»­å­˜æ´»ã€‚æ‰€ä»¥ï¼Œè¦å°½é‡é¿å…ä¸ºå¼•ç”¨ç±»å‹çš„å­—æ®µå®šä¹‰å¯ç»ˆç»“å¯¹è±¡ã€‚å¦å¤–è¦æ³¨æ„ï¼Œ <code>Finalize</code> æ–¹æ³•çš„æ‰§è¡Œæ—¶é—´æ˜¯æ§åˆ¶ä¸äº†çš„ã€‚åº”ç”¨ç¨‹åºè¯·æ±‚æ›´å¤šå†…å­˜æ—¶æ‰å¯èƒ½å‘ç”Ÿ GCï¼Œè€Œåªæœ‰ GC å®Œæˆåæ‰è¿è¡Œ <code>Finalize</code> ã€‚å¦å¤–ï¼ŒCLR ä¸ä¿è¯å¤šä¸ª <code>Finalize</code> æ–¹æ³•çš„è°ƒç”¨é¡ºåºã€‚æ‰€ä»¥ï¼Œåœ¨ <code>Finalize</code> æ–¹æ³•ä¸­ä¸è¦è®¿é—®å®šä¹‰äº† <code>Finalize</code> æ–¹æ³•çš„å…¶ä»–ç±»å‹çš„å¯¹è±¡ï¼›é‚£äº›å¯¹è±¡å¯èƒ½å·²ç»ç»ˆç»“äº†ã€‚ä½†å¯ä»¥å®‰å…¨åœ°è®¿é—®å€¼ç±»å‹çš„å®ä¾‹ï¼Œæˆ–è€…è®¿é—®æ²¡æœ‰å®šä¹‰ <code>Finalize</code> æ–¹æ³•çš„å¼•ç”¨ç±»å‹çš„å¯¹è±¡ã€‚è°ƒç”¨é™æ€æ–¹æ³•ä¹Ÿè¦å½“å¿ƒï¼Œè¿™äº›æ–¹æ³•å¯èƒ½åœ¨å†…éƒ¨è®¿é—®å·²ç»ˆç»“çš„å¯¹è±¡ï¼Œå¯¼è‡´é™æ€æ–¹æ³•çš„è¡Œä¸ºå˜å¾—æ— æ³•é¢„æµ‹ã€‚CLR ç”¨ä¸€ä¸ªç‰¹æ®Šçš„ã€é«˜ä¼˜å…ˆçº§çš„ä¸“ç”¨çº¿ç¨‹è°ƒç”¨ <code>Finalize</code> æ–¹æ³•æ¥é¿å…æ­»é”ã€‚å¦‚æœ <code>Finalize</code> æ–¹æ³•æŠ›å‡ºæœªå¤„ç†çš„å¼‚å¸¸ï¼Œåˆ™è¿›ç¨‹ç»ˆæ­¢ï¼Œæ²¡åŠæ³•æ•æ‰è¯¥å¼‚å¸¸ã€‚ç»¼ä¸Šæ‰€è¿°ï¼Œ <code>Finalize</code> æ–¹æ³•é—®é¢˜è¾ƒå¤šï¼Œä½¿ç”¨é¡»è°¨æ…ã€‚è®°ä½å®ƒä»¬æ˜¯ä¸ºé‡Šæ”¾æœ¬æœºèµ„æºè€Œè®¾è®¡çš„ã€‚å¼ºçƒˆå»ºè®®ä¸è¦é‡å†™ <code>Object</code> çš„ <code>Finalize</code> æ–¹æ³•ã€‚ç›¸åï¼Œä½¿ç”¨ Microsoft åœ¨ FCL ä¸­æä¾›çš„è¾…åŠ©ç±»ã€‚åˆ›å»ºå°è£…äº†æœ¬æœºèµ„æºçš„æ‰˜ç®¡ç±»å‹æ—¶ï¼Œåº”è¯¥å…ˆä» <code>System.Runtime.InteropServices.SafeHandle</code> è¿™ä¸ªç‰¹æ®ŠåŸºç±»æ´¾ç”Ÿå‡ºä¸€ä¸ªç±»ã€‚ <code>SafeHandle</code> ç±»æœ‰ä¸¤ç‚¹éœ€è¦æ³¨æ„ã€‚å…¶ä¸€ï¼Œå®ƒæ´¾ç”Ÿè‡ª <code>CriticalFinalizerObject</code> ï¼›åè€…åœ¨ <code>System.Runtime.ConstrainedExecution</code> å‘½åç©ºé—´å®šä¹‰ã€‚CLR ä»¥ç‰¹æ®Šæ–¹å¼å¯¹å¾…è¿™ä¸ªç±»åŠå…¶æ´¾ç”Ÿç±»ã€‚é¦–æ¬¡æ„é€ ä»»ä½• <code>CriticalFinalizerObject</code> æ´¾ç”Ÿç±»å‹çš„å¯¹è±¡æ—¶ï¼ŒCLR ç«‹å³å¯¹ç»§æ‰¿å±‚æ¬¡ç»“æ„ä¸­çš„å¤šæœ‰ <code>Finalize</code> æ–¹æ³•è¿›è¡Œ JIT ç¼–è¯‘ã€‚æ„é€ å¯¹è±¡æ—¶å°±ç¼–è¯‘è¿™äº›æ–¹æ³•ï¼Œå¯ç¡®ä¿å½“å¯¹è±¡è¢«ç¡®å®šä¸ºåƒåœ¾ä¹‹åï¼Œæœ¬æœºèµ„æºè‚¯å®šä¼šå¾—ä»¥é‡Šæ”¾ã€‚ä¸å¯¹ <code>Finalize</code> æ–¹æ³•è¿›è¡Œæå‰ç¼–è¯‘ï¼Œé‚£ä¹ˆä¹Ÿè®¸èƒ½åˆ†é…å¹¶ä½¿ç”¨æœ¬æœºèµ„æºï¼Œä½†æ— æ³•ä¿è¯é‡Šæ”¾ã€‚å†…å­˜ç´§å¼ æ—¶ï¼ŒCLR å¯èƒ½æ‰¾ä¸åˆ°è¶³å¤Ÿçš„å†…å­˜æ¥ç¼–è¯‘ <code>Finalize</code> æ–¹æ³•ï¼Œè¿™ä¼šé˜»æ­¢ <code>Finalize</code> æ–¹æ³•çš„æ‰§è¡Œï¼Œé€ æˆæœ¬æœºèµ„æºæ³„éœ²ã€‚å¦å¤–ï¼Œå¦‚æœ <code>Finalize</code> æ–¹æ³•ä¸­çš„ä»£ç å¼•ç”¨äº†å¦ä¸€ä¸ªç¨‹åºé›†ä¸­çš„ç±»å‹ï¼Œä½† CLR å®šä½è¯¥ç¨‹åºé›†å¤±è´¥ï¼Œé‚£ä¹ˆèµ„æºå°†å¾—ä¸åˆ°é‡Šæ”¾ã€‚CLR æ˜¯åœ¨è°ƒç”¨äº†é <code>CriticalFinalizerObject</code> æ´¾ç”Ÿç±»å‹çš„ <code>Finalize</code> æ–¹æ³•ä¹‹åï¼Œæ‰è°ƒç”¨ <code>CriticalFinalizerObject</code> æ´¾ç”Ÿç±»å‹çš„ <code>Finalize</code> æ–¹æ³•ã€‚è¿™æ ·ï¼Œæ‰˜ç®¡èµ„æºç±»å°±å¯ä»¥åœ¨å®ƒä»¬çš„ <code>Finalize</code> æ–¹æ³•ä¸­æˆåŠŸåœ°è®¿é—® <code>CriticalFinalizerObject</code> æ´¾ç”Ÿç±»å‹çš„å¯¹è±¡ã€‚å¦‚æœ <code>AppDomain</code> è¢«ä¸€ä¸ªå®¿ä¸»åº”ç”¨ç¨‹åº (ä¾‹å¦‚ Microsoft SQL Server æˆ–è€… Microsoft <span class="exturl" data-url="aHR0cDovL0FTUC5ORVQ=">ASP.NET</span>) å¼ºè¡Œä¸­æ–­ï¼ŒCLR å°†è°ƒç”¨ <code>CriticalFinalizerObject</code> æ´¾ç”Ÿç±»å‹çš„ <code>Finalize</code> æ–¹æ³•ã€‚å®¿ä¸»åº”ç”¨ç¨‹åºä¸å†ä¿¡ä»»å®ƒå†…éƒ¨è¿è¡Œçš„æ‰˜ç®¡ä»£ç æ—¶ï¼Œä¹Ÿåˆ©ç”¨è¿™ä¸ªåŠŸèƒ½ç¡®ä¿æœ¬æœºèµ„æºå¾—ä»¥é‡Šæ”¾ã€‚å…¶äºŒï¼Œ <code>SafeHandle</code> æ˜¯æŠ½è±¡ç±»ï¼Œå¿…é¡»æœ‰å¦ä¸€ä¸ªç±»ä»è¯¥ç±»æ´¾ç”Ÿå¹¶é‡å†™å—ä¿æŠ¤çš„æ„é€ å™¨ã€æŠ½è±¡æ–¹æ³• <code>ReleaseHandle</code> ä»¥åŠæŠ½è±¡å±æ€§ <code>IsInvalid</code> çš„ <code>get</code> è®¿é—®å™¨æ–¹æ³•ã€‚å¤§å¤šæ•°æœ¬æœºèµ„æºéƒ½ç”¨å¥æŸ„ (32 ä½ç³»ç»Ÿæ˜¯ 32 ä½å€¼ï¼Œ64 ä½ç³»ç»Ÿæ˜¯ 64 ä½å€¼) è¿›è¡Œæ“ä½œã€‚æ‰€ä»¥ <code>SafeHandle</code> ç±»å®šä¹‰äº†å—ä¿æŠ¤ <code>IntPtr</code> å­—æ®µ <code>handle</code> ã€‚åœ¨ Windows ä¸­ï¼Œå¤§å¤šæ•°å€¼ä¸º 0 æˆ– -1 çš„å¥æŸ„éƒ½æ˜¯æ— æ•ˆçš„ã€‚ <code>SafeHandle</code> æ´¾ç”Ÿç±»éå¸¸æœ‰ç”¨ï¼Œå› ä¸ºå®ƒä»¬ä¿è¯æœ¬æœºèµ„æºåœ¨åƒåœ¾å›æ”¶æ—¶å¾—ä»¥é‡Šæ”¾ã€‚é™¤äº†å‰é¢è®¨è®ºè¿‡çš„åŠŸèƒ½ï¼Œ <code>SafeHandle</code> ç±»è¿˜æœ‰ä¸¤ä¸ªåŠŸèƒ½å€¼å¾—æ³¨æ„ã€‚é¦–å…ˆï¼Œä¸æœ¬æœºä»£ç äº’æ“ä½œæ—¶ï¼Œ <code>SafeHandle</code> æ´¾ç”Ÿç±»å°†è·å¾— CLR çš„ç‰¹æ®Šå¯¹å¾…ã€‚ <code>SafeHandle</code> æ´¾ç”Ÿç±»æœ€åä¸€ä¸ªå€¼å¾—æ³¨æ„çš„åŠŸèƒ½æ˜¯é˜²æ­¢æœ‰äººåˆ©ç”¨æ½œåœ¨çš„å®‰å…¨æ¼æ´ã€‚ <code>SafeHandle</code> ç±»å†…éƒ¨å®šä¹‰äº†ç§æœ‰å­—æ®µæ¥ç»´æŠ¤ä¸€ä¸ªè®¡æ•°å™¨ã€‚ä¸€æ—¦æŸä¸ª <code>SafeHandle</code> æ´¾ç”Ÿå¯¹è±¡è¢«è®¾ä¸ºæœ‰æ•ˆå¥æŸ„ï¼Œè®¡æ•°å™¨å°±è¢«è®¾ä¸º 1ã€‚æ¯æ¬¡å°† <code>SafeHandle</code> æ´¾ç”Ÿå¯¹è±¡ä½œä¸ºå®å‚ä¼ ç»™ä¸€ä¸ªæœ¬æœºæ–¹æ³• (éæ‰˜ç®¡æ–¹æ³•)ï¼ŒCLR å°±ä¼šè‡ªåŠ¨é€’å¢è®¡æ•°å™¨ã€‚ç±»ä¼¼åœ°ï¼Œå½“æœ¬æœºæ–¹æ³•è¿”å›åˆ°æ‰˜ç®¡ä»£ç æ—¶ï¼ŒCLR å°±ä¼šè‡ªåŠ¨é€’å¢è®¡æ•°å™¨ã€‚ç±»ä¼¼åœ°ï¼Œå½“æœ¬æœºæ–¹æ³•è¿”å›åˆ°æ‰˜ç®¡ä»£ç æ—¶ï¼ŒCLR è‡ªåŠ¨é€’å‡è®¡æ•°å™¨ã€‚å½“ç„¶ï¼Œå¯¹è®¡æ•°å™¨çš„æ“ä½œæ˜¯ä»¥çº¿ç¨‹å®‰å…¨çš„æ–¹å¼è¿›è¡Œçš„ã€‚é‚£ä¹ˆå®‰å…¨æ€§å¦‚ä½•å¾—ä»¥ä¿éšœï¼Ÿå½“å¦ä¸€ä¸ªçº¿ç¨‹è¯•å›¾é‡Šæ”¾ <code>SafeHandle</code> å¯¹è±¡åŒ…è£…çš„æœ¬æœºèµ„æºæ—¶ï¼ŒCLR çŸ¥é“å®ƒå®é™…ä¸Šä¸èƒ½é‡Šæ”¾èµ„æºï¼Œå› ä¸ºè¯¥èµ„æºæ­£åœ¨ç”±ä¸€ä¸ªæœ¬æœº (éæ‰˜ç®¡) å‡½æ•°ä½¿ç”¨ã€‚æœ¬æœºå‡½æ•°è¿”å›åï¼Œè®¡æ•°å™¨é€’å‡ä¸º 0ï¼Œ èµ„æºæ‰ä¼šå¾—ä»¥é‡Šæ”¾ã€‚ <code>System.Runtime.InteropServices</code> å‘½åç©ºé—´è¿˜å®šä¹‰äº†ä¸€ä¸ª <code>CriticalHandle</code> ç±»ã€‚è¯¥ç±»é™¤äº†ä¸æä¾›å¼•ç”¨è®¡æ•°å™¨åŠŸèƒ½ï¼Œå…¶ä»–æ–¹é¢ä¸ <code>SafeHandle</code> ç±»ç›¸åŒã€‚ <code>CriticalHandle</code> ç±»åŠå…¶æ´¾ç”Ÿç±»é€šè¿‡ç‰ºç‰²å®‰å…¨æ€§æ¥æ¢å–æ›´å¥½çš„æ€§èƒ½ (å› ä¸ºä¸ç”¨æ“ä½œè®¡æ•°å™¨)ã€‚å’Œ <code>SafeHandle</code> ç›¸ä¼¼ï¼Œ <code>CriticalHandle</code> ç±»ä¹Ÿæœ‰è‡ªå·±çš„å‡ ä¸ªæ´¾ç”Ÿç±»å‹ï¼Œå…¶ä¸­åŒ…æ‹¬ <code>CriticalHandleMinusOneIsInvalid</code> å’Œ <code>CriricalHandleZeroOrMinusOneIsInvalid</code> ã€‚ç”±äº Microsoft å€¾å‘äºå»ºç«‹æ›´å®‰å…¨è€Œä¸æ˜¯æ›´å¿«çš„ç³»ç»Ÿï¼Œæ‰€ä»¥ç±»åº“ä¸­æ²¡æœ‰æä¾›ä»è¿™ä¸¤ä¸ªç±»æ´¾ç”Ÿçš„ç±»å‹ã€‚è‡ªå·±å†™ç¨‹åºæ—¶ï¼Œå»ºè®®åªæœ‰åœ¨å¿…é¡»è¿½æ±‚æ€§èƒ½çš„æ—¶å€™æ‰ä½¿ç”¨æ´¾ç”Ÿè‡ª <code>CriticalHandle</code> çš„ç±»å‹ã€‚å¦‚æœé™ä½å®‰å…¨æ€§ä¸ä¼šæœ‰ä»€ä¹ˆä¸¥é‡çš„åæœï¼Œå°±é€‰æ‹©ä» <code>CriticalHandle</code> æ´¾ç”Ÿçš„ä¸€ä¸ªç±»å‹ã€‚ç±»å¦‚æœæƒ³å…è®¸ä½¿ç”¨è€…æ§åˆ¶ç±»æ‰€åŒ…è£…çš„æœ¬æœºèµ„æºçš„ç”Ÿå­˜æœŸï¼Œå°±å¿…é¡»å®ç° <code>IDisposable</code> æ¥å£ã€‚æ³¨æ„ï¼Œå¹¶éä¸€å®šè¦è°ƒç”¨ <code>Dispose</code> æ‰èƒ½ä¿è¯æœ¬æœºèµ„æºå¾—ä»¥æ¸…ç†ã€‚æœ¬æœºèµ„æºçš„æ¸…ç†æœ€ç»ˆæ€»ä¼šå‘ç”Ÿï¼Œè°ƒç”¨ <code>Dispose</code> åªæ˜¯æ§åˆ¶è¿™ä¸ªæ¸…ç†åŠ¨ä½œçš„å‘ç”Ÿæ—¶é—´ã€‚å¦å¤–ï¼Œè°ƒç”¨ <code>Dispose</code> ä¸ä¼šå°†æ‰˜ç®¡å¯¹è±¡ä»æ‰˜ç®¡å †åˆ é™¤ã€‚åªæœ‰åœ¨åƒåœ¾å›æ”¶ä¹‹åï¼Œæ‰˜ç®¡å †ä¸­çš„å†…å­˜æ‰ä¼šå¾—ä»¥å›æ”¶ã€‚è¿™æ„å‘³ç€å³ä½¿ dispose äº†æ‰˜ç®¡å¯¹è±¡è¿‡å»ç”¨è¿‡çš„ä»»ä½•æœ¬æœºèµ„æºï¼Œä¹Ÿèƒ½åœ¨æ‰˜ç®¡å¯¹è±¡ä¸Šè°ƒç”¨æ–¹æ³•ã€‚ <code>using</code> è¯­å¥åˆå§‹åŒ–ä¸€ä¸ªå¯¹è±¡ï¼Œå¹¶å°†å®ƒçš„å¼•ç”¨ä¿å­˜åˆ°ä¸€ä¸ªå˜é‡ä¸­ã€‚ç„¶åå† <code>using</code> è¯­å¥çš„å¤§æ‹¬å·å†…è®¿é—®è¯¥å˜é‡ã€‚ç¼–è¯‘è¿™æ®µä»£ç æ—¶ï¼Œç¼–è¯‘å™¨è‡ªåŠ¨ç”Ÿæˆ <code>try</code> å—å’Œ <code>finally</code> å—ã€‚åœ¨ <code>finally</code> å—ä¸­ï¼Œç¼–è¯‘å™¨ç”Ÿæˆä»£ç å°†å˜é‡è½¬å‹ä¸ºä¸€ä¸ª <code>IDisposable</code> å¹¶è°ƒç”¨ <code>Dispose</code> æ–¹æ³•ã€‚ä½†æ˜¯å¾ˆæ˜¾ç„¶ï¼Œ <code>using</code> è¯­å¥åªèƒ½ç”¨äºé‚£äº›å®ç°äº† <code>IDisposable</code> æ¥å£çš„ç±»å‹ã€‚ <code>StreamWriter</code> ç±»å‹ä¸æ”¯æŒç»ˆç»“ï¼Œæ‰€ä»¥æ°¸è¿œä¸ä¼šå°†å®ƒçš„ç¼“å†²åŒºä¸­çš„æ•°æ® flush åˆ°åº•å±‚ <code>FileStream</code> å¯¹è±¡ã€‚è¿™æ„å‘³ç€å¦‚æœå¿˜è®°åœ¨ <code>StreamWriter</code> å¯¹è±¡ä¸Šæ˜¾å¼è°ƒç”¨ <code>Dispose</code> ï¼Œæ•°æ®è‚¯å®šä¼šä¸¢å¤±ã€‚Microsoft å¸Œæœ›å¼€å‘äººå‘˜æ³¨æ„åˆ°è¿™ä¸ªæ•°æ®ä¸€ç›´ä¸¢å¤±çš„é—®é¢˜ï¼Œå¹¶æ’å…¥å¯¹ <code>Dispose</code> çš„è°ƒç”¨æ¥ä¿®æ­£ä»£ç ã€‚åº”ç”¨ç¨‹åºåˆ›å»ºæ–°å¯¹è±¡æ—¶ï¼Œ <code>new</code> æ“ä½œç¬¦ä¼šä»å †ä¸­åˆ†é…å†…å­˜ã€‚å¦‚æœå¯¹è±¡çš„ç±»å‹å®šä¹‰äº† <code>Finalize</code> æ–¹æ³•ï¼Œé‚£ä¹ˆåœ¨è¯¥ç±»å‹çš„å®ä¾‹æ„é€ å™¨è¢«è°ƒç”¨ä¹‹å‰ï¼Œä¼šå°†æŒ‡å‘è¯¥å¯¹è±¡çš„æŒ‡é’ˆæ”¾åˆ°ä¸€ä¸ªç»ˆç»“åˆ—è¡¨ (finalization list) ä¸­ã€‚ç»ˆç»“åˆ—è¡¨æ˜¯ç”±åƒåœ¾å›æ”¶å™¨æ§åˆ¶çš„ä¸€ä¸ªå†…éƒ¨æ•°æ®ç»“æ„ã€‚åˆ—è¡¨ä¸­çš„æ¯ä¸€é¡¹éƒ½æŒ‡å‘ä¸€ä¸ªå¯¹è±¡ â€”â€”â€”â€” å›æ”¶è¯¥å¯¹è±¡çš„å†…å­˜å‰åº”è°ƒç”¨å®ƒçš„ <code>Finalize</code> æ–¹æ³•ã€‚freachable é˜Ÿåˆ— (å‘éŸ³æ˜¯ â€œF-reachableâ€) ä¹Ÿæ˜¯åƒåœ¾å›æ”¶å™¨çš„ä¸€ç§å†…éƒ¨æ•°æ®ç»“æ„ã€‚ä¸€ä¸ªç‰¹æ®Šçš„é«˜ä¼˜å…ˆçº§ CLR çº¿ç¨‹ä¸“é—¨è°ƒç”¨ <code>Finalize</code> æ–¹æ³•ã€‚ä¸“ç”¨çº¿ç¨‹å¯é¿å…æ½œåœ¨çš„çº¿ç¨‹åŒæ­¥é—®é¢˜ã€‚(ä½¿ç”¨åº”ç”¨ç¨‹åºçš„æ™®é€šä¼˜å…ˆçº§çº¿ç¨‹å°±å¯èƒ½å‘ç”Ÿè¿™ä¸ªé—®é¢˜ã€‚) freachable é˜Ÿåˆ—ä¸ºç©ºæ—¶ (è¿™å¾ˆå¸¸è§)ï¼Œè¯¥çº¿ç¨‹å°†ç¡çœ ã€‚ä½†ä¸€æ—¦é˜Ÿåˆ—ä¸­æœ‰è®°å½•é¡¹å‡ºç°ï¼Œçº¿ç¨‹å°±ä¼šè¢«å”¤é†’ï¼Œå°†æ¯ä¸€é¡¹éƒ½ä» freachable é˜Ÿåˆ—ä¸­ç§»é™¤ï¼ŒåŒæ—¶è°ƒç”¨æ¯ä¸ªå¯¹è±¡çš„ <code>Finalize</code> æ–¹æ³•ã€‚ç”±äºè¯¥çº¿ç¨‹çš„ç‰¹æ®Šå·¥ä½œæ–¹å¼ï¼Œ <code>Finalize</code> ä¸­çš„ä»£ç ä¸åº”è¯¥å¯¹æ‰§è¡Œä»£ç åšå‡ºä»»ä½•å‡è®¾ã€‚ä¾‹å¦‚ï¼Œä¸è¦åœ¨ <code>Finalize</code> æ–¹æ³•ä¸­è®¿é—®çº¿ç¨‹çš„æœ¬åœ°å­˜å‚¨ã€‚CLR æœªæ¥å¯èƒ½ä½¿ç”¨å¤šä¸ªç»ˆç»“å™¨çº¿ç¨‹ã€‚æ‰€ä»¥ï¼Œä»£ç ä¸åº”å‡è®¾ <code>Finalize</code> æ–¹æ³•ä¼šè¢«è¿ç»­è°ƒç”¨ã€‚ç»ˆç»“åˆ—è¡¨å’Œ freachable é˜Ÿåˆ—ä¹‹é—´çš„äº¤äº’å¾ˆæœ‰æ„æ€ã€‚é¦–å…ˆï¼Œè®©æˆ‘å‘Šè¯‰ä½  freachable é˜Ÿåˆ—è¿™ä¸ªåç§°çš„ç”±æ¥ã€‚â€œfâ€ æ˜æ˜¾ä»£è¡¨ â€œç»ˆç»“â€(finalization)ï¼›freachable é˜Ÿåˆ—ä¸­çš„æ¯ä¸ªè®°å½•é¡¹éƒ½æ˜¯å¯¹æ‰˜ç®¡å †ä¸­åº”ç”¨è°ƒç”¨å…¶ <code>Finalize</code> æ–¹æ³•çš„ä¸€ä¸ªå¯¹è±¡çš„å¼•ç”¨ã€‚â€œreachableâ€ æ„å‘³ç€å¯¹è±¡æ˜¯å¯è¾¾çš„ã€‚æ¢è¨€ä¹‹ï¼Œå¯å°† freachable é˜Ÿåˆ—çœ‹æˆæ˜¯åƒé™æ€å­—æ®µé‚£æ ·çš„ä¸€ä¸ªæ ¹ã€‚æ‰€ä»¥ï¼Œfreachable é˜Ÿåˆ—ä¸­çš„å¼•ç”¨ä½¿å®ƒæŒ‡å‘çš„å¯¹è±¡ä¿æŒå¯è¾¾ï¼Œä¸æ˜¯åƒåœ¾ã€‚ç®€å•åœ°è¯´ï¼Œå½“ä¸€ä¸ªå¯¹è±¡ä¸å¯è¾¾æ—¶ï¼Œåƒåœ¾å›æ”¶å™¨å°±æŠŠå®ƒè§†ä¸ºåƒåœ¾ã€‚ä½†æ˜¯ï¼Œå½“åƒåœ¾å›æ”¶å™¨å°†å¯¹è±¡çš„å¼•ç”¨ä»ç»ˆç»“åˆ—è¡¨ç§»è‡³ freachable é˜Ÿåˆ—æ—¶ï¼Œå¯¹è±¡ä¸å†è¢«è®¤ä¸ºæ˜¯åƒåœ¾ï¼Œä¸èƒ½å›æ”¶å®ƒçš„å†…å­˜ã€‚å¯¹è±¡è¢«è§†ä¸ºåƒåœ¾åˆå˜å¾—ä¸æ˜¯åƒåœ¾ï¼Œæˆ‘ä»¬è¯´å¯¹è±¡è¢«å¤æ´»äº†ã€‚æ ‡è®° freachable å¯¹è±¡æ—¶ï¼Œå°†é€’å½’æ ‡è®°å¯¹è±¡ä¸­çš„å¼•ç”¨ç±»å‹çš„å­—æ®µæ‰€å¼•ç”¨çš„å¯¹è±¡ï¼›æ‰€æœ‰è¿™äº›å¯¹è±¡ä¹Ÿå¿…é¡»å¤æ´»ä»¥ä¾¿åœ¨å›æ”¶è¿‡ç¨‹ä¸­å­˜æ´»ã€‚ä¸‹æ¬¡å¯¹è€ä¸€ä»£è¿›è¡Œåƒåœ¾å›æ”¶æ—¶ï¼Œä¼šå‘ç°å·²ç»ˆç»“çš„å¯¹è±¡æˆä¸ºçœŸæ­£çš„åƒåœ¾ï¼Œå› ä¸ºæ²¡æœ‰åº”ç”¨ç¨‹åºçš„æ ¹æŒ‡å‘å®ƒä»¬ï¼Œfreachable é˜Ÿåˆ—ä¹Ÿä¸å†æŒ‡å‘å®ƒä»¬ã€‚æ‰€ä»¥ï¼Œè¿™äº›å¯¹è±¡çš„å†…å­˜ä¼šç›´æ¥å›æ”¶ã€‚æ•´ä¸ªè¿‡ç¨‹ä¸­ï¼Œæ³¨æ„ï¼Œå¯ç»ˆç»“å¯¹è±¡éœ€è¦æ‰§è¡Œä¸¤æ¬¡åƒåœ¾å›æ”¶æ‰èƒ½é‡Šæ”¾å®ƒä»¬å ç”¨çš„å†…å­˜ã€‚åœ¨å®é™…åº”ç”¨ä¸­ï¼Œç”±äºå¯¹è±¡å¯èƒ½è¢«æå‡è‡³å¦ä¸€ä»£ï¼Œæ‰€ä»¥å¯èƒ½è¦æ±‚ä¸æ­¢è¿›è¡Œä¸¤æ¬¡åƒåœ¾å›æ”¶ã€‚</p><h2 id="monitoring-and-controlling-the-lifetime-of-objects-manually"><a class="anchor" href="#monitoring-and-controlling-the-lifetime-of-objects-manually">#</a> Monitoring and Controlling the Lifetime of Objects Manually</h2><blockquote><p>The CLR provides each AppDomain with a GC handle table. This table allows an application to monitor the lifetime of an object or manually control the lifetime of an object. When an AppDomain is created, the table is empty. Each entry on the table consists of a reference to an object on the managed heap and a flag indicating how you want to monitor or control the object. An application adds and removes entries from the table via the System.Runtime.InteropServices.GCHandle type, as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// This type is defined in the System.Runtime.InteropServices namespace </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">struct</span> <span class="token class-name">GCHandle</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// Static methods that create an entry in the table </span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">GCHandle</span> <span class="token function">Alloc</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span></span> <span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">GCHandle</span> <span class="token function">Alloc</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span></span> <span class="token keyword">value</span><span class="token punctuation">,</span> <span class="token class-name">GCHandleType</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Static methods that convert a GCHandle to an IntPtr </span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">explicit</span> <span class="token keyword">operator</span> <span class="token function">IntPtr</span><span class="token punctuation">(</span><span class="token class-name">GCHandle</span> <span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">IntPtr</span> <span class="token function">ToIntPtr</span><span class="token punctuation">(</span><span class="token class-name">GCHandle</span> <span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// Static methods that convert an IntPtr to a GCHandle </span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">explicit</span> <span class="token keyword">operator</span> <span class="token function">GCHandle</span><span class="token punctuation">(</span><span class="token class-name">IntPtr</span> <span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">GCHandle</span> <span class="token function">FromIntPtr</span><span class="token punctuation">(</span><span class="token class-name">IntPtr</span> <span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// Static methods that compare two GCHandles </span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> Boolean <span class="token keyword">operator</span> <span class="token operator">==</span><span class="token punctuation">(</span><span class="token class-name">GCHandle</span> a<span class="token punctuation">,</span> <span class="token class-name">GCHandle</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> Boolean <span class="token keyword">operator</span> <span class="token operator">!=</span><span class="token punctuation">(</span><span class="token class-name">GCHandle</span> a<span class="token punctuation">,</span> <span class="token class-name">GCHandle</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token comment">// Instance method to free the entry in the table (index is set to 0) </span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Free</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token comment">// Instance property to get/set the entry's object reference </span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">object</span></span> Target <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token comment">// Instance property that returns true if index is not 0 </span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Boolean</span> IsAllocated <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token comment">// For a pinned entry, this returns the address of the object </span></pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">IntPtr</span> <span class="token function">AddrOfPinnedObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name">Int32</span> <span class="token function">GetHashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name">Boolean</span> <span class="token function">Equals</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span></span> o<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Basically, to control or monitor an objectâ€™s lifetime, you call GCHandleâ€™s static Alloc method, passing a reference to the object that you want to monitor/control, and a GCHandleType, which is a flag indicating how you want to monitor/control the object. The GCHandleType type is an enumerated type defined as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">GCHandleType</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre> Weak <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment">// Used for monitoring an objectâ€™s existence </span></pre></td></tr><tr><td data-num="3"></td><td><pre> WeakTrackResurrection <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">// Used for monitoring an objectâ€™s existence </span></pre></td></tr><tr><td data-num="4"></td><td><pre> Normal <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token comment">// Used for controlling an objectâ€™s lifetime </span></pre></td></tr><tr><td data-num="5"></td><td><pre> Pinned <span class="token operator">=</span> <span class="token number">3</span> <span class="token comment">// Used for controlling an objectâ€™s lifetime </span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Now, hereâ€™s what each flag means:</p><ul><li><p>Weak This flag allows you to monitor the lifetime of an object. Specifically, you can detect when the garbage collector has determined this object to be unreachable from application code. Note that the objectâ€™s Finalize method may or may not have executed yet and therefore, the object may still be in memory.</p></li><li><p>WeakTrackResurrection This flag allows you to monitor the lifetime of an object. Specifically, you can detect when the garbage collector has determined that this object is unreachable from application code. Note that the objectâ€™s Finalize method (if it exists) has definitely executed, and the objectâ€™s memory has been reclaimed.</p></li><li><p>Normal This flag allows you to control the lifetime of an object. Specifically, you are telling the garbage collector that this object must remain in memory even though there may be no roots in the application that refer to this object. When a garbage collection runs, the memory for this object can be compacted (moved). The Alloc method that doesnâ€™t take a GCHandleType flag assumes that GCHandleType.Normal is specified.</p></li><li><p>Pinned This flag allows you to control the lifetime of an object. Specifically, you are telling the garbage collector that this object must remain in memory even though there might be no roots in the application that refer to this object. When a garbage collection runs, the memory for this object cannot be compacted. This is typically useful when you want to hand the address of the memory out to native code. The native code can write to this memory in the managed heap knowing that a GC will not move the object.</p></li></ul></blockquote><blockquote><p>When you call GCHandleâ€™s static Alloc method, it scans the AppDomainâ€™s GC handle table, looking for an available entry where the reference of the object you passed to Alloc is stored, and a flag is set to whatever you passed for the GCHandleType argument. Then, Alloc returns a GCHandle nstance back to you. A GCHandle is a lightweight value type that contains a single instance field, an IntPtr, which refers to the index of the entry in the table. When you want to free this entry in the GC handle table, you take the GCHandle instance and call the Free method (which also invalidates the GCHandle instance by setting its IntPtr field to zero).</p></blockquote><blockquote><p>Hereâ€™s how the garbage collector uses the GC handle table. When a garbage collection occurs:</p><ol><li>The garbage collector marks all of the reachable objects (as described at the beginning of this chapter). Then, the garbage collector scans the GC handle table; all Normal or Pinned objects are considered roots, and these objects are marked as well (including any objects that these objects refer to via their fields).</li><li>The garbage collector scans the GC handle table looking for all of the Weak entries. If a Weak entry refers to an object that isnâ€™t marked, the reference identifies an unreachable object (garbage), and the entry has its reference value changed to null.</li><li>The garbage collector scans the finalization list. If a reference in the list refers to an unmarked object, the reference identifies an unreachable object, and the reference is moved from the finalization list to the freachable queue. At this point, the object is marked because the object is now considered reachable.</li><li>The garbage collector scans the GC handle table looking for all of the WeakTrackResurrection entries. If a WeakTrackResurrection entry refers to an object that isnâ€™t marked (which now is an object referenced by an entry in the freachable queue), the reference identifies an unreachable object (garbage), and the entry has its reference value changed to null.</li><li>The garbage collector compacts the memory, squeezing out the holes left by the unreachable objects. Pinned objects are not compacted (moved); the garbage collector will move other objects around them.</li></ol></blockquote><blockquote><p>Now that you have an understanding of the mechanism, letâ€™s take a look at when youâ€™d use them. The easiest flags to understand are the Normal and Pinned flags, so letâ€™s start with these two. Both of these flags are typically used when interoperating with native code.</p></blockquote><blockquote><p>The Normal flag is used when you need to hand a pointer to a managed object to native code because, at some point in the future, the native code is going to call back into managed code, passing it the pointer. You canâ€™t actually pass a pointer to a managed object out to native code, because if a garbage collection occurs, the object could move in memory, invalidating the pointer. So to work around this, you would call GCHandleâ€™s Alloc method, passing in a reference to the object and the Normal flag. Then youâ€™d cast the returned GCHandle instance to an IntPtr and pass the IntPtr into the native code. When the native code calls back into managed code, the managed code would cast the passed IntPtr back to a GCHandle and then query the Target property to get the reference (or current address) of the managed object. When the native code no longer needs the reference, youâ€™d call GCHandleâ€™s Free method, which allows a future garbage collection to free the object (assuming no other root exists to this object).</p></blockquote><blockquote><p>Notice that in this scenario, the native code is not actually using the managed object itself; the native code wants a way just to reference the object. In some scenarios, the native code needs to actually use the managed object. In these scenarios, the managed object must be pinned. Pinning prevents the garbage collector from moving/compacting the object. A common example is when you want to pass a managed String object to a Win32 function. In this case, the String object must be pinned because you canâ€™t pass the reference of a managed object to native code and then have the garbage collector move the object in memory. If the String object were moved, the native code would either be reading or writing to memory that no longer contained the String objectâ€™s charactersâ€”this will surely cause the application to run unpredictably.</p></blockquote><blockquote><p>When you use the CLRâ€™s P/Invoke mechanism to call a method, the CLR pins the arguments for you automatically and unpins them when the native method returns. So, in most cases, you never have to use the GCHandle type to explicitly pin any managed objects yourself. You do have to use the GCHandle type explicitly when you need to pass the pointer to a managed object to native code; then the native function returns, but native code might still need to use the object later. The most common example of this is when performing asynchronous I/O operations.</p></blockquote><blockquote><p>Letâ€™s say that you allocate a byte array that should be filled as data comes in from a socket. Then, you would call GCHandleâ€™s Alloc method, passing in a reference to the array object and the Pinned flag. Then, using the returned GCHandle instance, you call the AddrOfPinnedObject method. This returns an IntPtr that is the actual address of the pinned object in the managed heap; youâ€™d then pass this address into the native function, which will return back to managed code immediately. While the data is coming from the socket, this byte array buffer should not move in memory; preventing this buffer from moving is accomplished by using the Pinned flag. When the asynchronous I/O operation has completed, youâ€™d call GCHandleâ€™s Free method, which will allow a future garbage collection to move the buffer. Your managed code should still have a reference to the buffer so that you can access the data, and this reference will prevent a garbage collection from freeing the buffer from memory completely.</p></blockquote><blockquote><p>It is also worth mentioning that C# offers a fixed statement that effectively pins an object over a block of code. Here is some code that demonstrates its use.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">unsafe</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Go</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Allocate a bunch of objects that immediately become garbage</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">IntPtr</span> originalMemoryAddress<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token class-name">Byte<span class="token punctuation">[</span><span class="token punctuation">]</span></span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Byte</span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Allocate this array after the garbage objects</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Get the address in memory of the Byte[]</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">fixed</span> <span class="token punctuation">(</span>Byte<span class="token operator">*</span> pbytes <span class="token operator">=</span> bytes<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> originalMemoryAddress <span class="token operator">=</span> <span class="token punctuation">(</span>IntPtr<span class="token punctuation">)</span> pbytes<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Force a collection; the garbage objects will go away &amp; the Byte[] might be compacted</span></pre></td></tr><tr><td data-num="9"></td><td><pre> GC<span class="token punctuation">.</span><span class="token function">Collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// Get the address in memory of the Byte[] now &amp; compare it to the first address</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">fixed</span> <span class="token punctuation">(</span>Byte<span class="token operator">*</span> pbytes <span class="token operator">=</span> bytes<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"The Byte[] did&#123;0&#125; move during the GC"</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token punctuation">(</span>originalMemoryAddress <span class="token operator">==</span> <span class="token punctuation">(</span>IntPtr<span class="token punctuation">)</span> pbytes<span class="token punctuation">)</span> <span class="token punctuation">?</span> <span class="token string">" not"</span> <span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Using C#â€™s fixed statement is more efficient that allocating a pinned GC handle. What happens is that the C# compiler emits a special â€œpinnedâ€ flag on the pbytes local variable. During a garbage collection, the GC examines the contents of this root, and if the root is not null, it knows not to move the object referred to by the variable during the compaction phase. The C# compiler emits IL to initialize the pbytes local variable to the address of the object at the start of a fixed block, and the compiler emits an IL instruction to set the pbytes local variable back to null at the end of the fixed block so that the variable doesnâ€™t refer to any object, allowing the object to move when the next garbage collection occurs.</p></blockquote><blockquote><p>Now, letâ€™s talk about the next two flags, Weak and WeakTrackResurrection. These two flags can be used in scenarios when interoperating with native code, but they can also be used in scenarios that use only managed code. The Weak flag lets you know when an object has been determined to be garbage but the objectâ€™s memory is not guaranteed to be reclaimed yet. The WeakTrackResurrection flag lets you know when an objectâ€™s memory has been reclaimed. Of the two flags, the Weak flag is much more commonly used than the WeakTrackResurrection flag. In fact, Iâ€™ve never seen anyone use the WeakTrackResurrection flag in a real application.</p></blockquote><blockquote><p>Letâ€™s say that Object-A periodically calls a method on Object-B. However, the fact that Object-A has a reference to Object-B forbids Object-B from being garbage collected, and in some rare scenarios, this may not be desired; instead, we might want Object-A to call Object-Bâ€™s method if Object-B is still alive in the managed heap. To accomplish this scenario, Object-A would call GCHandleâ€™s Alloc method, passing in the reference to Object-B and the Weak flag. Object-A would now just save the returned GCHandle instance instead of the reference to Object-B.</p></blockquote><blockquote><p>At this point, Object-B can be garbage collected if no other roots are keeping it alive. When Object-A wants to call Object-Bâ€™s method, it would query GCHandleâ€™s read-only Target property. If this property returns a non-null value, then Object-B is still alive. Object-Aâ€™s code would then cast the returned reference to Object-Bâ€™s type and call the method. If the Target property returns null, then Object-B has been collected (but not necessarily finalized) and Object-A would not attempt to call the method. At this point, Object-Aâ€™s code would probably also call GCHandleâ€™s Free method to relinquish the GCHandle instance.</p></blockquote><blockquote><p>Because working with the GCHandle type can be a bit cumbersome and because it requires elevated security to keep or pin an object in memory, the System namespace includes a WeakReference class to help you.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">WeakReference<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">ISerializable</span></span> <span class="token keyword">where</span> <span class="token class-name">T</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token keyword">class</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token function">WeakReference</span><span class="token punctuation">(</span><span class="token class-name">T</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token function">WeakReference</span><span class="token punctuation">(</span><span class="token class-name">T</span> target<span class="token punctuation">,</span> <span class="token class-name">Boolean</span> trackResurrection<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SetTarget</span><span class="token punctuation">(</span><span class="token class-name">T</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Boolean</span> <span class="token function">TryGetTarget</span><span class="token punctuation">(</span><span class="token keyword">out</span> <span class="token class-name">T</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>This class is really just an object-oriented wrapper around a GCHandle instance: logically, its constructor calls GCHandleâ€™s Alloc, its TryGetTarget method queries GCHandleâ€™s Target property, its SetTarget method sets GCHandleâ€™s Target property, and its Finalize method (not shown in the preceding code, because itâ€™s protected) calls GCHandleâ€™s Free method. In addition, no special permissions are required for code to use the WeakReference class because the class supports only weak references; it doesnâ€™t support the behavior provided by GCHandle instances allocated with a GCHandleType of Normal or Pinned. The downside of the WeakReference class is that an instance of it must be allocated on the heap. So the WeakReference class is a heavier-weight object than a GCHandle instance.</p></blockquote><p>ğŸ’¡é‡è¦æç¤ºï¼šå¼€å‘äººå‘˜åˆšå¼€å§‹å­¦ä¹ å¼±å¼•ç”¨æ—¶ï¼Œä¼šé©¬ä¸Šæƒ³åˆ°å®ƒä»¬åœ¨ç¼“å­˜æƒ…å½¢ä¸­çš„ç”¨å¤„ã€‚ä¾‹å¦‚ï¼Œä»–ä»¬ä¼šæƒ³åˆ°æ„é€ åŒ…å«å¤§é‡æ•°æ®çš„ä¸€ç»„å¯¹è±¡ï¼Œå¹¶åˆ›å»ºå¯¹è¿™äº›å¯¹è±¡çš„å¼±å¼•ç”¨ã€‚ç¨‹åºéœ€è¦æ•°æ®æ—¶æ£€æŸ¥è¿™äº›å¼±å¼•ç”¨ã€‚ç¨‹åºéœ€è¦æ•°æ®æ—¶å°±æ£€æŸ¥è¿™äº›å¼±å¼•ç”¨ï¼Œçœ‹çœ‹åŒ…å«è¿™äº›æ•°æ®çš„å¯¹è±¡æ˜¯å¦ä¾ç„¶ â€œå¥åœ¨â€ã€‚å¯¹è±¡è¿˜åœ¨ï¼Œç¨‹åºå°±ç›´æ¥ä½¿ç”¨å¯¹è±¡ï¼›è¿™æ ·ç¨‹åºå°±ä¼šæœ‰è¾ƒå¥½çš„æ€§èƒ½ã€‚ä½†å¦‚æœå‘ç”Ÿåƒåœ¾å›æ”¶ï¼ŒåŒ…å«æ•°æ®çš„å¯¹è±¡å°±ä¼šè¢«é”€æ¯ã€‚è€Œä¸€æ—¦éœ€è¦é‡æ–°åˆ›å»ºæ•°æ®ï¼Œç¨‹åºçš„æ€§èƒ½å°±ä¼šå—åˆ°å½±å“ã€‚</p><p>è¿™ä¸ªæŠ€æœ¯çš„é—®é¢˜åœ¨äºï¼šåƒåœ¾å›æ”¶ä¸æ˜¯åœ¨å†…å­˜æ»¡æˆ–æ¥è¿‘æ»¡æ—¶æ‰å‘ç”Ÿçš„ã€‚ç›¸åï¼Œåªè¦ç¬¬ 0 ä»£æ»¡äº†ï¼Œåƒåœ¾å›æ”¶å°±ä¼šå‘ç”Ÿã€‚å¤šä»¥ï¼Œå¯¹è±¡åœ¨å†…å­˜ä¸­è¢«æŠ›å¼ƒçš„é¢‘ç‡æ¯”é¢„æƒ³çš„é«˜å¾—å¤šï¼Œåº”ç”¨ç¨‹åºçš„æ€§èƒ½å°†å¤§æ‰“æŠ˜æ‰£ã€‚</p><p>å¼±å¼•ç”¨åœ¨ç¼“å­˜æƒ…å½¢ä¸­ç¡®å®èƒ½å¾—åˆ°é«˜æ•ˆåº”ç”¨ã€‚ä½†æ„å»ºè‰¯å¥½çš„ç¼“å­˜ç®—æ³•æ¥æ‰¾åˆ°å†…å­˜æ¶ˆè€—ä¸é€Ÿåº¦ä¹‹é—´çš„å¹³è¡¡ç‚¹ååˆ†å¤æ‚ã€‚ç®€å•åœ°è¯´ï¼Œä½ å¸Œæœ›ç¼“å­˜ä¿æŒå¯¹è‡ªå·±çš„æ‰€æœ‰å¯¹è±¡çš„å¼ºå¼•ç”¨ï¼Œå†…å­˜åƒç´§å°±å¼€å§‹å°†å¼ºå¼•ç”¨è½¬æ¢ä¸ºå¼±å¼•ç”¨ã€‚ç›®å‰ï¼ŒCLR æ²¡æœ‰æä¾›ä¸€ä¸ªèƒ½å‘Šè¯‰åº”ç”¨ç¨‹åºå†…å­˜åƒç´§çš„æœºåˆ¶ã€‚ä½†å·²ç»æœ‰äººé€šè¿‡å®šæ—¶è°ƒç”¨ Win32 <code>GlobalMemoryStatusEx</code> å‡½æ•°å¹¶æ£€æŸ¥è¿”å›çš„ <code>MEMORYSTATUSEX</code> ç»“æ„çš„ <code>dwMemoryLoad</code> æˆå‘˜æˆåŠŸåšåˆ°äº†è¿™ä¸€ç‚¹ã€‚å¦‚æœè¯¥æˆå‘˜æŠ¥å‘Šå¤§äº 80 çš„å€¼ï¼Œå†…å­˜ç©ºé—´å°±å¤„äºåƒç´§çŠ¶æ€ã€‚ç„¶åå¯ä»¥å¼€å§‹å°†å¼ºå¼•ç”¨è½¬æ¢ä¸ºå¼±å¼•ç”¨ â€”â€”â€”â€” å¯ä¾æ®çš„ç®—æ³•åŒ…æ‹¬ï¼šæœ€è¿‘æœ€å°‘ä½¿ç”¨ç®—æ³• (Least-Recently Used algorithm, LRU)ã€æœ€é¢‘ç¹ä½¿ç”¨ç®—æ³• (Most-Frequently Used algorithmï¼Œ MFU) ä»¥åŠæŸä¸ªæ—¶åŸºç®—æ³• (time-base algorithm) ç­‰ã€‚</p><blockquote><p>Developers frequently want to associate a piece of data with another entity. For example, you can associate data with a thread or with an AppDomain. It is also possible to associate data with an individual object by using the System.Runtime.CompilerServices.ConditionalWeakTable class, which looks like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">ConditionalWeakTable<span class="token punctuation">&lt;</span>TKey<span class="token punctuation">,</span> TValue<span class="token punctuation">></span></span> </pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">where</span> <span class="token class-name">TKey</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token keyword">class</span></span> <span class="token keyword">where</span> <span class="token class-name">TValue</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token keyword">class</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token function">ConditionalWeakTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token class-name">TKey</span> key<span class="token punctuation">,</span> <span class="token class-name">TValue</span> <span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">TValue</span> <span class="token function">GetValue</span><span class="token punctuation">(</span><span class="token class-name">TKey</span> key<span class="token punctuation">,</span> <span class="token class-name">CreateValueCallback<span class="token punctuation">&lt;</span>TKey<span class="token punctuation">,</span> TValue<span class="token punctuation">></span></span> createValueCallback<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Boolean</span> <span class="token function">TryGetValue</span><span class="token punctuation">(</span><span class="token class-name">TKey</span> key<span class="token punctuation">,</span> <span class="token keyword">out</span> <span class="token class-name">TValue</span> <span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">TValue</span> <span class="token function">GetOrCreateValue</span><span class="token punctuation">(</span><span class="token class-name">TKey</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Boolean</span> <span class="token function">Remove</span><span class="token punctuation">(</span><span class="token class-name">TKey</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">delegate</span> <span class="token return-type class-name">TValue</span> <span class="token function">CreateValueCallback</span><span class="token punctuation">(</span><span class="token class-name">TKey</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Nested delegate definition</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>If you want to associate some arbitrary data with one or more objects, you would first create an instance of this class. Then, call the Add method, passing in a reference to some object for the key parameter and the data you want to associate with the object in the value parameter. If you attempt to add a reference to the same object more than once, the Add method throws an ArgumentException; to change the value associated with an object, you must remove the key and then add it back in with the new value. Note that this class is thread-safe so multiple threads can use it concurrently, although this means that the performance of the class is not stellar; you should test the performance of this class to see how well it works for your scenario.</p></blockquote><blockquote><p>Of course, a table object internally stores a WeakReference to the object passed in as the key; this ensures that the table doesnâ€™t forcibly keep the object alive. But what makes the ConditionalWeakTable class so special is that it guarantees that the value remains in memory as long as the object identified by the key is in memory. So this is more than a normal WeakReference because if it were, the value could be garbage collected even though the key object continued to live. The ConditionalWeakTable class could be used to implement the dependency property mechanism used by XAML. It can also be used internally by dynamic languages to dynamically associate data with objects.</p></blockquote><blockquote><p>Here is some code that demonstrates the use of the ConditionalWeakTable class. It allows you to call the GCWatch extension method on any object passing in some String tag. Then it notifies you via the console window whenever that particular object gets garbage collected.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ConditionalWeakTableDemo</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Object</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GCWatch</span><span class="token punctuation">(</span><span class="token string">"My Object created at "</span> <span class="token operator">+</span> DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> GC<span class="token punctuation">.</span><span class="token function">Collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// We will not see the GC notification here</span></pre></td></tr><tr><td data-num="5"></td><td><pre> GC<span class="token punctuation">.</span><span class="token function">KeepAlive</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Make sure the object o refers to lives up to here</span></pre></td></tr><tr><td data-num="6"></td><td><pre> o <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// The object that o refers to can die now</span></pre></td></tr><tr><td data-num="7"></td><td><pre> GC<span class="token punctuation">.</span><span class="token function">Collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// We'll see the GC notification sometime after this line</span></pre></td></tr><tr><td data-num="8"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">GCWatcher</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// NOTE: Be careful with Strings due to interning and MarshalByRefObject proxy objects</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token keyword">static</span> <span class="token class-name">ConditionalWeakTable<span class="token punctuation">&lt;</span>Object<span class="token punctuation">,</span> NotifyWhenGCd<span class="token punctuation">&lt;</span>String<span class="token punctuation">></span><span class="token punctuation">></span></span> s_cwt <span class="token operator">=</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ConditionalWeakTable<span class="token punctuation">&lt;</span>Object<span class="token punctuation">,</span> NotifyWhenGCd<span class="token punctuation">&lt;</span>String<span class="token punctuation">></span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">NotifyWhenGCd<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">T</span> m_value<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token keyword">internal</span> <span class="token function">NotifyWhenGCd</span><span class="token punctuation">(</span><span class="token class-name">T</span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> m_value <span class="token operator">=</span> <span class="token keyword">value</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> <span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> m_value<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token operator">~</span><span class="token function">NotifyWhenGCd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"GC'd: "</span> <span class="token operator">+</span> m_value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">T</span> <span class="token generic-method"><span class="token function">GCWatch</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">T</span> @<span class="token keyword">object</span><span class="token punctuation">,</span> <span class="token class-name">String</span> tag<span class="token punctuation">)</span> <span class="token keyword">where</span> <span class="token class-name">T</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token keyword">class</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre> s_cwt<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>@<span class="token keyword">object</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">NotifyWhenGCd<span class="token punctuation">&lt;</span>String<span class="token punctuation">></span></span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token keyword">return</span> @<span class="token keyword">object</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>ğŸ’¡å°ç»“ï¼šCLR ä¸ºæ¯ä¸ª AppDomain éƒ½æä¾›äº†ä¸€ä¸ª GC å¥æŸ„è¡¨ (GC Handle table)ï¼Œå…è®¸åº”ç”¨ç¨‹åºç›‘è§†æˆ–æ‰‹åŠ¨æ§åˆ¶å¯¹è±¡çš„ç”Ÿå­˜æœŸã€‚è¿™ä¸ªè¡¨åœ¨ AppDomain åˆ›å»ºä¹‹åˆæ˜¯ç©ºç™½çš„ã€‚è¡¨ä¸­æ¯ä¸ªè®°å½•é¡¹éƒ½åŒ…å«ä»¥ä¸‹ä¸¤ç§ä¿¡æ¯ï¼šå¯¹æ‰˜ç®¡å †ä¸­çš„ä¸€ä¸ªå¯¹è±¡çš„å¼•ç”¨ï¼Œä»¥åŠæŒ‡å‡ºå¦‚ä½•ç›‘è§†æˆ–æ§åˆ¶å¯¹è±¡çš„æ ‡å¿— (flag)ã€‚ç®€å•åœ°è¯´ï¼Œä¸ºäº†æ§åˆ¶æˆ–ç›‘è§†å¯¹è±¡çš„ç”Ÿå­˜æœŸï¼Œå¯è°ƒç”¨ <code>GCHandle</code> çš„é™æ€ <code>Alloc</code> æ–¹æ³•å¹¶ä¼ é€’æƒ³æ§åˆ¶ / ç›‘è§†çš„å¯¹è±¡çš„å¼•ç”¨ã€‚è¿˜å¯ä¼ é€’ä¸€ä¸ª <code>GCHandleType</code> ï¼Œè¿™å¯ä¼ é€’ä¸€ä¸ª <code>GCHandleType</code> ï¼Œè¿™æ˜¯ä¸€ä¸ªæ ‡å¿—ï¼ŒæŒ‡å®šäº†ä½ æƒ³å¦‚ä½•æ§åˆ¶ / ç›‘è§†å¯¹è±¡ã€‚ <code>GCHandle</code> çš„é™æ€ <code>Alloc</code> æ–¹æ³•åœ¨è°ƒç”¨æ—¶ä¼šæ‰«æ <code>AppDomain</code> çš„ GC å¥æŸ„è¡¨ï¼ŒæŸ¥æ‰¾ä¸€ä¸ªå¯ç”¨çš„è®°å½•é¡¹æ¥å­˜å‚¨ä¼ ç»™ <code>Alloc</code> çš„å¯¹è±¡å¼•ç”¨ï¼Œå¹¶å°†æ ‡å¿—è®¾ä¸ºä½ ä¸º <code>GCHandleType</code> å®å‚ä¼ é€’çš„å€¼ã€‚ç„¶åï¼Œ <code>Alloc</code> æ–¹æ³•è¿”å›ä¸€ä¸ª <code>GCHandle</code> å®ä¾‹ã€‚ <code>GCHandle</code> æ˜¯è½»é‡çº§çš„å€¼ç±»å‹ï¼Œå…¶ä¸­åŒ…å«ä¸€ä¸ªå®ä¾‹å­—æ®µ (ä¸€ä¸ª <code>IntPtr</code> å­—æ®µ)ï¼Œå®ƒå¼•ç”¨äº†å¥æŸ„è¡¨ä¸­çš„è®°å½•é¡¹ç´¢å¼•ã€‚è¦é‡Šæ”¾ GC å¥æŸ„è¡¨ä¸­çš„è¿™ä¸ªè®°å½•é¡¹æ—¶ï¼Œå¯ä»¥è·å– <code>GCHandle</code> å®ä¾‹ï¼Œå¹¶åœ¨è¿™ä¸ªå®ä¾‹ä¸Šè°ƒç”¨ <code>Free</code> æ–¹æ³•ã€‚ <code>Free</code> æ–¹æ³•å°† <code>IntPtr</code> å­—æ®µè®¾ä¸º 0ï¼Œä½¿å®ä¾‹å˜å¾—æ— æ•ˆã€‚åƒåœ¾å›æ”¶å™¨å¦‚ä½•ä½¿ç”¨ GC å¥æŸ„è¡¨ã€‚å½“åƒåœ¾å›æ”¶å‘ç”Ÿæ—¶ï¼Œåƒåœ¾å›æ”¶å™¨çš„è¡Œä¸ºå¦‚ä¸‹ã€‚åƒåœ¾å›æ”¶å™¨æ ‡è®°æ‰€æœ‰å¯è¾¾çš„å¯¹è±¡ (æœ¬ç« å¼€å§‹çš„æ—¶å€™å·²è¿›è¡Œäº†æè¿°)ã€‚ç„¶åï¼Œåƒåœ¾å›æ”¶å™¨æ‰«æ GC å¥æŸ„è¡¨ï¼›æ‰€æœ‰ <code>Normal</code> æˆ– <code>Pinned</code> å¯¹è±¡éƒ½è¢«çœ‹æˆæ˜¯æ ¹ï¼ŒåŒæ—¶æ ‡è®°è¿™äº›å¯¹è±¡ (åŒ…æ‹¬è¿™äº›å¯¹è±¡é€šè¿‡å®ƒä»¬çš„å­—æ®µå¼•ç”¨çš„å¯¹è±¡)ã€‚åƒåœ¾å›æ”¶å™¨æ‰«æ GC å¥æŸ„è¡¨ï¼ŒæŸ¥æ‰¾æ‰€æœ‰ <code>Weak</code> è®°å½•é¡¹ã€‚å¦‚æœä¸€ä¸ª <code>Weak</code> è®°å½•é¡¹å¼•ç”¨äº†æœªæ ‡è®°çš„å¯¹è±¡ï¼Œè¯¥å¼•ç”¨æ ‡è¯†çš„å°±æ˜¯ä¸å¯è¾¾å¯¹è±¡ (åƒåœ¾)ï¼Œè¯¥è®°å½•é¡¹çš„å¼•ç”¨å€¼æ›´æ”¹ä¸º <code>null</code> ã€‚åƒåœ¾å›æ”¶å™¨æ‰«æç»ˆç»“åˆ—è¡¨ã€‚åœ¨åˆ—è¡¨ä¸­ï¼Œå¯¹æœªæ ‡è®°å¯¹è±¡çš„å¼•ç”¨æ ‡è¯†çš„æ˜¯ä¸å¯è¾¾å¯¹è±¡ï¼Œè¿™äº›å¼•ç”¨ä»ç»ˆç»“åˆ—è¡¨ç§»è‡³ freachable é˜Ÿåˆ—ã€‚è¿™æ—¶å¯¹è±¡ä¼šè¢«æ ‡è®°ï¼Œå› ä¸ºå¯¹è±¡åˆå˜æˆå¯è¾¾äº†ã€‚åƒåœ¾å›æ”¶å™¨æ‰«æ GC å¥æŸ„è¡¨ï¼ŒæŸ¥æ‰¾æ‰€æœ‰ <code>WeakTrackResurrection</code> è®°å½•é¡¹ã€‚å¦‚æœä¸€ä¸ª <code>WeakTrackResurrection</code> è®°å½•é¡¹å¼•ç”¨äº†æœªæ ‡è®°çš„å¯¹è±¡ (å®ƒç°åœ¨æ˜¯ç”± freachable é˜Ÿåˆ—ä¸­çš„è®°å½•é¡¹å¼•ç”¨çš„)ï¼Œè¯¥å¼•ç”¨æ ‡è¯†çš„å°±æ˜¯ä¸å¯è¾¾å¯¹è±¡ (åƒåœ¾)ï¼Œè¯¥è®°å½•é¡¹çš„å¼•ç”¨å€¼æ›´æ”¹ä¸º <code>null</code> ã€‚åƒåœ¾å›æ”¶å™¨å †å†…å­˜è¿›è¡Œå‹ç¼©ï¼Œå¡«è¡¥ä¸å¯è¾¾å¯¹è±¡ç•™ä¸‹çš„å†…å­˜ â€œç©ºè°ƒâ€ï¼Œè¿™å…¶å®å°±æ˜¯ä¸€ä¸ªå†…å­˜ç¢ç‰‡æ•´ç†çš„è¿‡ç¨‹ã€‚ <code>Pinned</code> å¯¹è±¡ä¸ä¼šå‹ç¼© (ç§»åŠ¨)ï¼Œåƒåœ¾å›æ”¶å™¨ä¼šç§»åŠ¨å®ƒå‘¨å›´çš„å…¶ä»–å¯¹è±¡ã€‚ä½¿ç”¨ CLR çš„ P/Invoke æœºåˆ¶è°ƒç”¨æ–¹æ³•æ—¶ï¼ŒCLR ä¼šè‡ªåŠ¨å¸®ä½ å›ºå®šå®å‚ï¼Œå¹¶åœ¨æœ¬æœºæ–¹æ³•è¿”å›æ—¶è‡ªåŠ¨è§£é™¤å›ºå®šã€‚æ‰€ä»¥ï¼Œå¤§å¤šæ•°æ—¶å€™éƒ½ä¸å¿…ä½¿ç”¨ <code>GCHandle</code> ç±»å‹æ¥æ˜¾å¼å›ºå®šä»»ä½•æ‰˜ç®¡å¯¹è±¡ã€‚åªæœ‰åœ¨å°†æ‰˜ç®¡å¯¹è±¡çš„æŒ‡é’ˆä¼ ç»™æœ¬æœºä»£ç ï¼Œç„¶åæœ¬æœºå‡½æ•°è¿”å›ï¼Œä½†æœ¬æœºä»£ç å°†æ¥ä»éœ€ä½¿ç”¨è¯¥å¯¹è±¡æ—¶ï¼Œæ‰éœ€è¦æ˜¾å¼ä½¿ç”¨ <code>GCHandle</code> ç±»å‹ã€‚æœ€å¸¸è§çš„ä¾‹å­å°±æ˜¯æ‰§è¡Œå¼‚æ­¥ I/O æ“ä½œã€‚å‡å®šåˆ†é…äº†ä¸€ä¸ªå­—èŠ‚æ•°ç»„ï¼Œå¹¶å‡†å¤‡åœ¨å…¶ä¸­å¡«å……æ¥è‡ªä¸€ä¸ªå¥—æ¥å­—çš„æ•°æ®ã€‚è¿™æ—¶åº”è¯¥è°ƒç”¨ <code>GCHandle</code> çš„ <code>Alloc</code> æ–¹æ³•ï¼Œä¼ é€’å¯¹æ•°ç»„å¯¹è±¡çš„å¼•ç”¨ä»¥åŠ <code>Pinned</code> æ ‡å¿—ã€‚ç„¶åï¼Œåœ¨è¿”å›çš„ <code>GCHandle</code> å®ä¾‹ä¸Šè°ƒç”¨ <code>AddrOfPinnedObject</code> æ–¹æ³•ã€‚è¿™ä¼šè¿”å›ä¸€ä¸ª <code>IntPtr</code> ï¼Œå®ƒæ˜¯å·²å›ºå®šå¯¹è±¡åœ¨æ‰˜ç®¡å †ä¸­çš„å®é™…åœ°å€ã€‚ç„¶åï¼Œå°±è¯¥åœ°å€ä¼ ç»™æœ¬æœºå‡½æ•°ï¼Œè¯¥å‡½æ•°ç«‹å³è¿”å›è‡³æ‰˜ç®¡ä»£ç ã€‚æ•°æ®ä»å¥—æ¥å­—ä¼ æ¥æ—¶ï¼Œè¯¥å­—èŠ‚æ•°ç»„ç¼“å†²åŒºåœ¨å†…å­˜ä¸­ä¸ä¼šç§»åŠ¨ï¼›é˜»æ­¢ç§»åŠ¨æ˜¯ <code>Pinned</code> æ ‡å¿—çš„åŠŸåŠ³ã€‚å¼‚æ­¥ I/O æ“ä½œå®Œæ¯•åè°ƒç”¨ <code>GCHandle</code> çš„ <code>Free</code> æ–¹æ³•ï¼Œä»¥ååƒåœ¾å›æ”¶æ—¶å°±å¯ä»¥ç§»åŠ¨ç¼“å†²åŒºäº†ã€‚æ‰˜ç®¡ä»£ç åº”åŒ…å«ä¸€ä¸ªç¼“å†²åŒºå¼•ç”¨ï¼Œè¿™ä½¿ä½ èƒ½è®¿é—®æ•°æ®ã€‚æ­£æ˜¯ç”±äºè¿™ä¸ªå¼•ç”¨çš„å­˜åœ¨ï¼Œæ‰€ä»¥æ‰ä¼šé˜»æ­¢åƒåœ¾å›æ”¶ä»å†…å­˜ä¸­å½»åº•é‡Šæ”¾è¯¥ç¼“å†²åŒºã€‚ä½¿ç”¨ C# çš„ <code>fixed</code> è¯­å¥æ¯”åˆ†é…ä¸€ä¸ªå›ºå®š GC å¥æŸ„é«˜æ•ˆå¾—å¤šã€‚è¿™é‡Œå‘ç”Ÿçš„äº‹æƒ…æ˜¯ï¼ŒC# ç¼–è¯‘å™¨åœ¨å±€éƒ¨å˜é‡ä¸Šç”Ÿæˆä¸€ä¸ªç‰¹æ®Šçš„â€ å·²å›ºå®š â€œæ ‡å¿—ã€‚åƒåœ¾å›æ”¶æœŸé—´ï¼ŒGC æ£€æŸ¥è¿™ä¸ªæ ¹çš„å†…å®¹ï¼Œå¦‚æœæ ¹ä¸ä¸º <code>null</code> ï¼Œå°±çŸ¥é“åœ¨å‹ç¼©é˜¶æ®µä¸è¦ç§»åŠ¨å˜é‡å¼•ç”¨çš„å¯¹è±¡ã€‚C# ç¼–è¯‘å™¨ç”Ÿæˆ IL å°†å±€éƒ¨å˜é‡åˆå§‹åŒ–ä¸º <code>fixed</code> å—èµ·å§‹å¤„çš„å¯¹è±¡çš„åœ°å€ã€‚åœ¨ <code>fixed</code> å—çš„å°¾éƒ¨ï¼Œç¼–è¯‘å™¨è¿˜ä¼šç”Ÿæˆ IL æŒ‡ä»¤å°†å±€éƒ¨å˜é‡è®¾å› <code>null</code> ï¼Œä½¿å˜é‡ä¸å¼•ç”¨ä»»ä½•å¯¹è±¡ã€‚è¿™æ ·ä¸€æ¥ï¼Œä¸‹ä¸€æ¬¡åƒåœ¾å›æ”¶å‘ç”Ÿæ—¶ï¼Œå¯¹è±¡å°±å¯ä»¥ç§»åŠ¨äº†ã€‚ <code>Weak</code> å’Œ <code>WeakTrackResurrection</code> å®ƒä»¬æ—¢å¯ç”¨äºå’Œæœ¬æœºä»£ç çš„äº’æ“ä½œï¼Œä¹Ÿå¯åœ¨åªæœ‰æ‰˜ç®¡ä»£ç çš„æ—¶å€™ä½¿ç”¨ã€‚ <code>Weak</code> æ ‡å¿—ä½¿ä½ çŸ¥é“åœ¨ä»€ä¹ˆæ—¶å€™ä¸€ä¸ªå¯¹è±¡è¢«åˆ¤å®šä¸ºåƒåœ¾ï¼Œä½†è¿™æ—¶å¯¹è±¡çš„å†…å­˜ä¸ä¸€å®šè¢«å›æ”¶ã€‚ <code>WeakTrackResurrection</code> æ ‡å¿—ä½¿ä½ çŸ¥é“åœ¨ä»€ä¹ˆæ—¶å€™å¯¹è±¡çš„å†…å­˜å·²è¢«å›æ”¶ã€‚ä¸¤ä¸ªæ ‡å¿—ä¸­ <code>Weak</code> æ›´å¸¸ç”¨ã€‚ç”±äºä½¿ç”¨ <code>GCHandle</code> ç±»å‹æœ‰äº›ç¹çï¼Œè€Œä¸”è¦æ±‚æå‡çš„å®‰å…¨æ€§æ‰èƒ½åœ¨å†…å­˜ä¸­ä¿æŒæˆ–å›ºå®šå¯¹è±¡ï¼Œæ‰€ä»¥ <code>System</code> å‘½åç©ºé—´æä¾›äº†ä¸€ä¸ª <code>WeakReference&lt;T&gt;</code> ç±»æ¥å¸®åŠ©ä½ ã€‚è¿™ä¸ªç±»å…¶å®æ˜¯åŒ…è£…äº†ä¸€ä¸ª <code>GCHandle</code> å®ä¾‹çš„é¢å‘å¯¹è±¡åŒ…è£…å™¨ (wrapper)ï¼šé€»è¾‘ä¸Šè¯´ï¼Œå®ƒçš„æ„é€ å™¨è°ƒç”¨ <code>GCHandle</code> çš„ <code>Alloc</code> æ–¹æ³•ï¼Œ <code>TryGetTarget</code> æ–¹æ³•æŸ¥è¯¢ <code>GCHandle</code> çš„ <code>Target</code> å±æ€§ï¼Œ <code>SetTarget</code> æ–¹æ³•è®¾ç½® <code>GCHandle</code> çš„ <code>Target</code> å±æ€§ï¼Œè€Œ <code>Finalize</code> æ–¹æ³• (è¿™é‡Œæœªæ˜¾ç¤ºï¼Œå› ä¸ºæ˜¯å—ä¿æŠ¤æ–¹æ³•) åˆ™è°ƒç”¨ <code>GCHandle</code> çš„ <code>Free</code> æ–¹æ³•ã€‚æ­¤å¤–ï¼Œä»£ç æ— éœ€ç‰¹æ®Šæƒé™å³å¯ä½¿ç”¨ <code>WeakReference&lt;T&gt;</code> ç±»ï¼Œå› ä¸ºè¯¥ç±»åªæ”¯æŒå¼±å¼•ç”¨ï¼›ä¸æ”¯æŒ <code>GCHandleType</code> è®¾ä¸º <code>Normal</code> æˆ– <code>Pinned</code> çš„ <code>GCHandle</code> å®ä¾‹çš„è¡Œä¸ºã€‚ <code>WeakReference&lt;T&gt;</code> ç±»çš„ç¼ºç‚¹åœ¨äºå®ƒçš„å®ä¾‹å¿…é¡»åœ¨å †ä¸Šåˆ†é…ã€‚æ‰€ä»¥ï¼Œ <code>WeakReference</code> ç±»æ¯” <code>GCHandle</code> å®ä¾‹æ›´ â€œé‡â€ã€‚å¼€å‘äººå‘˜ç»å¸¸éœ€è¦å°†ä¸€äº›æ•°æ®å’Œå¦ä¸€ä¸ªå®ä½“å…³è”ã€‚ä¾‹å¦‚ï¼Œæ•°æ®å¯ä»¥å’Œä¸€ä¸ªçº¿ç¨‹æˆ– AppDomain å…³è”ã€‚å¦å¤–ï¼Œå¯ç”¨ <code>System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey, TValue&gt;</code> ç±»å°†æ•°æ®å’Œå•ç‹¬çš„å¯¹è±¡å…³è”ã€‚æ³¨æ„è¿™ä¸ªç±»æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œå¤šä¸ªçº¿ç¨‹èƒ½åŒæ—¶ä½¿ç”¨å®ƒ (è™½ç„¶è¿™ä¹Ÿæ„å‘³ç€ç±»çš„æ€§èƒ½å¹¶ä¸å‡ºä¼—)ï¼›åº”æµ‹è¯•å¥½è¿™ä¸ªç±»çš„æ€§èƒ½ï¼ŒéªŒè¯å®ƒåœ¨æ˜¯å¦é€‚åˆä½ çš„å®é™…ç¯å¢ƒã€‚å½“ç„¶ï¼Œè¡¨å¯¹è±¡åœ¨å†…éƒ¨å­˜å‚¨äº†å¯¹ä½œä¸º <code>key</code> ä¼ é€’çš„å¯¹è±¡çš„å¼±å¼•ç”¨ (ä¸€ä¸ª <code>WeakReference</code> å¯¹è±¡)ï¼›è¿™æ ·å¯ä¿è¯ä¸ä¼šå› ä¸ºè¡¨çš„å­˜åœ¨è€Œé€ æˆå¯¹è±¡ â€œè¢«è¿«â€ å­˜æ´»ã€‚ä½†æ˜¯ï¼Œ <code>ConditionalWeakTable</code> ç±»æœ€ç‰¹åˆ«çš„åœ°æ–¹åœ¨äºï¼Œå®ƒä¿è¯äº†åªè¦ <code>key</code> æ‰€æ ‡è¯†çš„å¯¹è±¡åœ¨å†…å­˜ä¸­ï¼Œå€¼å°±è‚¯å®šåœ¨å†…å­˜ä¸­ã€‚è¿™ä½¿å…¶è¶…è¶Šäº†ä¸€ä¸ªæ™®é€šçš„ <code>WeakReference</code> ï¼Œå› ä¸ºå¦‚æœæ˜¯æ™®é€šçš„ <code>WeakReference</code> ï¼Œé‚£ä¹ˆå³ä½¿ <code>key</code> å¯¹è±¡ä¿æŒå­˜æ´»ï¼Œå€¼å°±è‚¯å®šåœ¨å†…å­˜ä¸­ã€‚è¿™ä½¿å…¶è¶…è¶Šäº†ä¸€ä¸ªæ™®é€šçš„ <code>WeakReference</code> ï¼Œå› ä¸ºå¦‚æœæ˜¯æ™®é€šçš„ <code>WeakReference</code> ï¼Œ é‚£ä¹ˆå³ä½¿ <code>key</code> å¯¹è±¡ä¿æŒå­˜æ´»ï¼Œå€¼ä¹Ÿå¯èƒ½è¢«åƒåœ¾å›æ”¶ã€‚ <code>ConditionalWeakTable</code> ç±»å¯ç”¨äºå®ç° XAML çš„ä¾èµ–å±æ€§ (dependency property) æœºåˆ¶ã€‚åŠ¨æ€è¯­è¨€ä¹Ÿå¯åœ¨å†…éƒ¨åˆ©ç”¨å®ƒå°†æ•°æ®å’Œå¯¹è±¡åŠ¨æ€å…³è”ã€‚</p><div class="tags"><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> è¯»ä¹¦ç¬”è®°</a> <a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C#</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2022-12-05 10:30:09" itemprop="dateModified" datetime="2022-12-05T10:30:09+08:00">2022-12-05</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(ï¿£â–½ï¿£)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Sakupinera WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Sakupinera Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Sakupinera PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Sakupinera <i class="ic i-at"><em>@</em></i>Sakupinera</li><li class="link"><strong>Post link: </strong><a href="http://sakupinera.github.io/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/" title="CLR via C# - Chapter 21 The Managed Heap and Garbage  Collection">http://sakupinera.github.io/2022/11/27/csharp/clr-via-csharp/Chapter 21 The Managed Heap and Garbage Collection/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;03&#x2F;08&#x2F;jV3gF2wSUYTdtsp.jpg" title="CLR via C# - Chapter 20 Exceptions and State Management"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 20 Exceptions and State Management</h3></a></div><div class="item right"><a href="/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;03&#x2F;08&#x2F;J4XewNCOu8fzIy9.jpg" title="CLR via C# - Chapter 22 CLR Hosting and AppDomains"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 22 CLR Hosting and AppDomains</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-21-the-managed-heap-and-garbage-collection"><span class="toc-number">1.</span> <span class="toc-text">Chapter 21 The Managed Heap and Garbage Collection</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#managed-heap-basics"><span class="toc-number">1.1.</span> <span class="toc-text">Managed Heap Basics</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#allocating-resources-from-the-managed-heap"><span class="toc-number">1.1.1.</span> <span class="toc-text">Allocating Resources from the Managed Heap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#the-garbage-collection-algorithm"><span class="toc-number">1.1.2.</span> <span class="toc-text">The Garbage Collection Algorithm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#garbage-collections-and-debugging"><span class="toc-number">1.1.3.</span> <span class="toc-text">Garbage Collections and Debugging</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#generations-improving-performance"><span class="toc-number">1.2.</span> <span class="toc-text">Generations: Improving Performance</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#garbage-collection-triggers"><span class="toc-number">1.2.1.</span> <span class="toc-text">Garbage Collection Triggers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#large-objects"><span class="toc-number">1.2.2.</span> <span class="toc-text">Large Objects</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#garbage-collection-modes"><span class="toc-number">1.2.3.</span> <span class="toc-text">Garbage Collection Modes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forcing-garbage-collections"><span class="toc-number">1.2.4.</span> <span class="toc-text">Forcing Garbage Collections</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#monitoring-your-applications-memory-usage"><span class="toc-number">1.2.5.</span> <span class="toc-text">Monitoring Your Applicationâ€™s Memory Usage</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#working-with-types-requiring-special-cleanup"><span class="toc-number">1.3.</span> <span class="toc-text">Working with Types Requiring Special Cleanup</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#using-a-type-that-wraps-a-native-resource"><span class="toc-number">1.3.1.</span> <span class="toc-text">Using a Type That Wraps a Native Resource</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#an-interesting-dependency-issue"><span class="toc-number">1.3.2.</span> <span class="toc-text">An Interesting Dependency Issue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#other-gc-features-for-use-with-native-resources"><span class="toc-number">1.3.3.</span> <span class="toc-text">Other GC Features for Use with Native Resources</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finalization-internals"><span class="toc-number">1.3.4.</span> <span class="toc-text">Finalization Internals</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#monitoring-and-controlling-the-lifetime-of-objects-manually"><span class="toc-number">1.4.</span> <span class="toc-text">Monitoring and Controlling the Lifetime of Objects Manually</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"><ul><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/" rel="bookmark" title="CLR via C# - Chapter 1 The CLRâ€™s Execution Model">CLR via C# - Chapter 1 The CLRâ€™s Execution Model</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/" rel="bookmark" title="CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types">CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%203%20Shared%20Assemblies%20and%20Strongly%20Named%20Assemblies/" rel="bookmark" title="CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies">CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies</a></li><li><a href="/2022/09/27/csharp/clr-via-csharp/Chapter%204%20Type%20Fundamentals/" rel="bookmark" title="CLR via C# - Chapter 4 Type Fundamentals">CLR via C# - Chapter 4 Type Fundamentals</a></li><li><a href="/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/" rel="bookmark" title="CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals">CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals</a></li><li><a href="/2022/10/21/csharp/clr-via-csharp/Chapter%206%20Type%20and%20Member%20Basics/" rel="bookmark" title="CLR via C# - Chapter 6 Type and Member Basics">CLR via C# - Chapter 6 Type and Member Basics</a></li><li><a href="/2022/10/24/csharp/clr-via-csharp/Chapter%207%20Constants%20and%20Fields/" rel="bookmark" title="CLR via C# - Chapter 7 Constants and Fields">CLR via C# - Chapter 7 Constants and Fields</a></li><li><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" rel="bookmark" title="CLR via C# - Chapter 8 Methods">CLR via C# - Chapter 8 Methods</a></li><li><a href="/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/" rel="bookmark" title="CLR via C# - Chapter 9 Parameters">CLR via C# - Chapter 9 Parameters</a></li><li><a href="/2022/10/28/csharp/clr-via-csharp/Chapter%2010%20Properties/" rel="bookmark" title="CLR via C# - Chapter 10 Properties">CLR via C# - Chapter 10 Properties</a></li><li><a href="/2022/10/29/csharp/clr-via-csharp/Chapter%2011%20Events/" rel="bookmark" title="CLR via C# - Chapter 11 Events">CLR via C# - Chapter 11 Events</a></li><li><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" rel="bookmark" title="CLR via C# - Chapter 12 Generics">CLR via C# - Chapter 12 Generics</a></li><li><a href="/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/" rel="bookmark" title="CLR via C# - Chapter 13 Interfaces">CLR via C# - Chapter 13 Interfaces</a></li><li><a href="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/" rel="bookmark" title="CLR via C# - Chapter 14 Chars, Strings, and Working with Text">CLR via C# - Chapter 14 Chars, Strings, and Working with Text</a></li><li><a href="/2022/11/17/csharp/clr-via-csharp/Chapter%2015%20Enumerated%20Types%20and%20Bit%20Flags/" rel="bookmark" title="CLR via C# - Chapter 15 Enumerated Types and Bit Flags">CLR via C# - Chapter 15 Enumerated Types and Bit Flags</a></li><li><a href="/2022/11/19/csharp/clr-via-csharp/Chapter%2016%20Arrays/" rel="bookmark" title="CLR via C# - Chapter 16 Arrays">CLR via C# - Chapter 16 Arrays</a></li><li><a href="/2022/11/21/csharp/clr-via-csharp/Chapter%2017%20Delegates/" rel="bookmark" title="CLR via C# - Chapter 17 Delegates">CLR via C# - Chapter 17 Delegates</a></li><li><a href="/2022/11/22/csharp/clr-via-csharp/Chapter%2018%20Custom%20Attributes/" rel="bookmark" title="CLR via C# - Chapter 18 Custom Attributes">CLR via C# - Chapter 18 Custom Attributes</a></li><li><a href="/2022/11/23/csharp/clr-via-csharp/Chapter%2019%20Nullable%20Value%20Types/" rel="bookmark" title="CLR via C# - Chapter 19 Nullable Value Types">CLR via C# - Chapter 19 Nullable Value Types</a></li><li><a href="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/" rel="bookmark" title="CLR via C# - Chapter 20 Exceptions and State Management">CLR via C# - Chapter 20 Exceptions and State Management</a></li><li class="active"><a href="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/" rel="bookmark" title="CLR via C# - Chapter 21 The Managed Heap and Garbage  Collection">CLR via C# - Chapter 21 The Managed Heap and Garbage Collection</a></li><li><a href="/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/" rel="bookmark" title="CLR via C# - Chapter 22 CLR Hosting and AppDomains">CLR via C# - Chapter 22 CLR Hosting and AppDomains</a></li><li><a href="/2022/11/29/csharp/clr-via-csharp/Chapter%2023%20Assembly%20Loading%20and%20Reflection/" rel="bookmark" title="CLR via C# - Chapter 23 Assembly Loading and Reflection">CLR via C# - Chapter 23 Assembly Loading and Reflection</a></li><li><a href="/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/" rel="bookmark" title="CLR via C# - Chapter 24 Runtime Serialization">CLR via C# - Chapter 24 Runtime Serialization</a></li><li><a href="/2022/12/06/csharp/clr-via-csharp/Chapter%2025%20Interoperating%20with%20WinRT%20%20Components/" rel="bookmark" title="CLR via C# - Chapter 25 Interoperating with WinRT Components">CLR via C# - Chapter 25 Interoperating with WinRT Components</a></li><li><a href="/2023/02/06/csharp/clr-via-csharp/Chapter%2026%20Thread%20Basics/" rel="bookmark" title="CLR via C# - Chapter 26 Thread Basics">CLR via C# - Chapter 26 Thread Basics</a></li><li><a href="/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations">CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations</a></li><li><a href="/2023/02/08/csharp/clr-via-csharp/Chapter%2028%20IO-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 28 IO-Bound Asynchronous Operations">CLR via C# - Chapter 28 IO-Bound Asynchronous Operations</a></li><li><a href="/2023/02/09/csharp/clr-via-csharp/Chapter%2029%20Primitive%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 29 Primitive Thread Synchronization">CLR via C# - Chapter 29 Primitive Thread Synchronization</a></li><li><a href="/2023/02/10/csharp/clr-via-csharp/Chapter%2030%20Hybrid%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 30 Hybrid Thread Synchronization">CLR via C# - Chapter 30 Hybrid Thread Synchronization</a></li></ul></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sakupinera" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Sakupinera</p><div class="description" itemprop="description">ä¿æŒä½ çš„å†³å¿ƒï¼</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">86</span> <span class="name">posts</span></a></div><div class="item categories"><a href="/categories/"><span class="count">13</span> <span class="name">categories</span></a></div><div class="item tags"><a href="/tags/"><span class="count">6</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nha3VwaW5lcmE=" title="https:&#x2F;&#x2F;github.com&#x2F;sakupinera"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9zYWt1cGluZXJh" title="https:&#x2F;&#x2F;twitter.com&#x2F;sakupinera"><i class="ic i-twitter"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQwNzIyOTA3MQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;407229071"><i class="ic i-cloud-music"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMjIzMDczOTg/c3BtX2lkX2Zyb209MzMzLjEwMDcuMC4w" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;22307398?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li><li class="item"><a href="/games/" rel="section"><i class="ic i-flag"></i>Games</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-person"></i>About</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CSharp-in-a-Nutshell/" title="In CSharp-in-a-Nutshell">CSharp-in-a-Nutshell</a></div><span><a href="/2022/09/04/csharp/csharp-in-a-nutshell/%E7%AC%AC14%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%BC%82%E6%AD%A5/" title="C# in a Nutshell - ç¬¬14ç«  å¹¶å‘ä¸å¼‚æ­¥">C# in a Nutshell - ç¬¬14ç«  å¹¶å‘ä¸å¼‚æ­¥</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/08/28/linux/learn-linux/%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/" title="LearnLinux - è½¯ä»¶åŒ…ç®¡ç†">LearnLinux - è½¯ä»¶åŒ…ç®¡ç†</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2022/12/14/cpp/cpp-primer/Chapter%206%20Functions/" title="C++ Primer - Chapter 6 Functions">C++ Primer - Chapter 6 Functions</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2022/12/10/cpp/cpp-primer/Chapter%202%20Variables%20and%20Basic%20Types/" title="C++ Primer - Chapter 2 Variables and Basic Types">C++ Primer - Chapter 2 Variables and Basic Types</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2023/02/09/csharp/clr-via-csharp/Chapter%2029%20Primitive%20Thread%20Synchronization%20Constructs/" title="CLR via C# - Chapter 29 Primitive Thread Synchronization">CLR via C# - Chapter 29 Primitive Thread Synchronization</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2023/01/03/cpp/cpp-primer/Chapter%2011%20Associative%20Containers/" title="C++ Primer - Chapter 11 Associative Containers">C++ Primer - Chapter 11 Associative Containers</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/29/csharp/clr-via-csharp/Chapter%2023%20Assembly%20Loading%20and%20Reflection/" title="CLR via C# - Chapter 23 Assembly Loading and Reflection">CLR via C# - Chapter 23 Assembly Loading and Reflection</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/" title="CLR via C# - Chapter 21 The Managed Heap and Garbage  Collection">CLR via C# - Chapter 21 The Managed Heap and Garbage Collection</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/19/csharp/clr-via-csharp/Chapter%2016%20Arrays/" title="CLR via C# - Chapter 16 Arrays">CLR via C# - Chapter 16 Arrays</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" title="CLR via C# - Chapter 12 Generics">CLR via C# - Chapter 12 Generics</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 â€“ <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Sakupinera @ Hanamai Sora</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="Symbols count total">2.2m words</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="Reading time total">33:30</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/11/27/csharp/clr-via-csharp/Chapter 21 The Managed Heap and Garbage  Collection/",favicon:{show:"ï¼ˆâ—Â´3ï½€â—ï¼‰Goooood",hide:"(Â´Ğ”ï½€)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/shifuku.model.json"},display:{position:"left",width:250,height:500},mobile:{show:!1},react:{opacity:.9},log:!1})</script></body></html>