<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sakupinera" href="http://sakupinera.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sakupinera" href="http://sakupinera.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sakupinera" href="http://sakupinera.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="è¯»ä¹¦ç¬”è®°,C#"><link rel="canonical" href="http://sakupinera.github.io/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/"><title>CLR via C# - Chapter 24 Runtime Serialization - CLR-via-CSharp - CSharp | Hanamai Sora = Sakupinera</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">CLR via C# - Chapter 24 Runtime Serialization</h1><div class="meta"><span class="item" title="Created: 2022-11-30 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2022-11-30T00:00:00+08:00">2022-11-30</time> </span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">Symbols count in article</span> <span>68k</span> <span class="text">words</span> </span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">Reading time</span> <span>1:02</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hanamai Sora</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s2.loli.net/2023/03/08/Rft6Y9pgTV5E17J.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/nishJ3GEKoDLIbw.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/3EGdFBS1HMzVQjJ.png"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/R9PEJQ54o7HMAis.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/AK1D84aqsYghTOC.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/03/08/utEsOX73wkq1ycI.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/" itemprop="item" rel="index" title="In CSharp"><span itemprop="name">CSharp</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/CLR-via-CSharp/" itemprop="item" rel="index" title="In CLR-via-CSharp"><span itemprop="name">CLR-via-CSharp</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://sakupinera.github.io/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Sakupinera"><meta itemprop="description" content=", ä¿æŒä½ çš„å†³å¿ƒï¼"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakupinera"></span><div class="body md" itemprop="articleBody"><h1 id="chapter-24-runtime-serialization"><a class="anchor" href="#chapter-24-runtime-serialization">#</a> Chapter 24 Runtime Serialization</h1><h2 id="serializationdeserialization-quick-start"><a class="anchor" href="#serializationdeserialization-quick-start">#</a> Serialization/Deserialization Quick Start</h2><blockquote><p>Letâ€™s start off by looking at some code.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>Generic</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>IO</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>Serialization<span class="token punctuation">.</span>Formatters<span class="token punctuation">.</span>Binary</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">QuickStart</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// Create a graph of objects to serialize them to the stream </span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token class-name"><span class="token keyword">var</span></span> objectGraph <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">List<span class="token punctuation">&lt;</span>String<span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span> <span class="token string">"Jeff"</span><span class="token punctuation">,</span> <span class="token string">"Kristin"</span><span class="token punctuation">,</span> <span class="token string">"Aidan"</span><span class="token punctuation">,</span> <span class="token string">"Grant"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token class-name">Stream</span> stream <span class="token operator">=</span> <span class="token function">SerializeToMemory</span><span class="token punctuation">(</span>objectGraph<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// Reset everything for this demo</span></pre></td></tr><tr><td data-num="11"></td><td><pre> stream<span class="token punctuation">.</span>Position <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> objectGraph <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token comment">// Deserialize the objects and prove it worked</span></pre></td></tr><tr><td data-num="14"></td><td><pre> objectGraph <span class="token operator">=</span> <span class="token punctuation">(</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token function">DeserializeFromMemory</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> s <span class="token keyword">in</span> objectGraph<span class="token punctuation">)</span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name">MemoryStream</span> <span class="token function">SerializeToMemory</span><span class="token punctuation">(</span><span class="token class-name">Object</span> objectGraph<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token comment">// Construct a stream that is to hold the serialized objects</span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token class-name">MemoryStream</span> stream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">MemoryStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token comment">// Construct a serialization formatter that does all the hard work</span></pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token class-name">BinaryFormatter</span> formatter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">BinaryFormatter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token comment">// Tell the formatter to serialize the objects into the stream</span></pre></td></tr><tr><td data-num="23"></td><td><pre> formatter<span class="token punctuation">.</span><span class="token function">Serialize</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> objectGraph<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token comment">// Return the stream of serialized objects back to the caller</span></pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token keyword">return</span> stream<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name">Object</span> <span class="token function">DeserializeFromMemory</span><span class="token punctuation">(</span><span class="token class-name">Stream</span> stream<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre> <span class="token comment">// Construct a serialization formatter that does all the hard work</span></pre></td></tr><tr><td data-num="29"></td><td><pre> <span class="token class-name">BinaryFormatter</span> formatter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">BinaryFormatter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre> <span class="token comment">// Tell the formatter to deserialize the objects from the stream</span></pre></td></tr><tr><td data-num="31"></td><td><pre> <span class="token keyword">return</span> formatter<span class="token punctuation">.</span><span class="token function">Deserialize</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Wow, look how simple this is! The SerializeToMemory method constructs a <span class="exturl" data-url="aHR0cDovL1N5c3RlbS5JTw==">System.IO</span>. MemoryStream object. This object identifies where the serialized block of bytes is to be placed. Then the method constructs a BinaryFormatter object (which can be found in the System. Runtime.Serialization.Formatters.Binary namespace). A formatter is a type (implementing the System.Runtime.Serialization.IFormatter interface) that knows how to serialize and deserialize an object graph. The Framework Class Library (FCL) ships with two formatters: the BinaryFormatter (used in this code example) and a SoapFormatter (which can be found in the System. Runtime.Serialization.Formatters.Soap namespace and is implemented in the System. Runtime.Serialization.Formatters.Soap.dll assembly).</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šä» .NET Framework 3.5 å¼€å§‹ä¾¿åºŸäº† <code>SoapFormatter</code> ç±»ï¼Œä¸è¦åœ¨ç”Ÿäº§ä»£ç ä¸­ä½¿ç”¨å®ƒã€‚ä½†åœ¨è°ƒè¯•åºåˆ—åŒ–ä»£ç æ—¶ï¼Œå®ƒä»æœ‰ä¸€å®šç”¨å¤„ï¼Œå› ä¸ºå®ƒèƒ½ç”Ÿæˆä¾¿äºé˜…è¯»çš„ XML æ–‡æœ¬ã€‚è¦åœ¨ç”Ÿäº§ä»£ç ä¸­ä½¿ç”¨ XML åºåˆ—åŒ–å’Œååºåˆ—åŒ–ï¼Œè¯·å‚è§ <code>XmlSerializer</code> å’Œ <code>DataContractSerializer</code> ç±»ã€‚</p><blockquote><p>To serialize a graph of objects, just call the formatterâ€™s Serialize method and pass it two things: a reference to a stream object and a reference to the object graph that you want to serialize. The stream object identifies where the serialized bytes should be placed and can be an object of any type derived from the System.IO.Stream abstract base class. This means that you can serialize an object graph to a MemoryStream, a FileStream, a NetworkStream, and so on.</p></blockquote><blockquote><p>The second parameter to Serialize is a reference to an object. This object could be anything: an Int32, a String, a DateTime, an Exception, a List, a Dictionary, and so on. The object referred to by the objectGraph parameter may refer to other objects. For example, objectGraph may refer to a collection that refers to a set of objects. These objects may also refer to other objects. When the formatterâ€™s Serialize method is called, all objects in the graph are serialized to the stream.</p></blockquote><blockquote><p>Formatters know how to serialize the complete object graph by referring to the metadata that describes each objectâ€™s type. The Serialize method uses reflection to see what instance fields are in each objectâ€™s type as it is serialized. If any of these fields refer to other objects, then the formatterâ€™s Serialize method knows to serialize these objects, too.</p></blockquote><blockquote><p>Formatters have very intelligent algorithms. They know to serialize each object in the graph no more than once out to the stream. That is, if two objects in the graph refer to each other, then the formatter detects this, serializes each object just once, and avoids entering into an infinite loop.</p></blockquote><blockquote><p>In my SerializeToMemory method, when the formatterâ€™s Serialize method returns, the MemoryStream is simply returned to the caller. The application uses the contents of this flat byte array any way it wants. For example, it could save it in a file, copy it to the clipboard, send it over a wire, or whatever.</p></blockquote><blockquote><p>The DeserializeFromStream method deserializes a stream back into an object graph. This method is even simpler than serializing an object graph. In this code, a BinaryFormatter is constructed and then its Deserialize method is called. This method takes the stream as a parameter and returns a reference to the root object within the deserialized object graph.</p></blockquote><blockquote><p>Internally, the formatterâ€™s Deserialize method examines the contents of the stream, constructs instances of all the objects that are in the stream, and initializes the fields in all these objects so that they have the same values they had when the object graph was serialized. Typically, you will cast the object reference returned from the Deserialize method into the type that your application is expecting.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šä¸‹é¢æ˜¯ä¸€ä¸ªæœ‰è¶£è€Œå®ç”¨çš„æ–¹æ³•ï¼Œå®ƒåˆ©ç”¨åºåˆ—åŒ–åˆ›å»ºå¯¹è±¡çš„æ·±æ‹·è´ (æˆ–è€…è¯´å…‹éš†ä½“)ï¼š</p><pre><code class="language-C#">private static Object DeepClone(Object original) &#123;
    // æ„é€ ä¸´æ—¶å†…å­˜æµ
    using (MemoryStream stream = new MemoryStream()) &#123;

        // æ„é€ åºåˆ—åŒ–æ ¼å¼åŒ–å™¨æ¥æ‰§è¡Œæ‰€æœ‰å®é™…å·¥ä½œ
        BinaryFormatter formatter = new BinaryFormatter();

        // å€¼ä¸€è¡Œåœ¨æœ¬ç«  24.6 èŠ‚â€œæµä¸Šä¸‹æ–‡â€ è§£é‡Š
        formatter.Context = new StreamingContext(StreamingContextStates.Clone);

        // å°†å¯¹è±¡å›¾åºåˆ—åŒ–åˆ°å†…å­˜æµä¸­
        formatter.Serialize(stream, original);

        // ååºåˆ—åŒ–å‰ï¼Œå®šä½åˆ°å†…å­˜æµçš„èµ·å§‹ä½ç½®
        stream.Position = 0;
        
        // å°†å¯¹è±¡å›¾ååºåˆ—åŒ–æˆä¸€ç»„æ–°å¯¹è±¡ï¼Œ
        // å‘è°ƒç”¨è€…è¿”å›å¯¹è±¡å›¾(æ·±æ‹·è´)çš„æ ¹
        return formatter.Deserialize(stream);
    &#125;
&#125; 
</code></pre><blockquote><p>At this point, Iâ€™d like to add a few notes to our discussion. First, it is up to you to ensure that your code uses the same formatter for both serialization and deserialization. For example, donâ€™t write code that serializes an object graph by using the SoapFormatter and then deserializes the graph by using the BinaryFormatter. If Deserialize canâ€™t decipher the contents of the stream, then a System. Runtime.Serialization.SerializationException exception will be thrown.</p></blockquote><blockquote><p>The second thing Iâ€™d like to point out is that it is possible and also quite useful to serialize multiple object graphs out to a single stream. For example, letâ€™s say that we have the following two class definitions.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Serializable</span></span><span class="token punctuation">]</span> <span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Customer</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* ... */</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Serializable</span></span><span class="token punctuation">]</span> <span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Order</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* ... */</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>And then, in the main class of our application, we define the following static fields.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">List<span class="token punctuation">&lt;</span>Customer<span class="token punctuation">></span></span> s_customers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">List<span class="token punctuation">&lt;</span>Customer<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">List<span class="token punctuation">&lt;</span>Order<span class="token punctuation">></span></span> s_pendingOrders <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">List<span class="token punctuation">&lt;</span>Order<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">List<span class="token punctuation">&lt;</span>Order<span class="token punctuation">></span></span> s_processedOrders <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">List<span class="token punctuation">&lt;</span>Order<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>We can now serialize our applicationâ€™s state to a single stream with a method that looks like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SaveApplicationState</span><span class="token punctuation">(</span><span class="token class-name">Stream</span> stream<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Construct a serialization formatter that does all the hard work</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">BinaryFormatter</span> formatter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">BinaryFormatter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// Serialize our application's entire state</span></pre></td></tr><tr><td data-num="5"></td><td><pre> formatter<span class="token punctuation">.</span><span class="token function">Serialize</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> s_customers<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> formatter<span class="token punctuation">.</span><span class="token function">Serialize</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> s_pendingOrders<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> formatter<span class="token punctuation">.</span><span class="token function">Serialize</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> s_processedOrders<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>To reconstruct our applicationâ€™s state, we would deserialize the state with a method that looks like this.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">RestoreApplicationState</span><span class="token punctuation">(</span><span class="token class-name">Stream</span> stream<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Construct a serialization formatter that does all the hard work</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">BinaryFormatter</span> formatter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">BinaryFormatter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// Deserialize our application's entire state (same order as serialized)</span></pre></td></tr><tr><td data-num="5"></td><td><pre> s_customers <span class="token operator">=</span> <span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Customer<span class="token operator">></span><span class="token punctuation">)</span> formatter<span class="token punctuation">.</span><span class="token function">Deserialize</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> s_pendingOrders <span class="token operator">=</span> <span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Order<span class="token operator">></span><span class="token punctuation">)</span> formatter<span class="token punctuation">.</span><span class="token function">Deserialize</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> s_processedOrders <span class="token operator">=</span> <span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Order<span class="token operator">></span><span class="token punctuation">)</span> formatter<span class="token punctuation">.</span><span class="token function">Deserialize</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The third and last thing Iâ€™d like to point out has to do with assemblies. When serializing an object, the full name of the type and the name of the typeâ€™s defining assembly are written to the stream. By default, BinaryFormatter outputs the assemblyâ€™s full identity, which includes the assemblyâ€™s file name (without extension), version number, culture, and public key information. When deserializing an object, the formatter first grabs the assembly identity and ensures that the assembly is loaded into the executing AppDomain by calling System.Reflection.Assemblyâ€™s Load method (discussed in Chapter 23, â€œAssembly Loading and Reflectionâ€).</p></blockquote><blockquote><p>After an assembly has been loaded, the formatter looks in the assembly for a type matching that of the object being deserialized. If the assembly doesnâ€™t contain a matching type, an exception is thrown and no more objects can be deserialized. If a matching type is found, an instance of the type is created and its fields are initialized from the values contained in the stream. If the typeâ€™s fields donâ€™t exactly match the names of the fields as read from the stream, then a SerializationException exception is thrown and no more objects can be deserialized. Later in this chapter, Iâ€™ll discuss some sophisticated mechanisms that allow you to override some of this behavior.</p></blockquote><p>ğŸ’¡é‡è¦æç¤ºï¼šæœ‰çš„å¯æ‰©å±•åº”ç”¨ç¨‹åºä½¿ç”¨ <code>Assembly.LoadFrom</code> åŠ è½½ç¨‹åºé›†ï¼Œç„¶åæ ¹æ®åŠ è½½çš„ç¨‹åºé›†ä¸­å®šä¹‰çš„ç±»å‹æ¥æ„é€ å¯¹è±¡ã€‚è¿™äº›å¯¹è±¡åºåˆ—åŒ–åˆ°æµä¸­æ˜¯æ²¡æœ‰é—®é¢˜çš„ã€‚ä½†åœ¨ååºåˆ—åŒ–æ—¶ï¼Œæ ¼å¼åŒ–å™¨ä¼šè°ƒç”¨ <code>Assembly</code> çš„ <code>Load</code> æ–¹æ³• (è€Œé <code>LoadFrom</code> æ–¹æ³•) æ¥åŠ è½½ç¨‹åºé›†ã€‚å¤§å¤šæ•°æƒ…å†µä¸‹ï¼ŒCLR éƒ½å°†æ— æ³•å®šä½ç¨‹åºé›†æ–‡ä»¶ï¼Œä»è€Œé€ æˆ <code>SerializationException</code> å¼‚å¸¸ã€‚è®¸å¤šå¼€å‘äººå‘˜å¯¹è¿™ä¸ªç»“æœæ·±æ„Ÿä¸è§£ã€‚åºåˆ—åŒ–éƒ½èƒ½æ­£ç¡®è¿›è¡Œï¼Œä»–ä»¬å½“ç„¶é¢„æœŸååºåˆ—åŒ–ä¹Ÿæ˜¯æ­£ç¡®çš„ã€‚</p><p>å¦‚æœåº”ç”¨ç¨‹åºä½¿ç”¨ <code>Assembly.LoadFrom</code> åŠ è½½ç¨‹åºé›†ï¼Œå†å¯¹ç¨‹åºé›†ä¸­å®šä¹‰çš„ç±»å‹è¿›è¡Œåºåˆ—åŒ–ï¼Œé‚£ä¹ˆåœ¨è°ƒç”¨æ ¼å¼åŒ–å™¨çš„ <code>Deserialize</code> æ–¹æ³•ä¹‹å‰ï¼Œæˆ‘å»ºè®®ä½ å®ç°ä¸€ä¸ªæ–¹æ³•ï¼Œå®ƒçš„ç­¾åè¦åŒ¹é… <code>System.ResolveEventHandler</code> å§”æ‰˜ï¼Œå¹¶å‘ <code>System.AppDomain</code> çš„ <code>AssemblyResolve</code> äº‹ä»¶æ³¨å†Œè¿™ä¸ªæ–¹æ³•ã€‚( <code>Deserialize</code> æ–¹æ³•è¿”å›åï¼Œé©¬ä¸Šå‘äº‹ä»¶æ³¨é”€è¿™ä¸ªæ–¹æ³•ã€‚) ç°åœ¨ï¼Œæ¯æ¬¡æ ¼å¼åŒ–å™¨åŠ è½½ä¸€ä¸ªç¨‹åºé›†å¤±è´¥ï¼ŒCLR éƒ½ä¼šè‡ªåŠ¨è°ƒç”¨ä½ çš„ <code>ResolveEventHandler</code> æ–¹æ³•ã€‚åŠ è½½å¤±è´¥çš„ç¨‹åºé›†çš„æ ‡è¯† (Identity) ä¼šä¼ ç»™è¿™ä¸ªæ–¹æ³•ã€‚æ–¹æ³•å¯ä»¥ä»ç¨‹åºé›†çš„æ ‡è¯†ä¸­æå–ç¨‹åºé›†æ–‡ä»¶åï¼Œå¹¶ç”¨è¿™ä¸ªåç§°æ¥æ„é€ è·¯å¾„ï¼Œä½¿åº”ç”¨ç¨‹åºçŸ¥é“å»å“ªé‡Œå¯»æ‰¾æ–‡ä»¶ã€‚ç„¶åï¼Œæ–¹æ³•å¯è°ƒç”¨ <code>Assembly.LoadFrom</code> åŠ è½½ç¨‹åºé›†ï¼Œæœ€åè¿”å›å¯¹ç»“æœç¨‹åºé›†çš„å¼•ç”¨ã€‚</p><blockquote><p>This section covered the basics of how to serialize and deserialize object graphs. In the remaining sections, weâ€™ll look at what you must do in order to define your own serializable types, and weâ€™ll also look at various mechanisms that allow you to have greater control over serialization and deserialization.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šåºåˆ—åŒ–æ—¶å°†å¯¹è±¡æˆ–å¯¹è±¡å›¾è½¬æ¢æˆå­—èŠ‚æµçš„è¿‡ç¨‹ã€‚ååºåˆ—åŒ–æ˜¯å°†å­—èŠ‚æµè½¬æ¢å›å¯¹è±¡å›¾çš„è¿‡ç¨‹ã€‚åœ¨å¯¹è±¡å’Œå­—èŠ‚æµä¹‹é—´è½¬æ¢æ˜¯å¾ˆæœ‰ç”¨çš„æœºåˆ¶ã€‚ä¸€æ—¦å°†å¯¹è±¡åºåˆ—åŒ–æˆå†…å­˜ä¸­çš„å­—èŠ‚æµï¼Œå°±å¯æ–¹ä¾¿åœ°ä»¥ä¸€äº›æ›´æœ‰ç”¨çš„æ–¹å¼å¤„ç†æ•°æ®ï¼Œæ¯”å¦‚è¿›è¡ŒåŠ å¯†å’Œå‹ç¼©ã€‚æ ¼å¼åŒ–å™¨æ˜¯å®ç°äº† <code>System.Runtime.Serialization.IFormatter</code> æ¥å£çš„ç±»å‹ï¼Œå®ƒçŸ¥é“å¦‚ä½•åºåˆ—åŒ–å’Œååºåˆ—åŒ–å¯¹è±¡å›¾ã€‚FCL æä¾›äº†ä¸¤ä¸ªæ ¼å¼åŒ–å™¨ï¼š <code>BinaryFormatter</code> å’Œ <code>SoapFormatter</code> (åœ¨ <code>System.Runtime.Serialization.Formatters.Soap</code> å‘½åç©ºé—´ä¸­å®šä¹‰ï¼Œåœ¨ <code>System.Runtime.Serialization.Formatters.Soap.dll</code> ç¨‹åºé›†ä¸­å®ç°)ã€‚åºåˆ—åŒ–å¯¹è±¡å›¾åªéœ€è°ƒç”¨æ ¼å¼åŒ–å™¨çš„ <code>Serialize</code> æ–¹æ³•ï¼Œå¹¶å‘å®ƒä¼ é€’ä¸¤æ ·ä¸œè¥¿ï¼šå¯¹æµå¯¹è±¡çš„å¼•ç”¨ï¼Œä»¥åŠå¯¹æƒ³è¦åºåˆ—åŒ–çš„å¯¹è±¡å›¾çš„å¼•ç”¨ã€‚æµå¯¹è±¡æ ‡è¯†äº†åºåˆ—åŒ–å¥½çš„å­—èŠ‚åº”æ”¾åˆ°å“ªé‡Œï¼Œå®ƒå¯ä»¥æ˜¯ä» <code>System.IO.Stream</code> æŠ½è±¡åŸºç±»æ´¾ç”Ÿçš„ä»»ä½•ç±»å‹çš„å¯¹è±¡ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¯¹è±¡å›¾å¯åºåˆ—åŒ–æˆä¸€ä¸ª <code>MemoryStream</code> ï¼Œ <code>FileStream</code> æˆ–è€… <code>NetworkStream</code> ç­‰ã€‚ <code>Serialize</code> çš„ç¬¬äºŒä¸ªå‚æ•°æ˜¯ä¸€ä¸ªå¯¹è±¡å¼•ç”¨ã€‚è¿™ä¸ªå¯¹è±¡å¯ä»¥æ˜¯ä»»ä½•ä¸œè¥¿ï¼Œå¯ä»¥æ˜¯ä¸€ä¸ª <code>Int32</code> ï¼Œ <code>String</code> ï¼Œ <code>DateTime</code> ï¼Œ <code>Exception</code> ï¼Œ <code>List&lt;String&gt;</code> æˆ–è€… <code>Dictionary&lt;Int32, DateTime&gt;</code> ç­‰ã€‚ <code>objectGraph</code> å‚æ•°å¼•ç”¨çš„å¯¹è±¡å¯å¼•ç”¨å…¶ä»–å¯¹è±¡ã€‚ä¾‹å¦‚ï¼Œ <code>objectGraph</code> å¯å¼•ç”¨ä¸€ä¸ªé›†åˆï¼Œè€Œè¿™ä¸ªé›†åˆå¼•ç”¨äº†ä¸€ç»„å¯¹è±¡ã€‚è¿™äº›å¯¹è±¡è¿˜å¯ç»§ç»­å¼•ç”¨å…¶ä»–å¯¹è±¡ï¼Œè°ƒç”¨æ ¼å¼åŒ–å™¨çš„ <code>Serialize</code> æ–¹æ³•æ—¶ï¼Œå¯¹è±¡å›¾ä¸­çš„æ‰€æœ‰å¯¹è±¡éƒ½è¢«åºåˆ—åŒ–åˆ°æµä¸­ã€‚æ ¼å¼åŒ–å™¨å‚è€ƒå¯¹æ¯ä¸ªå¯¹è±¡çš„ç±»å‹è¿›è¡Œæè¿°çš„å…ƒæ•°æ®ï¼Œä»è€Œäº†è§£å¦‚ä½•åºåˆ—åŒ–å®Œæ•´çš„å¯¹è±¡å›¾ã€‚åºåˆ—åŒ–æ—¶ï¼Œ <code>Serialize</code> æ–¹æ³•åˆ©ç”¨åå°„æ¥æŸ¥çœ‹æ¯ä¸ªå¯¹è±¡çš„ç±»å‹ä¸­éƒ½æœ‰å“ªäº›å®ä¾‹å­—æ®µã€‚åœ¨è¿™äº›å­—æ®µä¸­ï¼Œä»»ä½•ä¸€ä¸ªå¼•ç”¨äº†å…¶ä»–å¯¹è±¡ï¼Œæ ¼å¼åŒ–å™¨çš„ <code>Serialize</code> æ–¹æ³•å°±çŸ¥é“é‚£äº›å¯¹è±¡ä¹Ÿè¦è¿›è¡Œåºåˆ—åŒ–ã€‚åœ¨å†…éƒ¨ï¼Œæ ¼å¼åŒ–å™¨çš„ <code>Deserialize</code> æ–¹æ³•æ£€æŸ¥æµçš„å†…å®¹ï¼Œæ„é€ æµä¸­æ‰€æœ‰å¯¹è±¡çš„å®ä¾‹ï¼Œå¹¶åˆå§‹åŒ–æ‰€æœ‰è¿™äº›å¯¹è±¡ä¸­çš„å­—æ®µï¼Œä½¿å®ƒä»¬å…·æœ‰ä¸å½“åˆåºåˆ—åŒ–æ—¶ç›¸åŒçš„å€¼ã€‚é€šå¸¸è¦å°† <code>Deserialize</code> æ–¹æ³•è¿”å›çš„å¯¹è±¡å¼•ç”¨è½¬å‹ä¸ºåº”ç”¨ç¨‹åºæœŸå¾…çš„ç±»å‹ã€‚æœ‰å‡ ç‚¹éœ€è¦æ³¨æ„ã€‚é¦–å…ˆï¼Œæ˜¯ç”±ä½ æ¥ä¿è¯ä»£ç ä¸ºåºåˆ—åŒ–å’Œååºåˆ—åŒ–ä½¿ç”¨ç›¸åŒçš„æ ¼å¼åŒ–å™¨ã€‚ä¾‹å¦‚ï¼Œä¸è¦å†™ä»£ç ç”¨ <code>SoapFormatter</code> åºåˆ—åŒ–ä¸€ä¸ªå¯¹è±¡å›¾ï¼Œå†ç”¨ <code>BinaryFormatter</code> ååºåˆ—åŒ–ã€‚ <code>Deserialize</code> å¦‚æœè§£é‡Šä¸äº†æµçš„å†…å®¹ä¼šæŠ›å‡º <code>System.Runtime.Serialization.SerializationException</code> å¼‚å¸¸ã€‚å…¶æ¬¡ï¼Œå¯å°†å¤šä¸ªå¯¹è±¡å›¾åºåˆ—åŒ–åˆ°ä¸€ä¸ªæµä¸­ï¼Œè¿™æ˜¯å¾ˆæœ‰ç”¨çš„ä¸€ä¸ªæ“ä½œã€‚æœ€åä¸€ä¸ªä¸»æ„äº‹é¡¹ä¸ç¨‹åºé›†æœ‰å…³ã€‚åºåˆ—åŒ–å¯¹è±¡æ—¶ï¼Œç±»å‹çš„å…¨åå’Œç±»å‹å®šä¹‰ç¨‹åºé›†çš„å…¨åä¼šè¢«å†™å…¥æµã€‚ <code>BinaryFormatter</code> é»˜è®¤è¾“å‡ºç¨‹åºé›†çš„å®Œæ•´æ ‡è¯†ï¼Œå…¶ä¸­åŒ…æ‹¬ç¨‹åºé›†çš„æ–‡ä»¶å (æ— æ‰©å±•å)ã€ç‰ˆæœ¬å·ã€è¯­è¨€æ–‡åŒ–ä»¥åŠå…¬é’¥ä¿¡æ¯ã€‚ååºåˆ—åŒ–å¯¹è±¡æ—¶ï¼Œæ ¼å¼åŒ–å™¨é¦–å…ˆè·å–ç¨‹åºé›†æ ‡è¯†ä¿¡æ¯ã€‚å¹¶é€šè¿‡è°ƒç”¨ <code>System.Refleciton.Assembly</code> çš„ <code>Load</code> æ–¹æ³•ï¼Œç¡®ä¿ç¨‹åºé›†å·²åŠ è½½åˆ°æ­£åœ¨æ‰§è¡Œçš„ AppDomain ä¸­ã€‚</p><h2 id="making-a-type-serializable"><a class="anchor" href="#making-a-type-serializable">#</a> Making a Type Serializable</h2><blockquote><p>When a type is designed, the developer must make the conscious decision as to whether or not to allow instances of the type to be serializable. By default, types are not serializable. For example, the following code does not perform as expected.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">struct</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span> <span class="token class-name">Int32</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">OptInSerialization</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Point</span> pt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Point</span> <span class="token punctuation">&#123;</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">2</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> stream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">MemoryStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">BinaryFormatter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Serialize</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> pt<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// throws SerializationException</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>If you were to build and run this code in your program, youâ€™d see that the formatterâ€™s Serialize method throws a System.Runtime.Serialization.SerializationException exception. The problem is that the developer of the Point type has not explicitly indicated that Point objects may be serialized. To solve this problem, the developer must apply the System.SerializableAttribute custom attribute to this type as follows. (Note that this attribute is defined in the System namespace, not the System.Runtime.Serialization namespace.)</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Serializable</span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">struct</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span> <span class="token class-name">Int32</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Now, if we rebuild the application and run it, it does perform as expected and the Point objects will be serialized to the stream. When serializing an object graph, the formatter checks that every objectâ€™s type is serializable. If any object in the graph is not serializable, the formatterâ€™s Serialize method throws the SerializationException exception.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šåºåˆ—åŒ–å¯¹è±¡å›¾æ—¶ï¼Œä¹Ÿè®¸æœ‰çš„å¯¹è±¡çš„ç±»å‹èƒ½åºåˆ—åŒ–ï¼Œæœ‰çš„ä¸èƒ½ã€‚è€ƒè™‘åˆ°æ€§èƒ½ï¼Œåœ¨åºåˆ—åŒ–ä¹‹å‰ï¼Œæ ¼å¼åŒ–å™¨ä¸ä¼šéªŒè¯å¯¹è±¡å›¾ä¸­çš„æ‰€æœ‰å¯¹è±¡éƒ½èƒ½åºåˆ—åŒ–ã€‚æ‰€ä»¥ï¼Œåºåˆ—åŒ–å¯¹è±¡å›¾æ—¶ï¼Œåœ¨æŠ›å‡º <code>SerializationException</code> å¼‚å¸¸ä¹‹å‰ï¼Œå®Œå…¨æœ‰å¯èƒ½å·²ç»æœ‰ä¸€éƒ¨åˆ†å¯¹è±¡åºåˆ—åŒ–åˆ°æµä¸­ã€‚å¦‚æœå‘ç”Ÿè¿™ç§æƒ…å†µï¼Œæµä¸­å°±ä¼šåŒ…å«å·²æŸåçš„æ•°æ®ã€‚åºåˆ—åŒ–å¯¹è±¡å›¾æ—¶ï¼Œå¦‚æœä½ è®¤ä¸ºä¹Ÿè®¸æœ‰ä¸€äº›å¯¹è±¡ä¸å¯åºåˆ—åŒ–ï¼Œé‚£ä¹ˆå†™çš„ä»£ç å°±åº”è¯¥èƒ½å¾—ä½“åœ°ä»è¿™ç§æƒ…å†µä¸­æ¢å¤ã€‚ä¸€ä¸ªæ–¹æ¡ˆæ˜¯å…ˆå°†å¯¹è±¡åºåˆ—åŒ–åˆ°ä¸€ä¸ª <code>MemoryStream</code> ä¸­ã€‚ç„¶åï¼Œå¦‚æœæ‰€æœ‰å¯¹è±¡éƒ½æˆåŠŸåºåˆ—åŒ–ï¼Œå°±å¯ä»¥å°† <code>MemoryStream</code> ä¸­çš„å­—èŠ‚å¤åˆ¶åˆ°ä½ çœŸæ­£å¸Œæœ›çš„ç›®æ ‡æµä¸­ (æ¯”å¦‚æ–‡ä»¶å’Œç½‘ç»œ)ã€‚</p><blockquote><p>The SerializableAttribute custom attribute may be applied to reference types (class), value types (struct), enumerated types (enum), and delegate types (delegate) only. (Note that enumerated and delegate types are always serializable, so there is no need to explicitly apply the SerializableAttribute attribute to these types.) In addition, the SerializableAttribute attribute is not inherited by derived types. So, given the following two type definitions, a Person object can be serialized, but an Employee object cannot.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Serializable</span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Person</span></span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>To fix this, you would just apply the SerializableAttribute attribute to the Employee type as well.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Serializable</span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Serializable</span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Person</span></span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Note that this problem was easy to fix. However, the reverseâ€”defining a type derived from a base type that doesnâ€™t have the SerializableAttribute attribute applied to itâ€”is not easy to fix. But, this is by design; if the base type doesnâ€™t allow instances of its type to be serialized, its fields cannot be serialized, because a base object is effectively part of the derived object. This is why System. Object has the SerializableAttribute attribute applied to it.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šä¸€èˆ¬å»ºè®®å°†ä½ å®šä¹‰çš„å¤§å¤šæ•°ç±»å‹éƒ½è®¾ç½®æˆå¯åºåˆ—åŒ–ã€‚æ¯•ç«Ÿï¼Œè¿™æ ·èƒ½ä¸ºç±»å‹çš„ç”¨æˆ·æä¾›å¾ˆå¤§çš„çµæ´»æ€§ã€‚ä½†å¿…é¡»æ³¨æ„çš„æ˜¯ï¼Œåºåˆ—åŒ–ä¼šè¯»å–å¯¹è±¡çš„æ‰€æœ‰å­—æ®µï¼Œä¸ç®¡è¿™äº›å­—æ®µå£°æ˜ä¸º <code>public</code> ï¼Œ <code>protected</code> ï¼Œ <code>internal</code> è¿˜æ˜¯ <code>private</code> ã€‚å¦‚æœç±»å‹çš„å®ä¾‹è¦åŒ…å«æ•æ„Ÿæˆ–å®‰å…¨æ•°æ® (æ¯”å¦‚å¯†ç )ï¼Œæˆ–è€…æ•°æ®åœ¨è½¬ç§»ä¹‹åä¾¿æ²¡æœ‰å«ä¹‰æˆ–è€…æ²¡æœ‰å€¼ï¼Œå°±ä¸åº”ä½¿ç±»å‹å˜å¾—å¯åºåˆ—åŒ–ã€‚</p><p>å¦‚æœä½¿ç”¨çš„ç±»å‹ä¸æ˜¯ä¸ºåºåˆ—åŒ–è€Œè®¾è®¡çš„ï¼Œè€Œä¸”æ‰‹ä¸Šæ²¡æœ‰ç±»å‹çš„æºä»£ç ï¼Œæ— æ³•ä»æºå¤´æ·»åŠ åºåˆ—åŒ–æ”¯æŒï¼Œä¹Ÿä¸å¿…æ°”é¦ã€‚åœ¨æœ¬ç« æœ€åçš„ 24.9 èŠ‚ â€œååºåˆ—åŒ–å¯¹è±¡æ—¶é‡å†™ç¨‹åºé›†å’Œ / æˆ–ç±»å‹â€ ä¸­ï¼Œæˆ‘ä¼šè§£é‡Šå¦‚ä½•ä½¿ä»»ä½•ä¸å¯åºåˆ—åŒ–çš„ç±»å‹å˜å¾—å¯åºåˆ—åŒ–ã€‚</p><p>ğŸ’¡å°ç»“ï¼šè®¾è®¡ç±»å‹æ—¶ï¼Œè®¾è®¡äººå‘˜å¿…é¡»çé‡åœ°å†³å®šæ˜¯å¦å…è®¸ç±»å‹çš„å®ä¾‹åºåˆ—åŒ–ã€‚ç±»å‹é»˜è®¤æ˜¯ä¸å¯åºåˆ—åŒ–å¯¹çš„ã€‚å¼€å‘è€…å¿…é¡»å‘ç±»å‹åº”ç”¨å®šåˆ¶ç‰¹æ€§ <code>System.SerializableAttribute</code> ï¼ˆæ³¨æ„è¯¥ç‰¹æ€§åœ¨ <code>System</code> è€Œä¸æ˜¯ <code>System.Runtime.Serialization</code> å‘½åç©ºé—´ä¸­å®šä¹‰ï¼‰ã€‚åºåˆ—åŒ–å¯¹è±¡å›¾æ—¶ï¼Œæ ¼å¼åŒ–å™¨ä¼šç¡®è®¤æ¯ä¸ªå¯¹è±¡çš„ç±»å‹éƒ½æ˜¯å¯åºåˆ—åŒ–çš„ã€‚ä»»ä½•å¯¹è±¡ä¸å¯åºåˆ—åŒ–ï¼Œæ ¼å¼åŒ–å™¨çš„ <code>Serialize</code> æ–¹æ³•éƒ½ä¼šæŠ›å‡º <code>SerializationException</code> å¼‚å¸¸ã€‚ <code>SerializableAttribute</code> è¿™ä¸ªå®šåˆ¶ç‰¹æ€§åªèƒ½åº”ç”¨äºå¼•ç”¨ç±»å‹ ( <code>class</code> )ã€å€¼ç±»å‹ ( <code>struct</code> )ã€æšä¸¾ç±»å‹ ( <code>enum</code> ) å’Œå§”æ‰˜ç±»å‹ ( <code>delegate</code> )ã€‚æ³¨æ„ï¼Œæšä¸¾å’Œå§”æ‰˜ç±»å‹æ€»æ˜¯å¯åºåˆ—åŒ–çš„ï¼Œæ‰€ä»¥ä¸å¿…æ˜¾å¼åº”ç”¨ <code>SerializableAttribute</code> ç‰¹æ€§ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œ <code>SerializableAttribute</code> ç‰¹æ€§ä¸ä¼šè¢«æ´¾ç”Ÿç±»å‹ç»§æ‰¿ã€‚å¦‚æœåŸºç±»å‹ä¸å…è®¸å®ƒçš„å®ä¾‹åºåˆ—åŒ–ï¼Œå®ƒçš„å­—æ®µå°±ä¸èƒ½åºåˆ—åŒ–ï¼Œå› ä¸ºåŸºå¯¹è±¡å®é™…æ˜¯æ´¾ç”Ÿå¯¹è±¡çš„ä¸€éƒ¨åˆ†ã€‚è¿™æ­£æ˜¯ä¸ºä»€ä¹ˆ <code>System.Object</code> å·²ç»å¾ˆä½“è´´åœ°åº”ç”¨äº† <code>SerializableAttribute</code> ç‰¹æ€§çš„åŸå› ã€‚</p><h2 id="controlling-serialization-and-deserialization"><a class="anchor" href="#controlling-serialization-and-deserialization">#</a> Controlling Serialization and Deserialization</h2><blockquote><p>When you apply the SerializableAttribute custom attribute to a type, all instance fields (public, private, protected, and so on) are serialized.1 However, a type may define some instance fields that should not be serialized. In general, there are two reasons why you would not want some of a typeâ€™s instance fields to be serialized:</p><ul><li><p>The field contains information that would not be valid when deserialized. For example, an object that contains a handle to a Windows kernel object (such as a file, process, thread, mutex, event, semaphore, and so on) would have no meaning when deserialized into another process or machine because Windowsâ€™ kernel handles are process-relative values.</p></li><li><p>The field contains information that is easily calculated. In this case, you select which fields do not need to be serialized, thus improving your applicationâ€™s performance by reducing the amount of data transferred.</p></li></ul></blockquote><blockquote><p>The following code uses the System.NonSerializedAttribute custom attribute to indicate which fields of the type should not be serialized. (Note that this attribute is also defined in the System namespace, not the System.Runtime.Serialization namespace.)</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Serializable</span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">Circle</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Double</span> m_radius<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">NonSerialized</span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Double</span> m_area<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Circle</span><span class="token punctuation">(</span><span class="token class-name">Double</span> radius<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> m_radius <span class="token operator">=</span> radius<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> m_area <span class="token operator">=</span> Math<span class="token punctuation">.</span>PI <span class="token operator">*</span> m_radius <span class="token operator">*</span> m_radius<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In the preceding code, objects of Circle may be serialized. However, the formatter will serialize the values in the objectâ€™s m_radius field only. The value in the m_area field will not be serialized because it has the NonSerializedAttribute attribute applied to it. This attribute can be applied only to a typeâ€™s fields, and it continues to apply to this field when inherited by another type. Of course, you may apply the NonSerializedAttribute attribute to multiple fields within a type.</p></blockquote><blockquote><p>So, letâ€™s say that our code constructs a Circle object as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Circle</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Circle</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>Internally, the m_area field is set to a value approximate to 314.159. When this object gets serialized, only the value of the m_radius field (10) gets written to the stream. This is exactly what we want, but now we have a problem when the stream is deserialized back into a Circle object. When deserialized, the Circle object will get its m_radius field set to 10, but its m_area field will be initialized to 0â€”not 314.159!</p></blockquote><blockquote><p>The following code demonstrates how to modify the Circle type to fix this problem.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Serializable</span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">Circle</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Double</span> m_radius<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">NonSerialized</span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">Double</span> m_area<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Circle</span><span class="token punctuation">(</span><span class="token class-name">Double</span> radius<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> m_radius <span class="token operator">=</span> radius<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> m_area <span class="token operator">=</span> Math<span class="token punctuation">.</span>PI <span class="token operator">*</span> m_radius <span class="token operator">*</span> m_radius<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">OnDeserialized</span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">OnDeserialized</span><span class="token punctuation">(</span><span class="token class-name">StreamingContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> m_area <span class="token operator">=</span> Math<span class="token punctuation">.</span>PI <span class="token operator">*</span> m_radius <span class="token operator">*</span> m_radius<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Iâ€™ve changed Circle so that it now contains a method marked with the System.Runtime. Serialization.OnDeserializedAttribute custom attribute.2 Whenever an instance of a type is deserialized, the formatter checks whether the type defines a method with this attribute on it and then the formatter invokes this method. When this method is called, all the serializable fields will be set correctly, and they may be accessed to perform any additional work that would be necessary to fully deserialize the object.</p></blockquote><blockquote><p>In the preceding modified version of Circle, I made the OnDeserialized method simply calculate the area of the circle by using the m_radius field and place the result in the m_area field. Now, m_area will have the desired value of 314.159.</p></blockquote><blockquote><p>In addition to the OnDeserializedAttribute custom attribute, the System.Runtime.Serialization namespace also defines OnSerializingAttribute, OnSerializedAttribute, and OnDeserializingAttribute custom attributes, which you can apply to your typeâ€™s methods to have even more control over serialization and deserialization. Here is a sample class that applies each of these attributes to a method.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Serializable</span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyType</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Int32</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span> <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">NonSerialized</span></span><span class="token punctuation">]</span> <span class="token class-name">Int32</span> sum<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token function">MyType</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> x<span class="token punctuation">,</span> <span class="token class-name">Int32</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span> sum <span class="token operator">=</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">OnDeserializing</span></span><span class="token punctuation">]</span> </pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">OnDeserializing</span><span class="token punctuation">(</span><span class="token class-name">StreamingContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// Example: Set default values for fields in a new version of this type </span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> </pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">OnDeserialized</span></span><span class="token punctuation">]</span> </pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">OnDeserialized</span><span class="token punctuation">(</span><span class="token class-name">StreamingContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token comment">// Example: Initialize transient state from fields</span></pre></td></tr><tr><td data-num="15"></td><td><pre> sum <span class="token operator">=</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">OnSerializing</span></span><span class="token punctuation">]</span> </pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">OnSerializing</span><span class="token punctuation">(</span><span class="token class-name">StreamingContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token comment">// Example: Modify any state before serializing</span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">OnSerialized</span></span><span class="token punctuation">]</span> </pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">OnSerialized</span><span class="token punctuation">(</span><span class="token class-name">StreamingContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token comment">// Example: Restore any state after serializing</span></pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Whenever you use any of these four attributes, the method you define must take a single StreamingContext parameter (discussed in the â€œStreaming Contextsâ€ section later in this chapter) and return void. The name of the method can be anything you want it to be. Also, you should declare the method as private to prevent it from being called by normal code; the formatters run with enough security that they can call private methods.</p></blockquote><p>ğŸ’¡æ³¨æ„ åºåˆ—åŒ–ä¸€ç»„å¯¹è±¡æ—¶ï¼Œæ ¼å¼åŒ–å™¨é¦–å…ˆè°ƒç”¨å¯¹è±¡çš„æ ‡è®°äº† <code>OnSerializing</code> ç‰¹æ€§çš„æ‰€æœ‰æ–¹æ³•ã€‚æ¥ç€ï¼Œå®ƒåºåˆ—åŒ–å¯¹è±¡çš„æ‰€æœ‰å­—æ®µã€‚æœ€åï¼Œè°ƒç”¨å¯¹è±¡çš„æ ‡è®°äº† <code>OnSerialized</code> ç‰¹æ€§çš„æ‰€æœ‰æ–¹æ³•ã€‚ç±»ä¼¼åœ°ï¼Œååºåˆ—åŒ–ä¸€ç»„å¯¹è±¡æ—¶ï¼Œæ ¼å¼åŒ–å™¨é¦–å…ˆè°ƒç”¨å¯¹è±¡çš„æ ‡è®°äº† <code>OnDeserializing</code> ç‰¹æ€§çš„æ‰€æœ‰æ–¹æ³•ã€‚ç„¶åï¼Œå®ƒååºåˆ—åŒ–å¯¹è±¡çš„æ‰€æœ‰å­—æ®µã€‚æœ€åï¼Œå®ƒè°ƒç”¨å¯¹è±¡çš„æ ‡è®°äº† <code>OnDeserialized</code> ç‰¹æ€§çš„æ‰€æœ‰æ–¹æ³•ã€‚</p><p>è¿˜è¦æ³¨æ„ï¼Œåœ¨ååºåˆ—åŒ–æœŸé—´ï¼Œå½“æ ¼å¼åŒ–å™¨çœ‹åˆ°ç±»å‹æä¾›çš„ä¸€ä¸ªæ–¹æ³•æ ‡è®°äº† <code>OnDeserialized</code> ç‰¹æ€§æ—¶ï¼Œæ ¼å¼åŒ–å™¨ä¼šå°†è¿™ä¸ªå¯¹è±¡çš„å¼•ç”¨æ·»åŠ åˆ°ä¸€ä¸ªå†…éƒ¨åˆ—è¡¨ä¸­ã€‚æ‰€æœ‰å¯¹è±¡éƒ½ååºåˆ—åŒ–ä¹‹åï¼Œæ ¼å¼åŒ–å™¨åå‘éå†åˆ—è¡¨ï¼Œè°ƒç”¨æ¯ä¸ªå¯¹è±¡çš„ <code>OnDeserialized</code> æ–¹æ³•ï¼Œè°ƒç”¨è¿™ä¸ªæ–¹æ³•åï¼Œæ‰€æœ‰å¯åºåˆ—åŒ–çš„å­—æ®µéƒ½ä¼šè¢«æ­£ç¡®è®¾ç½®ï¼Œå¯è®¿é—®è¿™äº›å­—æ®µæ¥æ‰§è¡Œä»»ä½•å¿…è¦çš„ã€è¿›ä¸€æ­¥çš„å·¥ä½œï¼Œä»è€Œå°†å¯¹è±¡å®Œæ•´åœ°ååºåˆ—åŒ–ã€‚ä¹‹æ‰€ä»¥è¦ä»¥ç›¸åçš„é¡ºåºè°ƒç”¨è¿™äº›æ–¹æ³•ï¼Œå› ä¸ºè¿™æ ·æ‰èƒ½ä½¿å†…å±‚å¯¹è±¡å…ˆäºå¤–å±‚å¯¹è±¡å®Œæˆååºåˆ—åŒ–ã€‚</p><p>ä¾‹å¦‚ï¼Œå‡å®šä¸€ä¸ªé›†åˆå¯¹è±¡ (æ¯”å¦‚ <code>Hashtable</code> æˆ– <code>Dictionary</code> ) å†…éƒ¨ç”¨ä¸€ä¸ªå“ˆå¸Œè¡¨ç»´æŠ¤å®ƒçš„æ•°æ®é¡¹åˆ—è¡¨ã€‚é›†åˆå¯¹è±¡ç±»å‹å¯å®ç°ä¸€ä¸ªæ ‡è®°äº† <code>OnDeserialized</code> ç‰¹æ€§çš„æ–¹æ³•ã€‚å³ä½¿é›†åˆå¯¹è±¡å…ˆååºåˆ—åŒ– (å…ˆäºå®ƒåŒ…å«çš„æ•°æ®é¡¹)ï¼Œå®ƒçš„ <code>OnDeserialized</code> æ–¹æ³•ä¹Ÿä¼šæœ€åè°ƒç”¨ (åœ¨è°ƒç”¨å®Œå®ƒçš„æ•°æ®é¡¹çš„æ‰€æœ‰ <code>OnDeserialized</code> æ–¹æ³•ä¹‹å)ã€‚è¿™æ ·ä¸€æ¥ï¼Œæ‰€æœ‰æ•°æ®é¡¹åœ¨ååºåˆ—åŒ–åï¼Œå®ƒä»¬çš„æ‰€æœ‰å­—æ®µéƒ½èƒ½å¾—åˆ°æ­£ç¡®çš„åˆå§‹åŒ–ï¼Œä»¥ä¾¿è®¡ç®—å‡ºä¸€ä¸ªå¥½çš„å“ˆå¸Œç å€¼ã€‚ç„¶åï¼Œé›†åˆå¯¹è±¡åˆ›å»ºå®ƒçš„å†…éƒ¨å“ˆå¸Œæ¡¶ï¼Œå¹¶åˆ©ç”¨æ•°æ®é¡¹çš„å“ˆå¸Œç å°†æ•°æ®é¡¹æ”¾åˆ°æ¡¶ä¸­ã€‚æœ¬ç« ç¨åçš„ 24.5 èŠ‚â€ æ§åˆ¶åºåˆ—åŒ– / ååºåˆ—åŒ–çš„æ•°æ® â€œä¼šæä¾›ä¸€ä¸ªä¾‹å­ï¼Œå®ƒå±•ç¤ºäº† <code>Dictionary</code> ç±»å¦‚ä½•åˆ©ç”¨è¿™ä¸ªæŠ€æœ¯ã€‚</p><blockquote><p>If you serialize an instance of a type, add a new field to the type, and then try to deserialize the object that did not contain the new field, the formatter throws a SerializationException with a message indicating that the data in the stream being deserialized has the wrong number of members. This is very problematic in versioning scenarios where it is common to add new fields to a type in a newer version. Fortunately, you can use the System.Runtime.Serialization.OptionalFieldAttribute attribute to help you.</p></blockquote><blockquote><p>You apply the OptionalFieldAttribute attribute to each new field you add to a type. Now, when the formatters see this attribute applied to a field, the formatters will not throw the SerializationException exception if the data in the stream does not contain the field.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šå°† <code>SerializableAttribute</code> å®šåˆ¶ç‰¹æ€§åº”ç”¨äºç±»å‹ï¼Œæ‰€æœ‰å®ä¾‹å­—æ®µ ( <code>public</code> ï¼Œ <code>private</code> å’Œ <code>protected</code> ç­‰) éƒ½ä¼šè¢«åºåˆ—åŒ–ã€‚ä½†ç±»å‹å¯èƒ½å®šä¹‰äº†ä¸€äº›ä¸åº”åºåˆ—åŒ–çš„å®ä¾‹å­—æ®µã€‚ä¸€èˆ¬æœ‰ä¸¤ä¸ªåŸå› é€ æˆæˆ‘ä»¬ä¸æƒ³åºåˆ—åŒ–éƒ¨åˆ†å®ä¾‹å­—æ®µã€‚ä¸€æ˜¯å­—æ®µå«æœ‰ååºåˆ—åŒ–åå˜å¾—æ— æ•ˆçš„ä¿¡æ¯ã€‚ä¾‹å¦‚ï¼Œå‡å®šå¯¹è±¡åŒ…å« Windows å†…æ ¸å¯¹è±¡ (å¦‚æ–‡ä»¶ã€è¿›ç¨‹ã€çº¿ç¨‹ã€äº’æ–¥ä½“ã€äº‹ä»¶ã€ä¿¡å·é‡ç­‰) çš„å¥æŸ„ï¼Œé‚£ä¹ˆåœ¨ååºåˆ—åŒ–åˆ°å¦ä¸€ä¸ªè¿›ç¨‹æˆ–å¦ä¸€å°æœºå™¨ä¹‹åï¼Œå°±ä¼šå¤±å»æ„ä¹‰ã€‚å› ä¸º Windows å†…æ ¸å¯¹è±¡æ˜¯è·Ÿè¿›ç¨‹ç›¸å…³çš„å€¼ã€‚äºŒæ˜¯å­—æ®µå«æœ‰å¾ˆå®¹æ˜“è®¡ç®—çš„ä¿¡æ¯ã€‚è¿™æ—¶è¦é€‰å‡ºé‚£äº›æ— é¡»åºåˆ—åŒ–çš„å­—æ®µï¼Œå‡å°‘éœ€è¦ä¼ è¾“çš„æ•°æ®ï¼Œå¢å¼ºåº”ç”¨ç¨‹åºçš„æ€§èƒ½ã€‚å¯ä»¥ä½¿ç”¨ <code>System.NonSerializedAttribute</code> å®šåˆ¶ç‰¹æ€§æŒ‡å‡ºç±»å‹ä¸­ä¸åº”åºåˆ—åŒ–çš„å­—æ®µã€‚æ³¨æ„ï¼Œè¯¥ç‰¹æ€§ä¹Ÿåœ¨ <code>System</code> (è€Œé <code>System.Runtime.Serialization</code> ) å‘½åç©ºé—´ä¸­å®šä¹‰ã€‚æ³¨æ„ï¼Œè¯¥ç‰¹æ€§åªèƒ½åº”ç”¨äºç±»å‹ä¸­çš„å­—æ®µï¼Œè€Œä¸”ä¼šè¢«æ´¾ç”Ÿç±»å‹ç»§æ‰¿ã€‚å½“ç„¶ï¼Œå¯å‘ä¸€ä¸ªç±»å‹ä¸­çš„å¤šä¸ªå­—æ®µåº”ç”¨ <code>NonSerializedAttribute</code> ç‰¹æ€§ã€‚åœ¨æ ‡è®°äº† <code>[Serializable]</code> ç‰¹æ€§çš„ç±»å‹ä¸­ï¼Œä¸è¦ç”¨ C# çš„ â€œè‡ªåŠ¨å®ç°çš„å±æ€§â€ åŠŸèƒ½æ¥å®šä¹‰å±æ€§ã€‚è¿™æ˜¯ç”±äºå­—æ®µåæ˜¯ç”±ç¼–è¯‘å™¨è‡ªåŠ¨ç”Ÿæˆçš„ï¼Œè€Œç”Ÿæˆçš„åç§°æ¯æ¬¡é‡æ–°ç¼–è¯‘ä»£ç æ—¶éƒ½ä¸åŒã€‚è¿™ä¼šé˜»æ­¢ç±»å‹è¢«ååºåˆ—åŒ–ã€‚å¯ä»¥ä½¿ç”¨ <code>System.Runtime.Serialization.OnDeserializedAttribute</code> å®šåˆ¶ç‰¹æ€§æ ‡è®°æ–¹æ³•ã€‚æ¯æ¬¡ååºåˆ—åŒ–ç±»å‹çš„å®ä¾‹ï¼Œæ ¼å¼åŒ–å™¨éƒ½ä¼šæ£€æŸ¥ç±»å‹ä¸­æ˜¯å¦å®šä¹‰äº†åº”ç”¨äº†è¯¥ç‰¹æ€§çš„æ–¹æ³•ã€‚å¦‚æœæ˜¯ï¼Œå°±è°ƒç”¨è¯¥æ–¹æ³•ã€‚è°ƒç”¨è¿™ä¸ªæ–¹æ³•æ—¶ï¼Œæ‰€æœ‰å¯åºåˆ—åŒ–çš„å­—æ®µéƒ½ä¼šè¢«æ­£ç¡®è®¾ç½®ã€‚åœ¨è¯¥æ–¹æ³•ä¸­ï¼Œå¯èƒ½éœ€è¦è®¿é—®è¿™äº›å­—æ®µæ¥æ‰§è¡Œä¸€äº›é¢å¤–çš„å·¥ä½œï¼Œä»è€Œç¡®ä¿å¯¹è±¡çš„å®Œå…¨ååºåˆ—åŒ–ã€‚é™¤äº† <code>OnDeserializedAttribute</code> è¿™ä¸ªå®šåˆ¶ç‰¹æ€§ï¼Œ <code>System.Runtime.Serialization</code> å‘½åç©ºé—´è¿˜å®šä¹‰äº†åŒ…æ‹¬ <code>OnSerializingAttribute</code> ï¼Œ <code>OnSerializedAttribute</code> å’Œ <code>OnDeserializingAttribute</code> åœ¨å†…çš„å…¶ä»–å®šåˆ¶ç‰¹æ€§ã€‚å¯å°†å®ƒä»¬åº”ç”¨äºç±»å‹ä¸­å®šä¹‰çš„æ–¹æ³•ï¼Œå¯¹åºåˆ—åŒ–å’Œååºåˆ—åŒ–è¿‡ç¨‹è¿›è¡Œæ›´å¤šçš„æ§åˆ¶ã€‚ä½¿ç”¨è¿™ 4 ä¸ªå±æ€§ä¸­çš„ä»»ä½•ä¸€ä¸ªæ—¶ï¼Œä½ å®šä¹‰çš„æ–¹æ³•å¿…é¡»è·å–ä¸€ä¸ª <code>StreamingContext</code> å‚æ•°å¹¶è¿”å› <code>void</code> ã€‚æ–¹æ³•åå¯ä»¥æ˜¯ä½ å¸Œæœ›çš„ä»»ä½•åç§°ã€‚å¦å¤–ï¼Œåº”å°†æ–¹æ³•å£°æ˜ä¸º <code>private</code> ï¼Œä»¥å…å®ƒè¢«æ™®é€šçš„ä»£ç è°ƒç”¨ï¼›æ ¼å¼åŒ–å™¨è¿è¡Œæ—¶æœ‰å……è¶³çš„å®‰å…¨æƒé™ï¼Œæ‰€ä»¥èƒ½è°ƒç”¨ç§æœ‰æ–¹æ³•ã€‚å¦‚æœåºåˆ—åŒ–ç±»å‹çš„å®ä¾‹ï¼Œåœ¨ç±»å‹ä¸­æ·»åŠ æ–°å­—æ®µï¼Œç„¶åè¯•å›¾ååºåˆ—åŒ–ä¸åŒ…å«æ–°å­—æ®µçš„å¯¹è±¡ï¼Œæ ¼å¼åŒ–å™¨ä¼šæŠ›å‡º <code>SerializationException</code> å¼‚å¸¸ï¼Œå¹¶æ˜¾ç¤ºä¸€æ¡æ¶ˆæ¯å‘Šè¯‰ä½ æµä¸­è¦ååºåˆ—åŒ–çš„æ•°æ®åŒ…å«é”™è¯¯çš„æˆå‘˜æ•°ç›®ã€‚è¿™éå¸¸ä¸åˆ©äºç‰ˆæœ¬æ§åˆ¶ï¼Œå› ä¸ºæˆ‘ä»¬ç»å¸¸éƒ½è¦åœ¨ç±»å‹çš„æ–°ç‰ˆæœ¬ä¸­æ·»åŠ æ–°å­—æ®µã€‚å¹¸å¥½ï¼Œè¿™æ—¶å¯ä»¥åˆ©ç”¨ <code>System.Runtime.Serialization.OptionalFieldAttribute</code> ç‰¹æ€§ã€‚ç±»å‹ä¸­æ–°å¢çš„æ¯ä¸ªå­—æ®µéƒ½è¦åº”ç”¨ <code>OptionalFieldAttribute</code> ç‰¹æ€§ã€‚ç„¶åï¼Œå½“æ ¼å¼åŒ–å™¨çœ‹åˆ°è¯¥ç‰¹æ€§åº”ç”¨äºä¸€ä¸ªå­—æ®µæ—¶ï¼Œå°±ä¸ä¼šå› ä¸ºæµä¸­çš„æ•°æ®ä¸åŒ…å«è¿™ä¸ªå­—æ®µè€ŒæŠ›å‡º <code>SerializationException</code> ã€‚</p><h2 id="how-formatters-serialize-type-instances"><a class="anchor" href="#how-formatters-serialize-type-instances">#</a> How Formatters Serialize Type Instances</h2><blockquote><p>In this section, I give a bit more insight into how a formatter serializes an objectâ€™s fields. This knowledge can help you understand the more advanced serialization and deserialization techniques explained in the remainder of this chapter.</p></blockquote><blockquote><p>To make things easier for a formatter, the FCL offers a FormatterServices type in the System. Runtime.Serialization namespace. This type has only static methods in it, and no instances of the type may be instantiated. The following steps describe how a formatter automatically serializes an object whose type has the SerializableAttribute attribute applied to it.</p><ol><li>The formatter calls FormatterServicesâ€™s GetSerializableMembers method. public static MemberInfo[] GetSerializableMembers(Type type, StreamingContext context); This method uses reflection to get the typeâ€™s public and private instance fields (excluding any fields marked with the NonSerializedAttribute attribute). The method returns an array of MemberInfo objects, one for each serializable instance field.</li><li>The object being serialized and the array of System.Reflection.MemberInfo objects are then passed to FormatterServicesâ€™ static GetObjectData method. public static Object[] GetObjectData(Object obj, MemberInfo[] members); This method returns an array of Objects where each element identifies the value of a field in the object being serialized. This Object array and the MemberInfo array are parallel. That is, element 0 in the Object array is the value of the member identified by element 0 in the MemberInfo array.</li><li>The formatter writes the assemblyâ€™s identity and the typeâ€™s full name to the stream.</li><li>The formatter then enumerates over the elements in the two arrays, writing each memberâ€™s name and value to the stream.</li></ol></blockquote><blockquote><p>The following steps describe how a formatter automatically deserializes an object whose type has the SerializableAttribute attribute applied to it:</p><ol><li>The formatter reads the assemblyâ€™s identity and full type name from the stream. If the assembly is not currently loaded into the AppDomain, it is loaded (as described earlier). If the assembly canâ€™t be loaded, a SerializationException exception is thrown and the object cannot be deserialized. If the assembly is loaded, the formatter passes the assembly identity information and the typeâ€™s full name to FormatterServicesâ€™ static GetTypeFromAssembly method. public static Type GetTypeFromAssembly(Assembly assem, String name); This method returns a System.Type object indicating the type of object that is being deserialized.</li><li>The formatter calls FormatterServicesâ€™s static GetUninitializedObject method. public static Object GetUninitializedObject(Type type); This method allocates memory for a new object but does not call a constructor for the object. However, all the objectâ€™s bytes are initialized to null or 0.</li><li>The formatter now constructs and initializes a MemberInfo array as it did before by calling the FormatterServicesâ€™s GetSerializableMembers method. This method returns the set of fields that were serialized and that need to be deserialized.</li><li>The formatter creates and initializes an Object array from the data contained in the stream.</li><li>The reference to the newly allocated object, the MemberInfo array, and the parallel Object array of field values is passed to FormatterServicesâ€™ static PopulateObjectMembers method.</li></ol></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Object</span> <span class="token function">PopulateObjectMembers</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token class-name">Object</span> obj<span class="token punctuation">,</span> <span class="token class-name">MemberInfo<span class="token punctuation">[</span><span class="token punctuation">]</span></span> members<span class="token punctuation">,</span> <span class="token class-name">Object<span class="token punctuation">[</span><span class="token punctuation">]</span></span> data<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>This method enumerates over the arrays, initializing each field to its corresponding value. At this point, the object has been completely deserialized.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šä¸ºäº†ç®€åŒ–æ ¼å¼åŒ–å™¨çš„æ“ä½œï¼ŒFCL åœ¨ <code>System.Runtime.Serialization</code> å‘½åç©ºé—´æä¾›äº†ä¸€ä¸ª <code>FormatterServices</code> ç±»å‹ã€‚è¯¥ç±»å‹åªåŒ…å«é™æ€æ–¹æ³•ï¼Œè€Œä¸”è¯¥ç±»å‹ä¸èƒ½å®ä¾‹åŒ–ã€‚ä»¥ä¸‹æ­¥éª¤æè¿°äº†æ ¼å¼åŒ–å™¨å¦‚ä½•è‡ªåŠ¨åºåˆ—åŒ–ç±»å‹åº”ç”¨äº† <code>SerializableAttribute</code> ç‰¹æ€§çš„å¯¹è±¡ã€‚1. æ ¼å¼åŒ–å™¨è°ƒç”¨ <code>FormatterServices</code> çš„ <code>GetSerializableMembers</code> æ–¹æ³•ã€‚è¿™ä¸ªæ–¹æ³•åˆ©ç”¨åå°„è·å–ç±»å‹çš„ <code>public</code> å’Œ <code>private</code> å®ä¾‹å­—æ®µ (æ ‡è®°äº† <code>NonSerializedAttribute</code> ç‰¹æ€§çš„å­—æ®µé™¤å¤–)ã€‚æ–¹æ³•è¿”å›ç”± <code>MemberInfo</code> å¯¹è±¡æ„æˆçš„æ•°ç»„ï¼Œå…¶ä¸­æ¯ä¸ªå…ƒç´ éƒ½å¯¹åº”ä¸€ä¸ªå¯åºåˆ—åŒ–çš„å®ä¾‹å­—æ®µã€‚2. å¯¹è±¡è¢«åºåˆ—åŒ–ï¼Œ <code>System.Reflection.MemberInfo</code> å¯¹è±¡æ•°ç»„ä¼ ç»™ <code>FormatterServices</code> çš„é™æ€æ–¹æ³• <code>GetObjectData</code> ã€‚è¿™ä¸ªæ–¹æ³•è¿”å›ä¸€ä¸ª <code>Object</code> æ•°ç»„ï¼Œå…¶ä¸­æ¯ä¸ªå…ƒç´ éƒ½æ ‡è¯†äº†è¢«åºåˆ—åŒ–çš„é‚£ä¸ªå¯¹è±¡ä¸­çš„ä¸€ä¸ªå­—æ®µçš„å€¼ã€‚è¿™ä¸ª <code>Object</code> æ•°ç»„å’Œ <code>MemberInfo</code> æ•°ç»„æ˜¯å¹¶è¡Œ (parallel) çš„ï¼›æ¢è¨€ä¹‹ï¼Œ <code>Object</code> æ•°ç»„ä¸­å…ƒç´  0 æ˜¯ <code>MemberInfo</code> æ•°ç»„ä¸­çš„å…ƒç´  0 æ‰€æ ‡è¯†çš„é‚£ä¸ªæˆå‘˜çš„å€¼ã€‚3. æ ¼å¼åŒ–å™¨å°†ç¨‹åºé›†æ ‡è¯†å’Œç±»å‹çš„å®Œæ•´åç§°å†™å…¥æµä¸­ã€‚4. æ ¼å¼åŒ–å™¨ç„¶åéå†ä¸¤ä¸ªæ•°ç»„ä¸­çš„å…ƒç´ ï¼Œå°†æ¯ä¸ªæˆå‘˜çš„åç§°å’Œå€¼å†™å…¥æµä¸­ã€‚ä»¥ä¸‹æ­¥éª¤æè¿°äº†æ ¼å¼åŒ–å™¨å¦‚ä½•è‡ªåŠ¨ååºåˆ—åŒ–ç±»å‹åº”ç”¨äº† <code>SerializableAttribute</code> ç‰¹æ€§çš„å¯¹è±¡ã€‚1. æ ¼å¼åŒ–å™¨ä»æµä¸­è¯»å–ç¨‹åºé›†æ ‡è¯†å’Œå®Œæ•´ç±»å‹åç§°ã€‚å¦‚æœç¨‹åºé›†å½“å‰æ²¡æœ‰åŠ è½½åˆ° AppDomain ä¸­ï¼Œå°±åŠ è½½å®ƒ (è¿™ä¸€ç‚¹å‰é¢å·²ç»è®²è¿‡äº†)ã€‚å¦‚æœç¨‹åºé›†ä¸èƒ½åŠ è½½ï¼Œå°±æŠ›å‡ºä¸€ä¸ª <code>SerializationException</code> å¼‚å¸¸ï¼Œå¯¹è±¡ä¸èƒ½ååºåˆ—åŒ–ã€‚å¦‚æœç¨‹åºé›†å·²åŠ è½½ï¼Œæ ¼å¼åŒ–å™¨å°†ç¨‹åºé›†æ ‡è¯†ä¿¡æ¯å’Œç±»å‹å…¨åä¼ ç»™ <code>FormatterServices</code> çš„é™æ€æ–¹æ³• <code>GetTypeFromAssembly</code> ã€‚ è¿™ä¸ªæ–¹æ³•è¿”å›ä¸€ä¸ª <code>System.Type</code> å¯¹è±¡ï¼Œå®ƒä»£è¡¨è¦ååºåˆ—åŒ–çš„é‚£ä¸ªå¯¹è±¡çš„ç±»å‹ã€‚2. æ ¼å¼åŒ–å™¨è°ƒç”¨ <code>FormmatterServices</code> çš„é™æ€æ–¹æ³• <code>GetUninitializedObject</code> ã€‚è¿™ä¸ªæ–¹æ³•ä¸ºä¸€ä¸ªæ–°å¯¹è±¡åˆ†é…å†…å­˜ï¼Œä½†ä¸ä¸ºå¯¹è±¡è°ƒç”¨æ„é€ å™¨ã€‚ç„¶è€Œï¼Œå¯¹è±¡çš„æ‰€æœ‰å­—èŠ‚éƒ½è¢«åˆå§‹ä¸º <code>null</code> æˆ– <code>0</code> ã€‚3. æ ¼å¼åŒ–å™¨ç°åœ¨æ„é€ å¹¶åˆå§‹åŒ–ä¸€ä¸ª <code>MemberInfo</code> æ•°ç»„ï¼Œå…·ä½“åšæ³•å’Œå‰é¢ä¸€æ ·ï¼Œéƒ½æ˜¯è°ƒç”¨ <code>FormatterServices</code> çš„ <code>GetSerializableMembers</code> æ–¹æ³•ã€‚è¿™ä¸ªæ–¹æ³•è¿”å›åºåˆ—åŒ–å¥½ã€ç°åœ¨éœ€è¦ååºåˆ—åŒ–çš„ä¸€ç»„å­—æ®µã€‚4. æ ¼å¼åŒ–å™¨æ ¹æ®æµä¸­åŒ…å«çš„æ•°æ®åˆ›å»ºå¹¶åˆå§‹åŒ–ä¸€ä¸ª <code>Object</code> æ•°ç»„ã€‚5. å°†æ–°åˆ†é…å¯¹è±¡ã€ <code>MemberInfo</code> æ•°ç»„ä»¥åŠå¹¶è¡Œ <code>Object</code> æ•°ç»„ (å…¶ä¸­åŒ…å«å­—æ®µå€¼) çš„å¼•ç”¨ä¼ ç»™ <code>FormatterServices</code> çš„é™æ€æ–¹æ³• <code>PopulateObjectMembers</code> ã€‚è¿™ä¸ªæ–¹æ³•éå†æ•°ç»„ï¼Œå°†æ¯ä¸ªå­—æ®µåˆå§‹åŒ–æˆå¯¹åº”çš„å€¼ã€‚åˆ°æ­¤ä¸ºæ­¢ï¼Œå¯¹è±¡å°±ç®—æ˜¯è¢«å½»åº•ååºåˆ—åŒ–äº†ã€‚</p><h2 id="controlling-the-serializeddeserialized-data"><a class="anchor" href="#controlling-the-serializeddeserialized-data">#</a> Controlling the Serialized/Deserialized Data</h2><blockquote><p>As discussed earlier in this chapter, the best way to get control over the serialization and deserialization process is to use the OnSerializing, OnSerialized, OnDeserializing, OnDeserialized, NonSerialized, and OptionalField attributes. However, there are some very rare scenarios where these attributes do not give you all the control you need. In addition, the formatters use reflection internally and reflection is slow, which increases the time it takes to serialize and deserialize objects. To get complete control over what data is serialized/deserialized or to eliminate the use of reflection, your type can implement the System.Runtime.Serialization.ISerializable interface, which is defined as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ISerializable</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">GetObjectData</span><span class="token punctuation">(</span><span class="token class-name">SerializationInfo</span> info<span class="token punctuation">,</span> <span class="token class-name">StreamingContext</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>This interface has just one method in it, GetObjectData. But most types that implement this interface will also implement a special constructor that Iâ€™ll describe shortly.</p></blockquote><p>ğŸ’¡é‡è¦æç¤ºï¼š <code>ISerializable</code> æ¥å£æœ€å¤§çš„é—®é¢˜åœ¨äºï¼Œä¸€æ—¦ç±»å‹å®ç°äº†å®ƒï¼Œæ‰€æœ‰æ´¾ç”Ÿç±»å‹ä¹Ÿå¿…é¡»å®ç°å®ƒï¼Œè€Œä¸”æ´¾ç”Ÿç±»å‹å¿…é¡»ä¿è¯è°ƒç”¨åŸºç±»çš„ <code>GetObjectData</code> æ–¹æ³•å’Œç‰¹æ®Šæ„é€ å™¨ã€‚æ­¤å¤–ï¼Œä¸€æ—¦ç±»å‹å®ç°äº†è¯¥æ¥å£ï¼Œä¾¿æ°¸è¿œä¸èƒ½åˆ é™¤å®ƒï¼Œå¦åˆ™ä¼šå¤±å»ä¸æ´¾ç”Ÿç±»å‹çš„å…¼å®¹æ€§ã€‚æ‰€ä»¥ï¼Œå¯†å°ç±»å®ç° <code>ISerializable</code> æ¥å£æ˜¯æœ€è®©äººæ”¾å¿ƒçš„ã€‚ä½¿ç”¨æœ¬ç« å‰é¢æè¿°çš„å„ç§å®šåˆ¶ç‰¹æ€§ï¼Œ <code>ISerializable</code> æ¥å£çš„æ‰€æœ‰é—®é¢˜éƒ½å¯ä»¥é¿å…ã€‚</p><p>é‡è¦æç¤ºï¼š <code>ISerializable</code> æ¥å£å’Œç‰¹æ®Šæ„é€ å™¨æ—¨åœ¨ç”±æ ¼å¼åŒ–å™¨ä½¿ç”¨ã€‚ä½†å…¶ä»–ä»£ç å¯èƒ½è°ƒç”¨ <code>GetObjectData</code> æ¥è¿”å›æ•æ„Ÿæ•°æ®ã€‚å¦å¤–ï¼Œå…¶ä»–ä»£ç å¯èƒ½æ„é€ å¯¹è±¡ï¼Œå¹¶ä¼ å…¥æŸåçš„æ•°æ®ã€‚å› æ­¤ï¼Œå»ºè®®å‘ <code>GetObjectData</code> æ–¹æ³•å’Œç‰¹æ®Šæ„é€ å™¨åº”ç”¨ä»¥ä¸‹ç‰¹æ€§ï¼š<br><code>[SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]</code></p><blockquote><p>When a formatter serializes an object graph, it looks at each object. If its type implements the ISerializable interface, then the formatter ignores all custom attributes and instead constructs a new System.Runtime.Serialization.SerializationInfo object. This object contains the actual set of values that should be serialized for the object.</p></blockquote><blockquote><p>When constructing a SerializationInfo, the formatter passes two parameters: Type and System.Runtime.Serialization.IFormatterConverter. The Type parameter identifies the object that is being serialized. Two pieces of information are required to uniquely identify a type: the string name of the type and its assemblyâ€™s identity (which includes the assembly name, version, culture, and public key). When a SerializationInfo object is constructed, it obtains the typeâ€™s full name (by internally querying Typeâ€™s FullName property) and stores this string in a private field. You can obtain the typeâ€™s full name by querying SerializationInfoâ€™s FullTypeName property. Likewise, the constructor obtains the typeâ€™s defining assembly (by internally querying Typeâ€™s Module property followed by querying Moduleâ€™s Assembly property followed by querying Assemblyâ€™s FullName property) and stores this string in a private field. You can obtain the assemblyâ€™s identity by querying SerializationInfoâ€™s AssemblyName property.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šè™½ç„¶å¯ä»¥è®¾ç½®ä¸€ä¸ª <code>SerializationInfo</code> çš„ <code>FullTypeName</code> å’Œ <code>AssemblyName</code> å±æ€§ï¼Œä½†ä¸å»ºè®®è¿™æ ·åšã€‚å¦‚æœæƒ³è¦æ›´æ”¹è¢«åºåˆ—åŒ–çš„ç±»å‹ï¼Œå»ºè®®è°ƒç”¨ <code>SerializationInfo</code> çš„ <code>SetType</code> æ–¹æ³•ï¼Œä¼ é€’å¯¹ç›®æ ‡ <code>Type</code> å¯¹è±¡çš„å¼•ç”¨ã€‚è°ƒç”¨ <code>SetType</code> å¯ç¡®ä¿ç±»å‹çš„å…¨åå’Œå®šä¹‰ç¨‹åºé›†è¢«æ­£ç¡®è®¾ç½®ã€‚æœ¬ç« åé¢çš„ 24.7 èŠ‚ â€œç±»å‹åºåˆ—åŒ–ä¸ºä¸åŒç±»å‹ä»¥åŠå¯¹è±¡ååºåˆ—åŒ–ä¸ºä¸åŒå¯¹è±¡â€ å°†å±•ç¤ºè°ƒç”¨ <code>SetType</code> çš„ä¸€ä¸ªä¾‹å­ã€‚</p><blockquote><p>After the SerializationInfo object is constructed and initialized, the formatter calls the typeâ€™s GetObjectData method, passing it the reference to the SerializationInfo object. The GetObjectData method is responsible for determining what information is necessary to serialize the object and adding this information to the SerializationInfo object. GetObjectData indicates what information to serialize by calling one of the many overloaded AddValue methods provided by the SerializationInfo type. AddValue is called once for each piece of data that you want to add.</p></blockquote><blockquote><p>The following code shows an approximation of how the Dictionary type implements the ISerializable and IDeserializationCallback interfaces to take control over the serialization and deserialization of its objects.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Serializable</span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Dictionary<span class="token punctuation">&lt;</span>TKey<span class="token punctuation">,</span> TValue<span class="token punctuation">></span></span><span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">ISerializable</span><span class="token punctuation">,</span> <span class="token class-name">IDeserializationCallback</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// Private fields go here (not shown)</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">SerializationInfo</span> m_siInfo<span class="token punctuation">;</span> <span class="token comment">// Only used for deserialization</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// Special constructor (required by ISerializable) to control deserialization</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">[</span><span class="token function">SecurityPermissionAttribute</span><span class="token punctuation">(</span>SecurityAction<span class="token punctuation">.</span>Demand<span class="token punctuation">,</span> SerializationFormatter <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">protected</span> <span class="token function">Dictionary</span><span class="token punctuation">(</span><span class="token class-name">SerializationInfo</span> info<span class="token punctuation">,</span> <span class="token class-name">StreamingContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// During deserialization, save the SerializationInfo for OnDeserialization</span></pre></td></tr><tr><td data-num="9"></td><td><pre> m_siInfo <span class="token operator">=</span> info<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// Method to control serialization</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">[</span>SecurityCritical<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">GetObjectData</span><span class="token punctuation">(</span><span class="token class-name">SerializationInfo</span> info<span class="token punctuation">,</span> <span class="token class-name">StreamingContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> </pre></td></tr><tr><td data-num="15"></td><td><pre> info<span class="token punctuation">.</span><span class="token function">AddValue</span><span class="token punctuation">(</span><span class="token string">"Version"</span><span class="token punctuation">,</span> m_version<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre> info<span class="token punctuation">.</span><span class="token function">AddValue</span><span class="token punctuation">(</span><span class="token string">"Comparer"</span><span class="token punctuation">,</span> m_comparer<span class="token punctuation">,</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">IEqualityComparer<span class="token punctuation">&lt;</span>TKey<span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre> info<span class="token punctuation">.</span><span class="token function">AddValue</span><span class="token punctuation">(</span><span class="token string">"HashSize"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">m_</span> buckets <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">?</span> <span class="token number">0</span> <span class="token punctuation">:</span> m_buckets<span class="token punctuation">.</span>Length<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>m_buckets <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token class-name">KeyValuePair<span class="token punctuation">&lt;</span>TKey<span class="token punctuation">,</span> TValue<span class="token punctuation">></span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">KeyValuePair<span class="token punctuation">&lt;</span>TKey<span class="token punctuation">,</span> TValue<span class="token punctuation">></span></span><span class="token punctuation">[</span>Count<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token function">CopyTo</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre> info<span class="token punctuation">.</span><span class="token function">AddValue</span><span class="token punctuation">(</span><span class="token string">"KeyValuePairs"</span><span class="token punctuation">,</span> array<span class="token punctuation">,</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">KeyValuePair<span class="token punctuation">&lt;</span>TKey<span class="token punctuation">,</span> TValue<span class="token punctuation">></span><span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token comment">// Method called after all key/value objects have been deserialized </span></pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> IDeserializationCallback<span class="token punctuation">.</span><span class="token function">OnDeserialization</span><span class="token punctuation">(</span><span class="token class-name">Object</span> sender<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>m_siInfo <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// Never set, return</span></pre></td></tr><tr><td data-num="27"></td><td><pre> <span class="token class-name">Int32</span> num <span class="token operator">=</span> m_siInfo<span class="token punctuation">.</span><span class="token function">GetInt32</span><span class="token punctuation">(</span><span class="token string">"Version"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre> <span class="token class-name">Int32</span> num2 <span class="token operator">=</span> m_siInfo<span class="token punctuation">.</span><span class="token function">GetInt32</span><span class="token punctuation">(</span><span class="token string">"HashSize"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre> m_comparer <span class="token operator">=</span> <span class="token punctuation">(</span>IEqualityComparer<span class="token operator">&lt;</span>TKey<span class="token operator">></span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="30"></td><td><pre> m_siInfo<span class="token punctuation">.</span><span class="token function">GetValue</span><span class="token punctuation">(</span><span class="token string">"Comparer"</span><span class="token punctuation">,</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">IEqualityComparer<span class="token punctuation">&lt;</span>TKey<span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>num2 <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre> m_buckets <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Int32</span><span class="token punctuation">[</span>num2<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m_buckets<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> m_buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre> m_entries <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Entry<span class="token punctuation">&lt;</span>TKey<span class="token punctuation">,</span> TValue<span class="token punctuation">></span></span><span class="token punctuation">[</span>num2<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre> m_freeList <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre> <span class="token class-name">KeyValuePair<span class="token punctuation">&lt;</span>TKey<span class="token punctuation">,</span> TValue<span class="token punctuation">></span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> pairArray <span class="token operator">=</span> <span class="token punctuation">(</span>KeyValuePair<span class="token operator">&lt;</span>TKey<span class="token punctuation">,</span> TValue<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="37"></td><td><pre> m_siInfo<span class="token punctuation">.</span><span class="token function">GetValue</span><span class="token punctuation">(</span><span class="token string">"KeyValuePairs"</span><span class="token punctuation">,</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">KeyValuePair<span class="token punctuation">&lt;</span>TKey<span class="token punctuation">,</span> TValue<span class="token punctuation">></span><span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>pairArray <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="39"></td><td><pre> ThrowHelper<span class="token punctuation">.</span><span class="token function">ThrowSerializationException</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="40"></td><td><pre> ExceptionResource<span class="token punctuation">.</span>Serialization_MissingKeys<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> pairArray<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="42"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>pairArray<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>Key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="43"></td><td><pre> ThrowHelper<span class="token punctuation">.</span><span class="token function">ThrowSerializationException</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="44"></td><td><pre> ExceptionResource<span class="token punctuation">.</span>Serialization_NullKey<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre> </pre></td></tr><tr><td data-num="46"></td><td><pre> <span class="token function">Insert</span><span class="token punctuation">(</span>pairArray<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>Key<span class="token punctuation">,</span> pairArray<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>Value<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="47"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="48"></td><td><pre> <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> m_buckets <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="49"></td><td><pre> m_version <span class="token operator">=</span> num<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="50"></td><td><pre> m_siInfo <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="51"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Each AddValue method takes a String name and some data. Usually, the data is of a simple value type like Boolean, Char, Byte, SByte, Int16, UInt16, Int32, UInt32, Int64, UInt64, Single, Double, Decimal, or DateTime. However, you can also call AddValue, passing it a reference to an Object such as a String. After GetObjectData has added all of the necessary serialization information, it returns to the formatter.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šåŠ¡å¿…è°ƒç”¨ <code>AddValue</code> æ–¹æ³•çš„æŸä¸ªé‡è½½ç‰ˆæœ¬ä¸ºè‡ªå·±çš„ç±»å‹æ·»åŠ åºåˆ—åŒ–ä¿¡æ¯ã€‚å¦‚æœä¸€ä¸ªå­—æ®µçš„ç±»å‹å®ç°äº† <code>ISerializable</code> æ¥å£ï¼Œå°±ä¸è¦åœ¨å­—æ®µä¸Šè°ƒç”¨ <code>GetObjectData</code> ã€‚ç›¸åï¼Œè°ƒç”¨ <code>AddValue</code> æ¥æ·»åŠ å­—æ®µï¼›æ ¼å¼åŒ–å™¨ä¼šæ³¨æ„åˆ°å­—æ®µçš„ç±»å‹å®ç°äº† <code>ISerializable</code> ï¼Œä¼šå¸®ä½ è°ƒç”¨ <code>GetObjectData</code> ã€‚å¦‚æœè‡ªå·±åœ¨å­—æ®µå¯¹è±¡ä¸Šè°ƒç”¨ <code>GetObjectData</code> ï¼Œæ ¼å¼åŒ–å™¨ä¾¿ä¸çŸ¥é“åœ¨å¯¹æµè¿›è¡Œååºåˆ—åŒ–æ—¶åˆ›å»ºæ–°å¯¹è±¡ã€‚</p><blockquote><p>The formatter now takes all of the values added to the SerializationInfo object and serializes each of them out to the stream. Youâ€™ll notice that the GetObjectData method is passed another parameter: a reference to a System.Runtime.Serialization.StreamingContext object. Most typesâ€™ GetObjectData methods will completely ignore this parameter, so I will not discuss it now. Instead, Iâ€™ll discuss it in the â€œStreaming Contextsâ€ section later in this chapter.</p></blockquote><blockquote><p>So now you know how to set all of the information used for serialization. At this point, letâ€™s turn our attention to deserialization. As the formatter extracts an object from the stream, it allocates memory for the new object (by calling the System.Runtime.Serialization.FormatterServices typeâ€™s static GetUninitializedObject method). Initially, all of this objectâ€™s fields are set to 0 or null. Then, the formatter checks if the type implements the ISerializable interface. If this interface exists, the formatter attempts to call a special constructor whose parameters are identical to that of the GetObjectData method.</p></blockquote><blockquote><p>If your class is sealed, then it is highly recommended that you declare this special constructor to be private. This will prevent any code from accidentally calling increasing security. If not, then you should declare this special constructor as protected so that only derived classes can call it. Note that the formatters are able to call this special constructor no matter how it is declared.</p></blockquote><blockquote><p>This constructor receives a reference to a SerializationInfo object containing all of the values added to it when the object was serialized. The special constructor can call any of the GetBoolean, GetChar, GetByte, GetSByte, GetInt16, GetUInt16, GetInt32, GetUInt32, GetInt64, GetUInt64, GetSingle, GetDouble, GetDecimal, GetDateTime, GetString, and GetValue methods, passing in a string corresponding to the name used to serialize a value. The value returned from each of these methods is then used to initialize the fields of the new object.</p></blockquote><blockquote><p>When deserializing an objectâ€™s fields, you should call the Get method that matches the type of value that was passed to the AddValue method when the object was serialized. In other words, if the GetObjectData method called AddValue, passing it an Int32 value, then the GetInt32 method should be called for the same value when deserializing the object. If the valueâ€™s type in the stream doesnâ€™t match the type youâ€™re trying to get, then the formatter will attempt to use an IFormatterConvert object to â€œcastâ€ the streamâ€™s value to the desired type.</p></blockquote><blockquote><p>As I mentioned earlier, when a SerializationInfo object is constructed, it is passed an object whose type implements the IFormatterConverter interface. Because the formatter is responsible for constructing the SerializationInfo object, it chooses whatever IFormatterConverter type it wants. Microsoftâ€™s BinaryFormatter and SoapFormatter types always construct an instance of the System.Runtime.Serialization.FormatterConverter type. Microsoftâ€™s formatters donâ€™t offer any way for you to select a different IFormatterConverter type.</p></blockquote><blockquote><p>The FormatterConverter type calls the System.Convert classâ€™s static methods to convert values between the core types, such as converting an Int32 to an Int64. However, to convert a value between other arbitrary types, the FormatterConverter calls Convertâ€™s ChangeType method to cast the serialized (or original) type to an IConvertible interface and then calls the appropriate interface method. Therefore, to allow objects of a serializable type to be deserialized as a different type, you may want to consider having your type implement the IConvertible interface. Note that the FormatterConverter object is used only when deserializing objects and when youâ€™re calling a Get method whose type doesnâ€™t match the type of the value in the stream.</p></blockquote><blockquote><p>Instead of calling the various Get methods previously listed, the special constructor could instead call GetEnumerator, which returns a System.Runtime.Serialization.SerializationInfoEnumerator object that can be used to iterate through all the values contained within the SerializationInfo object. Each value enumerated is a System.Runtime.Serialization. SerializationEntry object.</p></blockquote><blockquote><p>Of course, you are welcome to define a type of your own that derives from a type that implements ISerializableâ€™s GetObjectData and special constructor. If your type also implements ISerializable, then your implementation of GetObjectData and your implementation of the special constructor must call the same functions in the base class in order for the object to be serialized and deserialized properly. Do not forget to do this or the objects will not serialize or deserialize correctly. The next section explains how to properly define an ISerializable type whose base type doesnâ€™t implement this interface.</p></blockquote><blockquote><p>If your derived type doesnâ€™t have any additional fields in it and therefore has no special serialization/deserialization needs, then you do not have to implement ISerializable at all. Like all interface members, GetObjectData is virtual and will be called to properly serialize the object. In addition, the formatter treats the special constructor as â€œvirtualized.â€ That is, during deserialization, the formatter will check the type that it is trying to instantiate. If that type doesnâ€™t offer the special constructor, then the formatter will scan base classes until it finds one that implements the special constructor.</p></blockquote><p>ğŸ’¡é‡è¦æç¤ºï¼šç‰¹æ®Šæ„é€ å™¨ä¸­çš„ä»£ç ä¸€èˆ¬ä»ä¼ ç»™å®ƒçš„ <code>SerializationInfo</code> å¯¹è±¡ä¸­æå–å­—æ®µã€‚æå–å­—æ®µåï¼Œä¸ä¿è¯å¯¹è±¡å·²å®Œå…¨ååºåˆ—åŒ–ï¼Œæ‰€ä»¥ç‰¹æ®Šæ„é€ å™¨ä¸­çš„ä»£ç ä¸åº”è¯¥å°è¯•æ“ä½œå®ƒæå–çš„å¯¹è±¡ã€‚</p><p>å¦‚æœä½ çš„ç±»å‹å¿…é¡»è®¿é—®æå–çš„å¯¹è±¡ä¸­çš„æˆå‘˜ (æ¯”å¦‚è°ƒç”¨æ–¹æ³•)ï¼Œå»ºè®®ä½ çš„ç±»å‹æä¾›ä¸€ä¸ªåº”ç”¨äº† <code>OnDeserialized</code> ç‰¹æ€§çš„æ–¹æ³•ï¼Œæˆ–è€…è®©ç±»å‹å®ç° <code>IDeserializationCallback</code> æ¥å£çš„ <code>OnDeserialization</code> æ–¹æ³• (å°±åƒå‰é¢çš„ <code>Dictionary</code> ç¤ºä¾‹ä¸­é‚£æ ·)ã€‚è°ƒç”¨è¯¥æ–¹æ³•æ—¶ï¼Œæ‰€æœ‰å¯¹è±¡çš„å­—æ®µéƒ½å·²è®¾ç½®å¥½ã€‚ç„¶è€Œï¼Œå¯¹äºå¤šä¸ªå¯¹è±¡æ¥è¯´ï¼Œå®ƒä»¬çš„ <code>OnDeserialized</code> æˆ– <code>OnDeserialization</code> æ–¹æ³•çš„è°ƒç”¨é¡ºåºæ˜¯æ²¡æœ‰ä¿éšœçš„ã€‚æ‰€ä»¥ï¼Œè™½ç„¶å­—æ®µå¯èƒ½å·²åˆå§‹åŒ–ï¼Œä½†ä½ ä»ç„¶ä¸çŸ¥é“è¢«å¼•ç”¨çš„å¯¹è±¡æ˜¯å¦å·²å®Œå…¨ååºåˆ—åŒ–å¥½ (å¦‚æœé‚£ä¸ªè¢«å¼•ç”¨çš„å¯¹è±¡ä¹Ÿæä¾›äº†ä¸€ä¸ª <code>OnDeserialized</code> æ–¹æ³•æˆ–è€…å®ç°äº† <code>IDeserializationCallback</code> )ã€‚</p><h3 id="how-to-define-a-type-that-implements-iserializable-when-the-base-type-doesnt-implement-this-interface"><a class="anchor" href="#how-to-define-a-type-that-implements-iserializable-when-the-base-type-doesnt-implement-this-interface">#</a> How to Define a Type That Implements ISerializable When the Base Type Doesnâ€™t Implement This Interface</h3><blockquote><p>As mentioned earlier, the ISerializable interface is extremely powerful, because it allows a type to take complete control over how instances of the type get serialized and deserialized. However, this power comes at a cost: The type is now responsible for serializing all of its base typeâ€™s fields as well. Serializing the base typeâ€™s fields is easy if the base type also implements the ISerializable interface; you just call the base typeâ€™s GetObjectData method.</p></blockquote><blockquote><p>However, someday, you may find yourself defining a type that needs to take control of its serialization, but whose base type does not implement the ISerializable interface. In this case, your derived class must manually serialize the base typeâ€™s fields by grabbing their values and adding them to the SerializationInfo collection. Then, in your special constructor, you will also have to get the values out of the collection and somehow set the base classâ€™s fields. Doing all of this is easy (albeit tedious) if the base classâ€™s fields are public or protected, but it can be very difficult or impossible to do if the base classâ€™s fields are private.</p></blockquote><blockquote><p>This following code shows how to properly implement ISerializableâ€™s GetObjectData method and its implied constructor so that the base typeâ€™s fields are serialized.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Serializable</span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">protected</span> <span class="token class-name">String</span> m_name <span class="token operator">=</span> <span class="token string">"Jeff"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* Make the type instantiable */</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Serializable</span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Base</span><span class="token punctuation">,</span> <span class="token class-name">ISerializable</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">private</span> <span class="token class-name">DateTime</span> m_date <span class="token operator">=</span> DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* Make the type instantiable*/</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// If this constructor didn't exist, we'd get a SerializationException</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// This constructor should be protected if this class were not sealed</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">[</span><span class="token function">SecurityPermissionAttribute</span><span class="token punctuation">(</span>SecurityAction<span class="token punctuation">.</span>Demand<span class="token punctuation">,</span> SerializationFormatter <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">private</span> <span class="token function">Derived</span><span class="token punctuation">(</span><span class="token class-name">SerializationInfo</span> info<span class="token punctuation">,</span> <span class="token class-name">StreamingContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token comment">// Get the set of serializable members for our class and base classes</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token class-name">Type</span> baseType <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>BaseType<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token class-name">MemberInfo<span class="token punctuation">[</span><span class="token punctuation">]</span></span> mi <span class="token operator">=</span> FormatterServices<span class="token punctuation">.</span><span class="token function">GetSerializableMembers</span><span class="token punctuation">(</span>baseType<span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token comment">// Deserialize the base class's fields from the info object</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> mi<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token comment">// Get the field and set it to the deserialized value</span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token class-name">FieldInfo</span> fi <span class="token operator">=</span> <span class="token punctuation">(</span>FieldInfo<span class="token punctuation">)</span>mi<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre> fi<span class="token punctuation">.</span><span class="token function">SetValue</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> info<span class="token punctuation">.</span><span class="token function">GetValue</span><span class="token punctuation">(</span>baseType<span class="token punctuation">.</span>FullName <span class="token operator">+</span> <span class="token string">"+"</span> <span class="token operator">+</span> fi<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> fi<span class="token punctuation">.</span>FieldType<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token comment">// Deserialize the values that were serialized for this class</span></pre></td></tr><tr><td data-num="24"></td><td><pre> m_date <span class="token operator">=</span> info<span class="token punctuation">.</span><span class="token function">GetDateTime</span><span class="token punctuation">(</span><span class="token string">"Date"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">SecurityPermissionAttribute</span><span class="token attribute-arguments"><span class="token punctuation">(</span>SecurityAction<span class="token punctuation">.</span>Demand<span class="token punctuation">,</span> SerializationFormatter <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="27"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">GetObjectData</span><span class="token punctuation">(</span><span class="token class-name">SerializationInfo</span> info<span class="token punctuation">,</span> <span class="token class-name">StreamingContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre> <span class="token comment">// Serialize the desired values for this class</span></pre></td></tr><tr><td data-num="29"></td><td><pre> info<span class="token punctuation">.</span><span class="token function">AddValue</span><span class="token punctuation">(</span><span class="token string">"Date"</span><span class="token punctuation">,</span> m_date<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre> <span class="token comment">// Get the set of serializable members for our class and base classes</span></pre></td></tr><tr><td data-num="31"></td><td><pre> <span class="token class-name">Type</span> baseType <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>BaseType<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre> <span class="token class-name">MemberInfo<span class="token punctuation">[</span><span class="token punctuation">]</span></span> mi <span class="token operator">=</span> FormatterServices<span class="token punctuation">.</span><span class="token function">GetSerializableMembers</span><span class="token punctuation">(</span>baseType<span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre> <span class="token comment">// Serialize the base class's fields to the info object</span></pre></td></tr><tr><td data-num="34"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> mi<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="35"></td><td><pre> <span class="token comment">// Prefix the field name with the fullname of the base type</span></pre></td></tr><tr><td data-num="36"></td><td><pre> info<span class="token punctuation">.</span><span class="token function">AddValue</span><span class="token punctuation">(</span>baseType<span class="token punctuation">.</span>FullName <span class="token operator">+</span> <span class="token string">"+"</span> <span class="token operator">+</span> mi<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>Name<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="37"></td><td><pre> <span class="token punctuation">(</span><span class="token punctuation">(</span>FieldInfo<span class="token punctuation">)</span>mi<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetValue</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="39"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="40"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name">String</span> <span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="41"></td><td><pre> <span class="token keyword">return</span> String<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"Name=&#123;0&#125;, Date=&#123;1&#125;"</span><span class="token punctuation">,</span> m_name<span class="token punctuation">,</span> m_date<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="42"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="43"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>In this code, there is a base class, Base, which is marked only with the SerializableAttribute custom attribute. Derived from Base is Derived, which also is marked with the SerializableAttribute attribute and also implements the ISerializable interface. To make the situation more interesting, youâ€™ll notice that both classes define a String field called m_name. When calling SerializationInfoâ€™s AddValue method, you canâ€™t add multiple values with the same name. The preceding code handles this situation by identifying each field by its class name prepended to the fieldâ€™s name. For example, when the GetObjectData method calls AddValue to serialize Baseâ€™s m_name field, the name of the value is written as â€œBase+m_name.â€</p></blockquote><p>ğŸ’¡å°ç»“ï¼šå‰é¢è®¨è®ºè¿‡ï¼Œæ§åˆ¶åºåˆ—åŒ–å’Œååºåˆ—åŒ–è¿‡ç¨‹çš„æœ€ä½³æ–¹å¼å°±æ˜¯ä½¿ç”¨ <code>OnSerializing</code> ï¼Œ <code>OnSerialized</code> ï¼Œ <code>OnDeserializing</code> ï¼Œ <code>OnDeserialized</code> ï¼Œ <code>NonSerialized</code> å’Œ <code>OptionalField</code> ç­‰ç‰¹æ€§ã€‚ç„¶è€Œï¼Œåœ¨ä¸€äº›æå°‘è§çš„æƒ…å†µä¸‹ï¼Œè¿™äº›ç‰¹æ€§ä¸èƒ½æä¾›ä½ æƒ³è¦çš„å…¨éƒ¨æ§åˆ¶ã€‚æ­¤å¤–ï¼Œæ ¼å¼åŒ–å™¨å†…éƒ¨ä½¿ç”¨çš„æ˜¯åå°„ï¼Œè€Œåå°„çš„é€Ÿåº¦æ˜¯æ¯”è¾ƒæ…¢çš„ï¼Œè¿™ä¼šå¢å¤§åºåˆ—åŒ–å’Œååºåˆ—åŒ–å¯¹è±¡æ‰€èŠ±çš„æ—¶é—´ï¼Œä¸ºäº†å¯¹åºåˆ—åŒ– / ååºåˆ—åŒ–çš„æ•°æ®è¿›è¡Œå®Œå…¨çš„æ§åˆ¶ï¼Œå¹¶é¿å…ä½¿ç”¨åå°„ï¼Œä½ çš„ç±»å‹å¯å®ç° <code>System.Runtime.Serialization.ISerializable</code> æ¥å£ã€‚è¿™ä¸ªæ¥å£åªæœ‰ä¸€ä¸ªæ–¹æ³•ï¼Œå³ <code>GetObjectData</code> ã€‚æ ¼å¼åŒ–å™¨åºåˆ—åŒ–å¯¹è±¡å›¾æ—¶ä¼šæ£€æŸ¥æ¯ä¸ªå¯¹è±¡ã€‚å¦‚æœå‘ç°ä¸€ä¸ªå¯¹è±¡çš„ç±»å‹å®ç°äº† <code>ISerializable</code> æ¥å£ï¼Œå°±ä¼šå¿½ç•¥æ‰€æœ‰å®šåˆ¶ç‰¹æ€§ï¼Œæ”¹ä¸ºæ„é€ æ–°çš„ <code>System.Runtime.Serialization.SerializationInfo</code> å¯¹è±¡ã€‚è¯¥å¯¹è±¡åŒ…å«äº†è¦ä»¥å¯¹è±¡åºåˆ—åŒ–çš„å€¼çš„é›†åˆã€‚æ„é€  <code>SerializationInfo</code> å¯¹è±¡æ—¶ï¼Œæ ¼å¼åŒ–å™¨è¦ä¼ é€’ä¸¤ä¸ªå‚æ•°ï¼š <code>Type</code> å’Œ <code>System.Runtime.Serialization.IFormatterConverter</code> ã€‚ <code>Type</code> å‚æ•°æ ‡è¯†è¦åºåˆ—åŒ–çš„å¯¹è±¡ã€‚å”¯ä¸€æ€§åœ°æ ‡è¯†ä¸€ä¸ªç±»å‹éœ€è¦ä¸¤ä¸ªéƒ¨åˆ†çš„ä¿¡æ¯ï¼šç±»å‹çš„å­—ç¬¦ä¸²åç§°åŠå…¶ç¨‹åºé›†æ ‡è¯† (åŒ…æ‹¬ç¨‹åºé›†åã€ç‰ˆæœ¬ã€è¯­è¨€æ–‡åŒ–å’Œå…¬é’¥)ã€‚æ„é€ å¥½çš„ <code>SerializationInfo</code> å¯¹è±¡åŒ…å«ç±»å‹çš„å…¨å (é€šè¿‡åœ¨å†…éƒ¨æŸ¥è¯¢ <code>Type</code> çš„ <code>FullName</code> å±æ€§)ï¼Œè¿™ä¸ªå­—ç¬¦ä¸²ä¼šå­˜å‚¨åˆ°ä¸€ä¸ªç§æœ‰å­—æ®µä¸­ï¼Œå¦‚æœä½ æƒ³è·å–ç±»å‹çš„å…¨åï¼Œå¯æŸ¥è¯¢ <code>SerializationInfo</code> çš„ <code>FullTypeName</code> å±æ€§ã€‚ç±»ä¼¼åœ°ï¼Œæ„é€ å™¨è·å–ç±»å‹çš„å®šä¹‰ç¨‹åºé›† (é€šè¿‡åœ¨å†…éƒ¨æŸ¥è¯¢ <code>Type</code> çš„ <code>Module</code> å±æ€§ï¼Œå†æŸ¥è¯¢ <code>Module</code> çš„ <code>Assembly</code> å±æ€§ï¼Œå†æŸ¥è¯¢ <code>Assembly</code> çš„ <code>FullName</code> å±æ€§)ï¼Œè¿™æ ·ä¸ªå­—ç¬¦ä¸²ä¼šå­˜å‚¨åœ¨ä¸€ä¸ªç§æœ‰å­—æ®µä¸­ã€‚å¦‚æœä½ æƒ³è·å–ç¨‹åºé›†çš„æ ‡è¯†ï¼Œå¯æŸ¥è¯¢ <code>SerializationInfo</code> çš„ <code>AssemblyName</code> å±æ€§ã€‚æ„é€ å¥½å¹¶åˆå§‹åŒ–å¥½ <code>SerializationInfo</code> å¯¹è±¡åï¼Œæ ¼å¼åŒ–å™¨è°ƒç”¨ç±»å‹çš„ <code>GetObjectData</code> æ–¹æ³•ï¼Œå‘å®ƒä¼ é€’å¯¹ <code>SerializationInfo</code> å¯¹è±¡çš„å¼•ç”¨ã€‚ <code>GetObjectData</code> æ–¹æ³•å†³å®šéœ€è¦å“ªäº›ä¿¡æ¯æ¥åºåˆ—åŒ–å¯¹è±¡ï¼Œå¹¶å°†è¿™äº›ä¿¡æ¯æ·»åŠ åˆ° <code>SerializationInfo</code> å¯¹è±¡ä¸­ã€‚ <code>GetObjectData</code> è°ƒç”¨ <code>SerializationInfo</code> ç±»å‹æä¾›çš„ <code>AddValue</code> æ–¹æ³•çš„ä¼—å¤šé‡è½½ç‰ˆæœ¬ä¹‹ä¸€æŒ‡å®šè¦åºåˆ—åŒ–çš„ä¿¡æ¯ã€‚é’ˆå¯¹è¦æ·»åŠ çš„æ¯ä¸ªæ•°æ®ï¼Œéƒ½è¦è°ƒç”¨ä¸€æ¬¡ <code>AddValue</code> ã€‚æ¯ä¸ª <code>AddValue</code> æ–¹æ³•éƒ½è·å–ä¸€ä¸ª <code>String</code> åç§°å¥½ä¸€äº›æ•°æ®ã€‚æ•°æ®ä¸€èˆ¬æ˜¯ç®€å•çš„å€¼ç±»å‹ï¼Œæ¯”å¦‚ <code>Boolean</code> ï¼Œ <code>Char</code> ï¼Œ <code>Byte</code> ï¼Œ <code>SByte</code> ï¼Œ <code>Int16</code> ï¼Œ <code>Int32</code> ï¼Œ <code>UInt32</code> ï¼Œ <code>Int64</code> ï¼Œ <code>UInt64</code> ï¼Œ <code>Single</code> ï¼Œ <code>Double</code> ï¼Œ <code>Decimal</code> æˆ–è€… <code>DateTime</code> ã€‚ç„¶è€Œï¼Œè¿˜å¯ä»¥åœ¨è°ƒç”¨ <code>AddValue</code> æ—¶å‘å®ƒä¼ é€’å¯¹ä¸€ä¸ª <code>Object</code> (æ¯”å¦‚ä¸€ä¸ª <code>String</code> ) çš„å¼•ç”¨ã€‚ <code>GetObjectData</code> æ·»åŠ å¥½æ‰€æœ‰å¿…è¦çš„åºåˆ—åŒ–ä¿¡æ¯ä¹‹åï¼Œä¼šè¿”å›è‡³æ ¼å¼åŒ–å™¨ã€‚ç°åœ¨ï¼Œæ ¼å¼åŒ–å™¨è·å–å·²ç»æ·»åŠ åˆ° <code>SerializationInfo</code> å¯¹è±¡çš„æ‰€æœ‰å€¼ï¼Œå¹¶æŠŠå®ƒä»¬éƒ½åºåˆ—åŒ–åˆ°æµä¸­ã€‚æ³¨æ„ï¼Œæˆ‘ä»¬è¿˜å‘ <code>GetObjectData</code> æ–¹æ³•ä¼ é€’äº†å¦ä¸€ä¸ªå‚æ•°ï¼Œä¹Ÿå°±æ˜¯å¯¹ä¸€ä¸ª <code>System.Runtime.Serialization.StreamingContext</code> å¯¹è±¡çš„å¼•ç”¨ã€‚å¤§å¤šæ•°ç±»å‹çš„ <code>GetObjectData</code> æ–¹æ³•éƒ½ä¼šå®Œå…¨å¿½ç•¥è¿™ä¸ªå‚æ•°ï¼Œåé¢çš„ä¸€èŠ‚ä¼šè¯´åˆ°è¿™ä¸ªå‚æ•°ã€‚çŸ¥é“äº†å¦‚ä½•è®¾ç½®åºåˆ—åŒ–æ‰€éœ€çš„å…¨éƒ¨ä¿¡æ¯ä¹‹åï¼Œå†æ¥çœ‹ååºåˆ—åŒ–ã€‚æ ¼å¼åŒ–å™¨ä»æµä¸­æå–ä¸€ä¸ªå¯¹è±¡æ—¶ï¼Œä¼šä¸ºæ–°å¯¹è±¡åˆ†é…å†…å­˜ (é€šè¿‡è°ƒç”¨ <code>System.Runtime.Serialize.FormatterServices</code> ç±»å‹çš„é™æ€ <code>GetUninitializedObject</code> æ–¹æ³•)ã€‚æœ€åˆï¼Œè¿™ä¸ªå¯¹è±¡çš„æ‰€æœ‰å­—æ®µéƒ½è®¾ä¸º <code>0</code> æˆ– <code>null</code> ã€‚ç„¶åï¼Œæ ¼å¼åŒ–å™¨æ£€æŸ¥ç±»å‹æ˜¯å¦å®ç°äº† <code>ISerializable</code> æ¥å£ã€‚å¦‚æœå­˜åœ¨è¿™ä¸ªæ¥å£ï¼Œæ ¼å¼åŒ–å™¨å°±å°è¯•è°ƒç”¨ä¸€ä¸ªç‰¹æ®Šæ„é€ å™¨ï¼Œå®ƒçš„å‚æ•°å’Œ <code>GetObjectData</code> æ–¹æ³•çš„å®Œå…¨ä¸€è‡´ã€‚å¦‚æœä½ çš„ç±»æ˜¯å¯†å°ç±»ï¼Œå¼ºçƒˆå»ºè®®å°†è¿™ä¸ªç‰¹æ®Šæ„é€ å™¨å£°æ˜ä¸º <code>private</code> ã€‚è¿™æ ·å¯é˜²æ­¢ä»»ä½•ä»£ç ä¸æ…è°ƒç”¨å®ƒï¼Œä»è€Œæå‡å®‰å…¨æ€§ã€‚å¦‚æœä¸æ˜¯å¯†å°ç±»ï¼Œåº”è¯¥å°†è¿™ä¸ªç‰¹æ®Šæ„é€ å™¨å£°æ˜ä¸º <code>protected</code> ï¼Œç¡®ä¿åªæœ‰æ´¾ç”Ÿç±»æ‰èƒ½è°ƒç”¨ã€‚æ³¨æ„ï¼Œæ— è®ºè¿™ä¸ªç‰¹æ®Šæ„é€ å™¨æ˜¯å¦‚ä½•å£°æ˜çš„ï¼Œæ ¼å¼åŒ–å™¨éƒ½èƒ½è°ƒç”¨å®ƒã€‚ååºåˆ—åŒ–å¯¹è±¡çš„å­—æ®µæ—¶ï¼Œåº”è°ƒç”¨å’Œå¯¹è±¡åºåˆ—åŒ–æ—¶ä¼ ç»™ <code>AddValue</code> æ–¹æ³•çš„å€¼çš„ç±»å‹åŒ¹é…çš„ <code>Get</code> æ–¹æ³•ã€‚æ¢è¨€ä¹‹ï¼Œå¦‚æœ <code>GetObjectData</code> æ–¹æ³•è°ƒç”¨ <code>GetInt32</code> æ–¹æ³•ã€‚å¦‚æœå€¼åœ¨æµä¸­çš„ç±»å‹å’Œä½ è¯•å›¾è·å– (Get) çš„ç±»å‹ä¸ç¬¦ï¼Œæ ¼å¼åŒ–å™¨ä¼šå°è¯•ç”¨ä¸€ä¸ª <code>IFormatterConverter</code> å¯¹è±¡å°†æµä¸­çš„å€¼è½¬å‹æˆä½ æŒ‡å®šçš„ç±»å‹ã€‚å‰é¢è¯´è¿‡ï¼Œæ„é€  <code>SerializationInfo</code> å¯¹è±¡æ—¶ï¼Œè¦å‘å®ƒä¼ é€’ç±»å‹å®ç°äº† <code>IFormatterConverter</code> æ¥å£çš„ä¸€ä¸ªå¯¹è±¡ã€‚ç”±äºæ˜¯æ ¼å¼åŒ–å™¨è´Ÿè´£æ„é€  <code>SerializationInfo</code> å¯¹è±¡ï¼Œæ‰€ä»¥è¦ç”±å®ƒé€‰æ‹©å®ƒæƒ³è¦çš„ <code>IFormatterConverter</code> ç±»å‹ã€‚ Microsoft çš„ <code>BinaryFormatter</code> å’Œ <code>SoapFormatter</code> ç±»å‹æ€»æ˜¯æ„é€  <code>System.Runtime.Serialization.FormatterConverter</code> ç±»å‹çš„å®ä¾‹ã€‚Microsoft çš„æ ¼å¼åŒ–å™¨æ²¡æœ‰æä¾›ä»»ä½•æ–¹å¼è®©ä½ é€‰æ‹©ä¸åŒçš„ <code>IFormatterConverter</code> ç±»å‹ã€‚ <code>FormatterConverter</code> ç±»å‹è°ƒç”¨ <code>System.Convert</code> ç±»çš„å„ç§é™æ€æ–¹æ³•åœ¨ä¸åŒçš„æ ¸å¿ƒç±»å‹ä¹‹é—´å¯¹å€¼è¿›è¡Œè½¬æ¢ï¼Œæ¯”å¦‚å°†ä¸€ä¸ª <code>Int32</code> è½¬æ¢æˆä¸€ä¸ª <code>Int64</code> ã€‚ç„¶è€Œï¼Œä¸ºäº†åœ¨å…¶ä»–ä»»æ„ç±»å‹ä¹‹é—´è½¬æ¢ä¸€ä¸ªå€¼ï¼Œ <code>FormatterConverter</code> è¦è°ƒç”¨ <code>Convert</code> çš„ <code>ChangeType</code> æ–¹æ³•å°†åºåˆ—åŒ–å¥½çš„ (æˆ–è€…åŸå§‹çš„) ç±»å‹è½¬å‹ä¸ºä¸€ä¸ª <code>IConvertible</code> æ¥å£ï¼Œå†è°ƒç”¨æ°å½“çš„æ¥å£æ–¹æ³•ã€‚æ‰€ä»¥ï¼Œè¦å…è®¸ä¸€ä¸ªå¯åºåˆ—åŒ–ç±»å‹çš„å¯¹è±¡ååºåˆ—åŒ–æˆä¸€ä¸ªä¸åŒçš„ç±»å‹ï¼Œå¯è€ƒè™‘è®©è‡ªå·±çš„ç±»å‹å®ç° <code>IConvertible</code> æ¥å£ã€‚æ³¨æ„ï¼Œåªæœ‰åœ¨ååºåˆ—åŒ–å¯¹è±¡æ—¶è°ƒç”¨ä¸€ä¸ª <code>Get</code> æ–¹æ³•ï¼Œä½†å‘ç°å®ƒçš„ç±»å‹å’Œæµä¸­çš„å€¼çš„ç±»å‹ä¸ç¬¦æ—¶ï¼Œæ‰ä¼šä½¿ç”¨ <code>FormatterConverter</code> å¯¹è±¡ã€‚å½“ç„¶ï¼Œå®Œå…¨å¯ä»¥å®šä¹‰è‡ªå·±çš„ç±»å‹ï¼Œè®©å®ƒä»å®ç°äº† <code>ISerializable</code> çš„ <code>GetObjectData</code> æ–¹æ³•å’Œç‰¹æ®Šæ„é€ å™¨ç±»å‹æ´¾ç”Ÿã€‚å¦‚æœä½ çš„ç±»å‹ä¹Ÿå®ç°äº† <code>ISerializable</code> ï¼Œé‚£ä¹ˆåœ¨ä½ å®ç°çš„ <code>GetObjectData</code> æ–¹æ³•å’Œç‰¹æ®Šæ„é€ å™¨ä¸­ï¼Œå¿…é¡»è°ƒç”¨åŸºç±»ä¸­çš„åŒåæ–¹æ³•ï¼Œç¡®ä¿å¯¹è±¡èƒ½æ­£ç¡®åºåˆ—åŒ–å’Œååºåˆ—åŒ–ã€‚è¿™ä¸€ç‚¹åŠ¡å¿…ç‰¢è®°ï¼Œå¦åˆ™å¯¹è±¡æ˜¯ä¸èƒ½æ­£ç¡®åºåˆ—åŒ–å’Œååºåˆ—åŒ–çš„ã€‚ä¸‹ä¸€èŠ‚å°†è§£é‡Šå¦‚ä½•æ­£ç¡®åœ°å®šä¹‰åŸºç±»å‹æœªå®ç° <code>ISerializable</code> æ¥å£ä¸€ä¸ª <code>ISerializable</code> ç±»å‹ã€‚æ€»æœ‰ä¸€å¤©éœ€è¦å®šä¹‰ç±»å‹æ¥æ§åˆ¶å®ƒçš„åºåˆ—åŒ–ï¼Œä½†å‘ç°å®ƒçš„åŸºç±»æ²¡æœ‰å®ç° <code>ISerializable</code> æ¥å£ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ´¾ç”Ÿç±»å¿…é¡»æ‰‹åŠ¨åºåˆ—åŒ–åŸºç±»çš„å­—æ®µï¼Œå…·ä½“çš„åšæ³•æ˜¯è·å–å®ƒä»¬çš„å€¼ï¼Œå¹¶æŠŠè¿™äº›å€¼æ·»åŠ åˆ° <code>SerializationInfo</code> é›†åˆä¸­ã€‚ç„¶åï¼Œåœ¨ä½ çš„ç‰¹æ®Šæ„é€ å™¨ä¸­ï¼Œè¿˜å¿…é¡»ä»é›†åˆä¸­å–å‡ºå€¼ï¼Œå¹¶ä»¥æŸç§æ–¹å¼è®¾ç½®åŸºç±»çš„å­—æ®µã€‚å¦‚æœåŸºç±»çš„å­—æ®µæ˜¯ <code>public</code> æˆ– <code>protected</code> çš„ï¼Œé‚£ä¹ˆä¸€åˆ‡éƒ½å¾ˆå®¹æ˜“å®ç°ã€‚å¦‚æœæ˜¯ <code>private</code> å­—æ®µï¼Œå°±å¾ˆéš¾æˆ–è€…æ ¹æœ¬ä¸å¯èƒ½å®ç°ã€‚</p><h2 id="streaming-contexts"><a class="anchor" href="#streaming-contexts">#</a> Streaming Contexts</h2><blockquote><p>As mentioned earlier, there are many destinations for a serialized set of objects: same process, different process on the same machine, different process on a different machine, and so on. In some rare situations, an object might want to know where it is going to be deserialized so that it can emit its state differently. For example, an object that wraps a Windows semaphore object might decide to serialize its kernel handle if the object knows that it will be deserialized into the same process, because kernel handles are valid within a process. However, the object might decide to serialize the semaphoreâ€™s string name if it knows that the object will be deserialized on the same machine but into a different process. Finally, the object might decide to throw an exception if it knows that it will be deserialized in a process running on a different machine because a semaphore is valid only within a single machine.</p></blockquote><blockquote><p>A number of the methods mentioned earlier in this chapter accept a StreamingContext. A StreamingContext structure is a very simple value type offering just two public read-only properties, as shown in Table 24-1.</p></blockquote><p><img data-src="/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/image-20221202205535261.png" alt="image-20221202205535261"></p><blockquote><p>A method that receives a StreamingContext structure can examine the State propertyâ€™s bit flags to determine the source or destination of the objects being serialized/deserialized. Table 24-2 shows the possible bit flag values.</p></blockquote><p><img data-src="/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/image-20221202205559702.png" alt="image-20221202205559702"></p><blockquote><p>Now that you know how to get this information, letâ€™s discuss how you would set this information. The IFormatter interface (which is implemented by both the BinaryFormatter and the SoapFormatter types) defines a read/write StreamingContext property called Context. When you construct a formatter, the formatter initializes its Context property so that StreamingContextStates is set to All and the reference to the additional state object is set to null.</p></blockquote><blockquote><p>After the formatter is constructed, you can construct a StreamingContext structure using any of the StreamingContextStates bit flags, and you can optionally pass a reference to an object containing any additional context information you need. Now, all you need to do is set the formatterâ€™s Context property with this new StreamingContext object before calling the formatterâ€™s Serialize or Deserialize methods. Code demonstrating how to tell a formatter that you are serializing/deserialzing an object graph for the sole purpose of cloning all the objects in the graph is shown in the DeepClone method presented earlier in this chapter.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šä¸€ç»„åºåˆ—åŒ–å¥½çš„å¯¹è±¡å¯ä»¥æœ‰è®¸å¤šç›®çš„åœ°ï¼šåŒä¸€ä¸ªè¿›ç¨‹ã€åŒä¸€å°æœºå™¨ä¸Šçš„ä¸åŒè¿›ç¨‹ã€ä¸åŒæœºå™¨ä¸Šçš„ä¸åŒè¿›ç¨‹ç­‰ã€‚åœ¨ä¸€äº›æ¯”è¾ƒå°‘è§çš„æƒ…å†µä¸‹ï¼Œä¸€ä¸ªå¯¹è±¡å¯èƒ½æƒ³çŸ¥é“å®ƒè¦åœ¨ä»€ä¹ˆåœ°æ–¹ååºåˆ—åŒ–ï¼Œä»è€Œä»¥ä¸åŒçš„å½“æ—¶ç”Ÿæˆå®ƒçš„çŠ¶æ€ã€‚ä¾‹å¦‚ï¼Œå¦‚æœå¯¹è±¡ä¸­åŒ…è£…äº† Windows ä¿¡å·é‡ (semaphore) å¯¹è±¡ï¼Œå¦‚æœå®ƒçŸ¥é“è¦ååºåˆ—åŒ–åˆ°åŒä¸€ä¸ªè¿›ç¨‹ä¸­ï¼Œå°±å¯å†³å®šå¯¹å®ƒçš„å†…æ ¸å¥æŸ„ (kernel handle) è¿›è¡Œåºåˆ—åŒ–ï¼Œè¿™æ˜¯å› ä¸ºå†…æ ¸å¥æŸ„åœ¨ä¸€ä¸ªè¿›ç¨‹ä¸­æœ‰æ•ˆã€‚ä½†å¦‚æœè¦ååºåˆ—åŒ–åˆ°åŒä¸€å°è®¡ç®—æœºçš„ä¸åŒè¿›ç¨‹ä¸­ï¼Œå°±å¯å†³å®šå¯¹ä¿¡å·é‡çš„å­—ç¬¦ä¸²åç§°è¿›è¡Œåºåˆ—åŒ–ã€‚æœ€åï¼Œå¦‚æœè¦ååºåˆ—åŒ–åˆ°ä¸åŒè®¡ç®—æœºä¸Šçš„è¿›ç¨‹ï¼Œå°±å¯å†³å®šæŠ›å‡ºå¼‚å¸¸ï¼Œå› ä¸ºä¿¡å·é‡åªåœ¨ä¸€å°æœºå™¨å†…æœ‰æ•ˆã€‚æœ¬ç« æåˆ°çš„å¤§é‡æ–¹æ³•éƒ½æ¥å—ä¸€ä¸ª <code>StreamingContext</code> (æµä¸Šä¸‹æ–‡)ã€‚ <code>StreamingContext</code> ç»“æ„æ˜¯ä¸€ä¸ªéå¸¸ç®€å•çš„å€¼ç±»å‹ï¼Œå®ƒåªæä¾›äº†ä¸¤ä¸ªå…¬å…±åªè¯»å±æ€§ï¼Œ <code>State</code> å’Œ <code>Context</code> ã€‚æ¥å—ä¸€ä¸ª <code>StreamingContext</code> ç»“æ„çš„æ–¹æ³•èƒ½æ£€æŸ¥ <code>State</code> å±æ€§çš„ä½æ ‡å¿—ï¼Œåˆ¤æ–­è¦åºåˆ—åŒ– / ååºåˆ—åŒ–çš„å¯¹è±¡çš„æ¥æºæˆ–ç›®çš„åœ°ã€‚è€Œ <code>Context</code> å±æ€§åˆ™æ˜¯ä¸€ä¸ªå¯¹è±¡çš„å¼•ç”¨ï¼Œå¯¹è±¡ä¸­åŒ…å«ç”¨æˆ·å¸Œæœ›çš„ä»»ä½•ä¸Šä¸‹æ–‡ä¿¡æ¯ã€‚ <code>IFormatter</code> æ¥å£ (åŒæ—¶ç”± <code>BinaryFormatter</code> å’Œ <code>SoapFormatter</code> ç±»å‹å®ç°) å®šä¹‰äº† <code>StreamingContext</code> ç±»å‹çš„å¯è¯» / å¯å†™å±æ€§ <code>Context</code> ã€‚æ„é€ æ ¼å¼åŒ–å™¨æ—¶ï¼Œæ ¼å¼åŒ–å™¨ä¼šåˆå§‹åŒ–å®ƒçš„ <code>Context</code> å±æ€§ï¼Œå°† <code>StreamingContextStates</code> è®¾ä¸º <code>All</code> ï¼Œå°†å¯¹é¢å¤–çŠ¶æ€å¯¹è±¡çš„å¼•ç”¨è®¾ä¸º <code>null</code> ã€‚æ ¼å¼åŒ–å™¨æ„é€ å¥½ä¹‹åï¼Œå°±å¯ä»¥ä½¿ç”¨ä»»ä½• <code>StreamingContextStates</code> ä½æ ‡å¿—æ¥æ„é€ ä¸€ä¸ª <code>StreamingContext</code> ç»“æ„ï¼Œå¹¶å¯é€‰æ‹©ä¼ é€’ä¸€ä¸ªå¯¹è±¡å¼•ç”¨ (å¯¹è±¡ä¸­åŒ…å«ä½ éœ€è¦çš„ä»»ä½•é¢å¤–çš„ä¸Šä¸‹æ–‡ä¿¡æ¯)ã€‚ç°åœ¨ï¼Œåœ¨è°ƒç”¨æ ¼å¼åŒ–å™¨çš„ <code>Serialize</code> æˆ– <code>Deserialize</code> æ–¹æ³•ä¹‹å‰ï¼Œä½ åªéœ€è¦å°†æ ¼å¼åŒ–å™¨çš„ <code>Context</code> å±æ€§è®¾ä¸ºè¿™ä¸ªæ–°çš„ <code>StreamingContext</code> å¯¹è±¡ã€‚</p><h2 id="serializing-a-type-as-a-different-type-and-deserializing-an-object-as-a-different-object"><a class="anchor" href="#serializing-a-type-as-a-different-type-and-deserializing-an-object-as-a-different-object">#</a> Serializing a Type As a Different Type and Deserializing an Object As a Different Object</h2><blockquote><p>The .NET Frameworkâ€™s serialization infrastructure is quite rich, and in this section, we discuss how a developer can design a type that can serialize or deserialize itself into a different type or object. Below are some examples where this is interesting:</p><ul><li><p>Some types (such as System.DBNull and System.Reflection.Missing) are designed to have only one instance per AppDomain. These types are frequently called singletons. If you have a reference to a DBNull object, serializing and deserializing it should not cause a new DBNull object to be created in the AppDomain. After deserializing, the returned reference should refer to the AppDomainâ€™s already-existing DBNull object.</p></li><li><p>Some types (such as System.Type, System.Reflection.Assembly, and other reflection types like MemberInfo) have one instance per type, assembly, member, and so on. Imagine you have an array where each element references a MemberInfo object. Itâ€™s possible that five array elements reference a single MemberInfo object. After serializing and deserializing this array, the five elements that referred to a single MemberInfo object should all refer to a single MemberInfo object. Whatâ€™s more, these elements should refer to the one MemberInfo object that exists for the specific member in the AppDomain. You could also imagine how this could be useful for polling database connection objects or any other type of object.</p></li><li><p>For remotely controlled objects, the CLR serializes information about the server object that, when deserialized on the client, causes the CLR to create a proxy object. This type of the proxy object is a different type than the server object, but this is transparent to the client code. When the client calls instance methods on the proxy object, the proxy code internally remotes the call to the server that actually performs the request.</p></li></ul></blockquote><blockquote><p>Letâ€™s look at some code that shows how to properly serialize and deserialize a singleton type.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// There should be only one instance of this type per AppDomain</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">[</span>Serializable<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">ISerializable</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// This is the one instance of this type</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">readonly</span> <span class="token class-name">Singleton</span> s_theOneObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token comment">// Here are the instance fields</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name">String</span> Name <span class="token operator">=</span> <span class="token string">"Jeff"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name">DateTime</span> Date <span class="token operator">=</span> DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">// Private constructor allowing this type to construct the singleton</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// Method returning a reference to the singleton</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Singleton</span> <span class="token function">GetSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> s_theOneObject<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token comment">// Method called when serializing a Singleton</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token comment">// I recommend using an Explicit Interface Method Impl. Here</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token punctuation">[</span><span class="token function">SecurityPermissionAttribute</span><span class="token punctuation">(</span>SecurityAction<span class="token punctuation">.</span>Demand<span class="token punctuation">,</span> SerializationFormatter <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token return-type class-name"><span class="token keyword">void</span></span> ISerializable<span class="token punctuation">.</span><span class="token function">GetObjectData</span><span class="token punctuation">(</span><span class="token class-name">SerializationInfo</span> info<span class="token punctuation">,</span> <span class="token class-name">StreamingContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre> info<span class="token punctuation">.</span><span class="token function">SetType</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">SingletonSerializationHelper</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token comment">// No other values need to be added</span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Serializable</span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token keyword">private</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SingletonSerializationHelper</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IObjectReference</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token comment">// Method called after this object (which has no fields) is deserialized</span></pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Object</span> <span class="token function">GetRealObject</span><span class="token punctuation">(</span><span class="token class-name">StreamingContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token keyword">return</span> Singleton<span class="token punctuation">.</span><span class="token function">GetSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre> <span class="token comment">// NOTE: The special constructor is NOT necessary because it's never called</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The Singleton class represents a type that allows only one instance of itself to exist per AppDomain. The following code tests the Singletonâ€™s serialization and deserialization code to ensure that only one instance of the Singleton type ever exists in the AppDomain.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SingletonSerializationTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token comment">// Create an array with multiple elements referring to the one Singleton object</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">Singleton<span class="token punctuation">[</span><span class="token punctuation">]</span></span> a1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span> Singleton<span class="token punctuation">.</span><span class="token function">GetSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Singleton<span class="token punctuation">.</span><span class="token function">GetSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Do both elements refer to the same object? "</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token operator">+</span> <span class="token punctuation">(</span>a1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> a1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "True"</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> stream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">MemoryStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token class-name">BinaryFormatter</span> formatter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">BinaryFormatter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Serialize and then deserialize the array elements</span></pre></td></tr><tr><td data-num="9"></td><td><pre> formatter<span class="token punctuation">.</span><span class="token function">Serialize</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> a1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> stream<span class="token punctuation">.</span>Position <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token class-name">Singleton<span class="token punctuation">[</span><span class="token punctuation">]</span></span> a2 <span class="token operator">=</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>formatter<span class="token punctuation">.</span><span class="token function">Deserialize</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token comment">// Prove that it worked as expected:</span></pre></td></tr><tr><td data-num="13"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Do both elements refer to the same object? "</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token operator">+</span> <span class="token punctuation">(</span>a2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> a2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "True"</span></pre></td></tr><tr><td data-num="15"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Do all elements refer to the same object? "</span> </pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token operator">+</span> <span class="token punctuation">(</span>a1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> a2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "True"</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Now, letâ€™s walk through the code to understand whatâ€™s happening. When the Singleton type is loaded into the AppDomain, the CLR calls its static constructor, which constructs a Singleton object and saves a reference to it in a static field, s_theOneObject. The Singleton class doesnâ€™t offer any public constructors, which prevents any other code from constructing any other instances of this class.</p></blockquote><blockquote><p>In SingletonSerializationTest, an array is created consisting of two elements; each element references the Singleton object. The two elements are initialized by calling Singletonâ€™s static GetSingleton method. This method returns a reference to the one Singleton object. The first call to Consoleâ€™s WriteLine method displays â€œTrue,â€ verifying that both array elements refer to the same exact object.</p></blockquote><blockquote><p>Now, SingletonSerializationTest calls the formatterâ€™s Serialize method to serialize the array and its elements. When serializing the first Singleton, the formatter detects that the Singleton type implements the ISerializable interface and calls the GetObjectData method. This method calls SetType, passing in the SingletonSerializationHelper type, which tells the formatter to serialize the Singleton object as a SingletonSerializationHelper object instead. Because AddValue is not called, no additional field information is written to the stream. Because the formatter automatically detected that both array elements refer to a single object, the formatter serializes only one object.</p></blockquote><blockquote><p>After serializing the array, SingletonSerializationTest calls the formatterâ€™s Deserialize method. When deserializing the stream, the formatter tries to deserialize a SingletonSerializationHelper object because this is what the formatter was â€œtrickedâ€ into serializing. (In fact, this is why the Singleton class doesnâ€™t provide the special constructor that is usually required when implementing the ISerializable interface.) After constructing the SingletonSerializationHelper object, the formatter sees that this type implements the System. Runtime.Serialization.IObjectReference interface. This interface is defined in the FCL as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IObjectReference</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token return-type class-name">Object</span> <span class="token function">GetRealObject</span><span class="token punctuation">(</span><span class="token class-name">StreamingContext</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>When a type implements this interface, the formatter calls the GetRealObject method. This method returns a reference to the object that you really want a reference to now that deserialization of the object has completed. In my example, the SingletonSerializationHelper type has GetRealObject return a reference to the Singleton object that already exists in the AppDomain. So, when the formatterâ€™s Deserialize method returns, the a2 array contains two elements, both of which refer to the AppDomainâ€™s Singleton object. The SingletonSerializationHelper object used to help with the deserialization is immediately unreachable and will be garbage collected in the future.</p></blockquote><blockquote><p>The second call to WriteLine displays â€œTrue,â€ verifying that both of a2â€™s array elements refer to the exact same object. The third and last call to WriteLine also displays â€œTrue,â€ proving that the elements in both arrays all refer to the exact same object.</p></blockquote><p>ğŸ’¡å°ç»“ï¼šæœ‰çš„ç±»å‹ (æ¯”å¦‚ <code>System.DBNull</code> å’Œ <code>System.Reflection.Missing</code> ) è®¾è®¡æˆæ¯ä¸ª AppDomain ä¸€ä¸ªå®ä¾‹ã€‚ç»å¸¸å°†è¿™äº›ç±»å‹ç§°ä¸ºå•å®ä¾‹ (singleton) ç±»å‹ã€‚ç»™å®šä¸€ä¸ª <code>DBNull</code> å¯¹è±¡å¼•ç”¨ï¼Œåºåˆ—åŒ–å’Œååºåˆ—åŒ–å®ƒä¸åº”é€ æˆåœ¨ AppDomain ä¸­æ–°å»ºä¸€ä¸ª <code>DBNull</code> å¯¹è±¡ã€‚ååºåˆ—åŒ–åï¼Œè¿”å›çš„å¼•ç”¨åº”æŒ‡å‘ AppDomain ä¸­ç°æœ‰çš„ <code>DBNull</code> å¯¹è±¡ã€‚å¯¹äºæŸäº›ç±»å‹ (ä¾‹å¦‚ <code>System.Type</code> å’Œ <code>System.Reflection.Assembly</code> ï¼Œä»¥åŠå…¶ä»–åå°„ç±»å‹ï¼Œä¾‹å¦‚ <code>MemberInfo</code> )ï¼Œæ¯ä¸ªç±»å‹ã€ç¨‹åºé›†æˆ–è€…æˆå‘˜ç­‰éƒ½åªèƒ½æœ‰ä¸€ä¸ªå®ä¾‹ã€‚ä¾‹å¦‚ï¼Œå‡å®šä¸€ä¸ªæ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½å¼•ç”¨ä¸€ä¸ª <code>MemberInfo</code> å¯¹è±¡ï¼Œå…¶ä¸­ 5 ä¸ªå…ƒç´ å¼•ç”¨çš„éƒ½æ˜¯ä¸€ä¸ª <code>MemerInfo</code> å¯¹è±¡ã€‚åºåˆ—åŒ–å’Œååºåˆ—åŒ–è¿™ä¸ªæ•°ç»„åï¼Œé‚£ 5 ä¸ªå…ƒç´ å¼•ç”¨çš„åº”è¯¥è¿˜æ˜¯ä¸€ä¸ª <code>MemberInfo</code> å¯¹è±¡ (è€Œä¸æ˜¯åˆ†åˆ«å¼•ç”¨ 5 ä¸ªä¸åŒçš„å¯¹è±¡)ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œè¿™äº›å…ƒç´ å¼•ç”¨çš„ <code>MemberInfo</code> å¯¹è±¡è¿˜å¿…é¡»å®é™…å¯¹åº”äº AppDomain ä¸­çš„ä¸€ä¸ªç‰¹å®šæˆå‘˜ã€‚è½®è¯¢æ•°æ®åº“è¿æ¥å¯¹è±¡æˆ–è€…å…¶ä»–ä»»ä½•ç±»å‹çš„å¯¹è±¡æ—¶ï¼Œè¿™ä¸ªåŠŸèƒ½ä¹Ÿæ˜¯å¾ˆå¥½ç”¨çš„ã€‚å¯¹äºè¿œç¨‹æ§åˆ¶çš„å¯¹è±¡ï¼ŒCLR åºåˆ—åŒ–ä¸æœåŠ¡å™¨å¯¹è±¡æœ‰å…³çš„ä¿¡æ¯ã€‚åœ¨å®¢æˆ·ç«¯ä¸Šååºåˆ—åŒ–æ—¶ï¼Œä¼šé€ æˆ CLR åˆ›å»ºä¸€ä¸ªä»£ç†å¯¹è±¡ã€‚è¿™ä¸ªä»£ç†å¯¹è±¡çš„ç±»å‹æœ‰åˆ«äºæœåŠ¡å™¨å¯¹è±¡çš„ç±»å‹ï¼Œä½†è¿™å¯¹äºå®¢æˆ·ç«¯ä»£ç æ¥è¯´æ˜¯é€æ˜çš„ (å®¢æˆ·ç«¯ä¸éœ€è¦å…³å¿ƒè¿™ä¸ªé—®é¢˜)ã€‚å®¢æˆ·ç«¯ç›´æ¥åœ¨ä»£ç†å¯¹è±¡ä¸Šè°ƒç”¨å®ä¾‹æ–¹æ³•ã€‚ç„¶åï¼Œä»£ç†ä»£ç å†…éƒ¨ä¼šè°ƒç”¨è¿œç¨‹å‘é€ç»™æœåŠ¡å™¨ï¼Œç”±åè€…å®é™…æ‰§è¡Œè¯·æ±‚çš„æ“ä½œã€‚å¦‚æœç±»å‹å®ç°äº† <code>System.Runtime.Serialization.IObjectReference</code> æ¥å£ï¼Œæ ¼å¼åŒ–å™¨ä¼šè°ƒç”¨ <code>GetRealObject</code> æ–¹æ³•ã€‚è¿™ä¸ªæ–¹æ³•è¿”å›åœ¨å¯¹è±¡ååºåˆ—åŒ–å¥½ä¹‹åä½ çœŸæ­£æƒ³å¼•ç”¨çš„å¯¹è±¡ã€‚</p><h2 id="serialization-surrogates"><a class="anchor" href="#serialization-surrogates">#</a> Serialization Surrogates</h2><blockquote><p>Up to now, Iâ€™ve been discussing how to modify a typeâ€™s implementation to control how a type serializes and deserializes instances of itself. However, the formatters also allow code that is not part of the typeâ€™s implementation to override how a type serializes and deserializes its objects. There are two main reasons why application code might want to override a typeâ€™s behavior:</p><ul><li><p>It allows a developer the ability to serialize a type that was not originally designed to be serialized.</p></li><li><p>It allows a developer to provide a way to map one version of a type to a different version of a type.</p></li></ul></blockquote><blockquote><p>Basically, to make this mechanism work, you first define a â€œsurrogate typeâ€ that takes over the actions required to serialize and deserialize an existing type. Then, you register an instance of your surrogate type with the formatter telling the formatter which existing type your surrogate type is responsible for acting on. When the formatter detects that it is trying to serialize or deserialize an instance of the existing type, it will call methods defined by your surrogate object. Letâ€™s build a sample that demonstrates how all this works.</p></blockquote><blockquote><p>A serialization surrogate type must implement the System.Runtime.Serialization.ISerializationSurrogate interface, which is defined in the FCL as follows.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ISerializationSurrogate</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">GetObjectData</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">,</span> <span class="token class-name">SerializationInfo</span> info<span class="token punctuation">,</span> <span class="token class-name">StreamingContext</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token return-type class-name">Object</span> <span class="token function">SetObjectData</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">,</span> <span class="token class-name">SerializationInfo</span> info<span class="token punctuation">,</span> <span class="token class-name">StreamingContext</span> context<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">ISurrogateSelector</span> selector<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Now, letâ€™s walk through an example that uses this interface. Letâ€™s say your program contains some DateTime objects that contain values that are local to the userâ€™s computer. What if you want to serialize the DateTime objects to a stream but you want the values to be serialized in universal time? This would allow you to send the data over a network stream to another machine in another part of the world and have the DateTime value be correct. Although you canâ€™t modify the DateTime type that ships with the FCL, you can define your own serialization surrogate class that can control how DateTime objects are serialized and deserialized. Here is how to define the surrogate class.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">UniversalToLocalTimeSerializationSurrogate</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">ISerializationSurrogate</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">GetObjectData</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">,</span> <span class="token class-name">SerializationInfo</span> info<span class="token punctuation">,</span> <span class="token class-name">StreamingContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// Convert the DateTime from local to UTC</span></pre></td></tr><tr><td data-num="4"></td><td><pre> info<span class="token punctuation">.</span><span class="token function">AddValue</span><span class="token punctuation">(</span><span class="token string">"Date"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>DateTime<span class="token punctuation">)</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToUniversalTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token string">"u"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">Object</span> <span class="token function">SetObjectData</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">,</span> <span class="token class-name">SerializationInfo</span> info<span class="token punctuation">,</span> <span class="token class-name">StreamingContext</span> context<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token class-name">ISurrogateSelector</span> selector<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token comment">// Convert the DateTime from UTC to local </span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">return</span> DateTime<span class="token punctuation">.</span><span class="token function">ParseExact</span><span class="token punctuation">(</span>info<span class="token punctuation">.</span><span class="token function">GetString</span><span class="token punctuation">(</span><span class="token string">"Date"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"u"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToLocalTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The GetObjectData method here works just like the ISerializable interfaceâ€™s GetObjectData method. The only difference is that ISerializationSurrogateâ€™s GetObjectData method takes one additional parameter: a reference to the â€œrealâ€ object that is to be serialized. In the GetObjectData method above, this object is cast to DateTime, the value is converted from local time to universal time, and a string (formatted using universal full date/time pattern) is added to the SerializationInfo collection.</p></blockquote><blockquote><p>The SetObjectData method is called in order to deserialize a DateTime object. When this method is called, it is passed a reference to a SerializationInfo object. SetObjectData gets the string date out of this collection, parses it as a universal full date/time formatted string, and then converts the resulting DateTime object from universal time to the machineâ€™s local time.</p></blockquote><blockquote><p>The Object that is passed for SetObjectDataâ€™s first parameter is a bit strange. Just before calling SetObjectData, the formatter allocates (via FormatterServicesâ€™s static GetUninitializedObject method) an instance of the type that the surrogate is a surrogate for. The instanceâ€™s fields are all 0/null and no constructor has been called on the object. The code inside SetObjectData can simply initialize the fields of this instance by using the values from the passed-in SerializationInfo object and then have SetObjectData return null. Alternatively, SetObjectData could create an entirely different object or even a different type of object and return a reference to this new object, in which case, the formatter will ignore any changes that may or may not have happened to the object it passed in to SetObjectData.</p></blockquote><blockquote><p>In my example, my UniversalToLocalTimeSerializationSurrogate class acts as a surrogate for the DateTime type, which is a value type. And so, the obj parameter refers to a boxed instance of a DateTime. There is no way to change the fields in most value types (because they are supposed to be immutable) and so, my SetObjectData method ignores the obj parameter and returns a new DateTime object with the desired value in it.</p></blockquote><blockquote><p>At this point, Iâ€™m sure youâ€™re all wondering how the formatter knows to use this ISerializationSurrogate type when it tries to serialize/deserialize a DateTime object. The following code demonstrates how to test the UniversalToLocalTimeSerializationSurrogate class.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SerializationSurrogateDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> stream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">MemoryStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// 1. Construct the desired formatter</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">IFormatter</span> formatter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SoapFormatter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// 2. Construct a SurrogateSelector object</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token class-name">SurrogateSelector</span> ss <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SurrogateSelector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// 3. Tell the surrogate selector to use our surrogate for DateTime objects</span></pre></td></tr><tr><td data-num="8"></td><td><pre> ss<span class="token punctuation">.</span><span class="token function">AddSurrogate</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">DateTime</span><span class="token punctuation">)</span><span class="token punctuation">,</span> formatter<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">UniversalToLocalTimeSerializationSurrogate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// NOTE: AddSurrogate can be called multiple times to register multiple surrogates</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token comment">// 4. Tell the formatter to use our surrogate selector</span></pre></td></tr><tr><td data-num="12"></td><td><pre> formatter<span class="token punctuation">.</span>SurrogateSelector <span class="token operator">=</span> ss<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token comment">// Create a DateTime that represents the local time on the machine &amp; serialize it</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token class-name">DateTime</span> localTimeBeforeSerialize <span class="token operator">=</span> DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> formatter<span class="token punctuation">.</span><span class="token function">Serialize</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> localTimeBeforeSerialize<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token comment">// The stream displays the Universal time as a string to prove it worked</span></pre></td></tr><tr><td data-num="17"></td><td><pre> stream<span class="token punctuation">.</span>Position <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">StreamReader</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ReadToEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token comment">// Deserialize the Universal time string &amp; convert it to a local DateTime</span></pre></td></tr><tr><td data-num="20"></td><td><pre> stream<span class="token punctuation">.</span>Position <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token class-name">DateTime</span> localTimeAfterDeserialize <span class="token operator">=</span> <span class="token punctuation">(</span>DateTime<span class="token punctuation">)</span>formatter<span class="token punctuation">.</span><span class="token function">Deserialize</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token comment">// Prove it worked correctly:</span></pre></td></tr><tr><td data-num="23"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"LocalTimeBeforeSerialize =&#123;0&#125;"</span><span class="token punctuation">,</span> localTimeBeforeSerialize<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"LocalTimeAfterDeserialize=&#123;0&#125;"</span><span class="token punctuation">,</span> localTimeAfterDeserialize<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>After steps 1 through 4 have executed, the formatter is ready to use the registered surrogate types. When the formatterâ€™s Serialize method is called, each objectâ€™s type is looked up in the set maintained by the SurrogateSelector. If a match is found, then the ISerializationSurrogate objectâ€™s GetObjectData method is called to get the information that should be written out to the stream.</p></blockquote><blockquote><p>When the formatterâ€™s Deserialize method is called, the type of the object about to be deserialized is looked up in the formatterâ€™s SurrogateSelector and if a match is found, then the ISerializationSurrogate objectâ€™s SetObjectData method is called to set the fields within the object being deserialized.</p></blockquote><blockquote><p>Internally, a SurrogateSelector object maintains a private hash table. When AddSurrogate is called, the Type and StreamingContext make up the key and the ISerializationSurrogate object is the keyâ€™s value. If a key with the same Type/StreamingContext already exists, then AddSurrogate throws an ArgumentException. By including a StreamingContext in the key, you can register one surrogate type object that knows how to serialize/deserialize a DateTime object to a file and register a different surrogate object that knows how to serialize/deserialize a DateTime object to a different process.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼š <code>BinaryFormatter</code> ç±»æœ‰ä¸€ä¸ª bugï¼Œä¼šé€ æˆä»£ç†æ— æ³•åºåˆ—åŒ–å¾ªç¯å¼•ç”¨çš„å¯¹è±¡ï¼Œä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œéœ€è¦å°†å¯¹è‡ªå·±çš„ <code>ISerializationSurrogate</code> å¯¹è±¡çš„å¼•ç”¨ä¼ ç»™ <code>FormatterServices</code> çš„é™æ€ <code>GetSurrogateForCyclicalReference</code> æ–¹æ³•ã€‚è¯¥æ–¹æ³•è¿”å›ä¸€ä¸ª <code>ISerializationSurrogate</code> å¯¹è±¡ã€‚ç„¶åï¼Œå¯ä»¥å°†å¯¹è¿™ä¸ªå¯¹è±¡çš„å¼•ç”¨ä¼ ç»™ <code>SurrogateSelector</code> çš„ <code>AddSurrogate</code> æ–¹æ³•ã€‚ä½†è¦æ³¨æ„ï¼Œä½¿ç”¨ <code>GetSurrogateForCyclicalReference</code> æ–¹æ³•æ—¶ï¼Œä»£ç†çš„ <code>SetObjectData</code> æ–¹æ³•å¿…é¡»ä¿®æ”¹ <code>SetObjectData</code> çš„ <code>obj</code> å‚æ•°æ‰€å¼•ç”¨çš„å¯¹è±¡ä¸­çš„å€¼ï¼Œè€Œä¸”æœ€åè¦å‘è°ƒç”¨æ–¹æ³•è¿”å› <code>null</code> æˆ– <code>obj</code> ã€‚åœ¨æœ¬ä¹¦çš„é…å¥—èµ„æºä¸­ï¼Œæœ‰ä¸€ä¸ªä¾‹å­å±•ç¤ºäº†å¦‚ä½•ä¿®æ”¹ <code>UniversalToLocalTimeSerializationSurrogate</code> ç±»å’Œ <code>SerializationSurrogateDemo</code> æ–¹æ³•æ¥æ”¯æŒå¾ªç¯å¼•ç”¨ã€‚</p><h3 id="surrogate-selector-chains"><a class="anchor" href="#surrogate-selector-chains">#</a> Surrogate Selector Chains</h3><blockquote><p>Multiple SurrogateSelector objects can be chained together. For example, you could have a SurrogateSelector that maintains a set of serialization surrogates that are used for serializing types into proxies that get remoted across the wire or between AppDomains. You could also have a separate SurrogateSelector object that contains a set of serialization surrogates that are used to convert Version 1 types into Version 2 types.</p></blockquote><blockquote><p>If you have multiple SurrogateSelector objects that youâ€™d like the formatter to use, you must chain them together into a linked list. The SurrogateSelector type implements the ISurrogateSelector interface, which defines three methods. All three of these methods are related to chaining. Here is how the ISurrogateSelector interface is defined.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ISurrogateSelector</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ChainSelector</span><span class="token punctuation">(</span><span class="token class-name">ISurrogateSelector</span> selector<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token return-type class-name">ISurrogateSelector</span> <span class="token function">GetNextSelector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token return-type class-name">ISerializationSurrogate</span> <span class="token function">GetSurrogate</span><span class="token punctuation">(</span><span class="token class-name">Type</span> type<span class="token punctuation">,</span> <span class="token class-name">StreamingContext</span> context<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">out</span> <span class="token class-name">ISurrogateSelector</span> selector<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>The ChainSelector method inserts an ISurrogateSelector object immediately after the ISurrogateSelector object being operated on (â€˜thisâ€™ object). The GetNextSelector method returns a reference to the next ISurrogateSelector object in the chain or null if the object being operated on is the end of the chain.</p></blockquote><blockquote><p>The GetSurrogate method looks up a Type/StreamingContext pair in the ISurrogateSelector object identified by this. If the pair cannot be found, then the next ISurrogateSelector object in the chain is accessed, and so on. If a match is found, then GetSurrogate returns the ISerializationSurrogate object that handles the serialization/deserialization of the type looked up. In addition, GetSurrogate also returns the ISurrogateSelector object that contained the match; this is usually not needed and is ignored. If none of the ISurrogateSelector objects in the chain have a match for the Type/StreamingContext pair, GetSurrogate returns null.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼šFCL å®šä¹‰äº†ä¸€ä¸ª <code>ISurrogateSelector</code> æ¥å£ï¼Œè¿˜å®šä¹‰äº†ä¸€ä¸ªå®ç°äº†è¯¥æ¥å£çš„ <code>SurrogateSelector</code> ç±»å‹ã€‚ç„¶è€Œï¼Œåªæœ‰åœ¨ä¸€äº›éå¸¸ç½•è§çš„æƒ…å†µä¸‹ï¼Œæ‰éœ€è¦å®šä¹‰è‡ªå·±çš„ç±»å‹æ¥å®ç° <code>ISurrogateSelector</code> æ¥å£ã€‚å®ç° <code>ISurrogateSelector</code> æ¥å£çš„å”¯ä¸€åŸå› å°±æ˜¯å°†ç±»å‹æ˜ å°„åˆ°å¦ä¸€ä¸ªç±»å‹æ—¶éœ€è¦æ›´å¤§çš„çµæ´»æ€§ã€‚ä¾‹å¦‚ï¼Œä½ å¯èƒ½å¸Œæœ›ä»¥ä¸€ç§ç‰¹æ®Šæ–¹å¼åºåˆ—åŒ–ä»ä¸€ä¸ªç‰¹å®šåŸºç±»ç»§æ‰¿çš„æ‰€æœ‰ç±»å‹ã€‚ <code>System.Runtime.Remoting.Messaging.RemotingSurrogateSelector</code> ç±»å°±æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„ä¾‹å­ã€‚å‡ºäºè¿œç¨‹è®¿é—® (remoting) ç›®çš„è€Œåºåˆ—åŒ–å¯¹è±¡æ—¶ï¼ŒCLR ä½¿ç”¨ <code>RemotingSurrogateSelector</code> æ¥æ ¼å¼åŒ–å¯¹è±¡ã€‚è¿™ä¸ªä»£ç†é€‰æ‹©å™¨ (surrogate selector) ä»¥ä¸€ç§ç‰¹æ®Šæ–¹å¼åºåˆ—åŒ–ä» <code>System.MarshalByRefObject</code> æ´¾ç”Ÿçš„æ‰€æœ‰å¯¹è±¡ï¼Œç¡®ä¿ååºåˆ—åŒ–ä¼šé€ æˆåœ¨å®¢æˆ·ç«¯åˆ›å»ºä»£ç†å¯¹è±¡ (proxy object)ã€‚</p><p>ğŸ’¡å°ç»“ï¼šå‰é¢è®¨è®ºäº†å¦‚ä½•ä¿®æ”¹ä¸€ä¸ªç±»å‹çš„å®ç°ï¼Œæ§åˆ¶è¯¥ç±»å‹å¦‚ä½•å¯¹å®ƒæœ¬èº«çš„å®ä¾‹è¿›è¡Œåºåˆ—åŒ–å’Œååºåˆ—åŒ–ã€‚ç„¶è€Œï¼Œæ ¼å¼åŒ–å™¨è¿˜å…è®¸ä¸æ˜¯â€ ç±»å‹å®ç°çš„ä¸€éƒ¨åˆ† â€œçš„ä»£ç é‡å†™è¯¥ç±»å‹â€ åºåˆ—åŒ–å’Œååºåˆ—åŒ–å…¶å¯¹è±¡ â€œçš„æ–¹å¼ã€‚åº”ç”¨ç¨‹åºä»£ç ä¹‹æ‰€ä»¥è¦é‡å†™ (è¦†ç›–) ç±»å‹çš„è¡Œä¸ºï¼Œä¸»è¦æ˜¯å‡ºäºä¸¤æ–¹é¢çš„è€ƒè™‘ã€‚1. å…è®¸å¼€å‘äººå‘˜åºåˆ—åŒ–æœ€åˆæ²¡æœ‰è®¾è®¡æˆè¦åºåˆ—åŒ–çš„ç±»å‹ã€‚2. å…è®¸å¼€å‘äººå‘˜æä¾›ä¸€ç§æ–¹å¼å°†ç±»å‹çš„ä¸€ä¸ªç‰ˆæœ¬æ˜ å°„åˆ°ç±»å‹çš„ä¸€ä¸ªä¸åŒçš„ç‰ˆæœ¬ã€‚ç®€å•åœ°è¯´ï¼Œä¸ºäº†ä½¿è¿™ä¸ªæœºåˆ¶å·¥ä½œèµ·æ¥ï¼Œé¦–å…ˆè¦å®šä¹‰ä¸€ä¸ªâ€ ä»£ç†ç±»å‹ â€œ(surrogate type)ï¼Œå®ƒæ¥ç®¡å¯¹ç°æœ‰ç±»å‹è¿›è¡Œåºåˆ—åŒ–å’Œååºåˆ—åŒ–çš„è¡ŒåŠ¨ã€‚ç„¶åï¼Œå‘æ ¼å¼åŒ–å™¨ç™»è®°è¯¥ä»£ç†ç±»å‹çš„å®ä¾‹ï¼Œå‘Šè¯‰æ ¼å¼åŒ–å™¨ä»£ç†ç±»å‹è¦ä½œç”¨äºç°æœ‰çš„å“ªä¸ªç±»å‹ã€‚ä¸€æ—¦æ ¼å¼åŒ–å™¨è¦å¯¹ç°æœ‰ç±»å‹çš„å®ä¾‹è¿›è¡Œåºåˆ—åŒ–æˆ–ååºåˆ—åŒ–ï¼Œå°±è°ƒç”¨ç”±ä½ çš„ä»£ç†å¯¹è±¡å®šä¹‰çš„æ–¹æ³•ã€‚åºåˆ—åŒ–ä»£ç†ç±»å‹å¿…é¡»å®ç° <code>System.Runtime.Serialization.ISerializationSurrogate</code> æ¥å£ï¼Œå®ƒåœ¨ FCL ä¸­å®šä¹‰äº† <code>GetObjectData</code> å’Œ <code>SetObjectData</code> æ–¹æ³•ã€‚ <code>GetObjectData</code> æ–¹æ³•åœ¨è¿™é‡Œçš„å·¥ä½œæ–¹å¼ä¸ <code>ISerializable</code> æ¥å£çš„ <code>GetObjectData</code> æ–¹æ³•å·®ä¸å¤šã€‚å”¯ä¸€çš„åŒºåˆ«åœ¨äºï¼Œ <code>ISerializationSurrogate</code> çš„ <code>GetObjectData</code> æ–¹æ³•è¦è·å–ä¸€ä¸ªé¢å¤–çš„å‚æ•° â€”â€” å¯¹è¦åºåˆ—åŒ–çš„â€ çœŸå®â€ å¯¹è±¡çš„å¼•ç”¨ã€‚è°ƒç”¨æ ¼å¼åŒ–å™¨çš„ <code>Serialize</code> æ–¹æ³•æ—¶ï¼Œä¼šåœ¨ <code>SurrogateSelector</code> ç»´æŠ¤çš„é›†åˆ (ä¸€ä¸ªå“ˆå¸Œè¡¨) ä¸­æŸ¥æ‰¾ (è¦åºåˆ—åŒ–çš„) æ¯ä¸ªå¯¹è±¡çš„ç±»å‹ã€‚å¦‚æœå‘ç°ä¸€ä¸ªåŒ¹é…ï¼Œå°±è°ƒç”¨ <code>ISerializationSurrogate</code> å¯¹è±¡çš„ <code>GetObjectData</code> æ–¹æ³•æ¥è·å–åº”è¯¥å†™å…¥æµçš„ä¿¡æ¯ã€‚æ ¼å¼åŒ–å™¨çš„ <code>Deserialize</code> æ–¹æ³•åœ¨è°ƒç”¨æ—¶ï¼Œä¼šåœ¨æ ¼å¼åŒ–å™¨çš„ <code>SurrogateSelector</code> ä¸­æŸ¥æ‰¾è¦ååºåˆ—åŒ–çš„å¯¹è±¡çš„ç±»å‹ã€‚å¦‚æœå‘ç°ä¸€ä¸ªåŒ¹é…ï¼Œå°±è°ƒç”¨ <code>ISerializationSurrogate</code> å¯¹è±¡çš„ <code>SetObjectData</code> æ–¹æ³•æ¥è®¾ç½®è¦ååºåˆ—åŒ–çš„å¯¹è±¡ä¸­çš„å­—æ®µã€‚ <code>SurrogateSelector</code> å¯¹è±¡åœ¨å†…éƒ¨ç»´æŠ¤äº†ä¸€ä¸ªç§æœ‰å“ˆå¸Œè¡¨ã€‚è°ƒç”¨ <code>AddSurrogate</code> æ—¶ï¼Œ <code>Type</code> å’Œ <code>StreamingContext</code> æ„æˆäº†å“ˆå¸Œè¡¨çš„é”® (key)ï¼Œå¯¹åº”çš„å€¼ (value) å°±æ˜¯ <code>ISerializationSurrogate</code> å¯¹è±¡ã€‚å¦‚æœå·²ç»å­˜åœ¨å’Œè¦æ·»åŠ çš„ <code>Type/StreamingContext</code> ç›¸åŒçš„ä¸€ä¸ªé”®ï¼Œ <code>AddSurrogate</code> ä¼šæŠ›å‡ºä¸€ä¸ª <code>ArgumentException</code> ã€‚é€šè¿‡åœ¨é”®ä¸­åŒ…å«ä¸€ä¸ª <code>StreamingContext</code> ï¼Œå¯ä»¥ç™»è®°ä¸€ä¸ªä»£ç†ç±»å‹å¯¹è±¡ï¼Œå®ƒçŸ¥é“å¦‚ä½•å°† <code>DateTime</code> å¯¹è±¡åºåˆ—åŒ– / ååºåˆ—åŒ–åˆ°ä¸€ä¸ªæ–‡ä»¶ä¸­ï¼›å†ç™»è®°ä¸€ä¸ªä¸åŒçš„ä»£ç†å¯¹è±¡ï¼Œå®ƒçŸ¥é“å¦‚ä½•å°† <code>DateTime</code> å¯¹è±¡åºåˆ—åŒ–ã€ååºåˆ—åŒ–åˆ°ä¸€ä¸ªä¸åŒçš„è¿›ç¨‹ä¸­ã€‚å¤šä¸ª <code>SurrogateSelector</code> å¯¹è±¡å¯é“¾æ¥åˆ°ä¸€èµ·ã€‚ä¾‹å¦‚ï¼Œå¯ä»¥è®©ä¸€ä¸ª <code>SurrogateSelector</code> å¯¹è±¡ç»´æŠ¤ä¸€ç»„åºåˆ—åŒ–ä»£ç†ï¼Œè¿™äº›åºåˆ—åŒ–ä»£ç† (surrogate) ç”¨äºå°†ç±»å‹åºåˆ—åŒ–æˆå¸¦ä»£ç† (proxy)ï¼Œä»¥ä¾¿é€šè¿‡ç½‘ç»œä¼ é€ï¼Œæˆ–è€…è·¨è¶Šä¸åŒçš„ AppDomain ä¼ é€ã€‚è¿˜å¯ä»¥è®©å¦ä¸€ä¸ª <code>SurrogateSelector</code> å¯¹è±¡ç»´æŠ¤ä¸€ç»„åºåˆ—åŒ–ä»£ç†ï¼Œè¿™äº›åºåˆ—åŒ–ä»£ç†ç”¨äºå°†ç‰ˆæœ¬ 1 çš„ç±»å‹è½¬æ¢æˆç‰ˆæœ¬ 2 çš„ç±»å‹ã€‚å¦‚æœæœ‰å¤šä¸ªå¸Œæœ›æ ¼å¼åŒ–å™¨ä½¿ç”¨çš„ <code>SurrogateSelector</code> å¯¹è±¡ï¼Œå¿…é¡»æŠŠå®ƒä»¬é“¾æ¥åˆ°ä¸€ä¸ªé“¾è¡¨ä¸­ã€‚ <code>SurrogateSelector</code> ç±»å‹å®ç°äº† <code>ISurrogateSelector</code> æ¥å£ï¼Œè¯¥æ¥å£å®šä¹‰äº†ä¸‰ä¸ªæ–¹æ³•ã€‚è¿™äº›æ–¹æ³•å…¨éƒ¨è·Ÿé“¾æ¥æœ‰å…³ã€‚ <code>ChainSelector</code> æ–¹æ³•ç´§æ¥åœ¨å½“å‰æ“ä½œçš„ <code>ISurrogateSelector</code> å¯¹è±¡ ( <code>this</code> å¯¹è±¡) ä¹‹åæ’å…¥ä¸€ä¸ª <code>ISurrogateSelector</code> å¯¹è±¡ã€‚ <code>GetNextSelector</code> æ–¹æ³•è¿”å›å¯¹é“¾è¡¨ä¸­çš„ä¸‹ä¸€ä¸ª <code>ISurrogateSelector</code> å¯¹è±¡çš„å¼•ç”¨ï¼›å¦‚æœå½“å‰æ“ä½œçš„å¯¹è±¡æ˜¯é“¾å°¾ï¼Œå°±è¿”å› <code>null</code> ã€‚ <code>GetSurrogate</code> æ–¹æ³•åœ¨ <code>this</code> æ‰€ä»£è¡¨çš„ <code>ISurrogateSelector</code> å¯¹è±¡ä¸­æŸ¥æ‰¾ä¸€å¯¹ <code>Type/StreamingContext</code> ã€‚å¦‚æœæ²¡æœ‰æ‰¾åˆ° <code>Type/StreamingContext</code> å¯¹ï¼Œå°±è®¿é—®é“¾ä¸­çš„ä¸‹ä¸€ä¸ª <code>ISurrogateSelector</code> å¯¹è±¡ï¼Œä¾æ¬¡ç±»æ¨ã€‚å¦‚æœæ‰¾åˆ°ä¸€ä¸ªåŒ¹é…é¡¹ï¼Œ <code>GetSurrogate</code> å°†è¿”å›ä¸€ä¸ª <code>ISerializationSurrogate</code> å¯¹è±¡ï¼Œè¯¥å¯¹è±¡è´Ÿè´£å¯¹æ‰¾åˆ°çš„ç±»å‹è¿›è¡Œåºåˆ—åŒ– / ååºåˆ—åŒ–ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œ <code>GetSurrogate</code> è¿˜ä¼šè¿”å›åŒ…å«åŒ¹é…é¡¹çš„ <code>ISurrogateSelector</code> å¯¹è±¡ï¼›ä¸€èˆ¬éƒ½ç”¨ä¸ç€è¿™ä¸ªå¯¹è±¡ï¼Œæ‰€ä»¥ä¸€èˆ¬ä¼šå°†å…¶å¿½ç•¥ã€‚å¦‚æœé“¾ä¸­æ‰€æœ‰ <code>ISurrogateSelector</code> å¯¹è±¡éƒ½ä¸åŒ…å«åŒ¹é…çš„ä¸€å¯¹ <code>Type/StreamingContext</code> ï¼Œ <code>GetSurrogate</code> å°†è¿”å› <code>null</code> ã€‚</p><h2 id="overriding-the-assembly-andor-type-when-deserializing-an-object"><a class="anchor" href="#overriding-the-assembly-andor-type-when-deserializing-an-object">#</a> Overriding the Assembly and/or Type When Deserializing an Object</h2><blockquote><p>When serializing an object, formatters output the typeâ€™s full name and the full name of the typeâ€™s defining assembly. When deserializing an object, formatters use this information to know exactly what type of object to construct and initialize. The earlier discussion about the ISerializationSurrogate interface showed a mechanism allowing you to take over the serialization and deserialization duties for a specific type. A type that implements the ISerializationSurrogate interface is tied to a specific type in a specific assembly.</p></blockquote><blockquote><p>However, there are times when the ISerializationSurrogate mechanism doesnâ€™t provide enough flexibility. Here are some scenarios when it might be useful to deserialize an object into a different type than it was serialized as:</p><ul><li><p>A developer might decide to move a typeâ€™s implementation from one assembly to a different assembly. For example, the assemblyâ€™s version number changes making the new assembly different from the original assembly.</p></li><li><p>An object on a server that gets serialized into a stream that is sent to a client. When the client processes the stream, it could deserialize the object to a completely different type whose code knows how to remotely invoke method calls to the serverâ€™s object.</p></li><li><p>A developer makes a new version of a type. We want to deserialize any already-serialized objects into the new version of the type.</p></li></ul></blockquote><blockquote><p>The System.Runtime.Serialization.SerializationBinder class makes deserializing an object to a different type very easy. To do this, you first define your own type that derives from the abstract SerializationBinder type. In the following code, assume that version 1.0.0.0 of your assembly defined a class called Ver1 and assume that the new version of your assembly defines the Ver1ToVer2SerializationBinder class and also defines a class called Ver2.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Ver1ToVer2SerializationBinder</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">SerializationBinder</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name">Type</span> <span class="token function">BindToType</span><span class="token punctuation">(</span><span class="token class-name">String</span> assemblyName<span class="token punctuation">,</span> <span class="token class-name">String</span> typeName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// Deserialize any Ver1 object from version 1.0.0.0 into a Ver2 object</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token comment">// Calculate the assembly name that defined the Ver1 type</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token class-name">AssemblyName</span> assemVer1 <span class="token operator">=</span> Assembly<span class="token punctuation">.</span><span class="token function">GetExecutingAssembly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> assemVer1<span class="token punctuation">.</span>Version <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Version</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// If deserializing the Ver1 object from v1.0.0.0, turn it into a Ver2 object </span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>assemblyName <span class="token operator">==</span> assemVer1<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> typeName <span class="token operator">==</span> <span class="token string">"Ver1"</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">return</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">Ver2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// Else, just return the same type being requested</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">return</span> Type<span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"&#123;0&#125;, &#123;1&#125;"</span><span class="token punctuation">,</span> typeName<span class="token punctuation">,</span> assemblyName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Now, after you construct a formatter, construct an instance of Ver1ToVer2SerializationBinder and set the formatterâ€™s Binder read/write property to refer to the binder object. After setting the Binder property, you can now call the formatterâ€™s Deserialize method. During deserialization, the formatter sees that a binder has been set. As each object is about to be deserialized, the formatter calls the binderâ€™s BindToType method, passing it the assembly name and type that the formatter wants to deserialize. At this point, BindToType decides what type should actually be constructed and returns this type.</p></blockquote><p>ğŸ’¡æ³¨æ„ï¼š <code>SerializationBinder</code> ç±»è¿˜å¯é‡å†™ <code>BindToName</code> æ–¹æ³•ï¼Œä»è€Œåºåˆ—åŒ–å¯¹è±¡æ—¶æ›´æ”¹ç¨‹åºé›† / ç±»å‹ä¿¡æ¯ï¼Œè¿™ä¸ªæ–¹æ³•çœ‹èµ·æ¥åƒä¸‹é¢è¿™æ ·ï¼š<br><code>public virtual void BindToName(Type serializedType, out string assemblyName, out string typeName)</code></p><p>åºåˆ—åŒ–æœŸé—´ï¼Œæ ¼å¼åŒ–å™¨è°ƒç”¨è¿™ä¸ªæ–¹æ³•ï¼Œä¼ é€’å®ƒæƒ³è¦åºåˆ—åŒ–çš„ç±»å‹ã€‚ç„¶åï¼Œä½ å¯ä»¥é€šè¿‡ä¸¤ä¸ª out å‚æ•°è¿”å›çœŸæ­£æƒ³è¦åºåˆ—åŒ–çš„ç¨‹åºé›†å’Œç±»å‹ã€‚å¦‚æœä¸¤ä¸ª out å‚æ•°è¿”å› <code>null</code> å’Œ <code>null</code> (é»˜è®¤å®ç°å°±æ˜¯è¿™æ ·çš„)ï¼Œå°±ä¸æ‰§è¡Œä»»ä½•æ›´æ”¹ã€‚</p><p>ğŸ’¡å°ç»“ï¼šåºåˆ—åŒ–å¯¹è±¡æ—¶ï¼Œæ ¼å¼åŒ–å™¨è¾“å‡ºç±»å‹åŠå…¶å®šä¹‰ç¨‹åºé›†çš„å…¨åã€‚ååºåˆ—åŒ–å¯¹è±¡æ—¶ï¼Œæ ¼å¼åŒ–å™¨æ ¹æ®è¿™ä¸ªä¿¡æ¯ç¡®å®šè¦ä¸ºå¯¹è±¡æ„é€ å¹¶åˆå§‹åŒ–ä»€ä¹ˆç±»å‹ã€‚å‰é¢è®¨è®ºäº†å¦‚ä½•åˆ©ç”¨ <code>ISerializationSurrogate</code> æ¥å£æ¥æ¥ç®¡ç‰¹å®šç±»å‹çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–å·¥ä½œã€‚å®ç°äº† <code>ISerializationSurrogate</code> æ¥å£çš„ç±»å‹ä¸ç‰¹å®šç¨‹åºé›†ä¸­çš„ç‰¹å®šç±»å‹å…³è”ã€‚ä½†æœ‰çš„æ—¶å€™ï¼Œ <code>ISerializationSurrogate</code> æœºåˆ¶çš„çµæ´»æ€§æ˜¾å¾—æœ‰ç‚¹ä¸è¶³ã€‚åœ¨ä¸‹é¢åˆ—ä¸¾çš„æƒ…å½¢ä¸­ï¼Œæœ‰å¿…è¦å°†å¯¹è±¡ååºåˆ—åŒ–æˆå’Œåºåˆ—åŒ–æ—¶ä¸åŒçš„ç±»å‹ã€‚1. å¼€å‘äººå‘˜å¯èƒ½æƒ³æŠŠä¸€ä¸ªç±»å‹çš„å®ç°ä»ä¸€ä¸ªç¨‹åºé›†ç§»åŠ¨åˆ°å¦ä¸€ä¸ªç¨‹åºé›†ã€‚ä¾‹å¦‚ï¼Œç¨‹åºé›†ç‰ˆæœ¬å·çš„å˜åŒ–é€ æˆæ–°ç¨‹åºé›†æœ‰åˆ«äºåŸå§‹ç¨‹åºé›†ã€‚2. æœåŠ¡å™¨å¯¹è±¡åºåˆ—åŒ–åˆ°å‘é€å®¢æˆ·ç«¯çš„æµä¸­ã€‚å®¢æˆ·ç«¯å¤„ç†æµæ—¶ï¼Œå¯ä»¥å°†å¯¹è±¡ååºåˆ—åŒ–æˆå®Œå…¨ä¸åŒçš„ç±»å‹ï¼Œè¯¥ç±»å‹çš„ä»£ç çŸ¥é“å¦‚ä½•å‘æœåŠ¡å™¨çš„å¯¹è±¡å‘å‡ºè¿œç¨‹æ–¹æ³•è°ƒç”¨ã€‚3. å¼€å‘äººå‘˜åˆ›å»ºäº†ç±»å‹çš„æ–°ç‰ˆæœ¬ï¼Œæƒ³æŠŠå·²åºåˆ—åŒ–çš„å¯¹è±¡ååºåˆ—åŒ–æˆç±»å‹çš„æ–°ç‰ˆæœ¬ã€‚åˆ©ç”¨ <code>System.Runtime.Serialization.SerializationBinder</code> ç±»ï¼Œå¯ä»¥éå¸¸ç®€å•åœ°å°†ä¸€ä¸ªå¯¹è±¡ååºåˆ—åŒ–æˆä¸åŒç±»å‹ã€‚ä¸ºæ­¤ï¼Œè¦å…ˆå®šä¹‰è‡ªå·±çš„ç±»å‹ï¼Œè®©å®ƒä»æŠ½è±¡ç±» <code>SerializationBinder</code> æ´¾ç”Ÿã€‚ç°åœ¨ï¼Œåœ¨æ„é€ å¥½æ ¼å¼åŒ–å™¨ä¹‹åï¼Œæ„é€ å¥½æ´¾ç”Ÿç±»çš„å®ä¾‹ï¼Œå¹¶è®¾ç½®æ ¼å¼åŒ–å™¨çš„å¯è¯» / å¯å†™å±æ€§ <code>Binder</code> ï¼Œè®©å®ƒå¼•ç”¨ç»‘å®šå™¨ (binder) å¯¹è±¡ã€‚è®¾ç½®å¥½ <code>Binder</code> å±æ€§åï¼Œè°ƒç”¨æ ¼å¼åŒ–å™¨çš„ <code>Deserialize</code> æ–¹æ³•ã€‚åœ¨ååºåˆ—åŒ–æœŸé—´ï¼Œæ ¼å¼åŒ–å™¨å‘ç°å·²è®¾ç½®äº†ä¸€ä¸ªç»‘å®šå™¨ã€‚æ¯ä¸ªå¯¹è±¡è¦ååºåˆ—åŒ–æ—¶ï¼Œæ ¼å¼åŒ–å™¨éƒ½è°ƒç”¨ç»‘å®šå™¨çš„ <code>BindToType</code> æ–¹æ³•ï¼Œå‘å®ƒä¼ é€’ç¨‹åºé›†åç§°ä»¥åŠæ ¼å¼åŒ–å™¨æƒ³è¦ååºåˆ—åŒ–çš„ç±»å‹ã€‚ç„¶åï¼Œ <code>BindToType</code> åˆ¤æ–­å®é™…åº”è¯¥æ„å»ºä»€ä¹ˆç±»å‹ï¼Œå¹¶è¿”å›è¿™ä¸ªç±»å‹ã€‚</p><div class="tags"><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> è¯»ä¹¦ç¬”è®°</a> <a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C#</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2022-12-05 14:46:25" itemprop="dateModified" datetime="2022-12-05T14:46:25+08:00">2022-12-05</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(ï¿£â–½ï¿£)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Sakupinera WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Sakupinera Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Sakupinera PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Sakupinera <i class="ic i-at"><em>@</em></i>Sakupinera</li><li class="link"><strong>Post link: </strong><a href="http://sakupinera.github.io/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/" title="CLR via C# - Chapter 24 Runtime Serialization">http://sakupinera.github.io/2022/11/30/csharp/clr-via-csharp/Chapter 24 Runtime Serialization/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/11/29/csharp/clr-via-csharp/Chapter%2023%20Assembly%20Loading%20and%20Reflection/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;03&#x2F;08&#x2F;lrzLEXqhHuVUcP2.jpg" title="CLR via C# - Chapter 23 Assembly Loading and Reflection"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 23 Assembly Loading and Reflection</h3></a></div><div class="item right"><a href="/2022/12/06/csharp/clr-via-csharp/Chapter%2025%20Interoperating%20with%20WinRT%20%20Components/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;03&#x2F;08&#x2F;W1a6ViLoBQPTj2C.jpg" title="CLR via C# - Chapter 25 Interoperating with WinRT Components"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 25 Interoperating with WinRT Components</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-24-runtime-serialization"><span class="toc-number">1.</span> <span class="toc-text">Chapter 24 Runtime Serialization</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#serializationdeserialization-quick-start"><span class="toc-number">1.1.</span> <span class="toc-text">Serialization&#x2F;Deserialization Quick Start</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#making-a-type-serializable"><span class="toc-number">1.2.</span> <span class="toc-text">Making a Type Serializable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#controlling-serialization-and-deserialization"><span class="toc-number">1.3.</span> <span class="toc-text">Controlling Serialization and Deserialization</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#how-formatters-serialize-type-instances"><span class="toc-number">1.4.</span> <span class="toc-text">How Formatters Serialize Type Instances</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#controlling-the-serializeddeserialized-data"><span class="toc-number">1.5.</span> <span class="toc-text">Controlling the Serialized&#x2F;Deserialized Data</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#how-to-define-a-type-that-implements-iserializable-when-the-base-type-doesnt-implement-this-interface"><span class="toc-number">1.5.1.</span> <span class="toc-text">How to Define a Type That Implements ISerializable When the Base Type Doesnâ€™t Implement This Interface</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#streaming-contexts"><span class="toc-number">1.6.</span> <span class="toc-text">Streaming Contexts</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#serializing-a-type-as-a-different-type-and-deserializing-an-object-as-a-different-object"><span class="toc-number">1.7.</span> <span class="toc-text">Serializing a Type As a Different Type and Deserializing an Object As a Different Object</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#serialization-surrogates"><span class="toc-number">1.8.</span> <span class="toc-text">Serialization Surrogates</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#surrogate-selector-chains"><span class="toc-number">1.8.1.</span> <span class="toc-text">Surrogate Selector Chains</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#overriding-the-assembly-andor-type-when-deserializing-an-object"><span class="toc-number">1.9.</span> <span class="toc-text">Overriding the Assembly and&#x2F;or Type When Deserializing an Object</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"><ul><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/" rel="bookmark" title="CLR via C# - Chapter 1 The CLRâ€™s Execution Model">CLR via C# - Chapter 1 The CLRâ€™s Execution Model</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/" rel="bookmark" title="CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types">CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%203%20Shared%20Assemblies%20and%20Strongly%20Named%20Assemblies/" rel="bookmark" title="CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies">CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies</a></li><li><a href="/2022/09/27/csharp/clr-via-csharp/Chapter%204%20Type%20Fundamentals/" rel="bookmark" title="CLR via C# - Chapter 4 Type Fundamentals">CLR via C# - Chapter 4 Type Fundamentals</a></li><li><a href="/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/" rel="bookmark" title="CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals">CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals</a></li><li><a href="/2022/10/21/csharp/clr-via-csharp/Chapter%206%20Type%20and%20Member%20Basics/" rel="bookmark" title="CLR via C# - Chapter 6 Type and Member Basics">CLR via C# - Chapter 6 Type and Member Basics</a></li><li><a href="/2022/10/24/csharp/clr-via-csharp/Chapter%207%20Constants%20and%20Fields/" rel="bookmark" title="CLR via C# - Chapter 7 Constants and Fields">CLR via C# - Chapter 7 Constants and Fields</a></li><li><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" rel="bookmark" title="CLR via C# - Chapter 8 Methods">CLR via C# - Chapter 8 Methods</a></li><li><a href="/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/" rel="bookmark" title="CLR via C# - Chapter 9 Parameters">CLR via C# - Chapter 9 Parameters</a></li><li><a href="/2022/10/28/csharp/clr-via-csharp/Chapter%2010%20Properties/" rel="bookmark" title="CLR via C# - Chapter 10 Properties">CLR via C# - Chapter 10 Properties</a></li><li><a href="/2022/10/29/csharp/clr-via-csharp/Chapter%2011%20Events/" rel="bookmark" title="CLR via C# - Chapter 11 Events">CLR via C# - Chapter 11 Events</a></li><li><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" rel="bookmark" title="CLR via C# - Chapter 12 Generics">CLR via C# - Chapter 12 Generics</a></li><li><a href="/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/" rel="bookmark" title="CLR via C# - Chapter 13 Interfaces">CLR via C# - Chapter 13 Interfaces</a></li><li><a href="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/" rel="bookmark" title="CLR via C# - Chapter 14 Chars, Strings, and Working with Text">CLR via C# - Chapter 14 Chars, Strings, and Working with Text</a></li><li><a href="/2022/11/17/csharp/clr-via-csharp/Chapter%2015%20Enumerated%20Types%20and%20Bit%20Flags/" rel="bookmark" title="CLR via C# - Chapter 15 Enumerated Types and Bit Flags">CLR via C# - Chapter 15 Enumerated Types and Bit Flags</a></li><li><a href="/2022/11/19/csharp/clr-via-csharp/Chapter%2016%20Arrays/" rel="bookmark" title="CLR via C# - Chapter 16 Arrays">CLR via C# - Chapter 16 Arrays</a></li><li><a href="/2022/11/21/csharp/clr-via-csharp/Chapter%2017%20Delegates/" rel="bookmark" title="CLR via C# - Chapter 17 Delegates">CLR via C# - Chapter 17 Delegates</a></li><li><a href="/2022/11/22/csharp/clr-via-csharp/Chapter%2018%20Custom%20Attributes/" rel="bookmark" title="CLR via C# - Chapter 18 Custom Attributes">CLR via C# - Chapter 18 Custom Attributes</a></li><li><a href="/2022/11/23/csharp/clr-via-csharp/Chapter%2019%20Nullable%20Value%20Types/" rel="bookmark" title="CLR via C# - Chapter 19 Nullable Value Types">CLR via C# - Chapter 19 Nullable Value Types</a></li><li><a href="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/" rel="bookmark" title="CLR via C# - Chapter 20 Exceptions and State Management">CLR via C# - Chapter 20 Exceptions and State Management</a></li><li><a href="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/" rel="bookmark" title="CLR via C# - Chapter 21 The Managed Heap and Garbage  Collection">CLR via C# - Chapter 21 The Managed Heap and Garbage Collection</a></li><li><a href="/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/" rel="bookmark" title="CLR via C# - Chapter 22 CLR Hosting and AppDomains">CLR via C# - Chapter 22 CLR Hosting and AppDomains</a></li><li><a href="/2022/11/29/csharp/clr-via-csharp/Chapter%2023%20Assembly%20Loading%20and%20Reflection/" rel="bookmark" title="CLR via C# - Chapter 23 Assembly Loading and Reflection">CLR via C# - Chapter 23 Assembly Loading and Reflection</a></li><li class="active"><a href="/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/" rel="bookmark" title="CLR via C# - Chapter 24 Runtime Serialization">CLR via C# - Chapter 24 Runtime Serialization</a></li><li><a href="/2022/12/06/csharp/clr-via-csharp/Chapter%2025%20Interoperating%20with%20WinRT%20%20Components/" rel="bookmark" title="CLR via C# - Chapter 25 Interoperating with WinRT Components">CLR via C# - Chapter 25 Interoperating with WinRT Components</a></li><li><a href="/2023/02/06/csharp/clr-via-csharp/Chapter%2026%20Thread%20Basics/" rel="bookmark" title="CLR via C# - Chapter 26 Thread Basics">CLR via C# - Chapter 26 Thread Basics</a></li><li><a href="/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations">CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations</a></li><li><a href="/2023/02/08/csharp/clr-via-csharp/Chapter%2028%20IO-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 28 IO-Bound Asynchronous Operations">CLR via C# - Chapter 28 IO-Bound Asynchronous Operations</a></li><li><a href="/2023/02/09/csharp/clr-via-csharp/Chapter%2029%20Primitive%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 29 Primitive Thread Synchronization">CLR via C# - Chapter 29 Primitive Thread Synchronization</a></li><li><a href="/2023/02/10/csharp/clr-via-csharp/Chapter%2030%20Hybrid%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 30 Hybrid Thread Synchronization">CLR via C# - Chapter 30 Hybrid Thread Synchronization</a></li></ul></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sakupinera" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Sakupinera</p><div class="description" itemprop="description">ä¿æŒä½ çš„å†³å¿ƒï¼</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">86</span> <span class="name">posts</span></a></div><div class="item categories"><a href="/categories/"><span class="count">13</span> <span class="name">categories</span></a></div><div class="item tags"><a href="/tags/"><span class="count">6</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nha3VwaW5lcmE=" title="https:&#x2F;&#x2F;github.com&#x2F;sakupinera"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9zYWt1cGluZXJh" title="https:&#x2F;&#x2F;twitter.com&#x2F;sakupinera"><i class="ic i-twitter"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQwNzIyOTA3MQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;407229071"><i class="ic i-cloud-music"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMjIzMDczOTg/c3BtX2lkX2Zyb209MzMzLjEwMDcuMC4w" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;22307398?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li><li class="item"><a href="/games/" rel="section"><i class="ic i-flag"></i>Games</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-person"></i>About</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/11/29/csharp/clr-via-csharp/Chapter%2023%20Assembly%20Loading%20and%20Reflection/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/12/06/csharp/clr-via-csharp/Chapter%2025%20Interoperating%20with%20WinRT%20%20Components/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/09/30/computer-graphics/games101/%E7%9D%80%E8%89%B2/" title="GAMES101 - Shadingï¼ˆç€è‰²ï¼‰">GAMES101 - Shadingï¼ˆç€è‰²ï¼‰</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/09/18/computer-graphics/games101/%E5%8F%98%E6%8D%A2/" title="GAMES101 - Transformationï¼ˆå˜æ¢ï¼‰">GAMES101 - Transformationï¼ˆå˜æ¢ï¼‰</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CMake/" title="In CMake">CMake</a></div><span><a href="/2022/08/28/cmake/CMake/" title="CMake">CMake</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/09/05/linux/learn-linux/%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/" title="LearnLinux - æ—¥å¿—ç®¡ç†">LearnLinux - æ—¥å¿—ç®¡ç†</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/08/28/linux/learn-linux/%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/" title="LearnLinux - ç”¨æˆ·å’Œç”¨æˆ·ç»„ç®¡ç†">LearnLinux - ç”¨æˆ·å’Œç”¨æˆ·ç»„ç®¡ç†</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/" title="CLR via C# - Chapter 24 Runtime Serialization">CLR via C# - Chapter 24 Runtime Serialization</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2022/12/09/cpp/cpp-primer/Chapter%201%20Getting%20Started/" title="C++ Primer - Chapter 1 Getting Started">C++ Primer - Chapter 1 Getting Started</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/10/14/computer-graphics/games101/%E6%9D%90%E8%B4%A8%E4%B8%8E%E5%A4%96%E8%A7%82/" title="GAMES101 - Materials and Appearancesï¼ˆæè´¨ä¸å¤–è§‚ï¼‰">GAMES101 - Materials and Appearancesï¼ˆæè´¨ä¸å¤–è§‚ï¼‰</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CSharp-in-a-Nutshell/" title="In CSharp-in-a-Nutshell">CSharp-in-a-Nutshell</a></div><span><a href="/2022/08/29/csharp/csharp-in-a-nutshell/%E7%AC%AC4%E7%AB%A0%20CSharp%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/" title="C# in a Nutshell - ç¬¬4ç«  C#çš„é«˜çº§ç‰¹æ€§">C# in a Nutshell - ç¬¬4ç«  C#çš„é«˜çº§ç‰¹æ€§</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/08/28/linux/learn-linux/Linux%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/" title="LearnLinux - Linuxç³»ç»Ÿç®€ä»‹">LearnLinux - Linuxç³»ç»Ÿç®€ä»‹</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 â€“ <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Sakupinera @ Hanamai Sora</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="Symbols count total">2.2m words</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="Reading time total">33:30</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/11/30/csharp/clr-via-csharp/Chapter 24 Runtime Serialization/",favicon:{show:"ï¼ˆâ—Â´3ï½€â—ï¼‰Goooood",hide:"(Â´Ğ”ï½€)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/shifuku.model.json"},display:{position:"left",width:250,height:500},mobile:{show:!1},react:{opacity:.9},log:!1})</script></body></html>