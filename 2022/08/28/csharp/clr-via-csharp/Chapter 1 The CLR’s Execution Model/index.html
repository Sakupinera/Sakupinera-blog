<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sakupinera" href="http://sakupinera.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sakupinera" href="http://sakupinera.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sakupinera" href="http://sakupinera.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="è¯»ä¹¦ç¬”è®°,C#"><link rel="canonical" href="http://sakupinera.github.io/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/"><title>CLR via C# - Chapter 1 The CLRâ€™s Execution Model - CLR-via-CSharp - CSharp | Hanamai Sora = Sakupinera</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">CLR via C# - Chapter 1 The CLRâ€™s Execution Model</h1><div class="meta"><span class="item" title="Created: 2022-08-28 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2022-08-28T00:00:00+08:00">2022-08-28</time> </span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">Symbols count in article</span> <span>31k</span> <span class="text">words</span> </span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">Reading time</span> <span>29 mins.</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hanamai Sora</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipeudstjqj20zk0m8k3r.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipey0a334j20zk0m8qpt.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giciub8ja1j20zk0m81ky.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gicitzannuj20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclga70tsj20zk0m84mr.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipew28b65j20zk0m8hdt.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/" itemprop="item" rel="index" title="In CSharp"><span itemprop="name">CSharp</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/CLR-via-CSharp/" itemprop="item" rel="index" title="In CLR-via-CSharp"><span itemprop="name">CLR-via-CSharp</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://sakupinera.github.io/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Sakupinera"><meta itemprop="description" content=", ä¿æŒä½ çš„å†³å¿ƒï¼"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakupinera"></span><div class="body md" itemprop="articleBody"><h1 id="chapter-1-the-clrs-execution-model"><a class="anchor" href="#chapter-1-the-clrs-execution-model">#</a> Chapter 1 The CLRâ€™s Execution Model</h1><h2 id="compiling-source-code-into-managed-modules"><a class="anchor" href="#compiling-source-code-into-managed-modules">#</a> Compiling Source Code into Managed Modules</h2><blockquote><p>The core features of the CLR (such as memory management, assembly loading, security, exception handling, and thread synchronization) are available to any and all programming languages that target itâ€”period.</p></blockquote><blockquote><p>The common language runtime (CLR) is just what its name says it is: a runtime that is usable by<br>different and varied programming languages. The core features of the CLR (such as memory management, assembly loading, security, exception handling, and thread synchronization) are available to any and all programming languages that target itâ€”period.</p></blockquote><blockquote><p>A managed module is a standard 32-bit Windows portable executable (PE32) file or a standard 64-bit Windows portable executable (PE32+) file that requires the CLR to execute. By the way, managed assemblies always take advantage of Data Execution Prevention (DEP) and Address Space Layout Randomization (ASLR) in Windows; these two features improve the security of your whole system.</p></blockquote><p><img data-src="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/Untitled.png" alt="Untitled"></p><p><img data-src="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/Untitled1.png" alt="Untitled"></p><blockquote><p>Native code compilers produce code targeted to a specific CPU architecture, such as x86, x64, or ARM. All CLR-compliant compilers produce IL code instead. (Iâ€™ll go into more detail about IL code later in this chapter.) IL code is sometimes referred to as managed code because the CLR manages its execution.</p></blockquote><p>ğŸ’¡ å…³äºä»€ä¹ˆæ˜¯ x86ï¼Œx64 å’Œ ARM æ¶æ„ï¼Œç®€å•æ¥è¯´å°±æ˜¯å‰ä¸¤ä¸ªæ˜¯ CISCï¼ˆå¤æ‚æŒ‡ä»¤é›†ï¼‰ï¼Œåä¸€ä¸ªæ˜¯ RISCï¼ˆç²¾ç®€æŒ‡ä»¤é›†ï¼‰ï¼Œå…·ä½“åŒºåˆ«è‡ªè¡Œ Googleã€‚</p><blockquote><p>In addition to emitting IL, every compiler targeting the CLR is required to emit full metadata into every managed module. In brief, metadata is a set of data tables that describe what is defined in the module, such as types and their members. In addition, metadata also has tables indicating what the managed module references, such as imported types and their members. Metadata is a superset of older technologies such as COMâ€™s Type Libraries and Interface Definition Language (IDL) files. The important thing to note is that CLR metadata is far more complete. And, unlike Type Libraries and IDL, metadata is always associated with the file that contains the IL code. In fact, the metadata is always embedded in the same EXE/DLL as the code, making it impossible to separate the two. Because the compiler produces the metadata and the code at the same time and binds them into the resulting managed module, the metadata and the IL code it describes are never out of sync with one another.</p></blockquote><blockquote><p>Metadata removes the need for native C/C++ header and library files when compiling because<br>all the information about the referenced types/members is contained in the file that has the<br>IL that implements the type/members. Compilers can read metadata directly from managed<br>modules.</p></blockquote><blockquote><p>Microsoftâ€™s C#, Visual Basic, F#, and the IL Assembler always produce modules that contain managed code (IL) and managed data (garbage-collected data types). End users must have the CLR (presently shipping as part of the .NET Framework) installed on their machine in order to execute any modules that contain managed code and/or managed data in the same way that they must have the Microsoft Foundation Class (MFC) library or Visual Basic DLLs installed to run MFC or Visual Basic 6.0 applications.</p></blockquote><blockquote><p>By default, Microsoftâ€™s C++ compiler builds EXE/DLL modules that contain unmanaged (native)<br>code and manipulate unmanaged data (native memory) at run time.</p></blockquote><blockquote><p>The flexibility provided by Microsoftâ€™s C++ compiler is unparalleled by other compilers because it allows developers to use their existing native C/C++ code from managed code and to start integrating the use of managed types as they see fit.</p></blockquote><p>ğŸ’¡ å°ç»“ï¼šå…¬å…±è¿è¡Œæ—¶ï¼ˆCommon Language Runtimeï¼ŒCLRï¼‰æ˜¯ä¸€ä¸ªå¯ç”±å¤šç§ç¼–ç¨‹è¯­è¨€ä½¿ç”¨çš„â€ è¿è¡Œæ—¶ â€œï¼ŒCLR çš„æ ¸å¿ƒåŠŸèƒ½å¯ä»¥è¢«æ‰€æœ‰é¢å‘ CLR çš„è¯­è¨€ä½¿ç”¨ã€‚ç»è¿‡â€ è¿è¡Œæ—¶ â€œçš„è¯­è¨€ç¼–è¯‘å™¨çš„ç¼–è¯‘åï¼Œäº§ç”Ÿçš„æ˜¯æ‰˜ç®¡æ¨¡å—ï¼ˆmanaged moduleï¼‰ï¼Œæ‰˜ç®¡æ¨¡å—åˆå«åš PE æ–‡ä»¶ï¼Œåˆ†ä¸ºæ ‡å‡†çš„ 32 ä½ PE32 æ–‡ä»¶å’Œæ ‡å‡†çš„ 64 ä½ PE32 + æ–‡ä»¶ï¼Œå®ƒä»¬éƒ½éœ€è¦ CLR æ‰èƒ½æ‰§è¡Œã€‚æ¯ä¸ªæ‰˜ç®¡æ¨¡å—åˆè¢«åˆ†ä¸ºä¸Šå›¾ 4 ä¸ªéƒ¨åˆ†ã€‚æœ¬æœºä»£ç ç¼–è¯‘å™¨ç”Ÿæˆçš„æ˜¯é¢å‘ç‰¹å®š CPU æ¶æ„çš„ä»£ç ï¼Œè€Œé¢å‘ CLR çš„ç¼–è¯‘å™¨ç”Ÿæˆéƒ½æ˜¯ IL ä»£ç ï¼ŒIL ä»£ç ä¹Ÿè¢«ç§°ä½œæ‰˜ç®¡ä»£ç ï¼Œç”± CLR ç®¡ç†å®ƒçš„æ‰§è¡Œã€‚é™¤äº†ç”Ÿæˆ ILï¼Œé¢å‘ CLR çš„æ¯ä¸ªç¼–è¯‘å™¨è¿˜è¦åœ¨æ¯ä¸ªæ‰˜ç®¡æ¨¡å—ä¸­ç”Ÿæˆå®Œæ•´çš„å…ƒæ•°æ®ï¼ˆmetadataï¼‰ã€‚å…ƒæ•°æ®æ€»æ˜¯å’ŒåŒ…å« IL ä»£ç çš„æ–‡ä»¶å…³è”ï¼Œå®ƒä»¬è¢«åµŒå…¥åˆ°äº†å’Œä»£ç ç›¸åŒçš„ EXE/DLL æ–‡ä»¶å½“ä¸­ï¼ˆåé¢å¯ä»¥çœ‹åˆ° DLL æ–‡ä»¶ç”±å¤šä¸ªæ‰˜ç®¡æ¨¡å—ç»„æˆï¼‰ï¼Œä½¿ä¸¤è€…å¯†ä¸å¯åˆ†ï¼Œæ­£æ˜¯å› ä¸ºåœ¨å®ç°ç±»å‹ / æˆå‘˜çš„ IL ä»£ç ä¸­å·²ç»åŒ…å«äº†æœ‰å…³å¼•ç”¨ç±»å‹ / æˆå‘˜çš„å…¨éƒ¨ä¿¡æ¯ï¼Œæ‰€ä»¥ç¼–è¯‘å™¨å¯ä»¥ç›´æ¥ä»æ‰˜ç®¡ä»£ç ä¸­è¯»å–å…ƒæ•°æ®ï¼Œä»è€Œé¿å…äº†ç¼–è¯‘æ—¶å¯¹åŸç”Ÿ C/C++ å¤´å’Œåº“æ–‡ä»¶çš„éœ€æ±‚ã€‚ä¸ºäº†æ‰§è¡ŒåŒ…å«æ‰˜ç®¡ä»£ç çš„æ¨¡å—ï¼Œç”¨æˆ·æœºä¸Šå¿…é¡»å®‰è£… CLRï¼ˆ<span class="exturl" data-url="aHR0cDovL3huLS1zaXE3MGEuTkVU">ä½œä¸º.NET</span> Framework çš„ä¸€éƒ¨åˆ†æä¾›ï¼‰ã€‚</p><h2 id="combining-managed-modules-into-assemblies"><a class="anchor" href="#combining-managed-modules-into-assemblies">#</a> Combining Managed Modules into Assemblies</h2><blockquote><p>The CLR doesnâ€™t actually work with modules, it works with assemblies. An assembly is an abstract concept that can be difficult to grasp initially. First, an assembly is a logical grouping of one or more modules or resource files. Second, an assembly is the smallest unit of reuse, security, and versioning. Depending on the choices you make with your compilers or tools, you can produce a single-file or a multifile assembly. In the CLR world, an assembly is what we would call a component.</p></blockquote><blockquote><p>Figure 1-2 should help explain what assemblies are about. In this figure, some managed modules and resource (or data) files are being processed by a tool. This tool produces a single PE32(+) file that represents the logical grouping of files. What happens is that this PE32(+) file contains a block of data called the manifest. The manifest is simply another set of metadata tables. These tables describe the files that make up the assembly, the publicly exported types implemented by the files in the assembly, and the resource or data files that are associated with the assembly.</p></blockquote><p><img data-src="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/Untitled2.png" alt="Untitled"></p><blockquote><p>An assemblyâ€™s modules also include information about referenced assemblies (including their<br>version numbers). This information makes an assembly self-describing. In other words, the CLR can determine the assemblyâ€™s immediate dependencies in order for code in the assembly to execute. No additional information is required in the registry or in Active Directory Domain Services (ADDS). Because no additional information is needed, deploying assemblies is much easier than deploying unmanaged components.</p></blockquote><p>ğŸ’¡ å°ç»“ï¼šCLR å®é™…ä¸Šä¸å’Œæ¨¡å—å·¥ä½œï¼Œè€Œæ˜¯å’Œç¨‹åºé›†å·¥ä½œï¼Œåœ¨ CLR çš„ä¸–ç•Œä¸­ï¼Œç¨‹åºé›†ç›¸å½“äº â€œç»„ä»¶â€ã€‚ä¸€äº›æ‰˜ç®¡æ¨¡å—å’Œèµ„æºï¼ˆæˆ–æ•°æ®ï¼‰æ–‡ä»¶äº¤ç”±ä¸€ä¸ªå·¥å…·å¤„ç†æˆä¸€ä¸ª PE32 (+) æ–‡ä»¶ï¼Œå°±æ˜¯å‰æ–‡æåˆ°çš„æ‰˜ç®¡æ¨¡å—ï¼Œåªä¸è¿‡å®ƒåŒ…å«äº†ä¸€ä¸ªåä¸ºæ¸…å•ï¼ˆmanifestï¼‰çš„æ•°æ®å—ï¼Œæ¸…å•ä¹Ÿæ˜¯å…ƒæ•°æ®è¡¨çš„é›†åˆï¼Œè¯¥æ‰˜ç®¡æ¨¡å—ç»ç¼–è¯‘å™¨è½¬æ¢ä¸ºç¨‹åºé›†ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œç¨‹åºé›†å°±æ˜¯ C# ç¼–è¯‘å™¨ç”Ÿæˆçš„å«æœ‰æ¸…å•çš„æ‰˜ç®¡æ¨¡å—ï¼Œæ¸…å•æŒ‡å‡ºäº†ç¨‹åºé›†åªæœ‰ä¸€ä¸ªæ–‡ä»¶æ„æˆã€‚ç¨‹åºé›†çš„æ¨¡å—ä¸­è¿˜åŒ…å«äº†è‡ªæè¿°ï¼ˆself-describingï¼‰çš„ä¿¡æ¯ï¼Œä»è€Œä¸éœ€è¦å†æ³¨å†Œè¡¨æˆ– ADDS ä¸­ä¿å­˜é¢å¤–çš„ä¿¡æ¯ï¼Œå› æ­¤æ›´å®¹æ˜“éƒ¨ç½²ã€‚</p><h2 id="loading-the-common-language-runtime"><a class="anchor" href="#loading-the-common-language-runtime">#</a> Loading the Common Language Runtime</h2><blockquote><p>Each assembly you build can be either an executable application or a DLL containing a set of types for use by an executable application.</p></blockquote><blockquote><p>Before we start looking at how the CLR loads, we need to spend a moment discussing 32-bit and 64-bit versions of Windows. If your assembly files contain only type-safe managed code, you are writing code that should work on both 32-bit and 64-bit versions of Windows. No source code changes are required for your code to run on either version of Windows. In fact, the resulting EXE/DLL file produced by the compiler should work correctly when running on x86 and x64 versions of Windows. In addition, Windows Store applications or class libraries will run on Windows RT machines (which use an ARM CPU). In other words, the one file will run on any machine that has the corresponding version of the .NET Framework installed on it.</p></blockquote><p>ğŸ’¡ Noteï¼šå…³äºä»€ä¹ˆæ˜¯åŸºäº ARM çš„ WinRT ç³»ç»Ÿï¼Œæ€»ç»“èµ·æ¥å°±æ˜¯ï¼Œåœ¨é’ˆå¯¹ ARM é€‚é…çš„ Windows RT ç³»ç»Ÿä¸­ï¼Œ<span class="exturl" data-url="aHR0cDovL3huLS0ycnF4NDJhbXVicmR3NDZicW5peHFwLk5ldA==">åº•å±‚å¹¶æ²¡æœ‰ä½¿ç”¨.Net</span> Frameworkï¼Œè€Œæ˜¯å’Œ x86 æ¶æ„çš„ Windows ä¸€æ ·ï¼Œåªæ˜¯åœ¨ Kernel å±‚é¢å¯¹ ARM æŒ‡ä»¤è¿›è¡Œäº†æ”¯æŒã€‚åœ¨ Kernel ä¹‹ä¸Šçš„ä¸ç®¡æ˜¯ Windows APIsã€Windows Runtime <span class="exturl" data-url="aHR0cDovL3huLS1BUElzLTNpMGkzNjRzLk5ldA==">APIs è¿˜æ˜¯.Net</span> Frameworkï¼Œé™¤äº†å°‘éƒ¨åˆ†å®ç°å¯èƒ½éœ€è¦åšé’ˆå¯¹ ARM æŒ‡ä»¤çš„ç‰¹æ®Šå¤„ç†ï¼Œå…¶å®ƒè¯¥æ˜¯ä»€ä¹ˆæ ·å°±æ˜¯ä»€ä¹ˆæ ·ã€‚è‡³äºæ›´é¡¶å±‚çš„ä¸€èˆ¬åº”ç”¨ï¼Œåœ¨å¤§éƒ¨åˆ†æ—¶å€™ç”šè‡³æ„ŸçŸ¥ä¸åˆ°åº•å±‚åˆ°åº•ç”¨äº† x86 è¿˜æ˜¯ ARM æ¶æ„çš„èŠ¯ç‰‡ã€‚</p><blockquote><p>On extremely rare occasions, developers want to write code that works only on a specific version of Windows. Developers might do this when using unsafe code or when interoperating with unmanaged code that is targeted to a specific CPU architecture. To aid these developers, the C# compiler offers a /platform command-line switch. This switch allows you to specify whether the resulting assembly can run on x86 machines running 32-bit Windows versions only, x64 machines running 64-bit Windows only, or ARM machines running 32-bit Windows RT only. If you donâ€™t specify a platform, the default is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>n</mi><mi>y</mi><mi>c</mi><mi>p</mi><mi>u</mi></mrow><annotation encoding="application/x-tex">anycpu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:.03588em">y</span><span class="mord mathnormal">c</span><span class="mord mathnormal">p</span><span class="mord mathnormal">u</span></span></span></span>, which indicates that the resulting assembly can run on any version of Windows.</p></blockquote><p><img data-src="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/Untitled3.png" alt="Untitled"></p><blockquote><p>Depending on the platform switch, the C# compiler will emit an assembly that contains either a PE32 or PE32+ header, and the compiler will also emit the desired CPU architecture (or agnostic) into the header as well. Microsoft ships two SDK command-line utilities, DumpBin.exe and CorFlags.exe, that you can use to examine the header information emitted in a managed module by the compiler.</p></blockquote><blockquote><p>When running an executable file, Windows examines this EXE fileâ€™s header to determine whether the application requires a 32-bit or 64-bit address space. A file with a PE32 header can run with a 32-bit or 64-bit address space, and a file with a PE32+ header requires a 64-bit address space. Windows also checks the CPU architecture information embedded inside the header to ensure that it matches the CPU type in the computer. Lastly, 64-bit versions of Windows offer a technology that allows 32-bit Windows applications to run. This technology is called WoW64 (for Windows on Windows 64).</p></blockquote><p><img data-src="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/Untitled4.png" alt="Untitled"></p><blockquote><p>After Windows has examined the EXE fileâ€™s header to determine whether to create a 32-bit or 64-bit process, Windows loads the x86, x64, or ARM version of MSCorEE.dll into the processâ€™s address space. Then, the processâ€™s primary thread calls a method defined inside MSCorEE.dll. This method initializes the CLR, loads the EXE assembly, and then calls its entry point method (Main). At this point, the managed application is up and running.</p></blockquote><blockquote><p>If an unmanaged application calls the Win32 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>o</mi><mi>a</mi><mi>d</mi><mi>L</mi><mi>i</mi><mi>b</mi><mi>r</mi><mi>a</mi><mi>r</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">LoadLibrary</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">L</span><span class="mord mathnormal">o</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord mathnormal">L</span><span class="mord mathnormal">i</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal" style="margin-right:.03588em">y</span></span></span></span> function to load a managed assembly, Windows knows to load and initialize the CLR (if not already loaded) in order to process the code contained within the assembly. Of course, in this scenario, the process is already up and running, and this may limit the usability of the assembly. For example, a managed assembly compiled with the /platform:x86 switch will not be able to load into a 64-bit process at all, whereas an executable file compiled with this same switch would have loaded in WoW64 on a computer running a 64-bit version of Windows.</p></blockquote><p>ğŸ’¡ å°ç»“ï¼šå¯¹äºç±»å‹å®‰å…¨çš„æ‰˜ç®¡ä»£ç æ¥è¯´ï¼Œä»£ç åœ¨ 32 ä½å’Œ 64 ä½ Windows ä¸Šéƒ½èƒ½æ­£å¸¸å·¥ä½œï¼Œä»£ç æ— éœ€ä»»ä½•æ”¹åŠ¨ï¼Œè€Œå¯¹äºä½¿ç”¨ ARM CPU çš„ WinRT æœºå™¨æ¥è¯´ï¼Œ<span class="exturl" data-url="aHR0cDovL3huLS15a3EzNGtpdWgzbWFzMWlmdXIxMnMyeGhxejZieHNiLk5FVA==">åªè¦å®‰è£…äº†å¯¹åº”ç‰ˆæœ¬çš„.NET</span> Frameworkï¼Œæ–‡ä»¶å°±èƒ½æ­£å¸¸è¿è¡Œã€‚æœ‰æ—¶éœ€è¦ä½¿ç”¨ä¸å®‰å…¨çš„ä»£ç æˆ–è€…è¦å’Œç‰¹å®šæ¶æ„çš„éæ‰˜ç®¡ä»£ç è¿›è¡Œäº’æ“ä½œæ—¶ï¼Œå¯ä»¥ä½¿ç”¨ /platform å‘½ä»¤è¡Œå¼€å…³é€‰é¡¹ã€‚åœ¨è¿è¡Œä¸€ä¸ªåº”ç”¨ç¨‹åºæ—¶ï¼ŒWindows æ£€æŸ¥ EXE æ–‡ä»¶å¤´ï¼Œå†³å®šæ˜¯åˆ›å»º 32 ä½è¿˜æ˜¯ 64 ä½è¿›ç¨‹åï¼Œä¼šåœ¨è¿›ç¨‹åœ°å€ç©ºé—´åŠ è½½ MSCorEE.dll çš„ x86ã€x64 æˆ– ARM ç‰ˆæœ¬ã€‚ç„¶åè¿›ç¨‹çš„ä¸»çº¿ç¨‹è°ƒç”¨ MSCorEE.dll ä¸­å®šä¹‰çš„ä¸€ä¸ªæ–¹æ³•ã€‚è¿™ä¸ªæ–¹æ³•åˆå§‹åŒ– CLRï¼ŒåŠ è½½ EXE ç¨‹åºé›†ï¼Œå†è°ƒç”¨å…¶å…¥å£æ–¹æ³•ï¼ˆMainï¼‰ã€‚éšå³ï¼Œæ‰˜ç®¡åº”ç”¨ç¨‹åºå¯åŠ¨å¹¶è¿è¡Œã€‚</p><h2 id="executing-your-assemblys-code"><a class="anchor" href="#executing-your-assemblys-code">#</a> Executing Your Assemblyâ€™s Code</h2><blockquote><p>As mentioned earlier, managed assemblies contain both metadata and IL. IL is a CPU-independent machine language created by Microsoft after consultation with several external commercial and academic language/compiler writers. IL is a much higher-level language than most CPU machine languages. IL can access and manipulate object types and has instructions to create and initialize objects, call virtual methods on objects, and manipulate array elements directly. It even has instructions to throw and catch exceptions for error handling. You can think of IL as an object-oriented machine language.</p></blockquote><p>Figure 1-4 shows what happens the first time a method is called.</p><p><img data-src="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/Untitled5.png" alt="Untitled"></p><blockquote><p>Just before the Main method executes, the CLR detects all of the types that are referenced by<br>Mainâ€™s code. This causes the CLR to allocate an internal data structure that is used to manage access to the referenced types. In Figure 1-4, the Main method refers to a single type, Console, causing the CLR to allocate a single internal structure. This internal data structure contains an entry for each method defined by the Console type. Each entry holds the address where the methodâ€™s implementation can be found. When initializing this structure, the CLR sets each entry to an internal, undocumented function contained inside the CLR itself. I call this function JITCompiler.</p></blockquote><blockquote><p>When Main makes its first call to WriteLine, the JITCompiler function is called. The JITCompiler function is responsible for compiling a methodâ€™s IL code into native CPU instructions.<br>Because the IL is being compiled â€œjust in time,â€ this component of the CLR is frequently referred to as a JITter or a JIT compiler.</p></blockquote><blockquote><p>When called, the JITCompiler function knows what method is being called and what type defines this method. The JITCompiler function then searches the defining assemblyâ€™s metadata for the called methodâ€™s IL. JITCompiler next verifies and compiles the IL code into native CPU instructions. The native CPU instructions are saved in a dynamically allocated block of memory. Then, JITCompiler goes back to the entry for the called method in the typeâ€™s internal data structure created by the CLR and replaces the reference that called it in the first place with the address of the block of memory containing the native CPU instructions it just compiled. Finally, the JITCompiler function jumps to the code in the memory block. This code is the implementation of the WriteLine method (the version that takes a String parameter). When this code returns, it returns to the code in Main, which continues execution as normal.</p></blockquote><p><img data-src="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/Untitled6.png" alt="Untitled"></p><blockquote><p>Main now calls WriteLine a second time. This time, the code for WriteLine has already been<br>verified and compiled. So the call goes directly to the block of memory, skipping the JITCompiler function entirely. After the WriteLine method executes, it returns to Main. Figure 1-5 shows what the process looks like when WriteLine is called the second time.</p></blockquote><blockquote><p>A performance hit is incurred only the first time a method is called. All subsequent calls to the<br>method execute at the full speed of the native code because verification and compilation to native code donâ€™t need to be performed again.</p></blockquote><blockquote><p>You should also be aware that the CLRâ€™s JIT compiler optimizes the native code just as the back end of an unmanaged C++ compiler does. Again, it may take more time to produce the optimized code, but the code will execute with much better performance than if it hadnâ€™t been optimized.</p></blockquote><p><img data-src="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/Untitled7.png" alt="Untitled"></p><blockquote><p>For those developers coming from an unmanaged C or C++ background, youâ€™re probably thinking about the performance ramifications of all this. After all, unmanaged code is compiled for a specific CPU platform, and, when invoked, the code can simply execute. In this managed environment, compiling the code is accomplished in two phases. First, the compiler passes over the source code, doing as much work as possible in producing IL. But to execute the code, the IL itself must be compiled into native CPU instructions at run time, requiring more non-shareable memory to be allocated and requiring additional CPU time to do the work.</p></blockquote><h3 id="il-and-verification"><a class="anchor" href="#il-and-verification">#</a> IL and Verification</h3><blockquote><p>IL is stack-based, which means that all of its instructions push operands onto an execution stack and pop results off the stack. Because IL offers no instructions to manipulate registers, it is easy for people to create new languages and compilers that produce code targeting the CLR.</p></blockquote><blockquote><p>IL instructions are also typeless. For example, IL offers an add instruction that adds the last two<br>operands pushed on the stack. There are no separate 32-bit and 64-bit versions of the add instruction. When the add instruction executes, it determines the types of the operands on the stack and performs the appropriate operation.</p></blockquote><blockquote><p>While compiling IL into native CPU instructions, the CLR performs a process called verification. Verification examines the high-level IL code and ensures that everything the code does is safe.</p></blockquote><blockquote><p>In Windows, each process has its own virtual address space. Separate address spaces are necessary because you canâ€™t trust an applicationâ€™s code. It is entirely possible (and unfortunately, all too common) that an application will read from or write to an invalid memory address. By placing each Windows process in a separate address space, you gain robustness and stability; one process canâ€™t adversely affect another process.</p></blockquote><blockquote><p>By verifying the managed code, however, you know that the code doesnâ€™t improperly access<br>memory and canâ€™t adversely affect another applicationâ€™s code. This means that you can run multiple managed applications in a single Windows virtual address space.</p></blockquote><blockquote><p>Because Windows processes require a lot of operating system resources, having many of them<br>can hurt performance and limit available resources. Reducing the number of processes by running multiple applications in a single operating system process can improve performance, require fewer resources, and be just as robust as if each application had its own process. This is another benefit of managed code as compared to unmanaged code.</p></blockquote><h3 id="unsafe-code"><a class="anchor" href="#unsafe-code">#</a> Unsafe Code</h3><blockquote><p>By default, Microsoftâ€™s C# compiler produces safe code. Safe code is code that is verifiably safe. However, Microsoftâ€™s C# compiler allows developers to write unsafe code. Unsafe code is allowed to work directly with memory addresses and can manipulate bytes at these addresses. This is a very powerful feature and is typically useful when interoperating with unmanaged code or when you want to improve the performance of a time-critical algorithm.</p></blockquote><blockquote><p>However, using unsafe code introduces a significant risk: unsafe code can corrupt data structures and exploit or even open up security vulnerabilities. For this reason, the C# compiler requires that all methods that contain unsafe code be marked with the unsafe keyword. In addition, the C# compiler requires you to compile the source code by using the /unsafe compiler switch.</p></blockquote><p>ğŸ’¡ å°ç»“ï¼šIL æ˜¯ä¸ CPU æ— å…³çš„æœºå™¨è¯­è¨€ï¼ŒIL èƒ½è®¿é—®å’Œæ“ä½œå¯¹è±¡ç±»å‹ï¼Œè€Œä¸”æä¾›äº†æŒ‡ä»¤æ¥åˆ›å»ºå’Œåˆå§‹åŒ–å¯¹è±¡ã€è°ƒç”¨å¯¹è±¡ä¸Šçš„è™šæ–¹æ³•ä»¥åŠç›´æ¥æ“ä½œæ•°ç»„å…ƒç´ ï¼Œç”šè‡³æä¾›äº†æŠ›å‡ºå’Œæ•æ‰å¼‚å¸¸çš„æŒ‡ä»¤æ¥å®ç°é”™è¯¯å¤„ç†ã€‚IL ä¹Ÿèƒ½ä½¿ç”¨æ±‡ç¼–è¯­è¨€ç¼–å†™ï¼Œé«˜çº§è¯­è¨€é€šå¸¸åªå…¬å¼€äº† CLR å…¨éƒ¨åŠŸèƒ½çš„ä¸€ä¸ªå­é›†ï¼Œä½†é€šè¿‡ IL æ±‡ç¼–è¯­è¨€æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ CLR çš„å…¨éƒ¨åŠŸèƒ½ã€‚å…è®¸åœ¨ä¸åŒç¼–ç¨‹è¯­è¨€ä¹‹é—´æ–¹ä¾¿åœ°åˆ‡æ¢ï¼ŒåŒæ—¶æœ‰ä¿æŒç´§å¯†é›†æˆï¼Œè¿™æ˜¯ CLR çš„ä¸€ä¸ªå¾ˆå‡ºä¼—çš„ç‰¹ç‚¹ã€‚æ‰§è¡Œæ–¹æ³•æ—¶ï¼ŒCLR çš„ JIT ç¼–è¯‘å™¨è´Ÿè´£æŠŠæ–¹æ³•çš„ IL ä»£ç è½¬æ¢æˆæœ¬æœº CPU æŒ‡ä»¤ï¼ŒJIT æ˜¯ just in time çš„æ„æ€ï¼Œåªæœ‰åœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨åˆ°ç¨‹åºé›†ä¸­çš„æ–¹æ³•æ—¶ï¼ŒCLR ä¼šåˆ†é…è¯¥æ–¹æ³•å¼•ç”¨ç±»å‹çš„ä¸€ä¸ªå†…éƒ¨ç»“æ„ï¼Œåœ¨è¿™ä¸ªæ•°æ®ç»“æ„ä¸­ï¼Œç±»å‹ä¸­çš„æ¯ä¸€ä¸ªæ–¹æ³•éƒ½æœ‰ä¸€ä¸ªå¯¹åº”çš„è®°å½•é¡¹ï¼Œåˆå§‹æ—¶ä¼šè¢«è®¾ç½®æˆæŒ‡å‘ JIPCompilerï¼Œä¹‹å JITCompiler åœ¨å®šä¹‰è¯¥ç±»å‹çš„ç¨‹åºé›†çš„å…ƒæ•°æ®ä¸­æŸ¥æ‰¾è¢«è°ƒç”¨æ–¹æ³•çš„ ILï¼Œæ­¤æ—¶ä¼šæœ‰ä¸€ä¸ªéªŒè¯çš„è¿‡ç¨‹ï¼ŒéªŒè¯è¿‡ç¨‹ä¼šæ£€æŸ¥ IL ä»£ç ï¼Œç¡®å®šä»£ç æ‰€ä½œçš„ä¸€åˆ‡éƒ½æ˜¯å®‰å…¨çš„ã€‚ä¹‹å IL ä»£ç è¢«ç¼–è¯‘æˆæœ¬æœº CPU æŒ‡ä»¤ä¿å­˜åœ¨åŠ¨æ€åˆ†é…çš„å†…å­˜å—ä¸­ï¼ˆè¿™å°±è§£é‡Šäº†ä¸ºä»€ä¹ˆåº”ç”¨ç¨‹åºä¸€æ—¦ç»ˆæ­¢ï¼Œç¬¬äºŒæ¬¡è¿è¡Œæ—¶ä»éœ€ç¼–è¯‘çš„åŸå› ï¼‰ã€‚ç„¶å JITCompiler ä¼šå›åˆ° CLR ä¸ºç±»å‹åˆ›å»ºçš„å†…éƒ¨æ•°æ®ç»“æ„ï¼Œæ‰¾åˆ°ä¸è¢«è°ƒç”¨æ–¹æ³•å¯¹åº”çš„é‚£æ¡è®°å½•ï¼Œä¿®æ”¹æœ€åˆå¯¹ JITCompiler çš„å¼•ç”¨ï¼Œä½¿å…¶æŒ‡å‘å†…å­˜å—ä¸­ç¼–è¯‘å¥½çš„æœ¬æœº CPU æŒ‡ä»¤çš„åœ°å€ã€‚æœ€åï¼ŒJITCompiler æ‰§è¡Œå†…å­˜å—ä¸­çš„ä»£ç ï¼Œæ‰§è¡Œå®Œæ¯•è¿”å›åˆ° Main ä¸­çš„ä¸‹ä¸€æ¡è¯­å¥ç»§ç»­æ‰§è¡Œï¼Œè‹¥ç¬¬äºŒæ¬¡æ‰§è¡Œç›¸åŒæ–¹æ³•æ—¶ï¼Œåˆ™ä¼šç›´æ¥æ‰§è¡Œå†…å­˜å—ä¸­çš„ä»£ç ã€‚å¯ä»¥çœ‹å‡ºï¼Œæ–¹æ³•åªæœ‰åœ¨é¦–æ¬¡è°ƒç”¨æ—¶æ‰å­˜åœ¨æ€§èƒ½æŸå¤±ã€‚é€šè¿‡å¯¹ Linux ä¸­è½¯ä»¶åŒ…ç®¡ç†çŸ¥è¯†çš„å­¦ä¹ ï¼Œæˆ‘ä»¬çŸ¥é“ C/C++ çš„æºç åŒ…é’ˆå¯¹ä¸€ç§å…·ä½“ CPU å¹³å°è¿›è¡Œç¼–è¯‘ï¼Œä»è€Œç”Ÿæˆé€‚åˆäºæœ¬æœºæ“ä½œç³»ç»Ÿçš„äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œæºç åŒ…ç¼–è¯‘å®‰è£…å®Œæˆåï¼Œä¸€æ—¦è°ƒç”¨ï¼Œä»£ç ç›´æ¥å°±èƒ½è¿è¡Œã€‚è€Œåœ¨æ‰˜ç®¡ç¯å¢ƒä¸­ï¼Œä»£ç çš„ç¼–è¯‘æ˜¯åˆ†ä¸¤ä¸ªé˜¶æ®µå®Œæˆçš„ã€‚é¦–å…ˆï¼Œç¼–è¯‘å™¨éå†æºä»£ç ï¼Œåšå¤§é‡çš„å·¥ä½œæ¥ç”Ÿæˆ IL ä»£ç ã€‚ä½†è¦çœŸæ­£æ‰§è¡Œï¼Œè¿™äº› IL ä»£ç æœ¬èº«å¿…é¡»åœ¨è¿è¡Œæ—¶ç¼–è¯‘æˆæœ¬æœº CPU æŒ‡ä»¤ï¼Œè¿™å°±éœ€è¦åˆ†é…æ›´å¤šçš„éå…±äº«å†…å­˜ï¼Œå¹¶ä¸”è¦èŠ±è´¹é¢å¤–çš„ CPU æ—¶é—´ã€‚ä¸è¿‡ï¼ŒJIT ç¼–è¯‘ä¹Ÿæœ‰å®ƒçš„ä¼˜ç‚¹ï¼Œä¾‹å¦‚å®ƒèƒ½ä½¿ç”¨æå‡æ€§èƒ½çš„ç‰¹æ®ŠæŒ‡ä»¤ã€ç”Ÿæˆçš„æœ¬æœºä»£ç å°†é’ˆå¯¹ä¸»æœºè¿›è¡Œä¼˜åŒ–ï¼Œä½¿æœ€ç»ˆä»£ç å˜å¾—æ›´å°ï¼Œæ‰§è¡Œå¾—æ›´å¿«ï¼Œæœ€å¤§çš„ä¼˜åŠ¿æ˜¯ï¼Œå®ƒä¿è¯äº†åº”ç”¨ç¨‹åºçš„å¥å£®æ€§å’Œå®‰å…¨æ€§ï¼Œå®ƒèƒ½éªŒè¯ä»£ç çš„å®‰å…¨æ€§ï¼Œèƒ½ç”¨ä¸€ä¸ªè¿›ç¨‹è¿è¡Œå¤šä¸ªåº”ç”¨ç¨‹åºå¹¶ä¸”ä¿è¯ä»£ç ä¸ä¼šä¸æ­£ç¡®åœ°è®¿é—®å†…å­˜ï¼Œä¸ä¼šå¹²æ‰°åˆ°å¦ä¸€ä¸ªåº”ç”¨ç¨‹åºçš„ä»£ç ã€‚å¯ä»¥çœ‹åˆ°ï¼Œåœ¨è¿™äº›æ–¹é¢æ‰˜ç®¡åº”ç”¨ç¨‹åºçš„æ€§èƒ½å®é™…ä¸Šè¶…è¶Šäº†éæ‰˜ç®¡åº”ç”¨ç¨‹åºã€‚</p><h2 id="the-native-code-generator-tool-ngenexe"><a class="anchor" href="#the-native-code-generator-tool-ngenexe">#</a> The Native Code Generator Tool: NGen.exe</h2><blockquote><p>The NGen.exe tool that ships with the .NET Framework can be used to compile IL code to native code when an application is installed on a userâ€™s machine. Because the code is compiled at install time, the CLRâ€™s JIT compiler does not have to compile the IL code at run time, and this can improve the applicationâ€™s performance. The NGen.exe tool is interesting in two scenarios:</p></blockquote><p>â–  <strong>Improving an applicationâ€™s startup time</strong></p><blockquote><p>Running NGen.exe can improve startup time because the code will already be compiled into native code so that compilation doesnâ€™t have to occur at run time.</p></blockquote><p>â–  <strong>Reducing an applicationâ€™s working set</strong></p><blockquote><p>If you believe that an assembly will be loaded into multiple processes simultaneously, running NGen.exe on that assembly can reduce the applicationsâ€™ working set. The reason is because the NGen.exe tool compiles the IL to native code and saves the output in a separate file. This file can be memory-mapped into multiple-process address spaces simultaneously, allowing the code to be shared; not every process needs its own copy of the code.</p></blockquote><p>ğŸ’¡ Noteï¼šæ‰€è°“å·¥ä½œé›†ï¼ˆworking setï¼‰ï¼Œæ˜¯æŒ‡åœ¨è¿›ç¨‹çš„æ‰€æœ‰å†…å­˜ä¸­ï¼Œå·²æ˜ å°„çš„ç‰©ç†å†…å­˜é‚£ä¸€éƒ¨åˆ†ï¼ˆå³è¿™äº›å†…å­˜å—å…¨åœ¨ç‰©ç†å†…å­˜ä¸­ï¼Œå¹¶ä¸” CPU å¯ä»¥ç›´æ¥è®¿é—®ï¼‰ï¼›è¿›ç¨‹è¿˜æœ‰ä¸€éƒ¨åˆ†è™šæ‹Ÿå†…å­˜ï¼Œå®ƒä»¬å¯èƒ½åœ¨è½¬æ¢åˆ—è¡¨ä¸­ï¼ˆCPU ä¸èƒ½é€šè¿‡è™šåœ°å€è®¿é—®ï¼Œéœ€è¦ Windows æ˜ å°„ä¹‹åæ‰èƒ½è®¿é—®ï¼‰ï¼›è¿˜æœ‰ä¸€éƒ¨åˆ†å†…å­˜åœ¨ç£ç›˜ä¸Šçš„åˆ†é¡µæ–‡ä»¶é‡Œã€‚</p><blockquote><p>Now, whenever the CLR loads an assembly file, the CLR looks to see if a corresponding <code>NGenâ€™d</code> native file exists. If a native file cannot be found, the CLR JIT compiles the IL code as usual. However, if a corresponding native file does exist, the CLR will use the compiled code contained in the native file, and the fileâ€™s methods will not have to be compiled at run time.</p></blockquote><blockquote><p>On the surface, this sounds great! It sounds as if you get all of the benefits of managed code (garbage collection, verification, type safety, and so on) without all of the performance problems of managed code (JIT compilation). However, the reality of the situation is not as rosy as it would first seem. There are several potential problems with respect to <code>NGenâ€™d</code> files:</p></blockquote><p>â–  <strong>No intellectual property protection</strong></p><blockquote><p>Many people believe that it might be possible to ship <code>NGenâ€™d</code> files without shipping the files containing the original IL code, thereby keeping their intellectual property a secret. Unfortunately, this is not possible. At run time, the CLR requires access to the assemblyâ€™s metadata (for functions such as reflection and serialization); this requires that the assemblies that contain IL and metadata be shipped. In addition, if the CLR canâ€™t use the <code>NGenâ€™d</code> file for some reason (described next), the CLR gracefully goes back to JIT compiling the assemblyâ€™s IL code, which must be available.</p></blockquote><p>â–  <strong><code>NGenâ€™d</code> files can get out of sync</strong></p><blockquote><p>When the CLR loads an <code>NGenâ€™d</code> file, it compares a number of characteristics about the previously compiled code and the current execution environment. If any of the characteristics donâ€™t match, the <code>NGenâ€™d</code> file cannot be used, and the normal JIT compiler process is used instead. Here is a partial list of characteristics that must match:</p></blockquote><ul><li>CLR version: This changes with patches or service packs.</li><li>CPU type: This changes if you upgrade your processor hardware.</li><li>Windows operating system version: This changes with a new service pack update.</li><li>Assemblyâ€™s identity module version ID (MVID): This changes when recompiling.</li><li>Referenced assemblyâ€™s version IDs: This changes when you recompile a referenced assembly.</li><li>Security: This changes when you revoke permissions (such as declarative inheritance, declarative link-time), <code>SkipVerification</code> , or <code>UnmanagedCode</code> permissions), that were once granted.</li></ul><p>â–  <strong>Inferior execution-time performance</strong></p><blockquote><p>When compiling code, <code>NGen</code> canâ€™t make as many assumptions about the execution environment as the JIT compiler can. This causes NGen.exe to produce inferior code. Some <code>NGenâ€™d</code> applications actually perform about 5 percent slower when compared to their JIT-compiled counterpart. So, if youâ€™re considering using NGen.exe to improve the performance of your application, you should compare <code>NGenâ€™d</code> and <code>non-NGenâ€™d</code> versions to be sure that the <code>NGenâ€™d</code> version doesnâ€™t actually run slower! For some applications, the reduction in working set size improves performance, so using <code>NGen</code> can be a net win.</p></blockquote><blockquote><p>For large client applications that experience very long startup times, Microsoft provides a Managed Profile Guided Optimization tool (MPGO.exe). This tool analyzes the execution of your application to see what it needs at startup. This information is then fed to the NGen.exe tool in order to better optimize the resulting native image. This allows your application to start faster and with a reduced working set.</p></blockquote><p>ğŸ’¡ å°ç»“ï¼š<span class="exturl" data-url="aHR0cDovL3huLS0ycnF6MTNnLk5FVA==">ä½¿ç”¨.NET</span> Framework æä¾›çš„ NGen.exe å·¥å…·ï¼Œå¯ä»¥åœ¨åº”ç”¨ç¨‹åºå®‰è£…åˆ°ç”¨æˆ·çš„è®¡ç®—æœºä¸Šæ—¶ï¼Œå°† IL ä»£ç ç¼–è¯‘æˆæœ¬æœºä»£ç ã€‚è¿™ç§æ–¹å¼èƒ½å¤Ÿæé«˜åº”ç”¨ç¨‹åºçš„å¯åŠ¨é€Ÿåº¦ï¼Œå¹¶ä¸”å‡å°‘åº”ç”¨ç¨‹åºçš„å·¥ä½œé›†ï¼ˆGen.exe å°† IL ä»£ç ç¼–è¯‘æˆæœ¬æœºä»£ç ï¼Œå¹¶å°†è¿™äº›ä»£ç ä¿å­˜åœ¨å•ç‹¬çš„æ–‡ä»¶ä¸­ã€‚è¯¥æ–‡ä»¶å¯ä»¥é€šè¿‡ â€œå†…å­˜æ˜ å°„â€ çš„æ–¹å¼ï¼ŒåŒæ—¶æ˜ å°„åˆ°å¤šä¸ªè¿›ç¨‹åœ°å€ç©ºé—´ä¸­ï¼Œä½¿ä»£ç å¾—åˆ°äº†å…±ç”¨ï¼Œé¿å…æ¯ä¸ªè¿›ç¨‹éƒ½éœ€è¦ä¸€ä»½å•ç‹¬çš„ä»£ç æ‹·è´ï¼‰ã€‚ä½†æ˜¯ï¼Œä½¿ç”¨ NGen ä¹Ÿä¼šå¸¦æ¥ä¸€äº›é—®é¢˜ï¼Œä¾‹å¦‚ï¼šæ²¡æœ‰çŸ¥è¯†äº§æƒä¿æŠ¤ï¼Œå³ä½¿å‘å¸ƒ NGen ç”Ÿæˆçš„æ–‡ä»¶è€Œä¸å‘å¸ƒåŒ…å«åŸå§‹ IL ä»£ç çš„æ–‡ä»¶è¿˜æ˜¯ä¸èƒ½ä¿æŠ¤çŸ¥è¯†äº§æƒï¼Œå› ä¸ºåœ¨è¿è¡Œæ—¶ï¼ŒCLR è¦æ±‚è®¿é—®ç¨‹åºé›†çš„å…ƒæ•°æ®ï¼ˆç”¨äºåå°„å’Œåºåˆ—åŒ–ç­‰åŠŸèƒ½ï¼‰ï¼Œè¿™å°±è¦æ±‚å‘å¸ƒåŒ…å« IL å’Œå…ƒæ•°æ®çš„ç¨‹åºé›†ï¼›NGen ç”Ÿæˆçš„æ–‡ä»¶å¯èƒ½å¤±å»åŒæ­¥ï¼ŒCLR åŠ è½½ NGen ç”Ÿæˆçš„æ–‡ä»¶æ—¶ï¼Œä¼šå°†é¢„ç¼–è¯‘ä»£ç çš„è®¸å¤šç‰¹å¾ä¸å½“å‰æ‰§è¡Œç¯å¢ƒè¿›è¡Œæ¯”è¾ƒï¼Œä»»ä½•ç‰¹ç§°ä¸åŒ¹é…ï¼ŒNGen ç”Ÿæˆçš„æ–‡ä»¶å°±ä¸èƒ½ä½¿ç”¨ï¼›è¾ƒå·®çš„æ‰§è¡Œæ€§èƒ½ï¼Œç¼–è¯‘ä»£ç æ—¶ï¼ŒNGen æ— æ³•æƒ³ JIT ç¼–è¯‘å™¨é‚£æ ·å¯¹æ‰§è¡Œç¯å¢ƒè¿›è¡Œè®¸å¤šå‡å®šï¼Œä¾‹å¦‚ä¸èƒ½ä¼˜åŒ– CPU æŒ‡ä»¤ã€é™æ€å­—æ®µåªèƒ½é—´æ¥è®¿é—®ï¼Œè€Œä¸èƒ½ç›´æ¥è®¿é—®ï¼Œå› ä¸ºé™æ€å­—æ®µçš„å®é™…åœ°å€åªèƒ½åœ¨è¿è¡Œæ—¶ç¡®å®šï¼Œä¹Ÿä¸èƒ½çŸ¥é“ä¸€ä¸ªç±»æ„é€ å™¨æ˜¯å¦å·²ç»è°ƒç”¨ç­‰é—®é¢˜ã€‚å› æ­¤ä½¿ç”¨å‰åº”ä»”ç»†æ¯”è¾ƒ NGen ç‰ˆæœ¬å’Œé NGen ç‰ˆæœ¬ï¼Œè°¨æ…ä½¿ç”¨ã€‚å¯¹äºå¯åŠ¨å¾ˆæ…¢çš„å¤§å‹å®¢æˆ·ç«¯åº”ç”¨ç¨‹åºï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨ MPGO.exeï¼ˆManaged Profile Guided Optimizationï¼‰ï¼Œè¯¥å·¥å…·åˆ†æç¨‹åºæ‰§è¡Œï¼Œæ£€æŸ¥å®ƒåœ¨å¯åŠ¨æ—¶éœ€è¦çš„ä¸œè¥¿ï¼Œå¹¶æŠŠè¿™äº›ä¿¡æ¯è¿”å›ç»™ NGen.exe æ¥æ›´å¥½åœ°ä¼˜åŒ–æœ¬æœºæ˜ åƒï¼Œè¿™ä½¿åº”ç”¨ç¨‹åºå¯åŠ¨å¾—æ›´å¿«ï¼Œå·¥ä½œé›†ä¹Ÿç¼©å°äº†ã€‚</p><h2 id="the-framework-class-library"><a class="anchor" href="#the-framework-class-library">#</a> The Framework Class Library</h2><blockquote><p>The .NET Framework includes the Framework Class Library (FCL). The FCL is a set of DLL assemblies that contain several thousand type definitions in which each type exposes some functionality. Microsoft is producing additional libraries such as the Windows Azure SDK and the DirectX SDK. These additional libraries provide even more types, exposing even more functionality for your use. In fact, Microsoft is producing many libraries at a phenomenal rate, making it easier than ever for developers to use various Microsoft technologies.</p></blockquote><blockquote><p>Here are just some of the kinds of applications developers can create by using these assemblies:</p></blockquote><p>â–  <strong>Web services</strong></p><p>â–  <strong>Web Forms/MVC HTML-based applications (websites)</strong></p><p>â–  <strong>Rich Windows GUI applications</strong></p><p>â–  <strong>Windows console applications</strong></p><p>â–  <strong>Windows services</strong></p><p>â–  <strong>Database stored procedures</strong></p><p>â–  <strong>Component library</strong></p><blockquote><p>Most of the namespaces in the FCL present types that can be used for any kind of application. Table 1-3 lists some of the more general namespaces and briefly describes what the types in that namespace are used for. This is a very small sampling of the namespaces available. Please see the documentation that accompanies the various Microsoft SDKs to gain familiarity with the ever-growing set of namespaces that Microsoft is producing.</p></blockquote><p><img data-src="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/Untitled8.png" alt="Untitled"></p><p>ğŸ’¡ å°ç»“ï¼š.NET Framework åŒ…å«äº† Framework ç±»åº“ï¼ˆFramework Class Libraryï¼ŒFCLï¼‰ã€‚FCL æ˜¯ä¸€ç»„ DLL ç¨‹åºé›†çš„ç»Ÿç§°ï¼Œå…¶ä¸­åŒ…å«äº†æ•°åƒä¸ªç±»å‹å®šä¹‰ï¼Œæ¯ä¸ªç±»å‹éƒ½å…¬å¼€äº†ä¸€äº›åŠŸèƒ½ï¼Œ<span class="exturl" data-url="aHR0cDovL3huLS00Z3E2bWhiYjcxYm0yYXg3a3Y1bmZub3c0YXMyd3F4M2R5am5rM3dtdzRja2lhajNidjI5Zi5ORVQ=">é€šè¿‡ä½¿ç”¨è¿™äº›ç¨‹åºé›†æˆ‘ä»¬èƒ½åˆ›å»ºä¸€äº›åŸºäº.NET</span> Framework çš„åº”ç”¨ç¨‹åºã€‚</p><h2 id="the-common-type-system"><a class="anchor" href="#the-common-type-system">#</a> The Common Type System</h2><blockquote><p>By now, it should be obvious to you that the CLR is all about types. Types expose functionality to your applications and other types. Types are the mechanism by which code written in one programming language can talk to code written in a different programming language. Because types are at the root of the CLR, Microsoft created a formal specificationâ€”the Common Type System (CTS)â€”that describes how types are defined and how they behave.</p></blockquote><p>ğŸ’¡ Note : <span class="exturl" data-url="aHR0cDovL3huLS1NaWNyb3NvZnRDVFMtZXg0c24wZDMyOWJrMXp0cmI5MnEuTkVU">Microsoft äº‹å®ä¸Šå·²å°† CTS å’Œ.NET</span> Framework çš„å…¶ä»–ç»„ä»¶ â€” åŒ…æ‹¬æ–‡ä»¶æ ¼å¼ã€å…ƒæ•°æ®ã€ä¸­é—´è¯­è¨€ä»¥åŠå¯¹åº•å±‚å¹³å°çš„è®¿é—®ï¼ˆP/Invokeï¼‰â€” æäº¤ç»™ ECMA ä»¥å®Œæˆæ ‡å‡†åŒ–å·¥ä½œã€‚æœ€åå½¢æˆçš„æ ‡å‡†ç§°ä¸º â€œå…¬å…±è¯­è¨€åŸºç¡€ç»“æ„â€ï¼ˆCommon Language Infrastructure, CLIï¼‰ã€‚é™¤æ­¤ä¹‹å¤–ï¼ŒMicrosoft è¿˜æäº¤äº† Framework ç±»åº“çš„ä¸€éƒ¨åˆ†ã€C# ç¼–ç¨‹è¯­è¨€ï¼ˆECMA-334ï¼‰ä»¥åŠ C++/CLI ç¼–ç¨‹è¯­è¨€ã€‚</p><blockquote><p>The CTS specification states that a type can contain zero or more members. In Part II, â€œDesigning Types,â€ Iâ€™ll cover all of these members in great detail. For now, I just want to give you a brief introduction to them:</p></blockquote><p>â–  <strong>Field</strong></p><p>A data variable that is part of the objectâ€™s state. Fields are identified by their name and type.</p><p>â–  <strong>Method</strong></p><p>A function that performs an operation on the object, often changing the objectâ€™s state. Methods have a name, a signature, and modifiers. The signature specifies the number of parameters (and their sequence), the types of the parameters, whether a value is returned by the method, and if so, the type of the value returned by the method.</p><p>â–  <strong>Property</strong></p><p>To the caller, this member looks like a field. But to the type implementer, it looks like a method (or two). Properties allow an implementer to validate input parameters and object state before accessing the value and/or calculating a value only when necessary. They also allow a user of the type to have simplified syntax. Finally, properties allow you to create read-only or write-only &quot;fields&quot;.</p><p>â–  <strong>Event</strong></p><p>An event allows a notification mechanism between an object and other interested objects. For example, a button could offer an event that notifies other objects when the button is clicked.</p><blockquote><p>The CTS also specifies the rules for type visibility and access to the members of a type. Thus, the CTS establishes the rules by which assemblies form a boundary of visibility for a type, and the CLR enforces the visibility rules.</p></blockquote><blockquote><p>A type that is visible to a caller can further restrict the ability of the caller to access the typeâ€™s members. The following list shows the valid options for controlling access to a member:</p></blockquote><p>â–  <strong>Private</strong></p><p>The member is accessible only by other members in the same class type.</p><p>â–  <strong>Family</strong></p><p>The member is accessible by derived types, regardless of whether they are within the same assembly. Note that many languages (such as C++ and C#) refer to family as protected.</p><p>â–  <strong>Family and assembly</strong></p><p>The member is accessible by derived types, but only if the derived type is defined in the same assembly. Many languages (such as C# and Visual Basic) donâ€™t offer this access control. Of course, IL Assembly language makes it available.</p><p>â–  <strong>Assembly</strong></p><p>The member is accessible by any code in the same assembly. Many languages refer to assembly as internal.</p><p>â–  <strong>Family or assembly</strong></p><p>The member is accessible by derived types in any assembly. The member is also accessible by any types in the same assembly. C# refers to family or assembly as protected internal.</p><p>â–  <strong>Public</strong></p><p>The member is accessible by any code in any assembly.</p><blockquote><p>In addition, the CTS defines the rules governing type inheritance, virtual methods, object lifetime, and so on. These rules have been designed to accommodate the semantics expressible in modern day programming languages. In fact, you wonâ€™t even need to learn the CTS rules per se because the language you choose will expose its own language syntax and type rules in the same way that youâ€™re familiar with today. And it will map the language-specific syntax into IL, the â€œlanguageâ€ of the CLR, when it emits the assembly during compilation.</p></blockquote><blockquote><p>Sure, the syntax you use for defining the type is different depending on the language you choose, but the behavior of the type will be identical regardless of the language because the CLRâ€™s CTS defines the behavior of the type.</p></blockquote><blockquote><p>Hereâ€™s another CTS rule. All types must (ultimately) inherit from a predefined type: System.Object. As you can see, Object is the name of a type defined in the System namespace. This Object is the root of all other types and therefore guarantees that every type instance has a minimum set of behaviors. Specifically, the System.Object type allows you to do the following:</p></blockquote><p>â–  Compare two instances for equality.</p><p>â–  Obtain a hash code for the instance.</p><p>â–  Query the true type of an instance.</p><p>â–  Perform a shallow (bitwise) copy of the instance.</p><p>â–  Obtain a string representation of the instance objectâ€™s current state.</p><p>ğŸ’¡ å°ç»“ï¼šé€šè¿‡ç±»å‹ï¼Œç”¨ä¸€ç§ç¼–ç¨‹è¯­è¨€å†™çš„ä»£ç èƒ½ä¸ç”¨å¦ä¸€ç§ç¼–ç¨‹è¯­è¨€å†™çš„ä»£ç æ²Ÿé€šã€‚ç”±äºç±»å‹æ˜¯ CLR çš„æ ¹æœ¬ï¼Œæ‰€ä»¥ Microsoft åˆ¶å®šäº†ä¸€ä¸ªæ­£å¼çš„è§„èŒƒæ¥æè¿°ç±»å‹çš„å®šä¹‰å’Œè¡Œä¸ºï¼Œä¹Ÿå°±æ˜¯ â€œé€šç”¨ç±»å‹ç³»ç»Ÿâ€ï¼ˆCommon Type System, CTSï¼‰ã€‚<span class="exturl" data-url="aHR0cDovL3huLS1DVFMtY2o0ZW0yMHIuTkVU">è€Œ CTS å’Œ.NET</span> Framework çš„å…¶ä»–ç»„ä»¶ï¼ˆåŒ…æ‹¬æ–‡ä»¶æ ¼å¼ã€å…ƒæ•°æ®ã€ä¸­é—´è¯­è¨€ä»¥åŠå¯¹åº•å±‚å¹³å°çš„è®¿é—® P/Invokeï¼‰æäº¤ç»™ ECMA å½¢æˆçš„æ ‡å‡†åˆç§°ä¸º â€œå…¬ç”¨è¯­è¨€åŸºç¡€ç»“æ„â€ï¼ˆCommon Language Infrastructure, CLIï¼‰ã€‚CTS è§„èŒƒè§„å®šäº†ä¸€ä¸ªç±»å‹å¯ä»¥åŒ…å«é›¶ä¸ªæˆ–è€…å¤šä¸ªæˆå‘˜ï¼Œè¿™äº›æˆå‘˜åŒ…æ‹¬ï¼šå­—æ®µã€æ–¹æ³•ã€å±æ€§ã€äº‹ä»¶ã€‚CTS è¿˜æŒ‡å®šäº†ç±»å‹å¯è§æ€§è§„åˆ™ä»¥åŠç±»å‹æˆå‘˜çš„è®¿é—®è§„åˆ™ï¼Œåˆ©ç”¨ CTS åˆ¶å®šçš„è§„åˆ™ï¼Œç¨‹åºé›†ä¸ºä¸€ä¸ªç±»å‹å»ºç«‹äº†å¯è§†è¾¹ç•Œï¼ŒCLR åˆ™å¼ºåˆ¶ï¼ˆè´¯å½»ï¼‰äº†è¿™äº›è§„åˆ™ã€‚é™¤æ­¤ä¹‹å¤–ï¼ŒCTS è¿˜ä¸ºç±»å‹ç»§æ‰¿ã€è™šæ–¹æ³•ã€å¯¹è±¡ç”Ÿå­˜æœŸç­‰å®šä¹‰äº†ç›¸åº”çš„è§„åˆ™ã€‚é€šè¿‡ç¼–è¯‘æ¥ç”Ÿæˆç¨‹åºé›†æ—¶ï¼Œå®ƒä¼šå°†è¯­è¨€ç‰¹æœ‰çš„è¯­æ³•æ˜ å°„åˆ° ILâ€” ä¹Ÿå°±æ˜¯ CLR çš„ â€œè¯­è¨€â€ã€‚æ— è®ºä½¿ç”¨å“ªä¸€ç§è¯­è¨€ï¼Œç±»å‹çš„è¡Œä¸ºéƒ½å®Œå…¨ä¸€è‡´ï¼Œå› ä¸ºæœ€ç»ˆæ˜¯ç”± CLR çš„ CTS æ¥å®šä¹‰ç±»å‹çš„è¡Œä¸ºã€‚å¦ä¸€æ¡ CTS è§„åˆ™æ˜¯ï¼šæ‰€æœ‰ç±»å‹æœ€ç»ˆå¿…é¡»ä»é¢„å®šä¹‰çš„ System.Object ç±»å‹ç»§æ‰¿ã€‚Object æ˜¯å…¶ä»–æ‰€æœ‰ç±»å‹çš„æ ¹ï¼Œå› è€Œä¿è¯äº†æ¯ä¸ªç±»å‹å®ä¾‹éƒ½æœ‰ä¸€ç»„æœ€åŸºæœ¬çš„è¡Œä¸ºã€‚</p><h2 id="the-common-language-specification"><a class="anchor" href="#the-common-language-specification">#</a> The Common Language Specification</h2><blockquote><p>COM allows objects created in different languages to communicate with one another. On the other hand, the CLR now integrates all languages and allows objects created in one language to be treated as equal citizens by code written in a completely different language. This integration is possible because of the CLRâ€™s standard set of types, metadata (self-describing type information), and common execution environment.</p></blockquote><blockquote><p>If you intend to create types that are easily accessible from other programming languages, you need to use only features of your programming language that are guaranteed to be available in all other languages. To help you with this, Microsoft has defined a Common Language Specification (CLS) that details for compiler vendors the minimum set of features their compilers must support if these compilers are to generate types compatible with other components written by other CLS-compliant languages on top of the CLR.</p></blockquote><blockquote><p>The CLR/CTS supports a lot more features than the subset defined by the CLS, so if you donâ€™t care about interlanguage operability, you can develop very rich types limited only by the languageâ€™s feature set. Specifically, the CLS defines rules that externally visible types and methods must adhere to if they are to be accessible from any CLS-compliant programming language. Note that the CLS rules donâ€™t apply to code that is accessible only within the defining assembly. Figure 1-6 summarizes the ideas expressed in this paragraph.</p></blockquote><p><img data-src="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/Untitled9.png" alt="Untitled"></p><blockquote><p>As Figure 1-6 shows, the CLR/CTS offers a set of features. Some languages expose a large subset of the CLR/CTS. A programmer willing to write in IL assembly language, for example, is able to use all of the features the CLR/CTS offers. Most other languages, such as C#, Visual Basic, and Fortran, expose a subset of the CLR/CTS features to the programmer. The CLS defines the minimum set of features that all languages must support.</p></blockquote><blockquote><p>If youâ€™re designing a type in one language, and you expect that type to be used by another language, you shouldnâ€™t take advantage of any features that are outside of the CLS in its public and protected members. Doing so would mean that your typeâ€™s members might not be accessible by programmers writing code in other programming languages.</p></blockquote><blockquote><p>Let me distill the CLS rules to something very simple. In the CLR, every member of a type is either a field (data) or a method (behavior). This means that every programming language must be able to access fields and call methods. Certain fields and certain methods are used in special and common ways. To ease programming, languages typically offer additional abstractions to make coding these common programming patterns easier. For example, languages expose concepts such as enums, arrays, properties, indexers, delegates, events, constructors, finalizers, operator overloads, conversion operators, and so on. When a compiler comes across any of these things in your source code, it must translate these constructs into fields and methods so that the CLR and any other programming language can access the construct.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// Constructor</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">// Finalizer</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token operator">~</span><span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">// Operator overload</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> Boolean <span class="token keyword">operator</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token class-name">Test</span> t1<span class="token punctuation">,</span> <span class="token class-name">Test</span> t2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> Boolean <span class="token keyword">operator</span> <span class="token operator">!=</span> <span class="token punctuation">(</span><span class="token class-name">Test</span> t1<span class="token punctuation">,</span> <span class="token class-name">Test</span> t2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token comment">// An operator overload</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> Test <span class="token keyword">operator</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token class-name">Test</span> t1<span class="token punctuation">,</span> <span class="token class-name">Test</span> t2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token comment">// A property</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">String</span> AProperty <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">set</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token comment">// An indexer</span></pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">String</span> <span class="token keyword">this</span><span class="token punctuation">[</span><span class="token class-name">Int32</span> x<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token keyword">set</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre> <span class="token comment">// An event</span></pre></td></tr><tr><td data-num="28"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">event</span> <span class="token class-name">EventHandler</span> AnEvent<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/Untitled10.png" alt="Untitled"></p><blockquote><p>When the compiler compiles this code, the result is a type that has a number of fields and methods defined in it. You can easily see this by using the IL Disassembler tool (ILDasm.exe) provided with the .NET Framework SDK to examine the resulting managed module, which is shown in Figure 1-7.</p></blockquote><p><img data-src="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/Untitled11.png" alt="Untitled"></p><p><em>FIGURE 1-7 <code>ILDasm</code> showing Test typeâ€™s fields and methods (obtained from metadata)</em></p><p><img data-src="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/Untitled12.png" alt="Untitled"></p><p><img data-src="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/Untitled13.png" alt="Untitled"></p><blockquote><p>The additional nodes under the Test type that arenâ€™t mentioned in Table 1-4â€”.class, .custom, AnEvent, AProperty, and Itemâ€”identify additional metadata about the type. These nodes donâ€™t map to fields or methods; they just offer some additional information about the type that the CLR, programming languages, or tools can get access to.</p></blockquote><p>ğŸ’¡ å°ç»“ï¼šä¸åŒè¯­è¨€åˆ›å»ºçš„å¯¹è±¡å¯é€šè¿‡ COMï¼ˆComponent Object Modelï¼‰é€šä¿¡ã€‚CLR åˆ™é›†æˆäº†æ‰€æœ‰çš„è¯­è¨€ï¼Œç”¨ä¸€ç§è¯­è¨€åˆ›å»ºå¯¹è±¡åœ¨å¦ä¸€ç§è¯­è¨€ä¸­ï¼Œå’Œç”¨åè€…åˆ›å»ºçš„å¯¹è±¡å…·æœ‰ç›¸åŒçš„åœ°ä½ã€‚ä¹‹æ‰€ä»¥èƒ½å®ç°è¿™æ ·çš„é›†æˆï¼Œæ˜¯å› ä¸º CLR ä½¿ç”¨äº†æ ‡å‡†ç±»å‹é›†ã€å…ƒæ•°æ®ï¼ˆè‡ªæè¿°çš„ç±»å‹ä¿¡æ¯ï¼‰ä»¥åŠå…¬å…±æ‰§è¡Œç¯å¢ƒã€‚ä¸ºäº†å¾ˆå®¹æ˜“ä»å…¶ä»–ç¼–ç¨‹è¯­è¨€ä¸­è®¿é—®ç±»å‹ï¼ŒMicrosoft å®šä¹‰äº† â€œå…¬å…±è¯­è¨€è§„èŒƒâ€ï¼ˆCommon Language Specification, CLSï¼‰ï¼Œå®ƒè¯¦ç»†å®šä¹‰äº†ä¸€ä¸ªæœ€å°åŠŸèƒ½é›†ã€‚ä»»ä½•ç¼–è¯‘å™¨åªæœ‰æ”¯æŒè¿™ä¸ªåŠŸèƒ½é›†ï¼Œç”Ÿæˆçš„ç±»å‹æ‰èƒ½å…¼å®¹ç”±å…¶ä»–ç¬¦åˆ CLSã€é¢å‘ CLR çš„è¯­è¨€ç”Ÿæˆçš„ç»„ä»¶ã€‚CLR/CTS æ”¯æŒçš„ç±»å‹æ¯” CLS å®šä¹‰çš„å¤šå¾—å¤šï¼ŒCLS å®šä¹‰çš„åªæ˜¯ä¸€ä¸ªå­é›†ã€‚åœ¨å¼€å‘ç±»å‹å’Œæ–¹æ³•æ—¶ï¼Œå¦‚æœå¸Œæœ›å®ƒä»¬å¯¹å¤– â€œå¯è§â€ï¼Œèƒ½ä»ç¬¦åˆ CLS çš„ä»»ä½•ç¼–ç¨‹è¯­è¨€ä¸­è®¿é—®ï¼Œå°±å¿…é¡»éµå®ˆ CLS å®šä¹‰çš„è§„åˆ™ã€‚å¦‚æœå¼€å‘äººå‘˜ç”¨ IL æ±‡ç¼–è¯­è¨€äº›ç¨‹åºï¼Œå¯ä»¥ä½¿ç”¨ CLR/CTS æä¾›çš„å…¨éƒ¨åŠŸèƒ½ã€‚ç”¨ä¸€ç§è¯­è¨€å®šä¹‰ç±»å‹æ—¶ï¼Œå¦‚æœå¸Œæœ›åœ¨å¦ä¸€ç§è¯­è¨€ä¸­ä½¿ç”¨è¯¥ç±»å‹ï¼Œå°±ä¸è¦åœ¨è¯¥ç±»å‹çš„ public å’Œ protected æˆå‘˜ä¸­ä½¿ç”¨ä½äº CLS å¤–éƒ¨çš„ä»»ä½•åŠŸèƒ½ã€‚å¦åˆ™ï¼Œå…¶ä»–å¼€å‘äººå‘˜ä½¿ç”¨å…¶ä»–è¯­è¨€å†™ä»£ç æ—¶ï¼Œå°±å¯èƒ½æ— æ³•è®¿é—®è¿™ä¸ªç±»å‹çš„æˆå‘˜ã€‚ç°åœ¨æç‚¼ä¸€ä¸‹ CLS çš„è§„åˆ™ã€‚åœ¨ CLR ä¸­ï¼Œç±»å‹çš„æ¯ä¸ªæˆå‘˜è¦ä¹ˆæ—¶å­—æ®µï¼ˆæ•°æ®ï¼‰ï¼Œè¦ä¹ˆæ˜¯æ–¹æ³•ï¼ˆè¡Œä¸ºï¼‰ã€‚ä¸ºç®€åŒ–ç¼–ç¨‹ï¼Œè¯­è¨€å¾€å¾€æä¾›äº†é¢å¤–çš„æŠ½è±¡ï¼Œä»è€Œå¯¹è¿™äº›å¸¸è§çš„ç¼–ç¨‹æ¨¡å¼è¿›è¡Œç®€åŒ–ã€‚ä¾‹å¦‚ï¼Œè¯­è¨€ä¼šå…¬å¼€æšä¸¾ã€æ•°ç»„ã€å±æ€§ã€ç´¢å¼•å™¨ã€å§”æ‰˜ã€äº‹ä»¶ã€æ„é€ å™¨ã€ç»ˆç»“å™¨ã€æ“ä½œç¬¦é‡è½½ã€è½¬æ¢æ“ä½œç¬¦ç­‰æ¦‚å¿µã€‚ç¼–è¯‘å™¨åœ¨æºä»£ç ä¸­é‡åˆ°å…¶ä¸­ä»»ä½•ä¸€æ ·ï¼Œéƒ½å¿…é¡»å°†å…¶è½¬æ¢æˆå­—æ®µå’Œæ–¹æ³•ï¼Œä½¿ CLR å’Œå…¶ä»–ä»»ä½•ç¼–ç¨‹è¯­è¨€èƒ½å¤Ÿè®¿é—®è¿™äº›æ„é€ ã€‚</p><h2 id="interoperability-with-unmanaged-code"><a class="anchor" href="#interoperability-with-unmanaged-code">#</a> Interoperability with Unmanaged Code</h2><blockquote><p>The .NET Framework offers a ton of advantages over other development platforms. However, very few companies can afford to redesign and re-implement all of their existing code. Microsoft realizes this and has constructed the CLR so that it offers mechanisms that allow an application to consist of both managed and unmanaged parts. Specifically, the CLR supports three interoperability scenarios:</p></blockquote><p>â–  <strong>Managed code can call an unmanaged function in a DLL</strong></p><p>â–  <strong>Managed code can use an existing COM component (server)</strong></p><p>â–  <strong>Unmanaged code can use a managed type (server)</strong></p><blockquote><p>With Windows 8, Microsoft has introduced a new Windows API called the Windows Runtime (WinRT). This API is implemented internally via COM components. But, instead of using type library files, the COM components describe their API via the metadata ECMA standard created by the .NET Framework team. The beauty of this is that code written via a .NET language can (for the most part) seamlessly communicate with WinRT APIs. Underneath the covers, the CLR is performing all of the COM interop for you without you having to use any additional tools at allâ€”it just works! Chapter 25, â€œInteroperating with WinRT Componentsâ€ goes into all the details.</p></blockquote><p>ğŸ’¡ å°ç»“ï¼šMicrosoft é€šè¿‡ CLR æä¾›äº†ä¸€äº›æœºåˆ¶ï¼Œå…è®¸åœ¨åº”ç”¨ç¨‹åºä¸­åŒæ—¶åŒ…å«æ‰˜ç®¡å’Œéæ‰˜ç®¡ä»£ç ã€‚CLR æ”¯æŒä¸‰ç§äº’æ“ä½œæƒ…å½¢ï¼šæ‰˜ç®¡ä»£ç èƒ½è°ƒç”¨ DLL ä¸­çš„éæ‰˜ç®¡ä»£ç ï¼›æ‰˜ç®¡ä»£ç å¯ä»¥ä½¿ç”¨ç°æœ‰ COM ç»„ä»¶ï¼ˆæœåŠ¡å™¨ï¼‰ï¼›éæ‰˜ç®¡ä»£ç å¯ä»¥ä½¿ç”¨æ‰˜ç®¡ç±»å‹ï¼ˆæœåŠ¡å™¨ï¼‰ã€‚</p><div class="tags"><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> è¯»ä¹¦ç¬”è®°</a> <a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C#</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2023-11-22 08:09:29" itemprop="dateModified" datetime="2023-11-22T08:09:29+08:00">2023-11-22</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(ï¿£â–½ï¿£)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Sakupinera WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Sakupinera Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Sakupinera PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Sakupinera <i class="ic i-at"><em>@</em></i>Sakupinera</li><li class="link"><strong>Post link: </strong><a href="http://sakupinera.github.io/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/" title="CLR via C# - Chapter 1 The CLRâ€™s Execution Model">http://sakupinera.github.io/2022/08/28/csharp/clr-via-csharp/Chapter 1 The CLRâ€™s Execution Model/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclh3brzpj20zk0m8ann.jpg" title="CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types</h3></a></div><div class="item right"><a href="/2022/08/28/cmake/CMake/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipexbei4hj20zk0m8npd.jpg" title="CMake"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i> CMake</span><h3>CMake</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-1-the-clrs-execution-model"><span class="toc-number">1.</span> <span class="toc-text">Chapter 1 The CLRâ€™s Execution Model</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#compiling-source-code-into-managed-modules"><span class="toc-number">1.1.</span> <span class="toc-text">Compiling Source Code into Managed Modules</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#combining-managed-modules-into-assemblies"><span class="toc-number">1.2.</span> <span class="toc-text">Combining Managed Modules into Assemblies</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#loading-the-common-language-runtime"><span class="toc-number">1.3.</span> <span class="toc-text">Loading the Common Language Runtime</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#executing-your-assemblys-code"><span class="toc-number">1.4.</span> <span class="toc-text">Executing Your Assemblyâ€™s Code</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#il-and-verification"><span class="toc-number">1.4.1.</span> <span class="toc-text">IL and Verification</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unsafe-code"><span class="toc-number">1.4.2.</span> <span class="toc-text">Unsafe Code</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#the-native-code-generator-tool-ngenexe"><span class="toc-number">1.5.</span> <span class="toc-text">The Native Code Generator Tool: NGen.exe</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#the-framework-class-library"><span class="toc-number">1.6.</span> <span class="toc-text">The Framework Class Library</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#the-common-type-system"><span class="toc-number">1.7.</span> <span class="toc-text">The Common Type System</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#the-common-language-specification"><span class="toc-number">1.8.</span> <span class="toc-text">The Common Language Specification</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#interoperability-with-unmanaged-code"><span class="toc-number">1.9.</span> <span class="toc-text">Interoperability with Unmanaged Code</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"><ul><li class="active"><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/" rel="bookmark" title="CLR via C# - Chapter 1 The CLRâ€™s Execution Model">CLR via C# - Chapter 1 The CLRâ€™s Execution Model</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/" rel="bookmark" title="CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types">CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%203%20Shared%20Assemblies%20and%20Strongly%20Named%20Assemblies/" rel="bookmark" title="CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies">CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies</a></li><li><a href="/2022/09/27/csharp/clr-via-csharp/Chapter%204%20Type%20Fundamentals/" rel="bookmark" title="CLR via C# - Chapter 4 Type Fundamentals">CLR via C# - Chapter 4 Type Fundamentals</a></li><li><a href="/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/" rel="bookmark" title="CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals">CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals</a></li><li><a href="/2022/10/21/csharp/clr-via-csharp/Chapter%206%20Type%20and%20Member%20Basics/" rel="bookmark" title="CLR via C# - Chapter 6 Type and Member Basics">CLR via C# - Chapter 6 Type and Member Basics</a></li><li><a href="/2022/10/24/csharp/clr-via-csharp/Chapter%207%20Constants%20and%20Fields/" rel="bookmark" title="CLR via C# - Chapter 7 Constants and Fields">CLR via C# - Chapter 7 Constants and Fields</a></li><li><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" rel="bookmark" title="CLR via C# - Chapter 8 Methods">CLR via C# - Chapter 8 Methods</a></li><li><a href="/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/" rel="bookmark" title="CLR via C# - Chapter 9 Parameters">CLR via C# - Chapter 9 Parameters</a></li><li><a href="/2022/10/28/csharp/clr-via-csharp/Chapter%2010%20Properties/" rel="bookmark" title="CLR via C# - Chapter 10 Properties">CLR via C# - Chapter 10 Properties</a></li><li><a href="/2022/10/29/csharp/clr-via-csharp/Chapter%2011%20Events/" rel="bookmark" title="CLR via C# - Chapter 11 Events">CLR via C# - Chapter 11 Events</a></li><li><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" rel="bookmark" title="CLR via C# - Chapter 12 Generics">CLR via C# - Chapter 12 Generics</a></li><li><a href="/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/" rel="bookmark" title="CLR via C# - Chapter 13 Interfaces">CLR via C# - Chapter 13 Interfaces</a></li><li><a href="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/" rel="bookmark" title="CLR via C# - Chapter 14 Chars, Strings, and Working with Text">CLR via C# - Chapter 14 Chars, Strings, and Working with Text</a></li><li><a href="/2022/11/17/csharp/clr-via-csharp/Chapter%2015%20Enumerated%20Types%20and%20Bit%20Flags/" rel="bookmark" title="CLR via C# - Chapter 15 Enumerated Types and Bit Flags">CLR via C# - Chapter 15 Enumerated Types and Bit Flags</a></li><li><a href="/2022/11/19/csharp/clr-via-csharp/Chapter%2016%20Arrays/" rel="bookmark" title="CLR via C# - Chapter 16 Arrays">CLR via C# - Chapter 16 Arrays</a></li><li><a href="/2022/11/21/csharp/clr-via-csharp/Chapter%2017%20Delegates/" rel="bookmark" title="CLR via C# - Chapter 17 Delegates">CLR via C# - Chapter 17 Delegates</a></li><li><a href="/2022/11/22/csharp/clr-via-csharp/Chapter%2018%20Custom%20Attributes/" rel="bookmark" title="CLR via C# - Chapter 18 Custom Attributes">CLR via C# - Chapter 18 Custom Attributes</a></li><li><a href="/2022/11/23/csharp/clr-via-csharp/Chapter%2019%20Nullable%20Value%20Types/" rel="bookmark" title="CLR via C# - Chapter 19 Nullable Value Types">CLR via C# - Chapter 19 Nullable Value Types</a></li><li><a href="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/" rel="bookmark" title="CLR via C# - Chapter 20 Exceptions and State Management">CLR via C# - Chapter 20 Exceptions and State Management</a></li><li><a href="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/" rel="bookmark" title="CLR via C# - Chapter 21 The Managed Heap and Garbage  Collection">CLR via C# - Chapter 21 The Managed Heap and Garbage Collection</a></li><li><a href="/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/" rel="bookmark" title="CLR via C# - Chapter 22 CLR Hosting and AppDomains">CLR via C# - Chapter 22 CLR Hosting and AppDomains</a></li><li><a href="/2022/11/29/csharp/clr-via-csharp/Chapter%2023%20Assembly%20Loading%20and%20Reflection/" rel="bookmark" title="CLR via C# - Chapter 23 Assembly Loading and Reflection">CLR via C# - Chapter 23 Assembly Loading and Reflection</a></li><li><a href="/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/" rel="bookmark" title="CLR via C# - Chapter 24 Runtime Serialization">CLR via C# - Chapter 24 Runtime Serialization</a></li><li><a href="/2022/12/06/csharp/clr-via-csharp/Chapter%2025%20Interoperating%20with%20WinRT%20%20Components/" rel="bookmark" title="CLR via C# - Chapter 25 Interoperating with WinRT Components">CLR via C# - Chapter 25 Interoperating with WinRT Components</a></li><li><a href="/2023/02/06/csharp/clr-via-csharp/Chapter%2026%20Thread%20Basics/" rel="bookmark" title="CLR via C# - Chapter 26 Thread Basics">CLR via C# - Chapter 26 Thread Basics</a></li><li><a href="/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations">CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations</a></li><li><a href="/2023/02/08/csharp/clr-via-csharp/Chapter%2028%20IO-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 28 IO-Bound Asynchronous Operations">CLR via C# - Chapter 28 IO-Bound Asynchronous Operations</a></li><li><a href="/2023/02/09/csharp/clr-via-csharp/Chapter%2029%20Primitive%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 29 Primitive Thread Synchronization">CLR via C# - Chapter 29 Primitive Thread Synchronization</a></li><li><a href="/2023/02/10/csharp/clr-via-csharp/Chapter%2030%20Hybrid%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 30 Hybrid Thread Synchronization">CLR via C# - Chapter 30 Hybrid Thread Synchronization</a></li></ul></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sakupinera" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Sakupinera</p><div class="description" itemprop="description">ä¿æŒä½ çš„å†³å¿ƒï¼</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">89</span> <span class="name">posts</span></a></div><div class="item categories"><a href="/categories/"><span class="count">17</span> <span class="name">categories</span></a></div><div class="item tags"><a href="/tags/"><span class="count">8</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nha3VwaW5lcmE=" title="https:&#x2F;&#x2F;github.com&#x2F;sakupinera"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9zYWt1cGluZXJh" title="https:&#x2F;&#x2F;twitter.com&#x2F;sakupinera"><i class="ic i-twitter"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQwNzIyOTA3MQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;407229071"><i class="ic i-cloud-music"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMjIzMDczOTg/c3BtX2lkX2Zyb209MzMzLjEwMDcuMC4w" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;22307398?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li><li class="item"><a href="/games/" rel="section"><i class="ic i-flag"></i>games</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-person"></i>About</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/08/28/cmake/CMake/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/" title="CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals">CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/08/28/hello-world/" title="Hello World">Hello World</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/" title="CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations">CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/09/02/linux/learn-linux/Shell%E5%9F%BA%E7%A1%80/" title="LearnLinux - ShellåŸºç¡€">LearnLinux - ShellåŸºç¡€</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CSharp-in-a-Nutshell/" title="In CSharp-in-a-Nutshell">CSharp-in-a-Nutshell</a></div><span><a href="/2022/08/29/csharp/csharp-in-a-nutshell/%E7%AC%AC2%E7%AB%A0%20%E5%9C%A8CSharp%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%9E%8B/" title="C# in a Nutshell - ç¬¬2ç«  C#è¯­è¨€åŸºç¡€">C# in a Nutshell - ç¬¬2ç«  C#è¯­è¨€åŸºç¡€</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CSharp-in-a-Nutshell/" title="In CSharp-in-a-Nutshell">CSharp-in-a-Nutshell</a></div><span><a href="/2022/09/01/csharp/csharp-in-a-nutshell/%E7%AC%AC12%E7%AB%A0%20%E5%AF%B9%E8%B1%A1%E9%94%80%E6%AF%81%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" title="C# in a Nutshell - ç¬¬12ç«  å¯¹è±¡é”€æ¯ä¸åƒåœ¾å›æ”¶">C# in a Nutshell - ç¬¬12ç«  å¯¹è±¡é”€æ¯ä¸åƒåœ¾å›æ”¶</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/09/06/computer-graphics/games101/%E5%90%91%E9%87%8F%E5%92%8C%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" title="GAMES101 - å‘é‡å’Œçº¿æ€§ä»£æ•°">GAMES101 - å‘é‡å’Œçº¿æ€§ä»£æ•°</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/10/03/computer-graphics/games101/%E5%87%A0%E4%BD%95/" title="GAMES101 - Geometryï¼ˆå‡ ä½•ï¼‰">GAMES101 - Geometryï¼ˆå‡ ä½•ï¼‰</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/08/28/linux/learn-linux/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/" title="LearnLinux - æ–‡ä»¶ç³»ç»Ÿç®¡ç†">LearnLinux - æ–‡ä»¶ç³»ç»Ÿç®¡ç†</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%203%20Shared%20Assemblies%20and%20Strongly%20Named%20Assemblies/" title="CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies">CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 â€“ <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Sakupinera @ Hanamai Sora</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="Symbols count total">2.2m words</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="Reading time total">34:05</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/08/28/csharp/clr-via-csharp/Chapter 1 The CLRâ€™s Execution Model/",favicon:{show:"ï¼ˆâ—Â´3ï½€â—ï¼‰Goooood",hide:"(Â´Ğ”ï½€)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/shifuku.model.json"},display:{position:"left",width:250,height:500},mobile:{show:!1},react:{opacity:.9},log:!1})</script></body></html>