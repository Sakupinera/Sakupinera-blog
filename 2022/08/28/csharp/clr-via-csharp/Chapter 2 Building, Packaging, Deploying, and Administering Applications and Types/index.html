<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sakupinera" href="http://sakupinera.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sakupinera" href="http://sakupinera.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sakupinera" href="http://sakupinera.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="读书笔记,C#"><link rel="canonical" href="http://sakupinera.github.io/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/"><title>CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types - CLR-via-CSharp - CSharp | Hanamai Sora = Sakupinera</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types</h1><div class="meta"><span class="item" title="Created: 2022-08-28 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2022-08-28T00:00:00+08:00">2022-08-28</time> </span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">Symbols count in article</span> <span>32k</span> <span class="text">words</span> </span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">Reading time</span> <span>29 mins.</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hanamai Sora</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gicm0n457cj20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipey0a334j20zk0m8qpt.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclh0m9pdj20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclxp31goj20zk0m8qv5.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclg5ms2rj20zk0m8u0x.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gicis081o9j20zk0m8dmr.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/" itemprop="item" rel="index" title="In CSharp"><span itemprop="name">CSharp</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/CLR-via-CSharp/" itemprop="item" rel="index" title="In CLR-via-CSharp"><span itemprop="name">CLR-via-CSharp</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://sakupinera.github.io/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Sakupinera"><meta itemprop="description" content=", 保持你的决心！"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakupinera"></span><div class="body md" itemprop="articleBody"><h1 id="chapter-2-building-packaging-deploying-and-administering-applications-and-types"><a class="anchor" href="#chapter-2-building-packaging-deploying-and-administering-applications-and-types">#</a> Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types</h1><blockquote><p>Today, applications consist of several types, which are typically created by you and Microsoft. In addition, there are many component vendors creating and selling types that other companies can use to reduce a software project’s development time. If these types are developed using any language that targets the common language runtime (CLR), they can all work together seamlessly; a type written in one language can use another type as its base class without concern for the language the base type was developed in.</p></blockquote><h2 id="net-framework-deployment-goals"><a class="anchor" href="#net-framework-deployment-goals">#</a> <strong>.NET Framework Deployment Goals</strong></h2><blockquote><p>Over the years, Windows has gotten a reputation for being unstable and complicated. This reputation, whether deserved or not, is the result of many different factors. First, all applications use dynamic-link libraries (DLLs) from Microsoft or other vendors.</p></blockquote><blockquote><p>I’m sure that everyone reading this book has experienced some variation of this problem: when installing a new application, you discover that it has somehow corrupted an already-installed application. This predicament is known as “DLL hell.” This type of instability puts fear into the hearts and minds of the typical computer user. The end result is that users have to carefully consider whether to install new software on their machines. Personally, I’ve decided not to try out certain applications out of fear that it might adversely affect some application I really rely on.</p></blockquote><blockquote><p>The second reason that contributed to the aforementioned reputation of Windows is installation complexities. Today, when most applications are installed, they affect all parts of the system. For example, installing an application causes files to be copied to various directories, updates registry settings, and installs shortcuts on your desktop and Start menu/screen. The problem with this is that the application isn’t isolated as a single entity. You can’t easily back up the application because you must copy the application’s files and also the relevant parts of the registry. In addition, you can’t easily move the application from one machine to another; you must run the installation program again so that all files and registry settings are set properly. Finally, you can’t easily uninstall or remove the application without having this nasty feeling that some part of the application is still lurking on your machine.</p></blockquote><blockquote><p>The third reason has to do with security. When applications are installed, they come with all kinds of files, many of them written by different companies. In addition, web applications frequently have code (like ActiveX controls) that is downloaded in such a way that users don’t even realize that code is being installed on their machine. Today, this code can perform any operation, including deleting files or sending email. Users are right to be terrified of installing new applications because of the potential damage they can cause. To make users comfortable, security must be built into the system so that the users can explicitly allow or disallow code developed by various companies to access their system’s resources.</p></blockquote><blockquote><p>The .NET Framework addresses the DLL hell issue in a big way, as you’ll see while reading this chapter and Chapter 3. It also goes a long way toward fixing the problem of having an application’s state scattered all over a user’s hard disk. For example, unlike COM, types no longer require settings in the registry. Unfortunately, applications still require shortcut links. As for security, the .NET Framework CHAPTER 2 Building, Packaging, Deploying, and Administering Applications and Types 35 includes a security model called code access security. Whereas Windows security is based on a user’s identity, code access security allows hosts to set permissions, thereby controlling what the loaded components can do. A host application like Microsoft SQL Server can grant just a few permissions to code, whereas a locally installed (self-hosting) application could run with full trust (all permissions). As you’ll see, the .NET Framework enables users to control what gets installed and what runs, and in general, to control their machines, more than Windows ever did.</p></blockquote><p>💡 小结：在 Windows 下，应用程序都使用来自 Microsoft 或其他厂商的动态链接库（Dynamic-Link Library, DLL）。对于用户来说，当它们更新安装的软件时，并不能保证新安装的文件一定向后兼容以前的文件。很多人都可能遇到这样的问题：安装新应用程序时，它可能莫名其妙破坏了另一个已经安装好的应用程序，这就是所谓的 “DLL hell”。造成 Windows 口碑不佳的第二个原因是安装的复杂性。大多数应用程序在安装时都会影响到系统的全部组件。应用程序不是一个孤立的实体，应用程序备份不易，因为必须复制应用程序的全部文件以及注册表中的相关部分。除此之外，也不能轻松地将应用程序从一台机器移动到另一台机器，只有再次运行安装程序才能确保所有文件和注册表设置的正确性。最后，即使卸载或移除了应用程序，也免不了担心它的一部分内容仍潜伏在我们的机器中。第三个原因涉及安全性。应用程序安装时会带来各种文件，其中许多是不同的公司开发的。此外，Web 应用程序经常会悄悄下载一些代码，而这些代码能够执行任何操作，包括删除文件或者发送电子邮件。<span class="exturl" data-url="aHR0cDovL3huLS02dzBhLk5FVA==">而.NET</span> Framework 正在尝试彻底解决 DLL hell 问题，另外，.NET Framework 还在很大程度上解决了应用程序状态在用户硬盘中四处分散的问题。安全性方面，.NET Framework 包含称为 “代码访问安全性”（Code Access Security）的安全模型。Windows 安全性基于用户身份，而代码访问安全性允许宿主设置权限，控制加载的组件能做的事情。.NET Framework 允许用户灵活地控制哪些东西能够安装，哪些东西能够运行。</p><h2 id="building-types-into-a-module"><a class="anchor" href="#building-types-into-a-module">#</a> <strong>Building Types into a Module</strong></h2><blockquote><p>In this section, I’ll show you how to turn your source file, containing various types, into a file that can be deployed. Let’s start by examining the following simple application.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> System<span class="token punctuation">.</span>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Hi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>To build this sample application, put the preceding code into a source code file, say, Program.cs, and then execute the following command line.</p></blockquote><pre><code>csc.exe /out:Program.exe /t:exe /r:MSCorLib.dll Program.cs
</code></pre><blockquote><p>This command line tells the C# compiler to emit an executable file called Program.exe ( <code>/out:Program.exe</code> ). The type of file produced is a Win32 console application ( <code>/t[arget]:exe</code> ).</p></blockquote><blockquote><p>When the C# compiler processes the source file, it sees that the code references the <code>System.Console</code> type’s WriteLine method. At this point, the compiler wants to ensure that this type exists somewhere, that it has a WriteLine method, and that the argument being passed to this method matches the parameter the method expects. Because this type is not defined in the C# source code, to make the C# compiler happy, you must give it a set of assemblies that it can use to resolve references to external types. In the preceding command line, I’ve included the <code>/r[eference]:MSCorLib.dll</code> switch, which tells the compiler to look for external types in the assembly identified by the MSCorLib.dll file.</p></blockquote><blockquote><p>MSCorLib.dll is a special file in that it contains all the core types: Byte, Char, String, Int32, and many more. In fact, these types are so frequently used that the C# compiler automatically references the MSCorLib.dll assembly. In other words, the following command line (with the /r switch omitted) gives the same results as the line shown earlier.</p><p><code>csc.exe /out:Program.exe /t:exe Program.cs</code></p></blockquote><blockquote><p>If, for some reason, you really don’t want the C# compiler to reference the MSCorLib.dll assembly, you can use the <code>/nostdlib</code> switch. Microsoft uses this switch when building the MSCorLib.dll assembly itself. For example, the following command line will generate an error when CSC.exe attempts to compile the <code>Program.cs</code> file because the <code>System.Console</code> type is defined in MSCorLib.dll.</p><p><code>csc.exe /out:Program.exe /t:exe /nostdlib Program.cs</code></p></blockquote><p><strong>Response Files</strong></p><blockquote><p>Before leaving the discussion about compiler switches, I’d like to spend a moment talking about response files. A response file is a text file that contains a set of compiler command-line switches. When you execute CSC.exe, the compiler opens response files and uses any switches that are specified in them as though the switches were passed to CSC.exe on the command line. You instruct the compiler to use a response file by specifying its name on the command line prepended by an @ sign. For example, you could have a response file called <code>MyProject.rsp</code> that contains the following text.</p></blockquote><pre><code>/out:MyProject.exe
/target:winexe
</code></pre><blockquote><p>To cause CSC.exe to use these settings, you’d invoke it as follows.</p></blockquote><pre><code>csc.exe @MyProject.rsp CodeFile1.cs CodeFile2.cs
</code></pre><blockquote><p>The C# compiler supports multiple response files. In addition to the files you explicitly specify on the command line, the compiler automatically looks for files called CSC.rsp. When you run CSC.exe, it looks in the directory containing the CSC.exe file for a global CSC.rsp file. Settings that you want applied to all of your projects should go in this file. The compiler aggregates and uses the settings in all of these response files. If you have conflicting settings in the local and global response files, the settings in the local file override the settings in the global file. Likewise, any settings explicitly passed on the command line override the settings taken from a local response file.</p></blockquote><p><img data-src="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/Untitled.png" alt="Untitled"></p><blockquote><p>Referencing all of these assemblies could slow the compiler down a bit. But if your source code doesn’t refer to a type or member defined by any of these assemblies, there is no impact to the resulting assembly file, nor to run-time execution performance.</p></blockquote><p>💡 小结：将类型生成到模块中可以使用 csc.exe 命令，/out: 文件名 指定生成的目标文件文件名，/t: 类型 指定应用程序的类型。Windwos 支持三种应用程序，控制台用户界面（Console User Interface，CUI）应用程序使用 /t:exe 开关；图形用户界面（Graphical User Interface，GUI）应用程序使用 /t:winexe 开关；Windows Store 应用使用 /t:appcontainerexe 开关。/r: 引用程序集 告诉编译器在指定程序集中查找外部类型。C# 编译器会自动引用 MSCorLib.dll 程序集，若不想自动引用 MSCorLib.dll 程序集，可以使用 /nostdlib 开关。响应文件时包含一组编译器命令行开关的文本文件。执行 CSC.exe 时，编译器打开响应文件，并使用其中包含的所有开关，感觉就像是这些开关直接在命令行上传递给 CSC.exe。C# 编译器支持多个响应文件，除了命令行上显式指定的文件，编译器还会自动查找名为 CSC.rsp 文件。CSC.exe 运行时，会在 CSC.exe 所在目录查找全局 CSC.rsp 文件。本地和全局响应文件中的某个设置发生冲突，将以本地设置为准。类似地，命令上显式指定的设置将覆盖本地响应文件中的设置。引用所有这些程序集对编译器的速度有一点影响。但是，如果源代码没有引用上述任何程序集定义的类型或成员，就不会影响最终的程序集文件，也不会影响程序的执行性能。另外，指定 /noconfig 命令行开关，编译器将忽略本地和全局 CSC.rsp 文件。</p><h2 id="a-brief-look-at-metadata"><a class="anchor" href="#a-brief-look-at-metadata">#</a> <strong>A Brief Look at Metadata</strong></h2><blockquote><p>Now we know what kind of PE file we’ve created. But what exactly is in the Program.exe file? A managed PE file has four main parts: the PE32(+) header, the CLR header, the metadata, and the IL. The PE32(+) header is the standard information that Windows expects. The CLR header is a small block of information that is specific to modules that require the CLR (managed modules). The header includes the major and minor version number of the CLR that the module was built for: some flags, a MethodDef token (described later) indicating the module’s entry point method if this module is a CUI, GUI, or Windows Store executable, and an optional strong-name digital signature (discussed in Chapter 3). Finally, the header contains the size and offsets of certain metadata tables contained within the module. You can see the exact format of the CLR header by examining the IMAGE_COR20_HEADER defined in the CorHdr.h header file.</p></blockquote><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">IMAGE_COR20_HEADER</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// Header versioning</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    DWORD                   cb<span class="token punctuation">;</span>              </pre></td></tr><tr><td data-num="5"></td><td><pre>    WORD                    MajorRuntimeVersion<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    WORD                    MinorRuntimeVersion<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    </pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// Symbol table and startup information</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    IMAGE_DATA_DIRECTORY    MetaData<span class="token punctuation">;</span>        </pre></td></tr><tr><td data-num="10"></td><td><pre>    DWORD                   Flags<span class="token punctuation">;</span>           </pre></td></tr><tr><td data-num="11"></td><td><pre>  </pre></td></tr><tr><td data-num="12"></td><td><pre>	<span class="token comment">// The main program if it is an EXE (not used if a DLL?)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">// If COMIMAGE_FLAGS_NATIVE_ENTRYPOINT is not set, EntryPointToken represents a managed entrypoint.</span></pre></td></tr><tr><td data-num="14"></td><td><pre>	<span class="token comment">// If COMIMAGE_FLAGS_NATIVE_ENTRYPOINT is set, EntryPointRVA represents an RVA to a native entrypoint</span></pre></td></tr><tr><td data-num="15"></td><td><pre>	<span class="token comment">// (depricated for DLLs, use modules constructors intead). </span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">union</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        DWORD               EntryPointToken<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        DWORD               EntryPointRVA<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    </pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token comment">// This is the blob of managed resources. Fetched using code:AssemblyNative.GetResource and</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token comment">// code:PEFile.GetResource and accessible from managed code from</span></pre></td></tr><tr><td data-num="23"></td><td><pre>	<span class="token comment">// System.Assembly.GetManifestResourceStream.  The meta data has a table that maps names to offsets into</span></pre></td></tr><tr><td data-num="24"></td><td><pre>	<span class="token comment">// this blob, so logically the blob is a set of resources. </span></pre></td></tr><tr><td data-num="25"></td><td><pre>    IMAGE_DATA_DIRECTORY    Resources<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>	<span class="token comment">// IL assemblies can be signed with a public-private key to validate who created it.  The signature goes</span></pre></td></tr><tr><td data-num="27"></td><td><pre>	<span class="token comment">// here if this feature is used. </span></pre></td></tr><tr><td data-num="28"></td><td><pre>    IMAGE_DATA_DIRECTORY    StrongNameSignature<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre>    IMAGE_DATA_DIRECTORY    CodeManagerTable<span class="token punctuation">;</span>			<span class="token comment">// Depricated, not used </span></pre></td></tr><tr><td data-num="31"></td><td><pre>	<span class="token comment">// Used for manged codee that has unmaanaged code inside it (or exports methods as unmanaged entry points)</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    IMAGE_DATA_DIRECTORY    VTableFixups<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    IMAGE_DATA_DIRECTORY    ExportAddressTableJumps<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre></pre></td></tr><tr><td data-num="35"></td><td><pre>	<span class="token comment">// null for ordinary IL images.  NGEN images it points at a code:CORCOMPILE_HEADER structure</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    IMAGE_DATA_DIRECTORY    ManagedNativeHeader<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>    </pre></td></tr><tr><td data-num="38"></td><td><pre><span class="token punctuation">&#125;</span> IMAGE_COR20_HEADER<span class="token punctuation">,</span> <span class="token operator">*</span>PIMAGE_COR20_HEADER<span class="token punctuation">;</span></pre></td></tr></table></figure><p><img data-src="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/Untitled1.png" alt="Untitled"></p><blockquote><p>The metadata is a block of binary data that consists of several tables. There are three categories of tables: definition tables, reference tables, and manifest tables.</p></blockquote><blockquote><p>As the compiler compiles your source code, everything your code defines causes an entry to be created in one of the tables described in Table 2-1. Metadata table entries are also created as the compiler detects the types, fields, methods, properties, and events that the source code references. The metadata created includes a set of reference tables that keep a record of the referenced items.</p></blockquote><p><img data-src="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/Untitled2.png" alt="Untitled"></p><p><img data-src="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/Untitled3.png" alt="Untitled"></p><p>💡 小结：托管 PE 文件由 4 部分构成：PE32 (+) 头、CLR 头、元数据以及 IL。PE32 (+) 头是 Windows 要求的标准信息。CLR 头是一个小的信息块，是需要 CLR 的模块（托管模块）特有的。这个头包含模块生成时所面向的 CLR 的 major (主) 和 minor (次) 版本号；一些标志（flag）；一个 MethodDef token，该 token 指定了模块的入口方法（前提是该模块是 CUI、GUI 或 Windows Store 执行体）；一个可选的强名称数字签名。最后，CLR 头还包含模块内部的一些元数据表的大小和偏移量。可以查看 CorHdr.h 头文件定义的 IMAGE_COR20_HEADER 来了解 CLR 头的具体格式。元数据是由几个表构成的二进制数据块。有 3 种表，分别是定义表（definition table）、引用表（reference table）和清单表（manifest table）。编译器编译源代码时，diamagnetic 定义的任何都系都会在元数据定义表中创建一个记录项。此外，编译器还会检测源代码引用的类型、字段、方法、属性和事件，并创建相应的元数据记录项。在创建的元数据中包含一组引用表，它们记录了所引用的内容。</p><h2 id="combining-modules-to-form-an-assembly"><a class="anchor" href="#combining-modules-to-form-an-assembly">#</a> <strong>Combining Modules to Form an Assembly</strong></h2><blockquote><p>The Program.exe file discussed in the previous section is more than just a PE file with metadata; it is also an assembly. An assembly is a collection of one or more files containing type definitions and resource files. One of the assembly’s files is chosen to hold a manifest. The manifest is another set of metadata tables that basically contain the names of the files that are part of the assembly. They also describe the assembly’s version, culture, publisher, publicly exported types, and all of the files that comprise the assembly.</p></blockquote><blockquote><p>The CLR operates on assemblies; that is, the CLR always loads the file that contains the manifest metadata tables first and then uses the manifest to get the names of the other files that are in the assembly. Here are some characteristics of assemblies that you should remember:</p><p>■ An assembly defines the reusable types.</p><p>■ An assembly is marked with a version number.</p><p>■ An assembly can have security information associated with it.</p></blockquote><blockquote><p>An assembly’s individual files don’t have these attributes—except for the file that contains the manifest metadata tables.</p></blockquote><blockquote><p>To package, version, secure, and use types, you must place them in modules that are part of an assembly. In most cases, an assembly consists of a single file, as the preceding Program.exe example does. However, an assembly can also consist of multiple files: some PE files with metadata and some resource files such as .gif or .jpg files. It might help you to think of an assembly as a logical EXE or a DLL.</p></blockquote><blockquote><p>An assembly allows you to decouple the logical and physical notions of reusable types.</p></blockquote><blockquote><p>I’ve identified three reasons to use multifile assemblies:</p><p>■ You can partition your types among separate files, allowing for files to be incrementally downloaded as described in the Internet download scenario.</p><p>■ You can add resource or data files to your assembly.</p><p>■ You can create assemblies consisting of types implemented in different programming languages.</p></blockquote><p>💡 Note：总之，程序集是进行重用、版本控制和应用安全性设置的基本单元。如果多个类型能共享相同的版本号和安全性设置，建议将所有这些类型放在同一个文件中，而不是分散到多个文件中，更不要分散到多个程序集中，因为加载较少的程序集有助于减少工作集（working set），并缓解进程地址空间的碎片化。</p><p><img data-src="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/Untitled4.png" alt="Untitled"></p><blockquote><p>The existence of a manifest provides a level of indirection between consumers of the assembly and the partitioning details of the assembly and makes assemblies self-describing. Also, note that the file containing the manifest has metadata information that indicates which files are part of the assembly, but the individual files themselves do not have metadata information that specifies that they are part of the assembly.</p></blockquote><p>💡 Note：包含清单的程序集文件还有一个 AssemblyRef 表。程序集全部文件引用的每个程序集在这个表中都有一个记录项。这样一来，工具只需打开程序集的清单，就可知道它引用的全部程序集，而不必打开程序集的其他文件。此外，清单元数据表其实并不包含从清单所在的 PE 文件导出的类型。这是一项优化措施，旨在减少 PE 文件中清单信息量。</p><blockquote><p>There are many ways to add a module to an assembly. If you’re using the C# compiler to build a PE file with a manifest, you can use the /addmodule switch. To understand how to build a multifile assembly, let’s assume that we have two source code files:</p><p>■ RUT.cs, which contains rarely used types</p><p>■ FUT.cs, which contains frequently used types</p></blockquote><pre><code>csc /t:module RUT.cs

csc /out:MultiFileLibrary.dll /t:library /addmodule:RUT.netmodule FUT.cs
</code></pre><p><img data-src="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/Untitled5.png" alt="Untitled"></p><blockquote><p>As the client code executes, it calls methods. When a method is called for the first time, the CLR detects the types that the method references as a parameter, a return type, or as a local variable. The CLR then attempts to load the referenced assembly’s file that contains the manifest. If the type being accessed is in this file, the CLR performs its internal bookkeeping, allowing the type to be used. If the manifest indicates that the referenced type is in a different file, the CLR attempts to load the necessary file, performs its internal bookkeeping, and allows the type to be accessed. The CLR loads assembly files only when a method referencing a type in an unloaded assembly is called. This means that to run an application, all of the files from a referenced assembly do not need to be present.</p></blockquote><p>💡 Note：元数据 token 是一个 4 字节的值。其中，高位字节指明 token 的类型 (0x01=TypeRef，0x02=TypeDef，0x23=AssemblyRef， 0x26=File (文件定义)，0x27=ExportedType)。要获取完整列表，请参见 .NET Framework SDK 包含的 <code>CorHdr.h</code><br>文件中的 <code>CorTokenType</code><br>枚举类型。token 的三个低位字节指明对应的元数据表中的行。例如，0x26000001 这个实现 token 引用的是 File 表的第一行。大多数表的行从 1 而不是 0 开始编号。 TypeDef 表的行号实际从 2 开始。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// Token tags.</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">//</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">enum</span> <span class="token class-name">CorTokenType</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    mdtModule               <span class="token operator">=</span> <span class="token number">0x00000000</span><span class="token punctuation">,</span>       <span class="token comment">//</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    mdtTypeRef              <span class="token operator">=</span> <span class="token number">0x01000000</span><span class="token punctuation">,</span>       <span class="token comment">//</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    mdtTypeDef              <span class="token operator">=</span> <span class="token number">0x02000000</span><span class="token punctuation">,</span>       <span class="token comment">//</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    mdtFieldDef             <span class="token operator">=</span> <span class="token number">0x04000000</span><span class="token punctuation">,</span>       <span class="token comment">//</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    mdtMethodDef            <span class="token operator">=</span> <span class="token number">0x06000000</span><span class="token punctuation">,</span>       <span class="token comment">//</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    mdtParamDef             <span class="token operator">=</span> <span class="token number">0x08000000</span><span class="token punctuation">,</span>       <span class="token comment">//</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    mdtInterfaceImpl        <span class="token operator">=</span> <span class="token number">0x09000000</span><span class="token punctuation">,</span>       <span class="token comment">//</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    mdtMemberRef            <span class="token operator">=</span> <span class="token number">0x0a000000</span><span class="token punctuation">,</span>       <span class="token comment">//</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    mdtCustomAttribute      <span class="token operator">=</span> <span class="token number">0x0c000000</span><span class="token punctuation">,</span>       <span class="token comment">//</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    mdtPermission           <span class="token operator">=</span> <span class="token number">0x0e000000</span><span class="token punctuation">,</span>       <span class="token comment">//</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    mdtSignature            <span class="token operator">=</span> <span class="token number">0x11000000</span><span class="token punctuation">,</span>       <span class="token comment">//</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    mdtEvent                <span class="token operator">=</span> <span class="token number">0x14000000</span><span class="token punctuation">,</span>       <span class="token comment">//</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    mdtProperty             <span class="token operator">=</span> <span class="token number">0x17000000</span><span class="token punctuation">,</span>       <span class="token comment">//</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    mdtMethodImpl           <span class="token operator">=</span> <span class="token number">0x19000000</span><span class="token punctuation">,</span>       <span class="token comment">//</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    mdtModuleRef            <span class="token operator">=</span> <span class="token number">0x1a000000</span><span class="token punctuation">,</span>       <span class="token comment">//</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    mdtTypeSpec             <span class="token operator">=</span> <span class="token number">0x1b000000</span><span class="token punctuation">,</span>       <span class="token comment">//</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    mdtAssembly             <span class="token operator">=</span> <span class="token number">0x20000000</span><span class="token punctuation">,</span>       <span class="token comment">//</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    mdtAssemblyRef          <span class="token operator">=</span> <span class="token number">0x23000000</span><span class="token punctuation">,</span>       <span class="token comment">//</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    mdtFile                 <span class="token operator">=</span> <span class="token number">0x26000000</span><span class="token punctuation">,</span>       <span class="token comment">//</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    mdtExportedType         <span class="token operator">=</span> <span class="token number">0x27000000</span><span class="token punctuation">,</span>       <span class="token comment">//</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    mdtManifestResource     <span class="token operator">=</span> <span class="token number">0x28000000</span><span class="token punctuation">,</span>       <span class="token comment">//</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    mdtGenericParam         <span class="token operator">=</span> <span class="token number">0x2a000000</span><span class="token punctuation">,</span>       <span class="token comment">//</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    mdtMethodSpec           <span class="token operator">=</span> <span class="token number">0x2b000000</span><span class="token punctuation">,</span>       <span class="token comment">//</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    mdtGenericParamConstraint <span class="token operator">=</span> <span class="token number">0x2c000000</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="30"></td><td><pre></pre></td></tr><tr><td data-num="31"></td><td><pre>    mdtString               <span class="token operator">=</span> <span class="token number">0x70000000</span><span class="token punctuation">,</span>       <span class="token comment">//</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    mdtName                 <span class="token operator">=</span> <span class="token number">0x71000000</span><span class="token punctuation">,</span>       <span class="token comment">//</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    mdtBaseType             <span class="token operator">=</span> <span class="token number">0x72000000</span><span class="token punctuation">,</span>       <span class="token comment">// Leave this on the high end value. This does not correspond to metadata table</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token punctuation">&#125;</span> CorTokenType<span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="using-the-assembly-linker"><a class="anchor" href="#using-the-assembly-linker">#</a> <strong>Using the Assembly Linker</strong></h3><blockquote><p>Instead of using the C# compiler, you might want to create assemblies by using the Assembly Linker utility, AL.exe. The Assembly Linker is useful if you want to create an assembly consisting of modules built from different compilers (if your compiler doesn’t support the equivalent of C#’s /addmodule switch) or perhaps if you just don’t know your assembly packaging requirements at build time. You can also use AL.exe to build resource-only assemblies, called satellite assemblies, which are typically used for localization purposes. I’ll talk about satellite assemblies later in the chapter.</p></blockquote><blockquote><p>The AL.exe utility can produce an EXE or a DLL PE file that contains only a manifest describing the types in other modules. To understand how AL.exe works, let’s change the way the MultiFileLibrary.dll assembly is built.</p></blockquote><pre><code>csc /t:module RUT.cs

csc /t:module FUT.cs

al /out: MultiFileLibrary.dll /t:library FUT.netmodule RUT.netmodule
</code></pre><p>Figure 2-3 shows the files that result from executing these statements.</p><p><img data-src="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/Untitled6.png" alt="Untitled"></p><h3 id="adding-resource-files-to-an-assembly"><a class="anchor" href="#adding-resource-files-to-an-assembly">#</a> <strong>Adding Resource Files to an Assembly</strong></h3><blockquote><p>When using AL.exe to create an assembly, you can add a file as a resource to the assembly by using the <code>/embed[resource]</code> switch. This switch takes a file (any file) and embeds the file’s contents into the resulting PE file. The manifest’s <code>ManifestResourceDef</code> table is updated to reflect the existence of the resources.</p></blockquote><blockquote><p>AL.exe also supports a <code>/link[resource]</code> switch, which also takes a file containing resources. However, the <code>/link[resource]</code> switch updates the manifest’s <code>ManifestResourceDef</code> and <code>FileDef</code> tables, indicating that the resource exists and identifying which of the assembly’s files contains it. The resource file is not embedded into the assembly PE file; it remains separate and must be packaged and deployed with the other assembly files.</p></blockquote><blockquote><p>Like AL.exe, CSC.exe also allows you to combine resources into an assembly produced by the C# compiler. The C# compiler’s <code>/resource</code> switch embeds the specified resource file into the resulting assembly PE file, updating the <code>ManifestResourceDef</code> table. The compiler’s <code>/linkresource</code> switch adds an entry to the <code>ManifestResourceDef</code> and the <code>FileDef</code> manifest tables to refer to a stand-alone resource file.</p></blockquote><p>💡 小结：程序集是一个或多个类型定义文件及资源文件的集合。在程序集的所有文件中，有一个文件容纳了清单。清单也是一个元数据表集合，表中主要包含了作为程序集组成部分的那些文件的名称。此外，还描述了程序集的版本、语言文化、发布者、公开导出的类型以及构成程序集的所有文件。类型为了顺利地进行打包、版本控制、安全保护以及使用，必须放在作为程序集一部分的模块中。而任意数量的模块和资源文件的组合则形成了多文件程序集。所谓多文件程序集指的是，在逻辑层面，拥有清单文件的文件本身已经完整的描述了自身，由于有了清单的存在，程序集的用户不用关心程序集的划分细节；但在物理层面，程序集所引用的一些模块可能又存在于别的文件当中。这也是 “使用程序集，可重用类型的逻辑表示与物理表示就可以分开” 这句话的含义。多文件程序集有以下优势：1. 不同的类型用不同的文件，使文件能以 “增量” 的方式下载。2. 可在程序集中添加资源或数据文件（使用 AL.exe 或 CSC.exe）。3. 程序集包含的多个类型可以用不同的编程语言来实现。遗憾的是，不能直接从 Microsoft Visual Studio 集成开发环境中创建多文件程序集。只能用命令行工具创建多文件程序集。</p><h2 id="assembly-version-resource-information"><a class="anchor" href="#assembly-version-resource-information">#</a> <strong>Assembly Version Resource Information</strong></h2><blockquote><p>When AL.exe or CSC.exe produces a PE file assembly, it also embeds into the PE file a standard Win32 version resource. Users can examine this resource by viewing the file’s properties. Application code can also acquire and examine this information at run time by calling <code>System.Diagnostics.FileVersionInfo</code> ’s static <code>GetVersionInfo</code> method with the assembly path as parameter. Figure 2-4 shows the Details tab of the MultiFileLibrary.dll Properties dialog box.</p></blockquote><blockquote><p>When building an assembly, you should set the version resource fields by using custom attributes that you apply at the assembly level in your source code. Here’s what the code that produced the version information in Figure 2-4 looks like.</p></blockquote><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Reflection</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// FileDescription 版本信息:</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token target keyword">assembly</span><span class="token punctuation">:</span> <span class="token class-name">AssemblyTitle</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token string">"MultiFileLibrary.dll"</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// Comments 版本信息:</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token target keyword">assembly</span><span class="token punctuation">:</span> <span class="token class-name">AssemblyDescription</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token string">"This assembly contains MultiFileLibrary's types"</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// CompanyName 版本信息:</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token target keyword">assembly</span><span class="token punctuation">:</span> <span class="token class-name">AssemblyCompany</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token string">"Wintellect"</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment">// ProductName 版本信息:</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token target keyword">assembly</span><span class="token punctuation">:</span> <span class="token class-name">AssemblyProduct</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token string">"Wintellect (R) MultiFileLibrary's Type Library"</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">// LegalCopyright 版本信息:</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token target keyword">assembly</span><span class="token punctuation">:</span> <span class="token class-name">AssemblyCopyright</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token string">"Copyright (c) Wintellect 2013"</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token comment">// LegalTrademarks 版本信息:</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token target keyword">assembly</span><span class="token punctuation">:</span><span class="token class-name">AssemblyTrademark</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token string">"MultiFileLibrary is a registered trademark of Wintellect"</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token comment">// AssemblyVersion 版本信息:</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token target keyword">assembly</span><span class="token punctuation">:</span> <span class="token class-name">AssemblyVersion</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token string">"3.0.0.0"</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token comment">// FILEVERSION/FileVersion 版本信息:</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token target keyword">assembly</span><span class="token punctuation">:</span> <span class="token class-name">AssemblyFileVersion</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token string">"1.0.0.0"</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token comment">// PRODUCTVERSION/ProductVersion 版本信息:</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token target keyword">assembly</span><span class="token punctuation">:</span> <span class="token class-name">AssemblyInformationalVersion</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token string">"2.0.0.0"</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token comment">// 设置 Language 字段 (参见 2.6 节” 语言文化 “)</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token punctuation">[</span>assembly<span class="token punctuation">:</span><span class="token function">AssemblyCulture</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">]</span></pre></td></tr></table></figure><p><img data-src="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/Untitled7.png" alt="Untitled"></p><p>💡 Note：Windows 资源管理器的属性对话框明显遗漏了一些特性值。最遗憾的是没有显示 <strong>AssemblyVersion</strong> 这个特性的值，因为 CLR 加载程序集时会使用这个值，详情将在第 3 章讨论。</p><h3 id="version-numbers"><a class="anchor" href="#version-numbers">#</a> <strong>Version Numbers</strong></h3><blockquote><p>the previous section, you saw that several version numbers can be applied to an assembly. All of these version numbers have the same format: each consists of four period-separated parts, as shown in Table 2-5.</p></blockquote><p><img data-src="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/Untitled8.png" alt="Untitled"></p><blockquote><p>You’ll notice that an assembly has three version numbers associated with it. This is very unfortunate and leads to a lot of confusion. Let me explain each version number’s purpose and how it is expected to be used:</p></blockquote><p>■ <strong><code>AssemblyFileVersion</code></strong></p><blockquote><p>This version number is stored in the Win32 version resource. This number is for information purposes only; the CLR doesn’t examine this version number in any way. Typically, you set the major and minor parts to represent the version you want the public to see. Then you increment the build and revision parts each time a build is performed. Ideally, Microsoft’s tool (such as CSC.exe or AL.exe) would automatically update the build and revision numbers for you (based on the date and time when the build was performed), but unfortunately, they don’t. This version number can be seen when using Windows Explorer and is typically used to identify a specific version of an assembly when troubleshooting a customer’s system.</p></blockquote><p>■ <strong><code>AssemblyInformationalVersion</code></strong></p><blockquote><p>This version number is also stored in the Win32 version resource, and again, this number is for information purposes only; the CLR doesn’t examine or care about it in any way. This version number exists to indicate the version of the product that includes this assembly. For example, version 2.0 of a product might contain several assemblies; one of these assemblies is marked as version 1.0 because it’s a new assembly that didn’t ship in version 1.0 of the same product. Typically, you set the major and minor parts of this version number to represent the public version of your product. Then you increment the build and revision parts each time you package a complete product with all its assemblies.</p></blockquote><p>■ <strong><code>AssemblyVersion</code></strong></p><blockquote><p>This version number is stored in the <code>AssemblyDef</code> manifest metadata table. The CLR uses this version number when binding to strongly named assemblies (discussed in Chapter 3). This number is extremely important and is used to uniquely identify an assembly. When starting to develop an assembly, you should set the major, minor, build, and revision numbers and shouldn’t change them until you’re ready to begin work on the next deployable version of your assembly. When Assembly-A references a strongly named Assembly-B, Assembly-B’s version is embedded inside Assembly-A’s <code>AssemblyRef</code> table’s entry. This way, when the CLR needs to load Assembly-B, it knows exactly which version Assembly-A was built and tested with. It is possible to have the CLR load a different version by using a binding redirect, which is discussed in Chapter 3.</p></blockquote><p>💡 小结：AL.exe 或 CSC.exe 生成 PE 文件程序集时，还会在 PE 文件中嵌入标准的 Win32 版本资源，可以通过定制特性或者 AL.exe 命令行开关设置这些信息。通过查看文件属性可以检查该资源，但在属性对话框中并不会显示 AssemblyVersion 这个特性的，因为 CLR 加载程序集时会使用这个值，这个版本号唯一地标识了程序集，如果程序集 A 引用了强命名的程序集 B，程序集 B 的版本会嵌入程序集的 AssemblyRef 表。这样一来，当 CLR 需要加载程序集 B 时，就准确地知道当初生成和测试的是程序集的哪个版本。程序集有三个版本号，AssemblyFileVersion 和 AssemblyInformationalVersion 版本号仅供参考，CLR 既不检查，也不关心它。</p><h2 id="culture"><a class="anchor" href="#culture">#</a> <strong>Culture</strong></h2><blockquote><p>Like version numbers, assemblies also have a culture as part of their identity. For example, I could have an assembly that is strictly for German, another assembly for Swiss German, another assembly for US English, and so on. Cultures are identified via a string that contains a primary and a secondary tag (as described in RFC 1766). Table 2-6 shows some examples.</p></blockquote><p><img data-src="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/Untitled9.png" alt="Untitled"></p><blockquote><p>In general, if you create an assembly that contains code, you don’t assign a culture to it. This is because code doesn’t usually have any culture-specific assumptions built into it. An assembly that isn’t assigned a culture is referred to as being culture neutral.</p></blockquote><blockquote><p>If you’re designing an application that has some culture-specific resources to it, Microsoft highly recommends that you create one assembly that contains your code and your application’s default (or fallback) resources. When building this assembly, don’t specify a culture. This is the assembly that other assemblies will reference when they create and manipulate types it publicly exposes.</p></blockquote><blockquote><p>Now you can create one or more separate assemblies that contain only culture-specific resources— no code at all. Assemblies that are marked with a culture are called satellite assemblies. For these satellite assemblies, assign a culture that accurately reflects the culture of the resources placed in the assembly. You should create one satellite assembly for each culture you intend to support.</p></blockquote><blockquote><p>You’ll usually use the AL.exe tool to build a satellite assembly. You won’t use a compiler because the satellite assembly should have no code contained within it. When using AL.exe, you specify the desired culture by using the <code>/c[ulture]:text</code> switch, where text is a string such as “en-US,” representing US English. When you deploy a satellite assembly, you should place it in a subdirectory whose name matches the culture text. For example, if the application’s base directory is C:\MyApp, the US English satellite assembly should be placed in the C:\MyApp\en-US subdirectory. At run time, you access a satellite assembly’s resources by using the <code>System.Resources.ResourceManager</code> class.</p></blockquote><blockquote><p>Normally, you shouldn’t build an assembly that references a satellite assembly. In other words, an assembly’s <code>AssemblyRef</code> entries should all refer to culture-neutral assemblies. If you want to access types or members contained in a satellite assembly, you should use reflection techniques as discussed in Chapter 23, “Assembly Loading and Reflection.”</p></blockquote><p>💡 小结：除了版本号，程序集还将语言文化（culture）作为其身份标识的一部分。创建含代码的程序集时一半不指定具体的语言文化。这是因为代码只讲 “逻辑”，不涉及具体的语言文化。未指定具体语言文化的程序集称为语言文化中性（culture neutral）。标记了语言文化的程序集称为附属程序集（satellite assembly）。通常使用 AL.exe 生成程序集。不用编译器的是因为附属程序集本身就不该含有代码。部署附属程序集时，应该把它保存到专门的子目录中，子目录名称和语言文化的文本匹配。一般不要生成引用了附属程序集的程序集。换言之，程序集的 AssemblyRef 记录项只应引用语言文化中性的程序集。</p><h2 id="simple-application-deployment-privately-deployed-assemblies"><a class="anchor" href="#simple-application-deployment-privately-deployed-assemblies">#</a> <strong>Simple Application Deployment (Privately Deployed Assemblies)</strong></h2><blockquote><p>Windows Store apps have very strict rules about packaging assemblies, and Visual Studio will package all of an application’s required assemblies together into a single .appx file, which is either uploaded to the Windows Store or can be side-loaded onto a machine. When a user installs an .appx file, all the assemblies it contains are placed in a directory where the CLR will load them and Windows adds an application tile to the user's Start screen. If other users install the same .appx file, the previously installed assemblies are used and the new user simply gets a tile added to their Start screen. When a user uninstalls a Windows Store app, the system removes the tile from the user's Start screen. If no other users have the app installed, then Windows destroys the directory along with all the assemblies. Note that different users can install different versions of the same Windows Store app. To accommodate this, Windows installs the assemblies into different directories so that multiple versions of a single app can reside on a single machine simultaneously.</p></blockquote><blockquote><p>For desktop (non-Windows Store) applications, assemblies don’t dictate or require any special means of packaging. The easiest way to package a set of assemblies is simply to copy all of the files directly. For example, you could put all of the assembly files on a CD-ROM and ship it to the user with a batch file setup program that just copies the files from the CD to a directory on the user’s hard drive. Because the assemblies include all of the dependent assembly references and types, the user can just run the application and the runtime will look for referenced assemblies in the application’s directory. No modifications to the registry are necessary for the application to run. To uninstall the application, just delete all the files—that’s it!</p></blockquote><blockquote><p>Of course, you can package and install the assembly files by using other mechanisms, such as .cab files (typically used for Internet download scenarios to compress files and reduce download times). You can also package the assembly files into an MSI file for use by the Windows Installer service (MSIExec.exe). Using MSI files allows assemblies to be installed on demand the first time the CLR attempts to load the assembly. This feature isn’t new to MSI; it can perform the same demand-load functionality for unmanaged EXE and DLL files as well.</p></blockquote><blockquote><p>Of course, Visual Studio has a built-in mechanism that you can use to publish an application by displaying a project’s Properties pages and clicking the Publish tab. You can use the options available on the Publish tab to cause Visual Studio to produce an MSI file and copy the resulting MSI file to a website, FTP server, or file path. The MSI file can also install any prerequisite components such as the .NET Framework or Microsoft SQL Server Express Edition. Finally, the application can automatically check for updates and install them on the user’s machine by taking advantage of ClickOnce technology.</p></blockquote><blockquote><p>Assemblies deployed to the same directory as the application are called privately deployed assemblies because the assembly files aren’t shared with any other application (unless the other application is also deployed to the same directory). Privately deployed assemblies are a big win for developers, end users, and administrators because they can simply be copied to an application’s base directory, and the CLR will load them and execute the code in them. In addition, an application can be uninstalled by simply deleting the assemblies in its directory. This allows simple backup and restore as well.</p></blockquote><blockquote><p>This simple install/move/uninstall scenario is possible because each assembly has metadata indicating which referenced assembly should be loaded; no registry settings are required. In addition, the referencing assembly scopes every type. This means that an application always binds to the same type it was built and tested with; the CLR can’t load a different assembly that just happens to provide a type with the same name. This is different from COM, in which types are recorded in the registry, making them available to any application running on the machine.</p></blockquote><p>💡 小结：对于 Windows Store 应用程序的打包，Visual Studio 会将应用程序所有必要的程序集打包成一个.appx 文件。用户安装.appx 文件时，其中包含的所有程序集都进入一个目录。对于非 Windows Store 的桌面应用，打包一组程序集最简单的方式就是直接复制所有文件。由于已经包含了所有依赖的程序集和类型，所以用户能直接运行应用程序，“运行时” 会在应用程序目录查找引用的程序集。不需要对注册表进行任何修改就能运行程序。卸载的话直接删除所有文件即可。也可以使用.cab 文件、MSI 文件打包和安装程序集。在应用程序基目录或者子目录部署的程序集称为私有部署的程序集（privately deployed assembly），这是因为程序集文件不和其他任何应用程序共享（除非其他应用程序徐也部署到改目录）。子所以能实现这种简单的安装 / 移动 / 卸载，是因为每个程序集都用元数据标明了自己引用的程序集，不需要注册表设置。一个应用程序总是和它生成和测试时的类型绑定。即便另一个程序集恰好提供了同名类型，CLR 也不可能加载那个程序集。这一点有别于 COM。在 COM 中，类型是在注册表中登记的，造成机器上运行的任何应用程序都能使用那些类型。</p><h2 id="simple-administrative-control-configuration"><a class="anchor" href="#simple-administrative-control-configuration">#</a> <strong>Simple Administrative Control (Configuration)</strong></h2><blockquote><p>To allow administrative control over an application, a configuration file can be placed in the application’s directory. An application’s publisher can create and package this file. The setup program would then install this configuration file in the application’s base directory. In addition, the machine’s administrator or an end user could create or modify this file. The CLR interprets the content of this file to alter its policies for locating and loading assembly files.</p></blockquote><blockquote><p>These configuration files contain Extensible Markup Language (XML) and can be associated with an application or with the machine. Using a separate file (versus registry settings) allows the file to be easily backed up and also allows the administrator to copy the application to another machine—just copy the necessary files and the administrative policy is copied too.</p></blockquote><blockquote><p>Whenever the CLR attempts to locate an assembly file, it always looks in the application’s directory first, and if it can’t find the file there, it looks in the AuxFiles subdirectory. You can specify multiple semicolon-delimited paths for the probing element’s privatePath attribute. Each path is considered relative to the application’s base directory. You can’t specify an absolute or a relative path identifying a directory that is outside of the application’s base directory. The idea is that an application can control its directory and its subdirectories but has no control over other directories.</p></blockquote><blockquote><p>The name and location of this XML configuration file is different depending on the application type:</p></blockquote><p>■ For executable applications (EXEs), the configuration file must be in the application’s base directory, and it must be the name of the EXE file with “.config” appended to it.</p><p>■ For Microsoft <span class="exturl" data-url="aHR0cDovL0FTUC5ORVQ=">ASP.NET</span> Web Form applications, the file must be in the Web application’s virtual root directory and is always named Web.config. In addition, subdirectories can also contain their own Web.config file, and the configuration settings are inherited. For example, a Web application located at <span class="exturl" data-url="aHR0cDovL3dpbnRlbGxlY3QuY29tL1RyYWluaW5n">http://Wintellect.com/Training</span> would use the settings in the Web.config files contained in the virtual root directory and in its Training subdirectory.</p><blockquote><p>As mentioned at the beginning of this section, configuration settings apply to a particular application and to the machine. When you install the .NET Framework, it creates a Machine.config file. There is one Machine.config file per version of the CLR you have installed on the machine.</p></blockquote><blockquote><p>The Machine.config file is located in the following directory:</p></blockquote><pre><code>%SystemRoot%\Microsoft.NET\Framework\version\CONFIG
</code></pre><blockquote><p>Of course, %SystemRoot% identifies your Windows directory (usually C:\WINDOWS), and version is a version number identifying a specific version of the .NET Framework (something like v4.0.#####).</p></blockquote><blockquote><p>Settings in the Machine.config file represent default settings that affect all applications running on the machine. An administrator can create a machine-wide policy by modifying the single Machine.config file. However, administrators and users should avoid modifying this file because it contains many settings related to various things, making it much more difficult to navigate. Plus, you want the application’s settings to be backed up and restored, and keeping an application’s settings in the application-specific configuration file enables this.</p></blockquote><p>💡 小结：为了实现对应用程序的管理控制，可在应用程序目录放入一个配置文件。应用程序的发布者可创建并打包该文件。安装程序会将配置文件安装到应用程序的基目录。另外，计算机管理员或最终用户也能创建或修改该文件。CLR 会解析文件内容来更改程序集文件的定位和加载策略。配置文件包含 XML 代码，它既能和应用程序关联，也能和机器关联。CLR 尝试定位程序集文件时，总是先在应用程序基目录查找。通过 XML 格式的配置文件可以指定包含程序集的子目录。对于可执行应用程序（EXE），配置文件必须在应用程序的基目录，而且必须采用 EXE 文件全名作为文件名，再附加.config 扩展名。对于 Microsoft <span class="exturl" data-url="aHR0cDovL0FTUC5ORVQ=">ASP.NET</span> Web 窗体应用程序，文件必须在 Web 应用程序的虚拟根目录中，而且总是命名为 Web.config。除此之外，子目录可以包含自己的 Web.config，而且配置设置会得到继承。应用于机器的配置设置指的是：.NET Framework 在安装时会创建一个 Machine.config。机器上安装的每个版本的 CLR 都有一个对应的 Machine.config。Machine.config 文件的设置将会影响机器上运行的所有应用程序的默认设置。</p><div class="tags"><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 读书笔记</a> <a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C#</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2023-11-22 08:09:43" itemprop="dateModified" datetime="2023-11-22T08:09:43+08:00">2023-11-22</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Sakupinera WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Sakupinera Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Sakupinera PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Sakupinera <i class="ic i-at"><em>@</em></i>Sakupinera</li><li class="link"><strong>Post link: </strong><a href="http://sakupinera.github.io/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/" title="CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types">http://sakupinera.github.io/2022/08/28/csharp/clr-via-csharp/Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%203%20Shared%20Assemblies%20and%20Strongly%20Named%20Assemblies/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicit31ffoj20zk0m8naf.jpg" title="CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies</h3></a></div><div class="item right"><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giciuja1j1j20zk0m8kjl.jpg" title="CLR via C# - Chapter 1 The CLR’s Execution Model"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i> CLR-via-CSharp</span><h3>CLR via C# - Chapter 1 The CLR’s Execution Model</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-2-building-packaging-deploying-and-administering-applications-and-types"><span class="toc-number">1.</span> <span class="toc-text">Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#net-framework-deployment-goals"><span class="toc-number">1.1.</span> <span class="toc-text">.NET Framework Deployment Goals</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#building-types-into-a-module"><span class="toc-number">1.2.</span> <span class="toc-text">Building Types into a Module</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a-brief-look-at-metadata"><span class="toc-number">1.3.</span> <span class="toc-text">A Brief Look at Metadata</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#combining-modules-to-form-an-assembly"><span class="toc-number">1.4.</span> <span class="toc-text">Combining Modules to Form an Assembly</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#using-the-assembly-linker"><span class="toc-number">1.4.1.</span> <span class="toc-text">Using the Assembly Linker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#adding-resource-files-to-an-assembly"><span class="toc-number">1.4.2.</span> <span class="toc-text">Adding Resource Files to an Assembly</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#assembly-version-resource-information"><span class="toc-number">1.5.</span> <span class="toc-text">Assembly Version Resource Information</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#version-numbers"><span class="toc-number">1.5.1.</span> <span class="toc-text">Version Numbers</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#culture"><span class="toc-number">1.6.</span> <span class="toc-text">Culture</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#simple-application-deployment-privately-deployed-assemblies"><span class="toc-number">1.7.</span> <span class="toc-text">Simple Application Deployment (Privately Deployed Assemblies)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#simple-administrative-control-configuration"><span class="toc-number">1.8.</span> <span class="toc-text">Simple Administrative Control (Configuration)</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"><ul><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/" rel="bookmark" title="CLR via C# - Chapter 1 The CLR’s Execution Model">CLR via C# - Chapter 1 The CLR’s Execution Model</a></li><li class="active"><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%202%20Building,%20Packaging,%20Deploying,%20and%20Administering%20Applications%20and%20Types/" rel="bookmark" title="CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types">CLR via C# - Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types</a></li><li><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%203%20Shared%20Assemblies%20and%20Strongly%20Named%20Assemblies/" rel="bookmark" title="CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies">CLR via C# - Chapter 3 Shared Assemblies and Strongly Named Assemblies</a></li><li><a href="/2022/09/27/csharp/clr-via-csharp/Chapter%204%20Type%20Fundamentals/" rel="bookmark" title="CLR via C# - Chapter 4 Type Fundamentals">CLR via C# - Chapter 4 Type Fundamentals</a></li><li><a href="/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/" rel="bookmark" title="CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals">CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals</a></li><li><a href="/2022/10/21/csharp/clr-via-csharp/Chapter%206%20Type%20and%20Member%20Basics/" rel="bookmark" title="CLR via C# - Chapter 6 Type and Member Basics">CLR via C# - Chapter 6 Type and Member Basics</a></li><li><a href="/2022/10/24/csharp/clr-via-csharp/Chapter%207%20Constants%20and%20Fields/" rel="bookmark" title="CLR via C# - Chapter 7 Constants and Fields">CLR via C# - Chapter 7 Constants and Fields</a></li><li><a href="/2022/10/25/csharp/clr-via-csharp/Chapter%208%20Methods/" rel="bookmark" title="CLR via C# - Chapter 8 Methods">CLR via C# - Chapter 8 Methods</a></li><li><a href="/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/" rel="bookmark" title="CLR via C# - Chapter 9 Parameters">CLR via C# - Chapter 9 Parameters</a></li><li><a href="/2022/10/28/csharp/clr-via-csharp/Chapter%2010%20Properties/" rel="bookmark" title="CLR via C# - Chapter 10 Properties">CLR via C# - Chapter 10 Properties</a></li><li><a href="/2022/10/29/csharp/clr-via-csharp/Chapter%2011%20Events/" rel="bookmark" title="CLR via C# - Chapter 11 Events">CLR via C# - Chapter 11 Events</a></li><li><a href="/2022/11/02/csharp/clr-via-csharp/Chapter%2012%20Generics/" rel="bookmark" title="CLR via C# - Chapter 12 Generics">CLR via C# - Chapter 12 Generics</a></li><li><a href="/2022/11/04/csharp/clr-via-csharp/Chapter%2013%20Interfaces/" rel="bookmark" title="CLR via C# - Chapter 13 Interfaces">CLR via C# - Chapter 13 Interfaces</a></li><li><a href="/2022/11/16/csharp/clr-via-csharp/Chapter%2014%20Chars,%20Strings,%20and%20Working%20%20with%20Text/" rel="bookmark" title="CLR via C# - Chapter 14 Chars, Strings, and Working with Text">CLR via C# - Chapter 14 Chars, Strings, and Working with Text</a></li><li><a href="/2022/11/17/csharp/clr-via-csharp/Chapter%2015%20Enumerated%20Types%20and%20Bit%20Flags/" rel="bookmark" title="CLR via C# - Chapter 15 Enumerated Types and Bit Flags">CLR via C# - Chapter 15 Enumerated Types and Bit Flags</a></li><li><a href="/2022/11/19/csharp/clr-via-csharp/Chapter%2016%20Arrays/" rel="bookmark" title="CLR via C# - Chapter 16 Arrays">CLR via C# - Chapter 16 Arrays</a></li><li><a href="/2022/11/21/csharp/clr-via-csharp/Chapter%2017%20Delegates/" rel="bookmark" title="CLR via C# - Chapter 17 Delegates">CLR via C# - Chapter 17 Delegates</a></li><li><a href="/2022/11/22/csharp/clr-via-csharp/Chapter%2018%20Custom%20Attributes/" rel="bookmark" title="CLR via C# - Chapter 18 Custom Attributes">CLR via C# - Chapter 18 Custom Attributes</a></li><li><a href="/2022/11/23/csharp/clr-via-csharp/Chapter%2019%20Nullable%20Value%20Types/" rel="bookmark" title="CLR via C# - Chapter 19 Nullable Value Types">CLR via C# - Chapter 19 Nullable Value Types</a></li><li><a href="/2022/11/25/csharp/clr-via-csharp/Chapter%2020%20Exceptions%20and%20State%20Management/" rel="bookmark" title="CLR via C# - Chapter 20 Exceptions and State Management">CLR via C# - Chapter 20 Exceptions and State Management</a></li><li><a href="/2022/11/27/csharp/clr-via-csharp/Chapter%2021%20The%20Managed%20Heap%20and%20Garbage%20%20Collection/" rel="bookmark" title="CLR via C# - Chapter 21 The Managed Heap and Garbage  Collection">CLR via C# - Chapter 21 The Managed Heap and Garbage Collection</a></li><li><a href="/2022/11/28/csharp/clr-via-csharp/Chapter%2022%20CLR%20Hosting%20and%20AppDomains/" rel="bookmark" title="CLR via C# - Chapter 22 CLR Hosting and AppDomains">CLR via C# - Chapter 22 CLR Hosting and AppDomains</a></li><li><a href="/2022/11/29/csharp/clr-via-csharp/Chapter%2023%20Assembly%20Loading%20and%20Reflection/" rel="bookmark" title="CLR via C# - Chapter 23 Assembly Loading and Reflection">CLR via C# - Chapter 23 Assembly Loading and Reflection</a></li><li><a href="/2022/11/30/csharp/clr-via-csharp/Chapter%2024%20Runtime%20Serialization/" rel="bookmark" title="CLR via C# - Chapter 24 Runtime Serialization">CLR via C# - Chapter 24 Runtime Serialization</a></li><li><a href="/2022/12/06/csharp/clr-via-csharp/Chapter%2025%20Interoperating%20with%20WinRT%20%20Components/" rel="bookmark" title="CLR via C# - Chapter 25 Interoperating with WinRT Components">CLR via C# - Chapter 25 Interoperating with WinRT Components</a></li><li><a href="/2023/02/06/csharp/clr-via-csharp/Chapter%2026%20Thread%20Basics/" rel="bookmark" title="CLR via C# - Chapter 26 Thread Basics">CLR via C# - Chapter 26 Thread Basics</a></li><li><a href="/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations">CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations</a></li><li><a href="/2023/02/08/csharp/clr-via-csharp/Chapter%2028%20IO-Bound%20Asynchronous%20Operations/" rel="bookmark" title="CLR via C# - Chapter 28 IO-Bound Asynchronous Operations">CLR via C# - Chapter 28 IO-Bound Asynchronous Operations</a></li><li><a href="/2023/02/09/csharp/clr-via-csharp/Chapter%2029%20Primitive%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 29 Primitive Thread Synchronization">CLR via C# - Chapter 29 Primitive Thread Synchronization</a></li><li><a href="/2023/02/10/csharp/clr-via-csharp/Chapter%2030%20Hybrid%20Thread%20Synchronization%20Constructs/" rel="bookmark" title="CLR via C# - Chapter 30 Hybrid Thread Synchronization">CLR via C# - Chapter 30 Hybrid Thread Synchronization</a></li></ul></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sakupinera" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Sakupinera</p><div class="description" itemprop="description">保持你的决心！</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">89</span> <span class="name">posts</span></a></div><div class="item categories"><a href="/categories/"><span class="count">17</span> <span class="name">categories</span></a></div><div class="item tags"><a href="/tags/"><span class="count">8</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nha3VwaW5lcmE=" title="https:&#x2F;&#x2F;github.com&#x2F;sakupinera"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9zYWt1cGluZXJh" title="https:&#x2F;&#x2F;twitter.com&#x2F;sakupinera"><i class="ic i-twitter"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQwNzIyOTA3MQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;407229071"><i class="ic i-cloud-music"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMjIzMDczOTg/c3BtX2lkX2Zyb209MzMzLjEwMDcuMC4w" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;22307398?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li><li class="item"><a href="/games/" rel="section"><i class="ic i-flag"></i>games</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-person"></i>About</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%203%20Shared%20Assemblies%20and%20Strongly%20Named%20Assemblies/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/08/28/csharp/clr-via-csharp/Chapter%201%20The%20CLR%E2%80%99s%20Execution%20Model/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2023/02/07/csharp/clr-via-csharp/Chapter%2027%20Compute-Bound%20Asynchronous%20Operations/" title="CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations">CLR via C# - Chapter 27 Compute-Bound Asynchronous Operations</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/10/14/computer-graphics/games101/%E6%9D%90%E8%B4%A8%E4%B8%8E%E5%A4%96%E8%A7%82/" title="GAMES101 - Materials and Appearances（材质与外观）">GAMES101 - Materials and Appearances（材质与外观）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2023/01/05/cpp/cpp-primer/Chapter%2013%20Copy%20Control/" title="C++ Primer - Chapter 13 Copy Control">C++ Primer - Chapter 13 Copy Control</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/" title="CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals">CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/17/csharp/clr-via-csharp/Chapter%2015%20Enumerated%20Types%20and%20Bit%20Flags/" title="CLR via C# - Chapter 15 Enumerated Types and Bit Flags">CLR via C# - Chapter 15 Enumerated Types and Bit Flags</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="In Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/Learn-Linux/" title="In Learn-Linux">Learn-Linux</a></div><span><a href="/2022/08/28/linux/learn-linux/%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/" title="LearnLinux - 软件包管理">LearnLinux - 软件包管理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2022/12/16/cpp/cpp-primer/Chapter%208%20The%20IO%20Library/" title="C++ Primer - Chapter 8 The IO Library">C++ Primer - Chapter 8 The IO Library</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/09/18/computer-graphics/games101/%E5%8F%98%E6%8D%A2/" title="GAMES101 - Transformation（变换）">GAMES101 - Transformation（变换）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2022/12/10/cpp/cpp-primer/Chapter%202%20Variables%20and%20Basic%20Types/" title="C++ Primer - Chapter 2 Variables and Basic Types">C++ Primer - Chapter 2 Variables and Basic Types</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/11/29/csharp/clr-via-csharp/Chapter%2023%20Assembly%20Loading%20and%20Reflection/" title="CLR via C# - Chapter 23 Assembly Loading and Reflection">CLR via C# - Chapter 23 Assembly Loading and Reflection</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Sakupinera @ Hanamai Sora</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="Symbols count total">2.2m words</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="Reading time total">34:05</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/08/28/csharp/clr-via-csharp/Chapter 2 Building, Packaging, Deploying, and Administering Applications and Types/",favicon:{show:"（●´3｀●）Goooood",hide:"(´Д｀)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/shifuku.model.json"},display:{position:"left",width:250,height:500},mobile:{show:!1},react:{opacity:.9},log:!1})</script></body></html>