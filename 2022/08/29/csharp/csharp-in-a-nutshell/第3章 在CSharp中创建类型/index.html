<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sakupinera" href="http://sakupinera.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sakupinera" href="http://sakupinera.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sakupinera" href="http://sakupinera.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="读书笔记,C#"><link rel="canonical" href="http://sakupinera.github.io/2022/08/29/csharp/csharp-in-a-nutshell/%E7%AC%AC3%E7%AB%A0%20%E5%9C%A8CSharp%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%9E%8B/"><title>C# in a Nutshell - 第 3 章 在 C# 中创建类型 - CSharp-in-a-Nutshell - CSharp | Hanamai Sora = Sakupinera</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">C# in a Nutshell - 第 3 章 在 C# 中创建类型</h1><div class="meta"><span class="item" title="Created: 2022-08-29 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2022-08-29T00:00:00+08:00">2022-08-29</time> </span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">Symbols count in article</span> <span>24k</span> <span class="text">words</span> </span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">Reading time</span> <span>22 mins.</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hanamai Sora</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclgrvbd6j20zk0m8qv5.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gicis081o9j20zk0m8dmr.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipewr8iypj20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclize41wj20zk0m87gk.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipevo9j1jj20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipeu7txpzj20zk0m81kx.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/" itemprop="item" rel="index" title="In CSharp"><span itemprop="name">CSharp</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CSharp/CSharp-in-a-Nutshell/" itemprop="item" rel="index" title="In CSharp-in-a-Nutshell"><span itemprop="name">CSharp-in-a-Nutshell</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://sakupinera.github.io/2022/08/29/csharp/csharp-in-a-nutshell/%E7%AC%AC3%E7%AB%A0%20%E5%9C%A8CSharp%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%9E%8B/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Sakupinera"><meta itemprop="description" content=", 保持你的决心！"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakupinera"></span><div class="body md" itemprop="articleBody"><h1 id="在c中创建类型"><a class="anchor" href="#在c中创建类型">#</a> 在 C# 中创建类型</h1><h2 id="类"><a class="anchor" href="#类">#</a> 类</h2><p><strong>表达式体方法</strong></p><p>以下仅由一个表达式构成的方法：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> x<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>可以用表达式体方法简洁地表示，用胖箭头来取代花括号和 return 关键字：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> x<span class="token punctuation">)</span><span class="token operator">=></span> x<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>表达式体函数也可以用 void 作为返回类型：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> x<span class="token punctuation">)</span><span class="token operator">=></span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="实例构造器"><a class="anchor" href="#实例构造器">#</a> 实例构造器</h3><p><mark>实例构造器支持以下的修饰符：</mark></p><ul><li>访问权限修饰符：public internal private protected</li><li>非托管代码修饰符：unsafe extern</li></ul><p><strong>重载构造器</strong></p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Wine</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">decimal</span></span> Price<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">int</span></span> Year<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> Wine <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">decimal</span></span> price<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Price <span class="token operator">=</span> price<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> Wine <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">decimal</span></span> price<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> year<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">this</span> <span class="token punctuation">(</span>price<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Year <span class="token operator">=</span> year<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>当构造器调用另一个构造器时，被调用的构造器先执行。</p><p>注意：表达式内不能使用 this 引用，例如，不能调用实例方法（这是强制性的。由于这个对象还没通过构造器初始化完毕，因此调用任何方法都有可能失败）。但是表达式可以调用静态方法。</p><p><strong>构造器和字段的初始化顺序</strong></p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Player</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name"><span class="token keyword">int</span></span> shields <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span> <span class="token comment">// Initialized first</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name"><span class="token keyword">int</span></span> health <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// Initialized second</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>字段的初始化按声明的先后顺序，在构造器之前执行。</p><p><strong>解构器</strong></p><p>解构器（或称之为解构方法）就像构造的反过程，名字必须为 Deconstruct，并且拥有一个或多个 out 参数。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Rectangle</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">readonly</span> <span class="token class-name"><span class="token keyword">float</span></span> Width<span class="token punctuation">,</span> Height<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token function">Rectangle</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">float</span></span> width<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">float</span></span> height<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>Width<span class="token punctuation">,</span> Height<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>width<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Deconstruct</span><span class="token punctuation">(</span><span class="token keyword">out</span> <span class="token class-name"><span class="token keyword">float</span></span> width<span class="token punctuation">,</span> <span class="token keyword">out</span> <span class="token class-name"><span class="token keyword">float</span></span> height<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        width <span class="token operator">=</span> Width<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        height <span class="token operator">=</span> Height<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Test</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token class-name"><span class="token keyword">var</span></span> rect <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Rectangle</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token comment">//(float width, float height) = rect;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token comment">//float width, height;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token comment">//rect.Deconstruct(out width, out height);		// Deconstruction</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token comment">//rect.Deconstruct(out var width, out var height);</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token comment">//(var width, var height) = rect;</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token keyword">var</span> <span class="token punctuation">(</span>width<span class="token punctuation">,</span> height<span class="token punctuation">)</span> <span class="token operator">=</span> rect<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre>            <span class="token comment">//var (_, height) = rect;</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre>            <span class="token comment">//Console.WriteLine(height);</span></pre></td></tr><tr><td data-num="31"></td><td><pre>            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>width <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> height<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 3  4</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="对象初始化器"><a class="anchor" href="#对象初始化器">#</a> 对象初始化器</h3><p>为了简化对象的初始化，可以在调用构造器之后直接通过对象初始化器设置对象的可访问字段或属性。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Bunny</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">string</span></span> Name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">bool</span></span> LikesCarrots<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">bool</span></span> LikesHumans<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> Bunny <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> Bunny <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Name <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">// Note parameterless constructors can omit empty parentheses</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token class-name">Bunny</span> b1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Bunny</span> <span class="token punctuation">&#123;</span> Name<span class="token operator">=</span><span class="token string">"Bo"</span><span class="token punctuation">,</span> LikesCarrots<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">,</span> LikesHumans<span class="token operator">=</span><span class="token boolean">false</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token class-name">Bunny</span> b2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Bunny</span> <span class="token punctuation">(</span><span class="token string">"Bo"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> LikesCarrots<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">,</span> LikesHumans<span class="token operator">=</span><span class="token boolean">false</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token class-name">Bunny</span> temp1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Bunny</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// temp1 is a compiler-generated name</span></pre></td></tr><tr><td data-num="15"></td><td><pre>temp1<span class="token punctuation">.</span>Name <span class="token operator">=</span> <span class="token string">"Bo"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>temp1<span class="token punctuation">.</span>LikesCarrots <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>temp1<span class="token punctuation">.</span>LikesHumans <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token class-name">Bunny</span> b1 <span class="token operator">=</span> temp1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token class-name">Bunny</span> temp2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Bunny</span> <span class="token punctuation">(</span><span class="token string">"Bo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>temp2<span class="token punctuation">.</span>LikesCarrots <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>temp2<span class="token punctuation">.</span>LikesHumans <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token class-name">Bunny</span> b2 <span class="token operator">=</span> temp2<span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="引用"><a class="anchor" href="#引用">#</a> 引用</h3><p>略</p><h3 id="属性"><a class="anchor" href="#属性">#</a> 属性</h3><p>属性支持以下的修饰符：</p><ul><li>静态修饰符：static</li><li>访问权限修饰符：public internal private protected</li><li>继承修饰符：new virtual abstract override sealed</li><li>非托管代码修饰符：unsafe extern</li></ul><p><strong>自动属性</strong></p><p>属性最常见的实现方式是使用 get 访问器和 set 访问器读写私有字段（该字段与属性类型相同）。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Stock</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">decimal</span></span> CurrentPrice <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>编译器会自动生成一个后台私有字段，该字段的名称由编译器生成且无法引用。如果希望属性对其他类型暴露为只读属性，则可以将 set 访问器标记为 private 或 protected。自动属性是在 C#3.0 中引入的。</p><p><strong>CLR 属性的实现</strong></p><p>C# 属性访问器在内部会编译名为 get_XXX 和 set_XXX 的方法：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">decimal</span></span> get_CurrentPrice <span class="token punctuation">&#123;</span><span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> set_CurrentPrice <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">decimal</span></span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>简单的非虚属性访问器会被 JIT（即使）编译器内联编译，消除了属性和字段访问键的性能差距。内联是一种优化方法，它用方法的函数体代替方法调用。</p><p>Windows Runtime 库中的属性则会被编译器转换为 put_XXX 作为属性命名约定而非 set_XXX。</p><h3 id="索引器"><a class="anchor" href="#索引器">#</a> 索引器</h3><p>索引器为访问类或结构体中封装的列表或字典型数据元素提供了自然的访问接口。使用索引器的语法就像使用数组一样，不同之处在于索引参数可以是任意类型。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token keyword">string</span></span> s <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'h'</span></pre></td></tr><tr><td data-num="3"></td><td><pre>Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'l'</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token class-name"><span class="token keyword">string</span></span> s <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>s<span class="token punctuation">?</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Writes nothing; no error.</span></pre></td></tr></table></figure><p><strong>索引器的实现</strong></p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Sentence</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> words <span class="token operator">=</span> <span class="token string">"The quick brown fox"</span><span class="token punctuation">.</span><span class="token function">Split</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> <span class="token keyword">this</span> <span class="token punctuation">[</span><span class="token class-name"><span class="token keyword">int</span></span> wordNum<span class="token punctuation">]</span> <span class="token comment">// indexer</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> words <span class="token punctuation">[</span>wordNum<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">set</span> <span class="token punctuation">&#123;</span> words <span class="token punctuation">[</span>wordNum<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">value</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> <span class="token keyword">this</span> <span class="token punctuation">[</span><span class="token class-name"><span class="token keyword">int</span></span> arg1<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span></span> arg2<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> <span class="token keyword">set</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> <span class="token keyword">this</span> <span class="token punctuation">[</span><span class="token class-name"><span class="token keyword">int</span></span> wordNum<span class="token punctuation">]</span> <span class="token operator">=></span> words <span class="token punctuation">[</span>wordNum<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>CLR 索引器的实现</strong></p><p>索引器在内部会编译名为 get_Item 和 set_Item 的方法，如下所示：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> get_Item <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> wordNum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> set_Item <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> wordNum<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span></span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>在索引器中使用索引和范围（C#）</strong></p><p>在自定义类中，可以在索引器参数中使用 Index 和 Range 类型来支持索引和范围操作。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> <span class="token keyword">this</span> <span class="token punctuation">[</span><span class="token class-name">Index</span> index<span class="token punctuation">]</span> <span class="token operator">=></span> words <span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> <span class="token keyword">this</span> <span class="token punctuation">[</span><span class="token class-name">Range</span> range<span class="token punctuation">]</span> <span class="token operator">=></span> words <span class="token punctuation">[</span>range<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">Sentence</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Sentence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>s <span class="token punctuation">[</span><span class="token operator">^</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// fox</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> firstTwoWords <span class="token operator">=</span> s <span class="token punctuation">[</span><span class="token range operator">..</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// (The, quick)</span></pre></td></tr></table></figure><h3 id="静态构造器"><a class="anchor" href="#静态构造器">#</a> 静态构造器</h3><p>每个类型的静态构造器只会执行一次，并不是每个实例执行一次。一个类型只能定义一个静态构造器，名称必须和类型同名，且没有参数：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Test</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">static</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Type Initialized"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>运行时将在类型使用之前调用静态构造器，以下两种行为可以触发静态构造器执行：</p><ul><li>实例化类型</li><li>访问类型的静态成员</li></ul><p>静态构造器只支持两个修饰符：unsafe 和 extern</p><p>如果静态构造器抛出了未处理的异常（见第 4 章），则该类型在整个应用程序声明周期内都是不可用的。</p><p><strong>静态构造器和字段初始化顺序</strong></p><p>静态字段初始化器会在调用静态构造器前运行。如果类型没有静态构造器，字段会在类型被使用之前或者在运行时中更早的时间进行初始化。</p><p>静态字段初始化器按照字段声明的先后顺序运行。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Foo</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Foo</span> Instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name"><span class="token keyword">int</span></span> X <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">StaticConstructors</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>Foo<span class="token punctuation">.</span>X<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="静态类"><a class="anchor" href="#静态类">#</a> 静态类</h3><p>类可以标记为 static，表明它必须只能够由 static 成员组成，并且不能派生子类。 <code>System.Console</code> 和 <code>System.Math</code> 类就是静态类的最好示例。</p><h3 id="终结器"><a class="anchor" href="#终结器">#</a> 终结器</h3><p>终结器是只能够在类中使用的方法。该方法在垃圾回收器回收未引用对象占用的内存前调用。终结器的语法是类的名称加上～前缀。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Class1</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token operator">~</span><span class="token function">Class1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>		<span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>事实上，这是 C# 语言重写 Object 类的 Finalize 方法的语言。编译器会将其扩展为如下声明：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">protected</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">Finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>终结器允许使用以下的修饰符：</p><ul><li>非托管代码修饰符：unsafe</li></ul><h3 id="分部类型和方法"><a class="anchor" href="#分部类型和方法">#</a> 分部类型和方法</h3><p>分布类型（partial type）允许一个类型分开进行定义，典型的做法是分开在多个文件中。分布类型使用的常见场景是从其他源文件自动生成分布类（例如从 Visual Studio 模板或设计器），而这些类任然需要额外手动编写方法。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// PaymentFormGen.cs - auto-generated</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">partial</span> <span class="token keyword">class</span> <span class="token class-name">PaymentForm</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// PaymentForm.cs - hand-authored</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">partial</span> <span class="token keyword">class</span> <span class="token class-name">PaymentForm</span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>每一个部分必须包含 partial 声明。</p><p>分布类型的各个组成部分不能包含冲突的成员，例如具有相同参数的构造器。分部类型完全由编译器处理，因此各部分在编译时必须可用，并且必须编译在同一个程序集中。可以在多个分布类中声明中指定基类，只要基类是同一个基类即可。此外，每一个分部类型组成部分可以独立指定实现的接口。</p><p>编译器并不保证分部类型声明中各个组成部分之间的字段初始化顺序。</p><p><strong>分部方法</strong></p><p>分部类型可以包含分部方法（partial method）。这些方法能够令自动生成的分部类型为手动编写的代码提供自定义钩子（hook）。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">partial</span> <span class="token keyword">class</span> <span class="token class-name">PaymentForm</span> <span class="token comment">// In auto-generated file</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">partial</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> ValidatePayment <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">decimal</span></span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">partial</span> <span class="token keyword">class</span> <span class="token class-name">PaymentForm</span> <span class="token comment">// In hand-authored file</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">partial</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> ValidatePayment <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">decimal</span></span> amount<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>amount <span class="token operator">></span> <span class="token number">100</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>分部方法由两部分组成：定义和实现。定义一般需要代码生成器生成，而实现一般需要手动编写。如果没有提供方法的实现，分部方法的定义会被编译器清除（调用它的代码部分也一样）。这样，自动生成的代码既可以提供钩子又不必单行代码过于臃肿。分部方法返回值类型必须是 void，且该方法是隐式的 private 方法。</p><h3 id="nameof运算符"><a class="anchor" href="#nameof运算符">#</a> <code>nameof</code> 运算符</h3><p><code>nameof</code> 运算符返回任意符号的字符串名称（类型、成员、变量等）。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token keyword">int</span></span> count <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name"><span class="token keyword">string</span></span> name <span class="token operator">=</span> <span class="token keyword">nameof</span> <span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// name is "count"</span></pre></td></tr></table></figure><h2 id="继承"><a class="anchor" href="#继承">#</a> 继承</h2><h3 id="多态"><a class="anchor" href="#多态">#</a> 多态</h3><p>引用是多态的，意味着 x 类型的变量可以指向 x 子类的对象。多态之所以能够实现，是因为子类具有基类的全部特征，反过来则不正确。</p><h3 id="类型转换和引用转换"><a class="anchor" href="#类型转换和引用转换">#</a> 类型转换和引用转换</h3><p><strong>as 运算符</strong></p><p>as 运算符再向下类型转换出错时返回 null（而不是抛出异常）：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Asset</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Asset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Stock</span> s <span class="token operator">=</span> a <span class="token keyword">as</span> <span class="token class-name">Stock</span><span class="token punctuation">;</span> <span class="token comment">// s is null; no exception thrown</span></pre></td></tr></table></figure><p>如果不用判断结果是否为 null，那么更推荐使用类型转换。因为如果发生错误，类型转换会抛出描述更加清晰的异常。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token keyword">int</span></span> shares <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Stock<span class="token punctuation">)</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span>SharesOwned<span class="token punctuation">;</span> <span class="token comment">// Approach #1</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name"><span class="token keyword">int</span></span> shares <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token keyword">as</span> <span class="token class-name">Stock</span><span class="token punctuation">)</span><span class="token punctuation">.</span>SharesOwned<span class="token punctuation">;</span> <span class="token comment">// Approach #2</span></pre></td></tr></table></figure><p>as 和类型转换运算符也可以用来实现向上类型转换，但是不常用。因为隐式转换就已经足够了。</p><p><strong>is 运算符</strong></p><p>is 运算符用于检测变量是否满足特定的模式。C# 支持若干模式，其中最重要的模式是类型模式。在这种模式下，is 运算符后跟类型的名称。</p><p>在类型模式上下文中，is 运算符检查引用的转换是否能够成功，即对象是否从某个特定的类派生（或是实现某个接口）。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token keyword">is</span> <span class="token class-name">Stock</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Stock<span class="token punctuation">)</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span>SharesOwned<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>引入模式变量</strong></p><p>在使用 is 运算符时可以引入一个变量：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token keyword">is</span> <span class="token class-name">Stock</span> s<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>s<span class="token punctuation">.</span>SharesOwned<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>上述代码等价于：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Stock</span> s<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token keyword">is</span> <span class="token class-name">Stock</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> s <span class="token operator">=</span> <span class="token punctuation">(</span>Stock<span class="token punctuation">)</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>s<span class="token punctuation">.</span>SharesOwned<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>引用的变量可以 “立即” 使用，因此以下代码是合法的：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token keyword">is</span> <span class="token class-name">Stock</span> s <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span>SharesOwned <span class="token operator">></span> <span class="token number">100000</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token string">"Wealthy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>同时，引入的变量即使在 is 表达式之外仍然在作用域内。例如：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token keyword">is</span> <span class="token class-name">Stock</span> s <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span>SharesOwned <span class="token operator">></span> <span class="token number">100000</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token string">"Wealthy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">Else</span></pre></td></tr><tr><td data-num="4"></td><td><pre> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Stock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// s is in scope</span></pre></td></tr><tr><td data-num="5"></td><td><pre>Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>s<span class="token punctuation">.</span>SharesOwned<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Still in scope</span></pre></td></tr></table></figure><h3 id="虚函数成员"><a class="anchor" href="#虚函数成员">#</a> 虚函数成员</h3><p>子类可以重写标识为 virtual 的函数以提供特定的实现。方法、属性、索引器和事件都可以声明为 virtual：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Asset</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">string</span></span> Name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token return-type class-name"><span class="token keyword">decimal</span></span> Liability <span class="token operator">=></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// Expression-bodied property</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>Liabiility =&gt; 0 是 {get { return 0;} } 的简写。</p><p>子类通过应用 override 修饰符重写虚方法：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Stock</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Asset</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">long</span></span> SharesOwned<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">House</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Asset</span></span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">decimal</span></span> Mortgage<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">decimal</span></span> Liability <span class="token operator">=></span> Mortgage<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>从构造器调用虚方法有潜在的危险性，因为编写子类的人在重写方法的时候未必知道现在正在操作一个未完成实例化的对象。换言之，重写的方法恒可能最终会访问到一些方法和属性，而这些方法或属性依赖的字段还未被构造器初始化。</p><h3 id="抽象类和抽象成员"><a class="anchor" href="#抽象类和抽象成员">#</a> 抽象类和抽象成员</h3><p>抽象类中可以定义抽象成员，抽象成员和虚成员相似，只不过抽象成员不提供默认的实现。除非子类也声明为抽象类，否则其实现必须由子类提供：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Asset</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// Note empty implementation</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token return-type class-name"><span class="token keyword">decimal</span></span> NetValue <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Stock</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Asset</span></span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">long</span></span> SharesOwned<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">decimal</span></span> CurrentPrice<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token comment">// Override like a virtual method.</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">decimal</span></span> NetValue <span class="token operator">=></span> CurrentPrice <span class="token operator">*</span> SharesOwned<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="隐藏继承成员"><a class="anchor" href="#隐藏继承成员">#</a> 隐藏继承成员</h3><p>基类和子类可能定义相同的成员，例如：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">int</span></span> Counter <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">A</span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">int</span></span> Counter <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>类 B 中的 Counter 字段隐藏了类 A 中的 Counter 字段。因此，编译器会产生一个警告，并采用下面的方法避免这种二义性：</p><ul><li>A 的引用（在编译时）绑定到 A.counter。</li><li>B 的引用（在编译时）绑定到 B.counter。</li></ul><p>有时需要故意隐藏一个成员。此时可以在子类的成员中使用 new 修饰符。new 修饰符仅用于阻止编译器发出警告，写法如下：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">int</span></span> Counter <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">A</span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token keyword">int</span></span> Counter <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>C# 在不同的上下文中的 new 关键字拥有完全不同的含义。<mark>特别注意 new 运算符和 new 修饰符是不同的。</mark></p><p><strong>new 和重写</strong></p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BaseClass</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token string">"BaseClass.Foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Overrider</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">BaseClass</span></span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token string">"Overrider.Foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Hider</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">BaseClass</span></span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">new</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token string">"Hider.Foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token class-name">Overrider</span> over <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Overrider</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token class-name">BaseClass</span> b1 <span class="token operator">=</span> over<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>over<span class="token punctuation">.</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Overrider.Foo</span></pre></td></tr><tr><td data-num="17"></td><td><pre>b1<span class="token punctuation">.</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Overrider.Foo</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token class-name">Hider</span> h <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Hider</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token class-name">BaseClass</span> b2 <span class="token operator">=</span> h<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>h<span class="token punctuation">.</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hider.Foo</span></pre></td></tr><tr><td data-num="21"></td><td><pre>b2<span class="token punctuation">.</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// BaseClass.Foo</span></pre></td></tr></table></figure><h3 id="封装函数和类"><a class="anchor" href="#封装函数和类">#</a> 封装函数和类</h3><p>重写的函数成员可以使用 sealed 关键字封闭其实现，防止其他的子类再次重写。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">decimal</span></span> Liability <span class="token punctuation">&#123;</span> <span class="token keyword">get</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> Mortgage<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="base关键字"><a class="anchor" href="#base关键字">#</a> base 关键字</h3><p>base 关键字和 this 关键字很类似。它由两个重要目的：</p><ul><li>从子类访问重写的基类函数成员。</li><li>调用基类的构造器。</li></ul><h3 id="构造器和继承"><a class="anchor" href="#构造器和继承">#</a> 构造器和继承</h3><p>子类必须声明自己的构造器。派生类可以访问基类的构造器，但是并非自动继承。</p><p>base 关键字和 this 关键字很像，但 base 关键字调用的是基类的构造器。</p><p>基类的构造器总是先执行，这保证了基类的初始化发生在子类特定的初始化之前。</p><p><strong>隐式调用基类的无参数构造器</strong></p><p>如果子类的构造器省略 base 关键字，那么基类的无参构造器将被隐式调用：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BaseClass</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">int</span></span> X<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token function">BaseClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> X <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Subclass</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">BaseClass</span></span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Subclass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// 1</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>如果基类没有可访问的无参数构造器，子类的构造器中就必须使用 base 关键字。</p><p><strong>构造器和字段初始化的顺序</strong></p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>When an <span class="token keyword">object</span> <span class="token keyword">is</span> <span class="token class-name">instantiated</span><span class="token punctuation">,</span> initialization <span class="token class-name">takes</span> place <span class="token keyword">in</span> the <span class="token class-name">following</span> order<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token number">1</span><span class="token punctuation">.</span> From subclass to <span class="token keyword">base</span> <span class="token keyword">class</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	a<span class="token punctuation">.</span> Fields are initialized</pre></td></tr><tr><td data-num="4"></td><td><pre>	b<span class="token punctuation">.</span> Arguments to <span class="token keyword">base</span><span class="token operator">-</span><span class="token keyword">class</span> <span class="token class-name">constructor</span> calls are evaluated</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token number">2</span><span class="token punctuation">.</span> From <span class="token keyword">base</span> <span class="token keyword">class</span> <span class="token class-name">to</span> subclass<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	a<span class="token punctuation">.</span> Constructor bodies execute</pre></td></tr><tr><td data-num="7"></td><td><pre>The following <span class="token class-name">code</span> demonstrates<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token class-name"><span class="token keyword">int</span></span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// Executes 3rd</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">public</span> B <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> x<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token comment">// Executes 4th</span></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">B</span></span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token class-name"><span class="token keyword">int</span></span> y <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// Executes 1st</span></pre></td></tr><tr><td data-num="19"></td><td><pre> <span class="token keyword">public</span> D <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> x<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token punctuation">:</span> <span class="token keyword">base</span> <span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// Executes 2nd</span></pre></td></tr><tr><td data-num="21"></td><td><pre> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token comment">// Executes 5th</span></pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="重载和解析"><a class="anchor" href="#重载和解析">#</a> 重载和解析</h3><p>继承对方法的重载有着特殊的影响。请考虑以下两个重载：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> Foo <span class="token punctuation">(</span><span class="token class-name">Asset</span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> Foo <span class="token punctuation">(</span><span class="token class-name">House</span> h<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>当重载被调用时，类型最明确的优先匹配：</p><pre><code class="language-C#">House h = new House (...);
Foo(h); // Calls Foo(House)

Asset a = new House (...);
Foo(a); // Calls Foo(Asset)
</code></pre><p>具体调用哪个重载是在编译器静态决定的而非运行时决定。</p><p>如果把 Asset 类转换为 dynamic，则会在运行时决定调用哪个重载。这样就会基于对象的实际类型进行选择：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Asset</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">House</span> <span class="token punctuation">(</span><span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>Foo <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">dynamic</span><span class="token punctuation">)</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Calls Foo(House)</span></pre></td></tr></table></figure><h2 id="object-类型"><a class="anchor" href="#object-类型">#</a> Object 类型</h2><p>object 时引用类型，承载了类的优点。尽管如此，int 等值类型也可以和 object 类型相互转换并加入栈中。C# 这种特性称为类型一致化。</p><p>当值类型和 object 类型相互转换时，公共语言运行时（CLR）必须进行一些特定的工作来对接值类型和引用类型在语义上的差异。这个过程称为装箱（boxing）和拆箱（unboxing）。</p><h3 id="装箱和拆箱"><a class="anchor" href="#装箱和拆箱">#</a> 装箱和拆箱</h3><p>装箱是将值类型实例转换为引用类型实例的行为。引用类型可以时 object 类型或接口。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token keyword">int</span></span> x <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name"><span class="token keyword">object</span></span> obj <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// Box the int</span></pre></td></tr></table></figure><p>拆箱操作刚好相反，它把 object 类型转换成原始的值类型：</p><pre><code class="language-C#">int y = (int)obj; // Unbox the int
</code></pre><p>拆箱需要显示类型转换。运行时将检查提供的值类型和真正的对象类型是否匹配，并在检查类型出错的时候抛出 InvalidCastException。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token keyword">object</span></span> obj <span class="token operator">=</span> <span class="token number">3.5</span><span class="token punctuation">;</span> <span class="token comment">// 3.5 is inferred to be of type double</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name"><span class="token keyword">int</span></span> x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> obj<span class="token punctuation">;</span> <span class="token comment">// x is now 3</span></pre></td></tr></table></figure><p>在上例中，(double) 时拆箱操作而 (int) 是数值转换操作。</p><p>装箱转换对系统提供一致性的数据类型至关重要。但这个体系并不是完美的；在 3.9 节中会介绍数组和泛型的变量只能支持引用转换，不能支持装箱转换：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token keyword">object</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> a1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name"><span class="token keyword">string</span></span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Legal</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name"><span class="token keyword">object</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> a2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name"><span class="token keyword">int</span></span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Error</span></pre></td></tr></table></figure><p><strong>装箱拆箱中的复制语义</strong></p><p>装箱是把值类型的实例复制到新对象中，而拆箱是吧对象的内容复制回值类型的实例中。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name"><span class="token keyword">object</span></span> boxed <span class="token operator">=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>boxed<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span></pre></td></tr></table></figure><h3 id="静态和运行时类型检查"><a class="anchor" href="#静态和运行时类型检查">#</a> 静态和运行时类型检查</h3><p>C# 程序在静态（编译时）和运行时（CLR）都会执行类型检查。</p><p>运行时可以进行类型检查是因为堆上的每一个对象都在内部存储了类型标识，这个标识可以通过调用 object 类型的 GetType 方法得到。</p><h3 id="gettype方法和typeof运算符"><a class="anchor" href="#gettype方法和typeof运算符">#</a> GetType 方法和 typeof 运算符</h3><p>C# 中的所有类型在运行时都会表示为 System.Type 类的实例。有两个基本方法可以获得 System.Type 对象：</p><ul><li>在类型实例上调用 GetType 方法</li><li>在类型名称上使用 typeof 运算符</li></ul><p>GetType 在运行时计算，而 typeof 在编译时静态计算（如果是泛型类型参数，那么它将由即时编译器解析）。</p><p>System.Type 拥有诸多属性，例如类型的名称、程序集、基类型等属性。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">int</span></span> X<span class="token punctuation">,</span> Y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Test</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token class-name">Point</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Point</span></pre></td></tr><tr><td data-num="9"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token punctuation">(</span><span class="token type-expression class-name">Point</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Point</span></pre></td></tr><tr><td data-num="10"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">Point</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// True</span></pre></td></tr><tr><td data-num="11"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>p<span class="token punctuation">.</span>X<span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Int32</span></pre></td></tr><tr><td data-num="12"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>p<span class="token punctuation">.</span>Y<span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>FullName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// System.Int32</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>System.Type 同时还是运行时反射模型的访问入口。</p><h3 id="tostring方法"><a class="anchor" href="#tostring方法">#</a> ToString 方法</h3><p>ToString 方法返回类型实例的默认文本描述。所有内置类型都重写了该方法。</p><p>当直接在值类型上调用 ToString 这样的 object 成员时，若该成员是重写的，则不会发生装箱。只有进行类型转换时才会执行装箱操作。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token keyword">int</span></span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name"><span class="token keyword">string</span></span> s1 <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Calling on nonboxed value</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name"><span class="token keyword">object</span></span> box <span class="token operator">=</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token class-name"><span class="token keyword">string</span></span> s2 <span class="token operator">=</span> box<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Calling on boxed value</span></pre></td></tr></table></figure><h3 id="object的成员列表"><a class="anchor" href="#object的成员列表">#</a> object 的成员列表</h3><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Object</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">extern</span> <span class="token return-type class-name">Type</span> <span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token return-type class-name"><span class="token keyword">bool</span></span> Equals <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span></span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">bool</span></span> Equals <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span></span> objA<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">object</span></span> objB<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">bool</span></span> ReferenceEquals <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span></span> objA<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">object</span></span> objB<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">GetHashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> <span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token keyword">protected</span> <span class="token keyword">virtual</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">protected</span> <span class="token keyword">extern</span> <span class="token return-type class-name"><span class="token keyword">object</span></span> <span class="token function">MemberwiseClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="结构体"><a class="anchor" href="#结构体">#</a> 结构体</h2><p>结构体和类相似，不同之处在于：</p><ul><li>结构体是值类型，而类型是引用类型</li><li>结构体不支持继承（除了隐式派生自 object 类型，或更精准地说，是派生自 System.valueType）。</li></ul><p>除了以下内容，结构体可以包含类的所有成员：</p><ul><li>无参数的构造器</li><li>字段初始化器</li><li>终结器</li><li>虚成员或 protected 成员</li></ul><p>由于结构体是值类型，因此其实例不需要在堆上实例化，创建一个类型的多个实例就更加高效了。结构体是值类型，因而其实例不能为 null。结构体对象的默认值是一个空值实例，即其所有的字段均为空值（均为其默认值）。</p><h3 id="结构体的构造语义"><a class="anchor" href="#结构体的构造语义">#</a> 结构体的构造语义</h3><p>需要之处的是结构体不支持字段初始化器</p><p>在构造结构体时使用 default 关键字的效果和调用隐式的无参数构造器的效果时一样的：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Point</span> p1 <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>以下实例包含三个编译时错误：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">struct</span> <span class="token class-name">Point</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name"><span class="token keyword">int</span></span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// Illegal: field initializer</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name"><span class="token keyword">int</span></span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// Illegal: parameterless constructor</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> Point <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token comment">// Illegal: must assign field y</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>如果把 struct 替换为 class，则以上写法都合法。</p><h3 id="只读结构体和只读函数"><a class="anchor" href="#只读结构体和只读函数">#</a> 只读结构体和只读函数</h3><h3 id="ref结构体"><a class="anchor" href="#ref结构体">#</a> ref 结构体</h3><h2 id="访问权限修饰符"><a class="anchor" href="#访问权限修饰符">#</a> 访问权限修饰符</h2><p>为了提高封装性，类型或类型成员可以在声明中添加以下六个访问权限修饰符之一来限定其他类型和其他程序集对它的访问。</p><ul><li>public：完全访问权限。枚举类型成员或接口成员隐含的可访问性。</li><li>internal：仅可以在程序集内访问，或供友元程序集访问。这是非嵌套类型的默认可访问性。</li><li>private：仅可以在包含类型中访问。这是类或者结构体成员的默认可访问性。</li><li>protected：仅可以在包含类型或子类中访问。</li><li>protected internal：protected 和 internal 可访问性的并集。protected internal 修饰符的成员在任意一种修饰符限定下都能够访问。</li><li>private protected：从 C#7.2 开始支持，protected 和 internal 可访问性的交集。若一个成员是 private protected 的，那么该成员只能够在其类型中或被其相同程序集中的子类型访问（它的可访问性比 protected 和 internal 都低）。</li></ul><h3 id="友元程序集"><a class="anchor" href="#友元程序集">#</a> 友元程序集</h3><h3 id="可访问性上限"><a class="anchor" href="#可访问性上限">#</a> 可访问性上限</h3><h3 id="访问权限修饰符的限制"><a class="anchor" href="#访问权限修饰符的限制">#</a> 访问权限修饰符的限制</h3><p>当重写基类的函数时，重写函数的可访问性必须一致，例如：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">BaseClass</span> <span class="token punctuation">&#123;</span> <span class="token keyword">protected</span> <span class="token keyword">virtual</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Subclass1</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">BaseClass</span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">protected</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// OK</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Subclass2</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">BaseClass</span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// Error</span></pre></td></tr></table></figure><p>若在另外一个程序集中重写 protected internal 方法，则重写方法必须为 protected。这是上述规则中的一个例外情况。</p><h2 id="接口"><a class="anchor" href="#接口">#</a> 接口</h2><p>接口和类相似，但接口只提供行为定义而不会持有任何状态（数据），因此：</p><ul><li>接口只能定义函数而不能定义字段</li><li>接口的成员都是隐式抽象的（虽然 C# 8 支持在接口中声明非抽象函数，但这应当视为一种特殊情况。3.6.6 节中详细接受该特性）</li><li>一个类（或者结构体）可以实现多个接口。而一个类只能够继承一个类，结构体则完全不支持继承（只能从 System.ValueType 派生）</li></ul><p>接口成员总是隐式 public 的，并且不能用访问权限修饰符声明。</p><h3 id="显式接口实现"><a class="anchor" href="#显式接口实现">#</a> 显式接口实现</h3><p>当实现多个接口时，有时会出现成员签名的冲突。显式实现（explicitly implementing）接口成员可以解决冲突。</p><p>调用显式实现成员的唯一方式是先将其转换为对应的接口：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Widget</span> w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>w<span class="token punctuation">.</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Widget's implementation of I1.Foo</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">(</span><span class="token punctuation">(</span>I1<span class="token punctuation">)</span>w<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Widget's implementation of I1.Foo</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">(</span><span class="token punctuation">(</span>I2<span class="token punctuation">)</span>w<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Widget's implementation of I2.Foo</span></pre></td></tr></table></figure><p>另一个使用显式接口成员的原因是隐藏那些高度定制化的或对类的正常使用干扰很大的接口成员。</p><h3 id="实现接口的需成员"><a class="anchor" href="#实现接口的需成员">#</a> 实现接口的需成员</h3><p>默认情况下，隐式实现的接口成员是密封的。为了重写，必须在基类中将其标识为 virtual 或者 abstract：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IUndoable</span> <span class="token punctuation">&#123;</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Undo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TextBox</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IUndoable</span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Undo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token string">"TextBox.Undo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RichTextBox</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">TextBox</span></span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Undo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token string">"RichTextBox.Undo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>显式实现的接口成员不能标识为 virtual，也不能实现通常意义的重写，但是它可以被重新实现。</p><h3 id="在子类中重新实现接口"><a class="anchor" href="#在子类中重新实现接口">#</a> 在子类中重新实现接口</h3><h3 id="接口和装箱"><a class="anchor" href="#接口和装箱">#</a> 接口和装箱</h3><p>将结构体转换为接口会引发装箱。而调用结构体的隐式实现实现接口成员不会引发装箱：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">interface</span> <span class="token class-name">I</span> <span class="token punctuation">&#123;</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">S</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">I</span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token class-name">S</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">S</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>s<span class="token punctuation">.</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// No boxing.</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token class-name">I</span> i <span class="token operator">=</span> s<span class="token punctuation">;</span> <span class="token comment">// Box occurs when casting to interface.</span></pre></td></tr><tr><td data-num="7"></td><td><pre>i<span class="token punctuation">.</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="默认接口成员c-8"><a class="anchor" href="#默认接口成员c-8">#</a> 默认接口成员（C# 8）</h3><p>从 C# 8 开始，可以在接口成员中添加默认实现，而该成员不必必须进行实现：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">interface</span> <span class="token class-name">ILogger</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token return-type class-name"><span class="token keyword">void</span></span> Log <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> text<span class="token punctuation">)</span> <span class="token operator">=></span> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>默认实现永远是显式的。因而假设一个类实现了 ILogger 接口但并未定义 Log 方法，那么要调用 Log 方法，必须通过接口来进行。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Logger</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">ILogger</span></span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">(</span><span class="token punctuation">(</span>ILogger<span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">Logger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Log <span class="token punctuation">(</span><span class="token string">"message"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>除此之外，接口中还能定义静态成员（包括静态字段）。接口的默认实现可以访问这些静态成员：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">interface</span> <span class="token class-name">ILogger</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token return-type class-name"><span class="token keyword">void</span></span> Log <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> text<span class="token punctuation">)</span> <span class="token operator">=></span></pre></td></tr><tr><td data-num="4"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>Prefix <span class="token operator">+</span> text<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">static</span> <span class="token class-name"><span class="token keyword">string</span></span> Prefix <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>由于接口成员是隐式 public 成员，因此在外部访问其静态成员也是可行的：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>ILogger<span class="token punctuation">.</span>Prefix <span class="token operator">=</span> <span class="token string">"File log: "</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>如需限制这一行为，可在接口的静态成员上添加访问权限修饰符（例如 private、protected 和 internal）。</p><p>在接口中声明实例字段仍然是非法的。这和接口的原则 -- 接口用于定义行为而非持有状态 -- 是一致的。</p><h2 id="枚举类型"><a class="anchor" href="#枚举类型">#</a> 枚举类型</h2><p>枚举类型是一种特殊的值类型。我们能够在该类型中定义一组命名的数值常量。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">BorderSide</span> <span class="token punctuation">&#123;</span> Left<span class="token punctuation">,</span> Right<span class="token punctuation">,</span> Top<span class="token punctuation">,</span> Bottom <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">BorderSide</span> topSide <span class="token operator">=</span> BorderSide<span class="token punctuation">.</span>Top<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name"><span class="token keyword">bool</span></span> isTop <span class="token operator">=</span> <span class="token punctuation">(</span>topSide <span class="token operator">==</span> BorderSide<span class="token punctuation">.</span>Top<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></pre></td></tr></table></figure><p>每一个枚举成员都对应一个整数。在默认情况下：</p><ul><li>对应的数值是 int 类型的</li><li>安装枚举成员的声明顺序，自动按照 1、2、3…… 进行常量赋值</li></ul><p>当然，也可以指定其他的整数类型代替默认类型，例如：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">BorderSide</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token keyword">byte</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token punctuation">&#123;</span> Left<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> Right<span class="token punctuation">,</span> Top<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> Bottom <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>编译器还支持显式指定部分枚举成员。没有指定的枚举成员，在最后一个显式指定的值基础上递增。</p><h3 id="枚举类型转换"><a class="anchor" href="#枚举类型转换">#</a> 枚举类型转换</h3><p>在枚举表达式中，编译器会特殊对待数值字面量 0。它不需要进行显式转换：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">BorderSide</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// No cast required</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr></table></figure><h3 id="标志枚举类型"><a class="anchor" href="#标志枚举类型">#</a> 标志枚举类型</h3><p>枚举类型的成员可以合并。为了避免混淆，合并枚举类型的成员要显式指定值，典型的值为 2 的幂次。例如：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Flags</span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">enum</span> <span class="token class-name">BorderSides</span> <span class="token punctuation">&#123;</span> None<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> Left<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> Right<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> Top<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> Bottom<span class="token operator">=</span><span class="token number">8</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">or</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">enum</span> <span class="token class-name">BorderSides</span> <span class="token punctuation">&#123;</span> None<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> Left<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> Right<span class="token operator">=</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">,</span> Top<span class="token operator">=</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">2</span><span class="token punctuation">,</span> Bottom<span class="token operator">=</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">3</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token class-name">BorderSides</span> leftRight <span class="token operator">=</span> BorderSides<span class="token punctuation">.</span>Left <span class="token operator">|</span> BorderSides<span class="token punctuation">.</span>Right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>leftRight <span class="token operator">&amp;</span> BorderSides<span class="token punctuation">.</span>Left<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token string">"Includes Left"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Includes Left</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token class-name"><span class="token keyword">string</span></span> formatted <span class="token operator">=</span> leftRight<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "Left, Right"</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token class-name">BorderSides</span> s <span class="token operator">=</span> BorderSides<span class="token punctuation">.</span>Left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>s <span class="token operator">|=</span> BorderSides<span class="token punctuation">.</span>Right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>s <span class="token operator">==</span> leftRight<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// True</span></pre></td></tr><tr><td data-num="13"></td><td><pre>s <span class="token operator">^=</span> BorderSides<span class="token punctuation">.</span>Right<span class="token punctuation">;</span> <span class="token comment">// Toggles BorderSides.Right</span></pre></td></tr><tr><td data-num="14"></td><td><pre>Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Left</span></pre></td></tr></table></figure><p>按照惯例，当枚举类型的成员可以合并时，其枚举类型一定要应用 Flags 特性。如果声明了一个没有标注 Flags 特性的枚举类型，其成员依然可以合并，但若在该枚举类型实例上调用 toString 方法，则会输出一个数值而非一组名字。</p><p>一般来说，合并枚举类型通常用复数名词而不是单数形式。</p><h3 id="类型安全性问题"><a class="anchor" href="#类型安全性问题">#</a> 类型安全性问题</h3><h2 id="嵌套类型"><a class="anchor" href="#嵌套类型">#</a> 嵌套类型</h2><p>嵌套类型是声明在另一个类型内部的类型：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TopLevel</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Nested</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// Nested class</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Color</span> <span class="token punctuation">&#123;</span> Red<span class="token punctuation">,</span> Blue<span class="token punctuation">,</span> Tan <span class="token punctuation">&#125;</span> <span class="token comment">// Nested enum</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>嵌套类型有如下的特征：</p><ul><li>可以访问包含它的外层类型中的私有成员，以及外层类所能访问的所有内容。</li><li>可以在声明上使用所有的访问权限修饰符，而不限于 public 和 internal</li><li>嵌套类型的默认可访问性是 private 而不是 internal</li><li>从外层类以外访问嵌套类型，需要使用外层类名称进行限定（就像访问静态成员一样）</li></ul><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">TopLevel<span class="token punctuation">.</span>Color</span> color <span class="token operator">=</span> TopLevel<span class="token punctuation">.</span>Color<span class="token punctuation">.</span>Red<span class="token punctuation">;</span></pre></td></tr></table></figure><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TopLevel</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">static</span> <span class="token class-name"><span class="token keyword">int</span></span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">class</span> <span class="token class-name">Nested</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span>TopLevel<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TopLevel</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">protected</span> <span class="token keyword">class</span> <span class="token class-name">Nested</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SubTopLevel</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">TopLevel</span></span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">TopLevel<span class="token punctuation">.</span>Nested</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TopLevel</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Nested</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Test</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token class-name">TopLevel<span class="token punctuation">.</span>Nested</span> n<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>如果使用嵌套类型的主要原因是为了避免命名空间类型定义杂乱无章，那么可以考虑使用嵌套命名空间。使用嵌套类型的原因应当是利用它较强的访问控制能力，或者是为了嵌套的类型必须访问外层类型的私有成员。</p><h2 id="泛型"><a class="anchor" href="#泛型">#</a> 泛型</h2><p>C# 有两种不同的机制来编写类型可复用的代码：继承和泛型。但继承的复用性来自基类，而泛型的复用性是通过带有占位符的模板类实现的。和继承相比，泛型能够提高类型的安全性，减少类型的转换和装箱。</p><p>C# 的泛型和 C++ 的模板是相似的概念，但它们的工作方式不同。</p><h3 id="泛型类型"><a class="anchor" href="#泛型类型">#</a> 泛型类型</h3><p>泛型类型中声明的类型参数（占位符类型）需要由泛型类型的消费者（即提供类型参数的一方）来填充。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Stack<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name"><span class="token keyword">int</span></span> position<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token class-name">T<span class="token punctuation">[</span><span class="token punctuation">]</span></span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">T</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> Push <span class="token punctuation">(</span><span class="token class-name">T</span> obj<span class="token punctuation">)</span> <span class="token operator">=></span> data<span class="token punctuation">[</span>position<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">T</span> <span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> data<span class="token punctuation">[</span><span class="token operator">--</span>position<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// We can use Stack&lt;T> as follows:</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token class-name"><span class="token keyword">var</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Stack<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>stack<span class="token punctuation">.</span>Push <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>stack<span class="token punctuation">.</span>Push <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token class-name"><span class="token keyword">int</span></span> x <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// x is 10</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token class-name"><span class="token keyword">int</span></span> y <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// y is 5</span></pre></td></tr></table></figure><p>技术上，我们称 Stack&lt;T&gt; 是开放类型，称 Stack&lt;int &gt; 是封闭类型。在运行时，所有的泛型实例都是封闭的，占位符已经被类型填充。</p><h3 id="为什么需要泛型"><a class="anchor" href="#为什么需要泛型">#</a> 为什么需要泛型</h3><p>泛型是为了代码能够跨类型复用而设计的。</p><h3 id="泛型方法"><a class="anchor" href="#泛型方法">#</a> 泛型方法</h3><p>泛型方法在方法的签名中声明类型参数。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">Swap</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span> <span class="token punctuation">(</span><span class="token keyword">ref</span> <span class="token class-name">T</span> a<span class="token punctuation">,</span> <span class="token keyword">ref</span> <span class="token class-name">T</span> b<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">T</span> temp <span class="token operator">=</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> a <span class="token operator">=</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> b <span class="token operator">=</span> temp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// Swap&lt;T> is called as follows:</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token class-name"><span class="token keyword">int</span></span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token class-name"><span class="token keyword">int</span></span> y <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>Swap <span class="token punctuation">(</span><span class="token keyword">ref</span> x<span class="token punctuation">,</span> <span class="token keyword">ref</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>通常调用泛型方法不需要提供类型参数，因为编译器可以隐式推断出类型信息。如果由二义性，则可以用以下方式调用泛型方法：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token generic-method"><span class="token function">Swap</span><span class="token generic class-name"><span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span></span> <span class="token punctuation">(</span><span class="token keyword">ref</span> x<span class="token punctuation">,</span> <span class="token keyword">ref</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在泛型中，只有引入类型参数（用尖括号标出）的方法才可归为泛型方法。</p><p>微有方法和可以引入类型参数。属性、索引器、事件、字段、构造器、运算符等都不能声明类型参数，虽然它们可以参与使用所在类型中已经声明的类型参数。</p><h4 id="声明类型参数"><a class="anchor" href="#声明类型参数">#</a> 声明类型参数</h4><p>可以在声明类、结构体、接口、委托和方法时引入类型参数。其他结构（如属性）虽不能引入类型参数，但可以使用类型参数。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">struct</span> <span class="token class-name">Nullable<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">T</span> Value <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>只要类型参数的数量不同，泛型类型名和泛型方法的名称就可以进行重载。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">A<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">A<span class="token punctuation">&lt;</span>T1<span class="token punctuation">,</span>T2<span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="typeof和未绑定泛型类型"><a class="anchor" href="#typeof和未绑定泛型类型">#</a> typeof 和未绑定泛型类型</h3><p>在运行时不存在开放的泛型类型：开放泛型类型将在编译过程中封闭。但运行时可能存在未绑定的泛型类型，这种泛型类型只作为 Type 对象存在。C# 中唯一指定未绑定泛型类型的方式是使用 typeof 运算符：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">A<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">A<span class="token punctuation">&lt;</span>T1<span class="token punctuation">,</span>T2<span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token class-name">Type</span> a1 <span class="token operator">=</span> <span class="token keyword">typeof</span> <span class="token punctuation">(</span><span class="token type-expression class-name">A<span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Unbound type (notice no type arguments).</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token class-name">Type</span> a2 <span class="token operator">=</span> <span class="token keyword">typeof</span> <span class="token punctuation">(</span><span class="token type-expression class-name">A<span class="token punctuation">&lt;</span><span class="token punctuation">,</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Use commas to indicate multiple type args.</span></pre></td></tr></table></figure><p>开放泛型类型一般与反射 API 一起使用。</p><p>typeof 运算符也可以用于指定封闭的类型：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Type</span> a3 <span class="token operator">=</span> <span class="token keyword">typeof</span> <span class="token punctuation">(</span><span class="token type-expression class-name">A<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>或开放类型（当然，他会在运行时封闭）：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">B<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">X</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token class-name">Type</span> t <span class="token operator">=</span> <span class="token keyword">typeof</span> <span class="token punctuation">(</span><span class="token type-expression class-name">T</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="泛型的默认值"><a class="anchor" href="#泛型的默认值">#</a> 泛型的默认值</h3><p>default 关键字可用于获取泛型类型参数的默认值。引用类型的默认值为 null，而值类型的默认值是将值类型的所有字段按位设置为 0 的值。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">Zap</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span> <span class="token punctuation">(</span><span class="token class-name">T<span class="token punctuation">[</span><span class="token punctuation">]</span></span> array<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">(</span><span class="token type-expression class-name">T</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>从 C# 7.1 开始，我们可以在编译器能够进行类型推断的情况下忽略类型参数。因此以上程序的最后一行可以写为：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="泛型的约束"><a class="anchor" href="#泛型的约束">#</a> 泛型的约束</h3><p>默认情况下，类型参数可以由任何类型来替换。在类型参数上应用约束可以将类型参数定义为指定的类型参数。以下列出了可用的约束：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">where</span> <span class="token class-name">T</span> <span class="token punctuation">:</span> <span class="token keyword">base</span><span class="token operator">-</span><span class="token keyword">class</span> <span class="token comment">// Base-class constraint</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">where</span> <span class="token class-name">T</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token keyword">interface</span></span> <span class="token comment">// Interface constraint</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">where</span> <span class="token class-name">T</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token keyword">class</span></span> <span class="token comment">// Reference-type constraint</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">where</span> <span class="token class-name">T</span> <span class="token punctuation">:</span> <span class="token keyword">class</span><span class="token punctuation">?</span> <span class="token comment">// (See "Nullable reference types")</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">where</span> <span class="token class-name">T</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token keyword">struct</span></span> <span class="token comment">// Value-type constraint (excludes Nullable types)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">where</span> <span class="token class-name">T</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token keyword">unmanaged</span></span> <span class="token comment">// Unmanaged constraint</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">where</span> <span class="token class-name">T</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span> <span class="token comment">// Parameterless constructor constraint</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">where</span> <span class="token class-name">U</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">T</span></span> <span class="token comment">// Naked type constraint</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">where</span> <span class="token class-name">T</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token keyword">notnull</span></span> <span class="token comment">// Non-nullable value type, or from C# 8</span></pre></td></tr><tr><td data-num="10"></td><td><pre> 					<span class="token comment">// a non-nullable reference type.</span></pre></td></tr></table></figure><p>约束可以应用在方法或类型定义这些可以定义类型参数的地方。</p><ul><li><p>基类约束要求类型参数必须是子类（或者匹配特定的类）；接口约束要求类型参数必须实现特定的接口。这些约束要求类型参数的实例可以隐式转换为相应的类或接口。</p></li><li><p>类约束和结构体约束规定 T 必须是引用类型或值类型（不能为空）。</p></li><li><p>C# 7.3 引入了非托管类型约束。该约束是一个增强型的结构体约束。其中 T 必须是一个简单的值类型或该值类型中（递归的）不包含任何引用类型字段</p></li><li><p>无参数构造器约束要求 T 有一个 public 无参数构造器。</p></li><li><p>裸类型约束要求一个类型参数必须从另一个类型参数中派生（或匹配）。</p></li></ul><blockquote><p>严格地说，非托管类型约束指类型参数必须是一个不可空的非托管类型。其中非托管类型指：sbyte、byte、short、ushort、int、uint、long、ulong、char、float、double、decimal 和 bool；枚举类型；指针类型以及任何自定义的不包含任意类型参数的仅仅包含非托管类型的字段和结构体。</p></blockquote><h3 id="继承泛型类型"><a class="anchor" href="#继承泛型类型">#</a> 继承泛型类型</h3><p>泛型类和非泛型类一样，都可以派生子类。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Stack<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span><span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">SpecialStack<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Stack<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span> <span class="token punctuation">&#123;</span><span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">IntStack</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Stack<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span></span> <span class="token punctuation">&#123;</span><span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">List<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span><span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">KeyedList<span class="token punctuation">&lt;</span>T<span class="token punctuation">,</span>TKey<span class="token punctuation">></span></span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">List<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span> <span class="token punctuation">&#123;</span><span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">List<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span><span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">KeyedList<span class="token punctuation">&lt;</span>TElement<span class="token punctuation">,</span>TKey<span class="token punctuation">></span></span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">List<span class="token punctuation">&lt;</span>TElement<span class="token punctuation">></span></span></span> <span class="token punctuation">&#123;</span><span class="token range operator">..</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="自引用泛型声明"><a class="anchor" href="#自引用泛型声明">#</a> 自引用泛型声明</h3><p>一个类型可以使用自身类型作为具体类型来封闭类型参数：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IEquatable<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span> <span class="token return-type class-name"><span class="token keyword">bool</span></span> Equals <span class="token punctuation">(</span><span class="token class-name">T</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Balloon</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IEquatable<span class="token punctuation">&lt;</span>Balloon<span class="token punctuation">></span></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> Color <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> CC <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">bool</span></span> Equals <span class="token punctuation">(</span><span class="token class-name">Balloon</span> b<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">return</span> b<span class="token punctuation">.</span>Color <span class="token operator">==</span> Color <span class="token operator">&amp;&amp;</span> b<span class="token punctuation">.</span>CC <span class="token operator">==</span> CC<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>以下写法也是合法的：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Foo<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token keyword">where</span> <span class="token class-name">T</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IComparable<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Bar<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token keyword">where</span> <span class="token class-name">T</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Bar<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span> <span class="token punctuation">&#123;</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="静态数据"><a class="anchor" href="#静态数据">#</a> 静态数据</h3><p>静态数据对每一个封闭的类型来说都是唯一的：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Bob<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name"><span class="token keyword">int</span></span> Count<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Test</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token operator">++</span>Bob<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">.</span>Count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span></pre></td></tr><tr><td data-num="7"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token operator">++</span>Bob<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">.</span>Count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span></pre></td></tr><tr><td data-num="8"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token operator">++</span>Bob<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token operator">></span><span class="token punctuation">.</span>Count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span></pre></td></tr><tr><td data-num="9"></td><td><pre> Console<span class="token punctuation">.</span>WriteLine <span class="token punctuation">(</span><span class="token operator">++</span>Bob<span class="token operator">&lt;</span><span class="token keyword">object</span><span class="token operator">></span><span class="token punctuation">.</span>Count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="类型参数和转换"><a class="anchor" href="#类型参数和转换">#</a> 类型参数和转换</h3><p>C# 的类型转换运算符可以进行多种类型转换，包括：</p><ul><li>数值转换</li><li>引用转换</li><li>装箱和拆箱转换</li><li>自定义转换（通过运算符重载）</li></ul><p>对于泛型类型参数来说，由于编译时操作数的类型还未确定，上述规则就会出现特殊的清醒。如果导致了二义性，那么编译器就会产生一个错误。</p><p>最常见的情形是在执行引用转换时：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token return-type class-name">StringBuilder</span> <span class="token generic-method"><span class="token function">Foo</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span> <span class="token punctuation">(</span><span class="token class-name">T</span> arg<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>arg <span class="token keyword">is</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">return</span> <span class="token punctuation">(</span>StringBuilder<span class="token punctuation">)</span> arg<span class="token punctuation">;</span> <span class="token comment">// Will not compile</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>由于不知道 T 的确切类型，编译器会疑惑你是否希望执行自定义转换。上述问题最简单的解决方案就是改用 as 运算符，由于它不能进行自定义类型转换，因此是没有二义性的：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token return-type class-name">StringBuilder</span> <span class="token generic-method"><span class="token function">Foo</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span> <span class="token punctuation">(</span><span class="token class-name">T</span> arg<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> arg <span class="token keyword">as</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">if</span> <span class="token punctuation">(</span>sb <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> sb<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token range operator">..</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>更一般的做法是先将其转换为 object 类型。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">return</span> <span class="token punctuation">(</span>StringBuilder<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">object</span><span class="token punctuation">)</span> arg<span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="协变"><a class="anchor" href="#协变">#</a> 协变</h3><p>假定 A 可以转换为 B，如果 X&lt;A&gt; 可以转换为 X&lt;B&gt;，那么称 X 有一个协变类型参数。</p><p>由于 C# 有协变（covariance）和逆变（contravariance）的概念，所以 “可转换” 意味着可以通过隐式引用转换进行类型转换。而数值转换、装箱转换和自定义转换是不包含在内的。</p><p>接口支持协变类型参数（委托也支持协变类型参数），但是类不支持协变类型参数。数组也支持协变（如果 A 可以隐式引用转换为 B，则 A [] 也可以隐式引用转换为 B []）。</p><p>在 C# 中引入和强化协变的动机是允许泛型接口和泛型类型（<span class="exturl" data-url="aHR0cDovL3huLS1nNnEyM3hvNWguTkVU">尤其是.NET</span> Core 中定义的那些类型，例如 IEnumerable&lt;T&gt;）像人们期待的那样工作。</p><p><strong>可变性不是自动的</strong></p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Bear</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Animal</span></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Camel</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Animal</span></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Stack<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> <span class="token comment">// A simple Stack implementation</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token class-name"><span class="token keyword">int</span></span> position<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token class-name">T<span class="token punctuation">[</span><span class="token punctuation">]</span></span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">T</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> Push <span class="token punctuation">(</span><span class="token class-name">T</span> obj<span class="token punctuation">)</span> <span class="token operator">=></span> data<span class="token punctuation">[</span>position<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token keyword">public</span> <span class="token return-type class-name">T</span> <span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> data<span class="token punctuation">[</span><span class="token operator">--</span>position<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">// The following fails to compile:</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token class-name">Stack<span class="token punctuation">&lt;</span>Bear<span class="token punctuation">></span></span> bears <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Stack<span class="token punctuation">&lt;</span>Bear<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token class-name">Stack<span class="token punctuation">&lt;</span>Animal<span class="token punctuation">></span></span> animals <span class="token operator">=</span> bears<span class="token punctuation">;</span> <span class="token comment">// Compile-time error</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token comment">// That restriction prevents the possibility of runtime failure with the following code:</span></pre></td></tr><tr><td data-num="15"></td><td><pre>animals<span class="token punctuation">.</span>Push <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">Camel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Trying to add Camel to bears</span></pre></td></tr></table></figure><p><strong>数组</strong></p><p>由于历史原因，数组类型支持协变。这说明如果 B 是 A 的子类，则 B [] 可以转换为 A []（A 和 B 都是引用类型）。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Bear<span class="token punctuation">[</span><span class="token punctuation">]</span></span> bears <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Bear</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Animal<span class="token punctuation">[</span><span class="token punctuation">]</span></span> animals <span class="token operator">=</span> bears<span class="token punctuation">;</span> <span class="token comment">// OK</span></pre></td></tr></table></figure><p>这种复用性的缺点是元素的赋值可能在运行时发生错误：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>animals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Camel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Runtime error</span></pre></td></tr></table></figure><p><strong>声明协变类型参数</strong></p><p>在接口和委托的类型参数上指定 out 修饰符可将其声明为协变参数。和数组不同。这个修饰符保证了协变类型参数完全是类型安全的。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IPoppable<span class="token punctuation">&lt;</span><span class="token keyword">out</span> T<span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span> <span class="token return-type class-name">T</span> <span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name"><span class="token keyword">var</span></span> bears <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Stack<span class="token punctuation">&lt;</span>Bear<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>bears<span class="token punctuation">.</span>Push <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">Bear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// Bears implements IPoppable&lt;Bear>. We can convert to IPoppable&lt;Animal>:</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token class-name">IPoppable<span class="token punctuation">&lt;</span>Animal<span class="token punctuation">></span></span> animals <span class="token operator">=</span> bears<span class="token punctuation">;</span> <span class="token comment">// Legal</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token class-name">Animal</span> a <span class="token operator">=</span> animals<span class="token punctuation">.</span><span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>T 上的 out 修饰符表明 T 只用于输出的位置（例如方法的返回值）。</p><p>接口中的协变或逆变都是很常见的，在接口中同时支持协变和逆变则是很少见的。</p><p>bears 到 animals 的转换是由编译器保证的，因为类型参数具有协变性。在这种情况下，若视图将 Camel 实例入栈，则编译器会阻止这种行为。由于 T 只能在输出位置出现，因此不可能将 Camel 类输入接口中。</p><p>特别注意，方法中的 out 参数是不支持协变的，这是 CLR 的限制。</p><p>不管是类型参数还是数组，协变（和逆变）仅对引用转换有效，对装箱转换无效。因此，如果编写了一个接受 IPoppable&lt;object&gt; 类型参数的方法，那么可以使用 IPoppable&lt;string &gt; 调用它，但不能是 IPoppable&lt;int&gt;。</p><h3 id="逆变"><a class="anchor" href="#逆变">#</a> 逆变</h3><p>假设 A 可以隐式引用转换为 B，如果 X&lt;A&gt; 允许引用类型转换为 X&lt;B&gt;，则类型 X 具有协变类型参数。而逆变的转换方向正好相反，即从 X&lt;B &gt; 转换到 X&lt;A&gt;。它仅在类型参数出现在输入位置上并用 in 修饰符标记时才行得通。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IPushable<span class="token punctuation">&lt;</span><span class="token keyword">in</span> T<span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> Push <span class="token punctuation">(</span><span class="token class-name">T</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">IPushable<span class="token punctuation">&lt;</span>Animal<span class="token punctuation">></span></span> animals <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Stack<span class="token punctuation">&lt;</span>Animal<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token class-name">IPushable<span class="token punctuation">&lt;</span>Bear<span class="token punctuation">></span></span> bears <span class="token operator">=</span> animals<span class="token punctuation">;</span> <span class="token comment">// Legal</span></pre></td></tr><tr><td data-num="5"></td><td><pre>bears<span class="token punctuation">.</span>Push <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">Bear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>IPushable 中没有任何成员输出 T，所以将 animals 转换为 bears 时不会出现问题（但是通过这个接口无法实现 Pop 方法）。</p><p>即使 T 含有相反的可变性标记，Stack&lt;T&gt; 类可以同时实现 IPushable&lt;T &gt; 和 IPoppable&lt;T&gt;。由于只能通过接口而不是类实现可变性，因此在进行可变性转换之前，必须首先选定 IPoppable 或者 IPushable 接口。而选定的接口会限制操作在合适的可变性规则下执行。</p><p>这也说明了为什么类不允许接受可变性参数类型：因为具体实现通常都需要数据进行双向流动。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IComparer<span class="token punctuation">&lt;</span><span class="token keyword">in</span> T<span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token comment">// Returns a value indicating the relative ordering of a and b</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token return-type class-name"><span class="token keyword">int</span></span> Compare <span class="token punctuation">(</span><span class="token class-name">T</span> a<span class="token punctuation">,</span> <span class="token class-name">T</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token class-name"><span class="token keyword">var</span></span> objectComparer <span class="token operator">=</span> Comparer<span class="token operator">&lt;</span><span class="token keyword">object</span><span class="token operator">></span><span class="token punctuation">.</span>Default<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// objectComparer implements IComparer&lt;object></span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token class-name">IComparer<span class="token punctuation">&lt;</span><span class="token keyword">string</span><span class="token punctuation">></span></span> stringComparer <span class="token operator">=</span> objectComparer<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token class-name"><span class="token keyword">int</span></span> result <span class="token operator">=</span> stringComparer<span class="token punctuation">.</span>Compare <span class="token punctuation">(</span><span class="token string">"Brett"</span><span class="token punctuation">,</span> <span class="token string">"Jemaine"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>与协变正好相反，如果将逆变的类型参数用在输出位置（例如返回值或者可读属性）上，编译器将会报告错误。</p><h3 id="c泛型和c模板的对比"><a class="anchor" href="#c泛型和c模板的对比">#</a> C# 泛型和 C++ 模板的对比</h3><p>C# 的泛型和 C++ 的模板在应用程序中很相似，但是它们的工作原理却大不相同。两者都发生了生产者和消费者的关联，且生产者的占位符将被消费者填充。但是在 C# 泛型中，生产者的类型（开放类型，如 List&lt;T&gt;）可以编译到程序库（如 mscorlib.dll）中。这是因为生产者和消费者进行关联生成封闭类型是在运行时发生的。而 C++ 模板中，这一关联是在编译时进行的。这意味着 C++ 不能将模板库部署为 .dll，它们只存在于源代码中。这令动态语法检查难以实现，更不用说即使创建或参数化类型了。</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// To dig deeper into why this is the case, consider again the Max method in C#:</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name">T</span> <span class="token generic-method"><span class="token function">Max</span> <span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span> <span class="token punctuation">(</span><span class="token class-name">T</span> a<span class="token punctuation">,</span> <span class="token class-name">T</span> b<span class="token punctuation">)</span> <span class="token keyword">where</span> <span class="token class-name">T</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IComparable<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token operator">=></span> a<span class="token punctuation">.</span>CompareTo <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">?</span> a <span class="token punctuation">:</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// Why couldn’t we have implemented it like this?</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name">T</span> <span class="token generic-method"><span class="token function">Max</span> <span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span> <span class="token punctuation">(</span><span class="token class-name">T</span> a<span class="token punctuation">,</span> <span class="token class-name">T</span> b<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token operator">=></span> <span class="token punctuation">(</span>a <span class="token operator">></span> <span class="token class-name">b <span class="token punctuation">?</span></span> a <span class="token punctuation">:</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Compile error</span></pre></td></tr></table></figure><p>第二种写法，Max 需要在编译时支持所有可能的 T 类型值。由于对于任意类型 T，运算符 &gt; 没有同一的含义，因此上述程序无法通过编译。实际上，并不是所有类型都支持 &gt; 运算符。相对地，下面的代码使用 C++ 的模板编写的 Max 方法。改代码会针对每一个 T 值分别编译，对特定 T 呈现不同的 &gt; 语义，而当 T 不支持 &gt; 运算符时编译失败：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> T <span class="token function">Max</span> <span class="token punctuation">(</span>T a<span class="token punctuation">,</span> T b<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">return</span> a <span class="token operator">></span> b <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><div class="tags"><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 读书笔记</a> <a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C#</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2023-11-22 08:07:36" itemprop="dateModified" datetime="2023-11-22T08:07:36+08:00">2023-11-22</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Sakupinera WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Sakupinera Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Sakupinera PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Sakupinera <i class="ic i-at"><em>@</em></i>Sakupinera</li><li class="link"><strong>Post link: </strong><a href="http://sakupinera.github.io/2022/08/29/csharp/csharp-in-a-nutshell/%E7%AC%AC3%E7%AB%A0%20%E5%9C%A8CSharp%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%9E%8B/" title="C# in a Nutshell - 第 3 章 在 C# 中创建类型">http://sakupinera.github.io/2022/08/29/csharp/csharp-in-a-nutshell/第3章 在CSharp中创建类型/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/08/29/csharp/csharp-in-a-nutshell/%E7%AC%AC4%E7%AB%A0%20CSharp%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclfw2t96j20zk0m8x6p.jpg" title="C# in a Nutshell - 第4章 C#的高级特性"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i> CSharp-in-a-Nutshell</span><h3>C# in a Nutshell - 第4章 C#的高级特性</h3></a></div><div class="item right"><a href="/2022/08/29/csharp/csharp-in-a-nutshell/%E7%AC%AC2%E7%AB%A0%20%E5%9C%A8CSharp%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%9E%8B/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclhfehz7j20zk0m8u0x.jpg" title="C# in a Nutshell - 第2章 C#语言基础"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i> CSharp-in-a-Nutshell</span><h3>C# in a Nutshell - 第2章 C#语言基础</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%A8c%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">在 C# 中创建类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">实例构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">对象初始化器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">1.1.3.</span> <span class="toc-text">引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-number">1.1.4.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%99%A8"><span class="toc-number">1.1.5.</span> <span class="toc-text">索引器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">1.1.6.</span> <span class="toc-text">静态构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%B1%BB"><span class="toc-number">1.1.7.</span> <span class="toc-text">静态类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E7%BB%93%E5%99%A8"><span class="toc-number">1.1.8.</span> <span class="toc-text">终结器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%83%A8%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.9.</span> <span class="toc-text">分部类型和方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nameof%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.1.10.</span> <span class="toc-text">nameof 运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.2.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">1.2.1.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E5%BC%95%E7%94%A8%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.2.</span> <span class="toc-text">类型转换和引用转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98"><span class="toc-number">1.2.3.</span> <span class="toc-text">虚函数成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%88%90%E5%91%98"><span class="toc-number">1.2.4.</span> <span class="toc-text">抽象类和抽象成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E7%BB%A7%E6%89%BF%E6%88%90%E5%91%98"><span class="toc-number">1.2.5.</span> <span class="toc-text">隐藏继承成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E5%87%BD%E6%95%B0%E5%92%8C%E7%B1%BB"><span class="toc-number">1.2.6.</span> <span class="toc-text">封装函数和类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#base%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.2.7.</span> <span class="toc-text">base 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="toc-number">1.2.8.</span> <span class="toc-text">构造器和继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E8%A7%A3%E6%9E%90"><span class="toc-number">1.2.9.</span> <span class="toc-text">重载和解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#object-%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">Object 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1"><span class="toc-number">1.3.1.</span> <span class="toc-text">装箱和拆箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5"><span class="toc-number">1.3.2.</span> <span class="toc-text">静态和运行时类型检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gettype%E6%96%B9%E6%B3%95%E5%92%8Ctypeof%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.3.3.</span> <span class="toc-text">GetType 方法和 typeof 运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tostring%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.4.</span> <span class="toc-text">ToString 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#object%E7%9A%84%E6%88%90%E5%91%98%E5%88%97%E8%A1%A8"><span class="toc-number">1.3.5.</span> <span class="toc-text">object 的成员列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.4.</span> <span class="toc-text">结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%9E%84%E9%80%A0%E8%AF%AD%E4%B9%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">结构体的构造语义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%8F%AA%E8%AF%BB%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.2.</span> <span class="toc-text">只读结构体和只读函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ref%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.4.3.</span> <span class="toc-text">ref 结构体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.5.</span> <span class="toc-text">访问权限修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E7%A8%8B%E5%BA%8F%E9%9B%86"><span class="toc-number">1.5.1.</span> <span class="toc-text">友元程序集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7%E4%B8%8A%E9%99%90"><span class="toc-number">1.5.2.</span> <span class="toc-text">可访问性上限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">1.5.3.</span> <span class="toc-text">访问权限修饰符的限制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.6.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.1.</span> <span class="toc-text">显式接口实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%9C%80%E6%88%90%E5%91%98"><span class="toc-number">1.6.2.</span> <span class="toc-text">实现接口的需成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%AD%90%E7%B1%BB%E4%B8%AD%E9%87%8D%E6%96%B0%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.6.3.</span> <span class="toc-text">在子类中重新实现接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E8%A3%85%E7%AE%B1"><span class="toc-number">1.6.4.</span> <span class="toc-text">接口和装箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%8E%A5%E5%8F%A3%E6%88%90%E5%91%98c-8"><span class="toc-number">1.6.5.</span> <span class="toc-text">默认接口成员（C# 8）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.7.</span> <span class="toc-text">枚举类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.7.1.</span> <span class="toc-text">枚举类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%BF%97%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.7.2.</span> <span class="toc-text">标志枚举类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.3.</span> <span class="toc-text">类型安全性问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.8.</span> <span class="toc-text">嵌套类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.9.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.9.1.</span> <span class="toc-text">泛型类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.9.2.</span> <span class="toc-text">为什么需要泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.9.3.</span> <span class="toc-text">泛型方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">1.9.3.1.</span> <span class="toc-text">声明类型参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typeof%E5%92%8C%E6%9C%AA%E7%BB%91%E5%AE%9A%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.9.4.</span> <span class="toc-text">typeof 和未绑定泛型类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">1.9.5.</span> <span class="toc-text">泛型的默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%BA%A6%E6%9D%9F"><span class="toc-number">1.9.6.</span> <span class="toc-text">泛型的约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.9.7.</span> <span class="toc-text">继承泛型类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%BC%95%E7%94%A8%E6%B3%9B%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="toc-number">1.9.8.</span> <span class="toc-text">自引用泛型声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE"><span class="toc-number">1.9.9.</span> <span class="toc-text">静态数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E5%92%8C%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.9.10.</span> <span class="toc-text">类型参数和转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E5%8F%98"><span class="toc-number">1.9.11.</span> <span class="toc-text">协变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E5%8F%98"><span class="toc-number">1.9.12.</span> <span class="toc-text">逆变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c%E6%B3%9B%E5%9E%8B%E5%92%8Cc%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.9.13.</span> <span class="toc-text">C# 泛型和 C++ 模板的对比</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"><ul><li><a href="/2022/08/29/csharp/csharp-in-a-nutshell/%E7%AC%AC2%E7%AB%A0%20%E5%9C%A8CSharp%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%9E%8B/" rel="bookmark" title="C# in a Nutshell - 第2章 C#语言基础">C# in a Nutshell - 第2章 C#语言基础</a></li><li class="active"><a href="/2022/08/29/csharp/csharp-in-a-nutshell/%E7%AC%AC3%E7%AB%A0%20%E5%9C%A8CSharp%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%9E%8B/" rel="bookmark" title="C# in a Nutshell - 第3章 在C#中创建类型">C# in a Nutshell - 第3章 在C#中创建类型</a></li><li><a href="/2022/08/29/csharp/csharp-in-a-nutshell/%E7%AC%AC4%E7%AB%A0%20CSharp%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/" rel="bookmark" title="C# in a Nutshell - 第4章 C#的高级特性">C# in a Nutshell - 第4章 C#的高级特性</a></li><li><a href="/2022/08/30/csharp/csharp-in-a-nutshell/%E7%AC%AC8%E7%AB%A0%20LINQ%E6%9F%A5%E8%AF%A2/" rel="bookmark" title="C# in a Nutshell - 第8章 LINQ查询">C# in a Nutshell - 第8章 LINQ查询</a></li><li><a href="/2022/09/01/csharp/csharp-in-a-nutshell/%E7%AC%AC12%E7%AB%A0%20%E5%AF%B9%E8%B1%A1%E9%94%80%E6%AF%81%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" rel="bookmark" title="C# in a Nutshell - 第12章 对象销毁与垃圾回收">C# in a Nutshell - 第12章 对象销毁与垃圾回收</a></li><li><a href="/2022/09/04/csharp/csharp-in-a-nutshell/%E7%AC%AC14%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%BC%82%E6%AD%A5/" rel="bookmark" title="C# in a Nutshell - 第14章 并发与异步">C# in a Nutshell - 第14章 并发与异步</a></li></ul></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sakupinera" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Sakupinera</p><div class="description" itemprop="description">保持你的决心！</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">89</span> <span class="name">posts</span></a></div><div class="item categories"><a href="/categories/"><span class="count">17</span> <span class="name">categories</span></a></div><div class="item tags"><a href="/tags/"><span class="count">8</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nha3VwaW5lcmE=" title="https:&#x2F;&#x2F;github.com&#x2F;sakupinera"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9zYWt1cGluZXJh" title="https:&#x2F;&#x2F;twitter.com&#x2F;sakupinera"><i class="ic i-twitter"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQwNzIyOTA3MQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;407229071"><i class="ic i-cloud-music"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMjIzMDczOTg/c3BtX2lkX2Zyb209MzMzLjEwMDcuMC4w" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;22307398?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li><li class="item"><a href="/games/" rel="section"><i class="ic i-flag"></i>games</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-person"></i>About</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/08/29/csharp/csharp-in-a-nutshell/%E7%AC%AC4%E7%AB%A0%20CSharp%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/08/29/csharp/csharp-in-a-nutshell/%E7%AC%AC2%E7%AB%A0%20%E5%9C%A8CSharp%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%9E%8B/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/09/18/computer-graphics/games101/%E5%8F%98%E6%8D%A2/" title="GAMES101 - Transformation（变换）">GAMES101 - Transformation（变换）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2023/08/20/computer-graphics/games101/%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/" title="GAMES101 - Color and Perception（颜色与感知）">GAMES101 - Color and Perception（颜色与感知）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2023/02/09/csharp/clr-via-csharp/Chapter%2029%20Primitive%20Thread%20Synchronization%20Constructs/" title="CLR via C# - Chapter 29 Primitive Thread Synchronization">CLR via C# - Chapter 29 Primitive Thread Synchronization</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2023/01/05/cpp/cpp-primer/Chapter%2013%20Copy%20Control/" title="C++ Primer - Chapter 13 Copy Control">C++ Primer - Chapter 13 Copy Control</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/10/27/csharp/clr-via-csharp/Chapter%209%20Parameters/" title="CLR via C# - Chapter 9 Parameters">CLR via C# - Chapter 9 Parameters</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2022/12/10/cpp/cpp-primer/Chapter%202%20Variables%20and%20Basic%20Types/" title="C++ Primer - Chapter 2 Variables and Basic Types">C++ Primer - Chapter 2 Variables and Basic Types</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Computer-Graphics/" title="In Computer-Graphics">Computer-Graphics</a> <i class="ic i-angle-right"></i> <a href="/categories/Computer-Graphics/GAMES101/" title="In GAMES101">GAMES101</a></div><span><a href="/2022/10/21/computer-graphics/games101/%E6%B8%B2%E6%9F%93%E4%B8%AD%E7%9A%84%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/" title="GAMES101 - Advanced Topics in Rendering（渲染中的高级主题）">GAMES101 - Advanced Topics in Rendering（渲染中的高级主题）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CSharp/" title="In CSharp">CSharp</a> <i class="ic i-angle-right"></i> <a href="/categories/CSharp/CLR-via-CSharp/" title="In CLR-via-CSharp">CLR-via-CSharp</a></div><span><a href="/2022/10/15/csharp/clr-via-csharp/Chapter%205%20Primitive,%20Reference,%20and%20Value%20%20Types/" title="CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals">CLR via C# - Chapter 5 Primitive, Reference, and Value Types Fundamentals</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2023/01/03/cpp/cpp-primer/Chapter%2011%20Associative%20Containers/" title="C++ Primer - Chapter 11 Associative Containers">C++ Primer - Chapter 11 Associative Containers</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Cpp/" title="In Cpp">Cpp</a> <i class="ic i-angle-right"></i> <a href="/categories/Cpp/Cpp-Primer/" title="In Cpp-Primer">Cpp-Primer</a></div><span><a href="/2022/12/09/cpp/cpp-primer/Chapter%201%20Getting%20Started/" title="C++ Primer - Chapter 1 Getting Started">C++ Primer - Chapter 1 Getting Started</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Sakupinera @ Hanamai Sora</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="Symbols count total">2.2m words</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="Reading time total">34:05</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/08/29/csharp/csharp-in-a-nutshell/第3章 在CSharp中创建类型/",favicon:{show:"（●´3｀●）Goooood",hide:"(´Д｀)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/shifuku.model.json"},display:{position:"left",width:250,height:500},mobile:{show:!1},react:{opacity:.9},log:!1})</script></body></html>